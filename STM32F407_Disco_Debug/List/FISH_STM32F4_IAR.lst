###################################################################################################
#                                                                                                 #
#     IAR Assembler V8.22.1.15669/W32 for ARM 12/Oct/2018  19:15:47                               #
#     Copyright 1999-2018 IAR Systems AB.                                                         #
#                                                                                                 #
#           Source file   =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\FISH_STM32F4_IAR.s   #
#           List file     =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\List\FISH_STM32F4_IAR.lst#
#           Object file   =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\Obj\FISH_STM32F4_IAR.o#
#           Command line  =  -f C:\Users\CLYDEW~1\AppData\Local\Temp\EW8826.tmp                   #
#                            (C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\FISH_STM32F4_IAR.s  #
#                            -OC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\Obj #
#                            -s+ -M<> -w+ -r -DFISH_PubRel_WORDSET -DFISH_Debug_WORDSET           #
#                            -DSTM32F4_XRC08_168MHZ                                               #
#                            -LC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\List #
#                            -t8 --cpu Cortex-M4 --fpu VFPv4_sp                                   #
#                            -IC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\..\FISH_Libs\FISH_RM_COMMON\ #
#                            -IC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\..\FISH_Libs\FISH_RM_COMMON_CODE_CORTEX_M\) #
#                                                                                                 #
###################################################################################################

    1                           // FISH_STM32F4_IAR.s - FULL WORD v1.7.2
    2                           // FISH FOR THE STM IS CURRENTLY SUPPORTING F2 TO F4
    3                           // Code is common, seperate linker files used for memory map differences.
    4                           $FISH_STM32F4_MAIN_INCLUDES.h
    5                           //------------------------------------------------------------------------------
    6                           
    7                           // 2DO: Add VIO_UARTX, VIO_KEY, VIO_?KEY and VIO_EMIT
    8                           // (EMIT), (KEY?), and (KEY).
    9                           
   10                           // v1.8 4th tos/nos caching
   11                           
   12                           // v1.7.2 Fixed backspace issue
   13                           
   14                           // v1.7.1:
   15                           
   16                           // Fix NUMBER by merge with NXP which works correctly!
   17                           // 2DO: Restore SYSTICK ISR to ASM version
   18                           // 2DO: Signon updated. (FOR TEST - FIX B4 SHIP)
   19                           // 2DO: Updated .hex .out and sym.bat
   20                           
   21                           // #define EOL_DLE // DLE 0x10/16d in QUIT>CR after last word interpreted.
   22                           // #define EOL_NAK // NAK 0x15/21d in error messages for STDLED editor highlight
   23                           // The EOL_NAK makes SPACE NAK end of string in FISH_RM_MSGS.h
   24                           
   25                           // Split out files to FISH_RM_COMMON and FISH_RM_COMMON_CODE_CORTEX_M
   26                           
   27                           // ADDED EHON and EHOFF to FISH RM
   28                           // Changes iar.s COLD, ERROR and ABORT
   29                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM:
   30                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - ERROR_HALT: SV 
   31                           
   32                           // ADDED P(PROMPT), PON(PROMPTON) and POFF(PROMPTOFF) to FISH RM
   33                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM: & QUIT:
   34                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - PROMPT: SV 
   35                           
   36                           // Added #define TRUE_EQU_NEG_ONE
   37                           // Changed all user visible true flags to -1
   38                           
   39                           // Added SXTB Rd, Rm  and SXTH Rd, Rm
   40                           
   41                           // Number Stuff Wordcat reorganized (search NOEXEC or WC_NUMBERS_NFA)
   42                           // EXPECT does counted null strings:
   43                           // NUMBER to look for null terminatiion instead of BLANK.
   44                           // WORD changed to expect null string and elimated BLANKS fill of HERE.
   45                           //      SPEEDS UP TOKENIZATION OF TIB INPUT!
   46                           // ALL IN AND IN_SV INIT SET TO 1 in QUERY SV_INIT_VALUES CLRTIB
   47                           // NUMBERSUFFIX changed to replace suffix with null
   48                           // PAREN ( changed to use TIB+1
   49                           // DPL restored to dictionairy.
   50                           
   51                           //------------------------------------------------------------------------------
   52                            SECTION .text : CONST (2)
   53                           msg_FISH:
   54                           // DC8 "?" IS A NULL TERMINATED STRING
   55                           // DC8 '?' IS NOT
   56                           //#if FISH_PubRel_WORDSET | FISH_DebugSrc_WORDSET
   57    00000000 4649534820415         DC8     'FISH ARM '
                  24D20        
   58                           //#endif
   59                           #if FISH_PubRel_WORDSET & FISH_Debug_WORDSET
   60    00000009 20313031302C3         DC8     ' 1010,1100 - EHON/EHOFF '
                  1313030202D20
                  45484F4E2F454
                  84F464620    
   61                           //        DC8     '-1 True Flag '
   62                           #endif
   63                           #if VTOR_PATCH & STM32F205RC
   65                           #endif
   66                           #ifdef FISH_Debug_WORDSET
   67    00000021 4465627567537         DC8     'DebugSrc '
                  26320        
   68                           #endif
   69                           #ifdef  STM32F4_XRC08_168MHZ
   70    0000002A 53544D3332463         DC8     'STM32F407VG DISCO @168Mhz '
                  4303756472044
                  4953434F20403
                  136384D687A20
   71                           #endif
   72                           #ifdef STM32F205RC_XRC10_118MHZ
   74                           #endif
   75                           #ifdef FISH_PRO_WORDCAT
   77                           #endif
   78    00000044 524D2056312E3         DC8     'RM V1.7.2 (C)2014-2018 A-TEAM FORTH : '
                  72E3220284329
                  323031342D323
                  0313820412D54
                  45414D20464F5
                  25448203A20  
   79    0000006A 4F63742031322         DC8     __DATE__        // Null string
                  03230313800  
   80                           msg_FISH_TIMESTAMP:
   81    00000076 20617420              DC8     ' at '
   82    0000007A 31393A31353A3         DC8     __TIME__        // Null string
                  43700        
   83                           #ifdef EOL_NAK
   84                           msg_SIGNON_DLE:
   85    00000083 1500                  DC8     0x15, 0
   86                           #endif
   87                           msg_MY_OK:
   88    00000085 206F6B2C20676         DC8     " ok, go fish in BASE "
                  F206669736820
                  696E204241534
                  52000        
   89                           //-----------------START OF DICTIONARY = Last word in search--------------------
   90                           // Conditionally include FISH_STM32F4_Peripheral_Register_ADDRS.h include here
   91                           #ifdef FISH_STM32F4_Peripheral_Register_ADDRS
   94                           #endif
   95                           // 
   96                           //      NOOP NOOP:      ( -- )
   97                            SECTION .text : CONST (2)
   98                           NOOP_NFA:
   99    00000000 84                    DC8     0x84
  100    00000001 4E4F4F                DC8     'NOO'
  101    00000004 D0                    DC8     'P'+0x80
  102    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  103    00000008 00000000              DC32    0       // 0 START OF DICTIONARY = Last word in search
  104                           NOOP:
  105    0000000C ........              DC32    .+5
  106                            SECTION .text : CODE (2)
  107                                   NEXT
  107.1                         // ARMv7-M Thumb = .+5
  107.2  00000000 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  107.3                         // ARMv6-M Thumb = .+4
  107.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  107                                   NEXT1
  107.1  00000004 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  107.2  00000008 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  107.3  0000000C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  107.4                         // ARMv6-M Thumb = .+4
  107.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  107.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  107.7                                 ENDM
  107.8                                 ENDM
  108                           
  109                           
  110                           //      EXECUTE EXEC:   ( cfa -- ) RENAMED: EXECUTE to EXEC
  111                           //      Execute a single word whose cfa is on the stack
  112                           
  113                            SECTION .text : CONST (2)
  114                           EXEC_NFA:
  115    00000000 87                    DC8     0x87
  116    00000001 455845435554          DC8     'EXECUT'
  117    00000007 C5                    DC8     'E'+0x80
  118                            ALIGNROM 2,0xFFFFFFFF
  119    00000008 ........              DC32    NOOP_NFA
  120                           EXEC:
  121    0000000C ........              DC32    .+5
  122                            SECTION .text : CODE (2)
  123                           #ifndef IO2TP
  124                           #ifdef XON_XOFF
  125    00000000 ........              BL      TXRDY_SUBR
  126    00000004 ........              BL      XOFF_SUBR
  127                           #endif
  128                           #endif
  129                           EXEC_ACTION:
  130                                   POPp2w // as in xeq token at ToS setup for exec LDM     p!, {w}
  130.1                                 // as in xeq token on ToS setup for exec
  130.2  00000008 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
  130.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
  130.4                                 ENDM
  131                                   NEXT1
  131.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  131.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  131.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  131.4                         // ARMv6-M Thumb = .+4
  131.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  131.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  131.7                                 ENDM
  132                           
  133                           #ifndef IO2TP
  134                           // TXRDY_SUBR:
  135                            SECTION .text : CODE (2)
  136                           TXRDY_SUBR:
  137    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  138    00000002 024C                  LDR     y, = USART3_SR  // Line Status Register
  139                           txRDY?:
  140    00000004 2168                  LDR     n, [y]          // Get Line Status
  141                           // THIS IS TXE TEST AND FAILS IN TEXT DOWNLOAD
  142                           //        LSRS    n, n, #7      // 80h Bit 7 TXE: Transmit data register empty
  143                           // THIS IS ___ AND WORKS IN TEXT DOWNLOAD
  144    00000006 090A                  LSRS    n, n, #8        // 100h Bit 8 ORIG
  145    00000008 FCD3                  BCC     txRDY?          // Ready
  146    0000000A 1047                  BX      w               // lr  - SUBR RETURN
  147                           
  148                           // XOFF_SUBR:
  149                           #ifdef XON_XOFF
  149.1                                  TABLE
  149.2  0000000C 00480040              Reference on line 138
  150                            SECTION .text : CODE (2)
  151                           XOFF_SUBR:
  152    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  153    00000002 0249                  LDR     n,= USART3_DR
  154    00000004 1324                  LDR     y,  = XOFF_CHAR
  155    00000006 0C70                  STRB    y, [n]
  156    00000008 1047                  BX      w               // lr  - SUBR RETURN
  157                           #endif // XON_XOFF
  158                           
  159                           // XON_SUBR:
  160                           #ifdef XON_XOFF
  160.1                                  TABLE
  160.2  0000000C 04480040              Reference on line 153
  161                            SECTION .text : CODE (2)
  162                           XON_SUBR:
  163    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  164    00000002 0249                  LDR     n,= USART3_DR
  165    00000004 1124                  LDR     y, = XON_CHAR   // preserve TOS 11 24 01 49
  166    00000006 0C70                  STRB    y, [n]
  167    00000008 1047                  BX      w       //lr              // SUBR RETURN
  168                           #endif // XON_XOFF
  169                           #endif // IO2TP
  170    0000000A 0000           LTORG
  170.1                                  TABLE
  170.2  0000000C 04480040              Reference on line 164
  171                           
  172                           //      BL BLANK:       ( -- n )
  173                           //      Push ascii space character as n to TOS.
  174                           
  175                            SECTION .text : CONST (2)
  176                           BLANK_NFA:
  177    00000000 82                    DC8     0x82
  178    00000001 42                    DC8     'B'
  179    00000002 CC                    DC8     'L'+0x80
  180    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  181    00000004 ........              DC32    EXEC_NFA
  182                           BLANK:
  183    00000008 ........20000         DC32    DOCON, 0x20
                  000          
  184                           
  185                           
  186                           //========================= START SYSTEM VARIABLES ===========================//
  187                           // _SV IS cfa label of WORD's that return their address.
  188                           // MODIFIED ALL to be label based vs. offset based.
  189                           
  190                           
  191                           //      UP UP_SV:       ( -- addr of UP ) Value stored here is ALIGNED
  192                           //      A system variable, the RAM VAR pointer, which contains
  193                           //      the address of the next free memory above in the USERRAMSPACE.
  194                           //      The value may be read by .UV and altered by VAR.
  195                           
  196                            SECTION .text : CONST (2)
  197                           UP_NFA:
  198    00000000 82                    DC8     0x82
  199    00000001 55                    DC8     'U'
  200    00000002 D0                    DC8     'P'+0x80
  201    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  202    00000004 ........              DC32    BLANK_NFA
  203                           UP_SV:
  204    00000008 .............         DC32    DOCON, UP
                  ...          
  205                           
  206                           
  207                           //      FENCE FENCE_SV: ( -- addr of FENCE )
  208                           //      A system variable containing an address below which FORGET ting is
  209                           //      trapped. To forget below this point the system must alter the contents
  210                           //      of FENCE.
  211                           
  212                            SECTION .text : CONST (2)
  213                           FENCE_NFA:
  214    00000000 85                    DC8     0x85
  215    00000001 46454E43              DC8     'FENC'
  216    00000005 C5                    DC8     'E'+0x80
  217    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  218    00000008 ........              DC32    UP_NFA
  219                           FENCE_SV:
  220    0000000C .............         DC32    DOCON, FENCE
                  ...          
  221                           
  222                           
  223                           //      DP DP_SV:       ( -- addr of DP ) Value stored here is ALIGNED
  224                           //      A system variable, the dictionary pointer, which contains the address
  225                           //      of the next free memory above the dictionary. The value may be read
  226                           //      by HERE and altered by COMMA (ALIGNED) , ALLOT and CALLOT (UNALIGNED) .
  227                           
  228                            SECTION .text : CONST (2)
  229                           DP_NFA:
  230    00000000 82                    DC8     0x82
  231    00000001 44                    DC8     'D'
  232    00000002 D0                    DC8     'P'+0x80
  233    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  234    00000004 ........              DC32    FENCE_NFA
  235                           DP_SV:
  236    00000008 .............         DC32    DOCON, DP
                  ...          
  237                           
  238                           
  239                           //      BASE BASE_SV:   ( -- addr of NBASE )
  240                           //      A system variable containing the current number base used for input
  241                           //      and output conversion.
  242                           
  243                            SECTION .text : CONST (2)
  244                           BASE_NFA:
  245    00000000 84                    DC8     0x84
  246    00000001 424153                DC8     'BAS'
  247    00000004 C5                    DC8     'E'+0x80
  248    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  249    00000008 ........              DC32    DP_NFA
  250                           BASE_SV:
  251    0000000C .............         DC32    DOCON, NBASE
                  ...          
  252                           
  253                           
  254                           //      CURRENT CURRENT_SV:     ( -- addr of CURRENT )
  255                           //      CURRENT searched everytime. CONTEXT is not used
  256                           //      Used by Create, Definitions, etc and by Latest
  257                           //      to leave the nfa of the topmost word in the CURRENT
  258                           //      vocabulary.  See LATEST NOTE:(FIG) CURR @ @ this CURR @
  259                           
  260                            SECTION .text : CONST (2)
  261                           CURRENT_NFA:
  262    00000000 87                    DC8     0x87
  263    00000001 43555252454E          DC8     'CURREN'
  264    00000007 D4                    DC8     'T'+0x80
  265                            ALIGNROM 2,0xFFFFFFFF
  266    00000008 ........              DC32    BASE_NFA
  267                           CURRENT_SV:
  268    0000000C .............         DC32    DOCON, CURRENT  // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
                  ...          
  269                           
  270                           
  271                           //      STATE STATE_SV: ( -- addr of CSTATE )
  272                           //      A system variable containing the compilation state. A non-zero value
  273                           //      indicates compilation. The value itself may be implementation
  274                           //      dependent. 0xC0 must be used for INTERPRET to execute IMMEDIATE words.
  275                           
  276                            SECTION .text : CONST (2)
  277                           STATE_NFA:
  278    00000000 85                    DC8     0x85
  279    00000001 53544154              DC8     'STAT'
  280    00000005 C5                    DC8     'E'+0x80
  281    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  282    00000008 ........              DC32    CURRENT_NFA
  283                           STATE_SV:
  284    0000000C .............         DC32    DOCON, CSTATE       //Compile STATE
                  ...          
  285                           
  286                           
  287                           //      OUT OUT_SV:     ( -- addr of OUT )
  288                           //      A system variable that contains a value incremented by EMIT. The system
  289                           //      may alter and examine OUT to control display formating.
  290                           
  291                            SECTION .text : CONST (2)
  292                           OUT_NFA:
  293    00000000 83                    DC8     0x83
  294    00000001 4F55                  DC8     'OU'
  295    00000003 D4                    DC8     'T'+0x80
  296                            ALIGNROM 2,0xFFFFFFFF
  297    00000004 ........              DC32    STATE_NFA
  298                           OUT_SV:
  299    00000008 .............         DC32    DOCON, OUT
                  ...          
  300                           
  301                           
  302                           //      IN IN_SV:       ( -- addr of IN )
  303                           //      A system variable containing the byte offset within (TIB),
  304                           //      from which the tokens are parsed by WORD and moved to HERE,
  305                           //      as a counted null terminated string (created by EXPECT).
  306                           //      Initialized to 1 to skip count byte produced by EXPECT.
  307                           
  308                            SECTION .text : CONST (2)
  309                           IN_NFA:
  310    00000000 82                    DC8     0x82
  311    00000001 49                    DC8     'I'
  312    00000002 CE                    DC8     'N'+0x80
  313    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  314    00000004 ........              DC32    OUT_NFA
  315                           IN_SV:
  316    00000008 .............          DC32   DOCON, IN
                  ...          
  317                           
  318                           
  319                           //      PAD PAD_SV:     ( -- addr of PAD )
  320                           //      Leave the address of the text output buffer PAD on the stack.
  321                           //      Typically at least 82 bytes long.
  322                           
  323                            SECTION .text : CONST (2)
  324                           PAD_NFA:
  325    00000000 83                    DC8     0x83
  326    00000001 5041                  DC8     'PA'
  327    00000003 C4                    DC8     'D'+0x80
  328                            ALIGNROM 2,0xFFFFFFFF
  329    00000004 ........              DC32    IN_NFA
  330                           PAD_SV:
  331    00000008 .............         DC32    DOCON, PAD
                  ...          
  332                           
  333                           
  334                           //      TIB TIB_SV:     ( -- addr of INITTIB )
  335                           //      Leave the address of the text input buffer TIB on the stack.
  336                           //      Typically at least 82 bytes long.
  337                           
  338                            SECTION .text : CONST (2)
  339                           TIB_NFA:
  340    00000000 83                    DC8     0x83
  341    00000001 5449                  DC8     'TI'
  342    00000003 C2                    DC8     'B'+0x80
  343                            ALIGNROM 2,0xFFFFFFFF
  344    00000004 ........              DC32    PAD_NFA
  345                           TIB_SV:
  346    00000008 .............         DC32    DOCON, TIB
                  ...          
  347                           
  348                           
  349                           //======================== END SYSTEM VARIABLES ==============================//
  350                           
  351                           
  352                           //      HERE HERE:      ( -- addr ) Value stored here is ALIGNED
  353                           //      Leave the address of the next available dictionary location.
  354                           
  355                            SECTION .text : CONST (2)
  356                           HERE_NFA:
  357    00000000 84                    DC8     0x84
  358    00000001 484552                DC8     'HER'
  359    00000004 C5                    DC8     'E'+0x80
  360    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  361    00000008 ........              DC32    TIB_NFA
  362                           HERE:
  363    0000000C ........              DC32    DOCOL
  364    00000010 ........              DC32    DP_SV
  365    00000014 ........              DC32    AT
  366    00000018 ........              DC32    SEMIS
  367                           
  368                           
  369                           //      ALLOT ALLOT:    ( sn -- ) Warning: UNALIGNED:
  370                           //      IF DICTIONAIRY FULL PRINT error MESSAGE AND abort.
  371                           //      Add the signed number to the dictionary pointer DP. May be used to
  372                           //      reserve dictionary space or re-origin memory.
  373                           //      CAUTION!
  374                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  375                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  376                           
  377                            SECTION .text : CONST (2)
  378                           ALLOT_NFA:
  379    00000000 85                    DC8     0x85
  380    00000001 414C4C4F              DC8     'ALLO'
  381    00000005 D4                    DC8     'T'+0x80
  382    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  383    00000008 ........              DC32    HERE_NFA
  384                           ALLOT:
  385    0000000C ........              DC32    DOCOL
  386    00000010 ........              DC32    DICTSPACE       // \ -- n
  387    00000014 .............         DC32    OVER, SUBB
                  ...          
  388    0000001C ........              DC32    ZLESS
  389    00000020 ........              DC32    ZBRAN
  390    00000024 08000000              DC32    ALLOTOK-.
  391                           
  392    00000028 ........              DC32    DICTFULL_ABORT
  393                           
  394                           ALLOTOK:
  395    0000002C ........              DC32    DP_SV
  396    00000030 ........              DC32    PSTORE
  397    00000034 ........              DC32    SEMIS
  398                           
  399                           
  400                           //      ALIGNED ALIGNED:        ( addr -- a-addr ) DPANS94
  401                           
  402                            SECTION .text : CONST (2)
  403                           ALIGNED_NFA:
  404    00000000 87                    DC8     0x87
  405    00000001 414C49474E45          DC8     'ALIGNE'
  406    00000007 C4                    DC8     'D'+0x80
  407                            ALIGNROM 2,0xFFFFFFFF
  408    00000008 ........              DC32    ALLOT_NFA
  409                           ALIGNED:
  410    0000000C ........              DC32    .+5
  411                            SECTION .text : CODE (2)
  412                                   POP2t
  412.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  412.2                         //#ifndef TOSCT
  412.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  412.4                         //#endif
  412.5                         //      ADDS    p, p, #4
  412.6                                 ENDM
  413    00000004 C01C                  ADDS    t, t, #3
  414    00000006 0549                  LDR     n, =-4
  415    00000008 0840                  ANDS    t, t, n
  416                                   TPUSH
  416                                   PUSHt   // push t to p, pre decrement p
  416.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  416.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  416.3                         //      STR     t, [p]
  416.4                                 ENDM
  416                                   NEXT
  416.1                         // ARMv7-M Thumb = .+5
  416.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  416.3                         // ARMv6-M Thumb = .+4
  416.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  416                                   NEXT1
  416.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  416.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  416.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  416.4                         // ARMv6-M Thumb = .+4
  416.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  416.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  416.7                                 ENDM
  416.8                                 ENDM
  416.9                                 ENDM
  417                            LTORG
  417.1                                  TABLE
  417.2  0000001C FCFFFFFF              Reference on line 414
  418                           
  419                           
  420                           //      ALIGN32_DP_FF_PAD ALIGN:        ( -- ) DPANS94
  421                           //      Align DP_SV primitive. Pads current DP with 0xFF until aligned.
  422                           //      USED IN , (COMMA:) .  Reflected by HERE .
  423                           //      CAUTION! USE AFTER ALLOT or C, (CCOMMA:) .
  424                           //      See , (COMMA:) which is ALIGNED.
  425                           
  426                            SECTION .text : CONST (2)
  427                           ALIGN_NFA:
  428    00000000 85                    DC8     0x85
  429    00000001 414C4947              DC8     'ALIG'
  430    00000005 CE                    DC8     'N'+0x80
  431    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  432    00000008 ........              DC32    ALIGNED_NFA
  433                           ALIGN:
  434                           ALIGN32_DP_FF_PAD:
  435    0000000C ........              DC32    DOCOL
  436    00000010 ........              DC32    HERE
  437                                   // COULD ADD CODE TO SEE IF ALIGNED ALREADY
  438    00000014 .............         DC32    THREE, PLUS             // 3PLUS
                  ...          
  439    0000001C .............         DC32    DUP, TOR
                  ...          
  440    00000024 ........              DC32    HERE
  441    00000028 ........              DC32    XDO
  442                           ALIGN_PAD_DO:
  443    0000002C ........FF000         DC32    LIT, 0xFF, I, CSTORE
                  000..........
                  ......       
  444    0000003C ........              DC32    XLOOP
  445    00000040 ECFFFFFF              DC32    ALIGN_PAD_DO-.
  446                           
  447    00000044 ........              DC32    RFROM
  448    00000048 ........FCFFF         DC32    LIT, 0xFFFFFFFC // -4
                  FFF          
  449    00000050 ........              DC32    ANDD
  450    00000054 .............         DC32    DP_SV, STORE
                  ...          
  451    0000005C ........              DC32    SEMIS
  452                           
  453                           
  454                           //      , COMMA:        ( n -- ) ALIGNED
  455                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  456                           //      Write n into next ALIGNED dictionary memory cell, DP reflected by HERE
  457                           
  458                            SECTION .text : CONST (2)
  459                           COMMA_NFA:
  460    00000000 81                    DC8     0x81
  461    00000001 AC                    DC8     ','+0x80
  462    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  463    00000004 ........              DC32    ALIGN_NFA
  464                           COMMA:
  465    00000008 ........              DC32    DOCOL
  466    0000000C ........              DC32    DICTSPACE       // \ -- n
  467    00000010 ........              DC32    ZLESS
  468    00000014 ........              DC32    ZBRAN
  469    00000018 08000000              DC32    COMMA_OK-.
  470                           
  471    0000001C ........              DC32    DICTFULL_ABORT
  472                           
  473                           COMMA_OK:
  474    00000020 ........              DC32    COMMA_PRIM
  475    00000024 ........              DC32    SEMIS
  476                           
  477                           
  478                           //      C, CCOMMA:      ( n -- ) Warning: UNALIGNED:
  479                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  480                           //      Store LS 8 bits of n into the next available dictionary byte, advancing
  481                           //      the dictionary pointer.
  482                           //      CAUTION!
  483                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  484                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  485                           //      See , (COMMA:) which is ALIGNED.
  486                           
  487                            SECTION .text : CONST (2)
  488                           CCOMMA_NFA:
  489    00000000 82                    DC8     0x82
  490    00000001 43                    DC8     'C'
  491    00000002 AC                    DC8     ','+0x80
  492    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  493    00000004 ........              DC32    COMMA_NFA
  494                           CCOMMA:
  495    00000008 ........              DC32    DOCOL
  496    0000000C ........              DC32    DICTSPACE       // \ -- n
  497    00000010 ........              DC32    ZLESS
  498    00000014 ........              DC32    ZBRAN
  499    00000018 08000000              DC32    CCOMMA_OK-.
  500                           
  501    0000001C ........              DC32    DICTFULL_ABORT
  502                           
  503                           CCOMMA_OK:
  504    00000020 ........              DC32    HERE
  505    00000024 ........              DC32    CSTORE
  506    00000028 ........              DC32    ONE
  507    0000002C ........              DC32    ALLOT_PRIM
  508    00000030 ........              DC32    SEMIS
  509                           
  510                           
  511                           //      VARALLOT VARALLOT:      ( n -- addr ) Value stored here is ALIGNED
  512                           //      IF USERVAR SPACE FULL PRINT Error MESSAGE AND Abort.
  513                           //      Add n * 32 bits to the RAMVARSPACE pointer UP.
  514                           //      Used to allocate space in Ram for VAR's and other system data structures
  515                           
  516                            SECTION .text : CONST (2)
  517                           VARALLOT_NFA:
  518    00000000 88                    DC8     0x88
  519    00000001 564152414C4C4         DC8     'VARALLO'
                  F            
  520    00000008 D4                    DC8     'T'+0x80
  521    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  522    0000000C ........              DC32    CCOMMA_NFA
  523                           VARALLOT:
  524    00000010 ........              DC32    DOCOL
  525    00000014 ........              DC32    VARSPACE                // \ -- n
  526    00000018 .............         DC32    FOUR, SLASH, OVER, SUBB
                  .............
                  ......       
  527    00000028 ........              DC32    ZLESS
  528    0000002C ........              DC32    ZBRAN
  529    00000030 18000000              DC32    VALLOT_OK-.
  530                           
  531    00000034 .............         DC32    LIT, msg_uvfull
                  ...          
  532    0000003C .............         DC32    NULLSTRLEN, TYPE
                  ...          
  533                           #ifdef IO2TP
  537                           #endif
  538    00000044 ........              DC32    ABORT
  539                           
  540                           VALLOT_OK:
  541    00000048 .............         DC32    UP_SV, AT       // Address of this allotment
                  ...          
  542    00000050 ........              DC32    SWAP            // n
  543    00000054 .............         DC32    FOUR, STAR      // n = 4 bytes
                  ...          
  544    0000005C ........              DC32    UP_SV
  545    00000060 ........              DC32    PSTORE          // Address of next var available
  546    00000064 ........              DC32    SEMIS
  547                           
  548                           
  549                           //      LATEST LATEST: ( -- nfa )
  550                           //      Initially ADDR OF LAST WORD IN THE DICTIONARY
  551                           //      Leave the nfa of the topmost word in the dictionary.
  552                           
  553                            SECTION .text : CONST (2)
  554                           LATEST_NFA:
  555    00000000 86                    DC8     0x86
  556    00000001 4C41544553            DC8     'LATES'
  557    00000006 D4                    DC8     'T'+0x80
  558    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  559    00000008 ........              DC32    VARALLOT_NFA
  560                           LATEST:
  561    0000000C ........              DC32    DOCOL
  562    00000010 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
  563    00000014 ........              DC32    AT
  564    00000018 ........              DC32    SEMIS
  565                           
  566                           
  567                           //      LFA LFA:        ( pfa -- lfa )
  568                           //      Convert the parameter field address of a dictionary definition to
  569                           //      its link field address.
  570                           
  571                            SECTION .text : CONST (2)
  572                           LFA_NFA:
  573    00000000 83                    DC8     0x83
  574    00000001 4C46                  DC8     'LF'
  575    00000003 C1                    DC8     'A'+0x80
  576                            ALIGNROM 2,0xFFFFFFFF
  577    00000004 ........              DC32    LATEST_NFA
  578                           LFA:
  579    00000008 ........              DC32    .+5
  580                            SECTION .text : CODE (2)
  581                                   POP2t
  581.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  581.2                         //#ifndef TOSCT
  581.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  581.4                         //#endif
  581.5                         //      ADDS    p, p, #4
  581.6                                 ENDM
  582    00000004 0838                  SUBS     t, t, #8
  583                                   TPUSH
  583                                   PUSHt   // push t to p, pre decrement p
  583.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  583.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  583.3                         //      STR     t, [p]
  583.4                                 ENDM
  583                                   NEXT
  583.1                         // ARMv7-M Thumb = .+5
  583.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  583.3                         // ARMv6-M Thumb = .+4
  583.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  583                                   NEXT1
  583.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  583.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  583.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  583.4                         // ARMv6-M Thumb = .+4
  583.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  583.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  583.7                                 ENDM
  583.8                                 ENDM
  583.9                                 ENDM
  584                           
  585                           
  586                           //      CFA CFA:        ( pfa -- cfa )
  587                           //      Convert the parameter field address of a dictionary definition to
  588                           //      its code field address. <if thumb2 execution addr smudged>
  589                           
  590                            SECTION .text : CONST (2)
  591                           CFA_NFA:
  592    00000000 83                    DC8     0x83
  593    00000001 4346                  DC8     'CF'
  594    00000003 C1                    DC8     'A'+0x80
  595                            ALIGNROM 2,0xFFFFFFFF
  596    00000004 ........              DC32    LFA_NFA
  597                           CFA:
  598    00000008 ........              DC32    .+5
  599                            SECTION .text : CODE (2)
  600                                   POP2t
  600.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  600.2                         //#ifndef TOSCT
  600.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  600.4                         //#endif
  600.5                         //      ADDS    p, p, #4
  600.6                                 ENDM
  601    00000004 001F                  SUBS     t, t, #4
  602                                   TPUSH
  602                                   PUSHt   // push t to p, pre decrement p
  602.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  602.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  602.3                         //      STR     t, [p]
  602.4                                 ENDM
  602                                   NEXT
  602.1                         // ARMv7-M Thumb = .+5
  602.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  602.3                         // ARMv6-M Thumb = .+4
  602.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  602                                   NEXT1
  602.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  602.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  602.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  602.4                         // ARMv6-M Thumb = .+4
  602.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  602.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  602.7                                 ENDM
  602.8                                 ENDM
  602.9                                 ENDM
  603                           
  604                           
  605                           //      NFA NFA:        ( pfa -- nfa )
  606                           //      Convert the parameter field address of a definition to its name
  607                           //      field. Modified for nfa alighnment padding
  608                           
  609                            SECTION .text : CONST (2)
  610                           NFA_NFA:
  611    00000000 83                    DC8     0x83
  612    00000001 4E46                  DC8     'NF'
  613    00000003 C1                    DC8     'A'+0x80
  614                            ALIGNROM 2,0xFFFFFFFF
  615    00000004 ........              DC32    CFA_NFA
  616                           NFA:
  617    00000008 ........              DC32    DOCOL
  618    0000000C .............         DC32    EIGHT, SUBB     // Addr OF lfa, DUPED TO TRAVERSE Padding
                  ...          
  619                           
  620                           NFA_ALIGN_BEGIN:
  621    00000014 .............         DC32    ONE, SUBB       // ADDR 1 BEFORE lfa, eliminate padding
                  ...          
  622    0000001C .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  623    00000024 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  624    00000030 ........              DC32    ZBRAN           // UNTIL
  625    00000034 E0FFFFFF              DC32    NFA_ALIGN_BEGIN-.
  626                                       
  627    00000038 ........FFFFF         DC32    LIT,-1          // DIRECTION FOR TRAVERSE = Toward nfa
                  FFF          
  628    00000040 ........              DC32    TRAVERSE                // \ -- addr2
  629    00000044 ........              DC32    SEMIS
  630                           
  631                           
  632                           //      PFA PFA:        ( nfa -- pfa )
  633                           //      Convert the name field address of a compiled definition to its
  634                           //      parameter field address.
  635                           
  636                            SECTION .text : CONST (2)
  637                           PFA_NFA:
  638    00000000 83                    DC8     0x83
  639    00000001 5046                  DC8     'PF'
  640    00000003 C1                    DC8     'A'+0x80
  641                            ALIGNROM 2,0xFFFFFFFF
  642    00000004 ........              DC32    NFA_NFA
  643                           PFA:
  644    00000008 ........              DC32    DOCOL           // \ NFA --
  645    0000000C ........              DC32    ONE             // DIRECTION FOR TRAVERSE = Toward CFA
  646    00000010 ........              DC32    TRAVERSE        // \ NFA 1 -- addr2
  647                           
  648                           PFA_ALIGN_BEGIN:
  649    00000014 ........              DC32    ONEP            // ADDR 1 BEFORE lfa, eliminate padding
  650    00000018 .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  651    00000020 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  652    0000002C ........              DC32    ZBRAN           // UNTIL
  653    00000030 E4FFFFFF              DC32    PFA_ALIGN_BEGIN-.
  654                           
  655    00000034 ........              DC32    EIGHT
  656    00000038 ........              DC32    PLUS
  657    0000003C ........              DC32    SEMIS
  658                           
  659                           
  660                           //      ?ALIGNED QALIGNED: ( value -- )
  661                           //      If value not aligned by 4 issue message and ABORT.
  662                           
  663                            SECTION .text : CONST (2)
  664                           QALIGNED_NFA:
  665    00000000 88                    DC8     0x88
  666    00000001 3F414C49474E4         DC8     '?ALIGNE'
                  5            
  667    00000008 C4                    DC8     'D'+0x80
  668    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  669    0000000C ........              DC32    PFA_NFA
  670                           QALIGNED:
  671    00000010 ........              DC32    DOCOL
  672    00000014 ........03000         DC32    LIT, 3, ANDD
                  000........  
  673    00000020 ........              DC32    ZBRAN           //IF no err leave
  674    00000024 3C000000              DC32     QALIGN_OK-.
  675                           
  676    00000028 ........              DC32    PDOTQ
  677    0000002C 2E                    DC8     46
  678    0000002D 56414C5545204         DC8     'VALUE MUST BE EVEN NOT ODD AND MULTIPLE OF 4! '
                  D555354204245
                  204556454E204
                  E4F54204F4444
                  20414E44204D5
                  54C5449504C45
                  204F462034212
                  0            
  679    0000005B FF             ALIGNROM 2,0xFFFFFFFF
  680    0000005C ........              DC32    ABORT
  681                           
  682                           QALIGN_OK:
  683    00000060 ........              DC32    SEMIS
  684                           
  685                           
  686                           //      ?ERROR QERROR: ( f nullstr -- )
  687                           //      If f NON ZERO type error message (nullstr) and ABORT.
  688                           
  689                            SECTION .text : CONST (2)
  690                           QERROR_NFA:
  691    00000000 86                    DC8     0x86
  692    00000001 3F4552524F            DC8     '?ERRO'
  693    00000006 D2                    DC8     'R'+0x80
  694    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  695    00000008 ........              DC32    QALIGNED_NFA
  696                           QERROR:
  697    0000000C ........              DC32    DOCOL
  698    00000010 ........              DC32    SWAP
  699    00000014 ........              DC32    ZBRAN   //IF no err leave
  700    00000018 10000000              DC32     QERROR_FINISH-.
  701                           
  702    0000001C ........              DC32    ERROR   // nullstr-addr ---  ABORT's
  703    00000020 ........              DC32    BRAN    // ELSE
  704    00000024 08000000              DC32     QERROR_DONE-.
  705                           
  706                           QERROR_FINISH:
  707    00000028 ........              DC32    DROP    //endif
  708                           
  709                           QERROR_DONE:
  710    0000002C ........              DC32    SEMIS
  711                           
  712                           
  713                           //      DIGIT DIGIT:    ( c base -- digit 1 ) (ok)
  714                           //                      ( c base -- 0 (bad)
  715                           //      Converts the ascii character c using base to its binary
  716                           //      equivalent digit, accompanied by a true flag. If the conversion is
  717                           //      invalid, leaves only a false flag.
  718                           
  719                           //      If digit gets 0, space, dot, comma or any non number it returns 0 
  720                           
  721                            SECTION .text : CONST (2)
  722                           DIGIT_NFA:
  723    00000000 85                    DC8     0x85
  724    00000001 44494749              DC8     'DIGI'
  725    00000005 D4                    DC8     'T'+0x80
  726    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  727    00000008 ........              DC32    QERROR_NFA
  728                           DIGIT:
  729    0000000C ........              DC32    .+5
  730                            SECTION .text : CODE (2)
  731                                   POP2w                   // Number base
  731.1  00000000 57F8042B              LDR     w, [p],#4
  731.2                         //      LDR     w, [p]
  731.3                         //      ADDS    p, p, #4
  731.4                                 ENDM
  732                                   POP2t                   // ASCII DIGIT
  732.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
  732.2                         //#ifndef TOSCT
  732.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  732.4                         //#endif
  732.5                         //      ADDS    p, p, #4
  732.6                                 ENDM
  733    00000008 3038                  SUBS   t, t, #'0'
  734    0000000A 13D4                  BMI   DIGI2             // Number error
  735                           
  736    0000000C 0928                  CMP   t, #9
  737    0000000E 02DD                  BLE   DIGI1             // Number = 0 THRU 9
  738                           
  739                                   // Combine?
  740    00000010 C01F                  SUBS   t, t, #7
  741    00000012 0A28                  CMP   t, #10            // Number 'A' THRU 'Z'?
  742    00000014 0EDB                  BLT   DIGI2             // NO
  743                           
  744                           DIGI1:
  745    00000016 9042                  CMP     t, w            // COMPARE Number TO base
  746    00000018 0CDA                  BGE     DIGI2
  747                           
  748    0000001A 0246                  MOV     w, t            // NEW BINARY Number
  749    0000001C 0120                  MOVS    t, #1           // TRUE FLAG
  750                                   DPUSH
  750                                   PUSHw   // push w to p, post decrement p
  750.1  0000001E 47F8042D              STR     w, [p, #-4]!
  750.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  750.3                         //      STR     w, [p]
  750.4                                 ENDM
  750                                   TPUSH
  750                                   PUSHt   // push t to p, pre decrement p
  750.1  00000022 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  750.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  750.3                         //      STR     t, [p]
  750.4                                 ENDM
  750                                   NEXT
  750.1                         // ARMv7-M Thumb = .+5
  750.2  00000026 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  750.3                         // ARMv6-M Thumb = .+4
  750.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  750                                   NEXT1
  750.1  0000002A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  750.2  0000002E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  750.3  00000032 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  750.4                         // ARMv6-M Thumb = .+4
  750.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  750.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  750.7                                 ENDM
  750.8                                 ENDM
  750.9                                 ENDM
  750.10                                ENDM
  751                           
  752                                   // Number error
  753                           DIGI2:
  754    00000034 0020                  MOVS   t, #0            // FALSE FLAG
  755                                   TPUSH
  755                                   PUSHt   // push t to p, pre decrement p
  755.1  00000036 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  755.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  755.3                         //      STR     t, [p]
  755.4                                 ENDM
  755                                   NEXT
  755.1                         // ARMv7-M Thumb = .+5
  755.2  0000003A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  755.3                         // ARMv6-M Thumb = .+4
  755.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  755                                   NEXT1
  755.1  0000003E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  755.2  00000042 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  755.3  00000046 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  755.4                         // ARMv6-M Thumb = .+4
  755.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  755.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  755.7                                 ENDM
  755.8                                 ENDM
  755.9                                 ENDM
  756                           
  757                           
  758                           //      ENCLOSE ENCL:   ( addr1 c -- addr1 n1 n2 n3 )
  759                           //      A text scanning iterative primitive used only in WORD.
  760                           //      IN is used before and after callS for the iteration
  761                           //      Typically TIB + IN = addr1
  762                           //      noop EX: \ TIB   32 -- TIB   0 4 5
  763                           //      NULL EX: \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  764                           //      NULL EX: \ WORD/ENCL -> TIB 1, 0, 20'S
  765                           //      From the text address addr1 and an ascii delimiting character c,
  766                           //      is determined the byte offset to the first non-delimiter character n1,
  767                           //      the offset to the first delimiter after the text n2,
  768                           //      and the offset to the first character not included.
  769                           //      This procedure will not process past an ASCII 'null', treating it
  770                           //      as an unconditional delimiter. NULL termination by EXPECT in QUERY.
  771                           
  772                            SECTION .text : CONST (2)
  773                           ENCL_NFA:
  774    00000000 87                    DC8     0x87
  775    00000001 454E434C4F53          DC8     'ENCLOS'
  776    00000007 C5                    DC8     'E'+0x80
  777                            ALIGNROM 2,0xFFFFFFFF
  778    00000008 ........              DC32    DIGIT_NFA
  779                           ENCL:
  780    0000000C ........              DC32    .+5
  781                            SECTION .text : CODE (2)
  782                                   POP2t                   // TERMINATOR CHAR
  782.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  782.2                         //#ifndef TOSCT
  782.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  782.4                         //#endif
  782.5                         //      ADDS    p, p, #4
  782.6                                 ENDM
  783    00000004 3968                  LDR     n, [p]          // get text address but leave on stack
  784    00000006 0022                  MOVS    w, #0
  785    00000008 521E                  SUBS    w, w, #1        // CHAR  COUNTER
  786    0000000A 491E                  SUBS    n, n, #1        // ADDR -1
  787                           
  788                           //  SCAN TO FIRST NON-TERMINATOR CHARACTER
  789                           //      and PUSH count to stack leaving last 2 params to compute
  790                           ENCL1:
  791    0000000C 491C                  ADDS    n, n, #1        // ADDR+1
  792    0000000E 521C                  ADDS    w, w, #1        // COUNT+1
  793    00000010 0B78                  LDRB    x, [n]
  794    00000012 9842                  CMP     t, x            //CMP   AL,[BX]
  795    00000014 FAD0                  BEQ     ENCL1           //JZ    ENCL1   // WAIT FOR NON-TERMINATOR
  796                                   PUSHw                   //offset to the first non-delimiter character
  796.1  00000016 47F8042D              STR     w, [p, #-4]!
  796.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  796.3                         //      STR     w, [p]
  796.4                                 ENDM
  797                                                           //EXiT is now only DPUSH
  798    0000001A 002B                  CMP     x, #0           //CMP   AH,[BX] // null CHAR?
  799    0000001C 0CD1                  BNE     ENCL2           //JNZ   ENCL2   // NO
  800                           
  801                           // FOUND null BEFORE 1ST NON-TERM CHAR
  802                           // RETURN ok args = NULL EX//
  803                           // \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  804                           //
  805    0000001E 1846                  MOV     t, x
  806    00000020 521C                  ADDS    w, w, #1        // w = offset to the delimiter after the text
  807                                   DPUSH
  807                                   PUSHw   // push w to p, post decrement p
  807.1  00000022 47F8042D              STR     w, [p, #-4]!
  807.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  807.3                         //      STR     w, [p]
  807.4                                 ENDM
  807                                   TPUSH
  807                                   PUSHt   // push t to p, pre decrement p
  807.1  00000026 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  807.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  807.3                         //      STR     t, [p]
  807.4                                 ENDM
  807                                   NEXT
  807.1                         // ARMv7-M Thumb = .+5
  807.2  0000002A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  807.3                         // ARMv6-M Thumb = .+4
  807.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  807                                   NEXT1
  807.1  0000002E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  807.2  00000032 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  807.3  00000036 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  807.4                         // ARMv6-M Thumb = .+4
  807.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  807.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  807.7                                 ENDM
  807.8                                 ENDM
  807.9                                 ENDM
  807.10                                ENDM
  808                           
  809                           //   FOUND FIRST TEXT CHAR - COUNT THE CHARS
  810                           ENCL2:
  811    00000038 491C                  ADDS    n, n, #1        // ADDR+1
  812    0000003A 521C                  ADDS    w, w, #1        //COUNT+1
  813    0000003C 0B78                  LDRB    x, [n]
  814    0000003E 9842                  CMP     t, x            //TERMINATOR CHAR?
  815    00000040 01D0                  BEQ     ENCL4           //YES
  816                           
  817    00000042 002B                  CMP     x, #0           //null CHAR?
  818    00000044 F8D1                  BNE     ENCL2           //NO, LOOP AGAIN
  819                           
  820                           ENCL3:  //   FOUND null AT END OF TEXT
  821                           ENCL4:  //   FOUND TERMINATOR CHARACTER
  822    00000046 1046                  MOV     t, w            // COUNT+1 =
  823    00000048 401C                  ADDS    t, t, #1        // offset to the first character not included
  824                                   DPUSH
  824                                   PUSHw   // push w to p, post decrement p
  824.1  0000004A 47F8042D              STR     w, [p, #-4]!
  824.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  824.3                         //      STR     w, [p]
  824.4                                 ENDM
  824                                   TPUSH
  824                                   PUSHt   // push t to p, pre decrement p
  824.1  0000004E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  824.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  824.3                         //      STR     t, [p]
  824.4                                 ENDM
  824                                   NEXT
  824.1                         // ARMv7-M Thumb = .+5
  824.2  00000052 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  824.3                         // ARMv6-M Thumb = .+4
  824.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  824                                   NEXT1
  824.1  00000056 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  824.2  0000005A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  824.3  0000005E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  824.4                         // ARMv6-M Thumb = .+4
  824.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  824.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  824.7                                 ENDM
  824.8                                 ENDM
  824.9                                 ENDM
  824.10                                ENDM
  825                           
  826                           
  827                           //      0 NULL: ( -- ) IMMEDIATE
  828                           //      Don't return to Interpret, return to Quit at end of a line of input.
  829                           //      Executed at end of TIB when QUERY lenght or CR entered.
  830                           
  831                            SECTION .text : CONST (2)
  832                           NULL_NFA:
  833    00000000 C1                    DC8     0x0C1                   // A BINARY ZER
  834    00000001 80                    DC8     0x80
  835    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  836    00000004 ........              DC32    ENCL_NFA
  837                           NULL:
  838                           //      DC32    SEMIS                   // Actual Semis code below
  839    00000008 ........              DC32    .+5
  840                            SECTION .text : CODE (2)
  841                                   POPr2i  // pop docol saved IP from Rstack
  841.1  00000000 56F8045B              LDR     i, [r],#4       ; pop DOCOL'd IP from Rstack
  841.2                         //      LDR i, [r]              //  pop r to i, post increment r
  841.3                         //      ADDS    r, r, #4
  841.4                                 ENDM
  842                                   NEXT
  842.1                         // ARMv7-M Thumb = .+5
  842.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  842.3                         // ARMv6-M Thumb = .+4
  842.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  842                                   NEXT1
  842.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  842.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  842.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  842.4                         // ARMv6-M Thumb = .+4
  842.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  842.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  842.7                                 ENDM
  842.8                                 ENDM
  843                           
  844                           
  845                           //      WORD WORD:      ( c -- )
  846                           //      Parse the text in TIB , until a delimiter c is found, tokenizing input.
  847                           //      Move the token to HERE, with a count byte and 2 nulls at the end.
  848                           //      Leading occurrences of c are ignored. IN is incremented.
  849                           //      See IN. Usually used inside a definition.
  850                           
  851                            SECTION .text : CONST (2)
  852                           WORD_NFA:
  853    00000000 84                    DC8     0x84
  854    00000001 574F52                DC8     'WOR'
  855    00000004 C4                    DC8     'D'+0x80
  856    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  857    00000008 ........              DC32    NULL_NFA
  858                           WORD:
  859    0000000C ........              DC32    DOCOL
  860                           WORD1:
  861                           //      This is required for number suffix's at least ???
  862                           // NOT WITH NEW COUNTED NULL STRING EXPECT
  863                           //      DC32    HERE, LIT, MAXWORDLEN+2, BLANKS
  864    00000010 ........              DC32    TIB_SV
  865                           WORD2:
  866    00000014 ........              DC32    IN_SV
  867    00000018 ........              DC32    AT
  868    0000001C ........              DC32    PLUS
  869    00000020 ........              DC32    SWAP    // ( TIB+IN CH-DELIM -- )
  870    00000024 ........              DC32    ENCL    // ( TIB+IN 32 -- TIB+IN   0 4 5 )
  871                           WENCL:
  872    00000028 ........              DC32    IN_SV   // encl TOS = end of word offset to be added to IN
  873    0000002C ........              DC32    PSTORE  // TIB+IN   0 4
  874    00000030 ........              DC32    OVER    // 
  875    00000034 ........              DC32    SUBB    // Char cnt going to R and HERE
  876    00000038 ........              DC32    TOR
  877    0000003C ........              DC32    R
  878    00000040 ........              DC32    HERE
  879    00000044 ........              DC32    CSTORE   // CHAR CNT OF word
  880    00000048 ........              DC32    PLUS
  881    0000004C ........              DC32    HERE
  882    00000050 ........              DC32    ONEP
  883                           //      DC32    RFROM
  884                           // MOVE word TO DICT FOR finding ENDING WITH NULLS
  885    00000054 ........              DC32    R
  886    00000058 ........              DC32    CMOVE   // ( from to count -- )
  887                           // add null to end of token - NUMBER adjusted        
  888    0000005C .............         DC32    ZERO, HERE, ONEP, RFROM, PLUS, CSTORE
                  .............
                  .............
                  .........    
  889                           #ifdef  IOBUFS_DEBUG
  891                           #endif        
  892    00000074 ........              DC32    SEMIS
  893                           
  894                           
  895                           //      NUMBER NUMBER:  ( addr -- sd )
  896                           //      If error print message and ABORT.
  897                           //      Convert a character string left at addr with a preceeding count,
  898                           //      and a terminating null, to a signed number, in the current numeric base.
  899                           //      If a decimal point is encountered in the text, its position will be
  900                           //      given in DPL, but no other effect occurs. If numeric conversion is
  901                           //      not possible, an error message will be given.
  902                           
  903                           //      Added support for , as a single number formatter.
  904                           
  905                           #define comma_test
  906                           
  907                            SECTION .text : CONST (2)
  908                           NUMBER_NFA:
  909    00000000 86                    DC8     0x86
  910    00000001 4E554D4245            DC8     'NUMBE'
  911    00000006 D2                    DC8     'R'+0x80
  912    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  913    00000008 ........              DC32    WORD_NFA
  914                           NUMBER:
  915    0000000C ........              DC32    DOCOL
  916    00000010 ........              DC32    BASE_TO_R12     // Save current BASE.
  917    00000014 ........              DC32    NUMBERSUFFIX    // (addr -- sddr) Change BASE if suffix used.
  918                           
  919                           // SETUP: stack arguments for PNUMBER.
  920    00000018 .............         DC32    ZERO, ZERO
                  ...          
  921    00000020 ........              DC32    ROT             // ( 0 0 addr -- )
  922                           
  923                           // SETUP: reeturn stack with sign flag
  924                           // NONAME CANDIDATE!
  925                           // START: Handle minus sign by saving status on Return Stack.
  926                           // and incrementing to addr after it.
  927    00000024 .............         DC32    DUP, ONEP       // ( 0 0 addr addr+1 -- )
                  ...          
  928    0000002C ........              DC32    CAT             // ( 0 0 addr 1rstchar -- )
  929    00000030 ........2D000         DC32    LIT, '-'        // ( 0 0 addr 1rstchar 0x2D --- )
                  000          
  930    00000038 ........              DC32    EQUAL           // ( 0 0 addr f -- )
  931                           #ifdef TRUE_EQU_NEG_ONE         // EQUAL returns -1 NEED 0 or 1 here!
  932    0000003C .............         DC32    ONE, ANDD       // ( 0 0 addr f -- ) MAKE FLAG ONE OR ZERO!
                  ...          
  933                           #endif
  934    00000044 .............         DC32    DUP, TOR        // ( 0 0 addr f -- ) copy of f >R
                  ...          
  935                           // END: Handle - by saving status on Return Stack.
  936                           
  937                           // SETUP: addr pointing to 1rst digit.
  938                           // If minus sign, flag from above will increment to next char.
  939    0000004C ........              DC32    PLUS            // Increment (OR NOT) addr to next char
  940                           
  941                           // So could be at 1rst OR 2nd character in string here!
  942                           
  943                           // ENTER LOOP WITH -1 DPL = single number and sign flag on return stack.
  944    00000050 ........FFFFF         DC32    LIT, -1
                  FFF          
  945                           // PNUMBER is used in loop to convert string segment until non-mumeric chracter.
  946                           // A period in the string manipulates DPL to create a double number.
  947                           // A comma in the string resets DPL to create a single number.
  948                           // A null indicates the end of the string.
  949                           NUMB1:                          // Begin
  950    00000058 .............         DC32    DPL_SV, STORE   // PNUMBER creates whole, dot or comma number segment
                  ...          
  951                           
  952                           // PNUMBER converts one or more characters until first unconvertable digit.
  953                           // ud and addr in string is maintained while in loop.
  954    00000060 ........              DC32    PNUMBER         // ( 0 0 addr -- ud=(LSW MSW) ADDR=PAST#)
  955                           // Perform check for period, comma and null.
  956                           // Any other character here invalidates this number conversion.
  957                           
  958                           // Null Test: = end of string.
  959    00000064 .............         DC32    DUP, CAT
                  ...          
  960    0000006C ........              DC32    ZERO            // End of string used to be BLANK, is now Null.
  961    00000070 ........              DC32    SUBB
  962    00000074 ........              DC32    ZBRAN           // IF emd of number string conversion is
  963    00000078 6C000000              DC32      NUMB2-.       // DONE UNLESS IT NEEDS TO BE NEGATED.
  964                           
  965                           // Period Test: = increment DPL.
  966    0000007C .............         DC32    DUP, CAT
                  ...          
  967    00000084 ........2E000         DC32    LIT, '.'        // 2Eh = period.
                  000          
  968    0000008C ........              DC32    SUBB
  969    00000090 ........              DC32    ZBRAN
  970    00000094 44000000              DC32      DPL_ZERO_INCR-.
  971                           
  972                           #ifdef  comma_test
  973                           // Comma Test: = reset DPL.
  974    00000098 .............         DC32    DUP, CAT
                  ...          
  975    000000A0 ........2C000         DC32    LIT, ','        // 2CH comma
                  000          
  976    000000A8 ........              DC32    EQUAL
  977    000000AC ........              DC32    ZBRAN
  978    000000B0 14000000              DC32      BASE_RESET_THEN_ERROR-.
  979                           
  980                           // Fall thru if comma so reset DPL to create a single number.
  981                           DPL_RESET:        
  982    000000B4 ........FFFFF         DC32    LIT, -1
                  FFF          
  983    000000BC ........              DC32    BRAN
  984    000000C0 98FFFFFF              DC32      NUMB1-.
  985                           #endif
  986                           
  987                           BASE_RESET_THEN_ERROR:
  988                           // GOING TO ERROR SO RESTORE BASE!
  989    000000C4 ........              DC32    BASE_FROM_R12   // Restore BASE
  990                           //NO_BASE_RESTORE:
  991    000000C8 ........              DC32    ONE     // provide non zero flag for error
  992    000000CC .............         DC32    LIT, msg_number_error
                  ...          
  993    000000D4 ........              DC32    QERROR // ( f nullstr-addr -- ) IF f TRUE EXECUTE ERROR!
  994                           
  995                           DPL_ZERO_INCR:      // set DPL to zero
  996    000000D8 ........              DC32    ZERO
  997    000000DC ........              DC32    BRAN
  998    000000E0 78FFFFFF              DC32      NUMB1-.
  999                           
 1000                           NUMB2:
 1001    000000E4 ........              DC32    DROP
 1002    000000E8 ........              DC32    RFROM           // FLAG OF "-" TEST
 1003                                                           // IF
 1004    000000EC ........              DC32    ZBRAN
 1005    000000F0 08000000              DC32      NUMB3-.
 1006                           
 1007    000000F4 ........              DC32    DNEGATE
 1008                           
 1009                           NUMB3:                          // endif
 1010    000000F8 ........              DC32    BASE_FROM_R12   // Restore BASE
 1011    000000FC ........              DC32    SEMIS
 1012                           
 1013                           
 1014                           //      ERROR ERROR:    ( nullstr --- )
 1015                           //      Execute error notification and restart of system.
 1016                           //      IN_SV is saved to assist in determining the location of the error.
 1017                           
 1018                            SECTION .text : CONST (2)
 1019                           ERROR_NFA:
 1020    00000000 85                    DC8     0x85
 1021    00000001 4552524F              DC8     'ERRO'
 1022    00000005 D2                    DC8     'R'+0x80
 1023    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1024                           //      DC32    DFIND_NFA
 1025    00000008 ........              DC32    NUMBER_NFA
 1026                           ERROR:
 1027    0000000C ........              DC32    DOCOL
 1028    00000010 .............         DC32    HERE, COUNT, TYPE       // Offending item
                  ...........  
 1029    0000001C .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 1030                           #ifdef IO2TP
 1034                           #endif
 1035                           #ifdef XON_XOFF
 1036    00000024 ........              DC32    XOFF    // TEMP TEST THRE
 1037                           #endif
 1038                                   
 1039                           //      DO THIS WHERE STATE IS SET BACK TO ZERO
 1040    00000028 .............         DC32    STATE_SV, AT
                  ...          
 1041    00000030 ........              DC32    ZBRAN
 1042    00000034 40000000              DC32     CREATED_OK-.
 1043                           
 1044                           //      NON-ZERO CSDP = RESTORE DP TO forget DAMAGED WORDS
 1045    00000038 .............         DC32    CSDP_SV, AT   // Create saves dp here for if word exists err
                  ...          
 1046    00000040 ........              DC32    ZBRAN
 1047    00000044 30000000              DC32     CREATED_OK-.
 1048                           
 1049                           // assume ITS A CREATE'd WORD!!!!
 1050                           ERROR_FIXUP:     // CSDP_SV contains NFA of definition that has error.
 1051    00000048 .............         DC32    CSDP_SV, AT     // SHOULD BE AT NFA!!
                  ...          
 1052    00000050 ........              DC32    PFA     // \ nfa -- pfa
 1053    00000054 .............         DC32    LFA, AT // \ pfa --- lfa
                  ...          
 1054    0000005C .............         DC32    CURRENT_SV, STORE       // Has to be NFA of last good word
                  ...          
 1055                           // RESET DP!
 1056    00000064 .............         DC32    CSDP_SV, AT
                  ...          
 1057    0000006C .............         DC32    DP_SV, STORE
                  ...          
 1058                           
 1059                           CREATED_OK:
 1060    00000074 ........              DC32    SEMIC_CREATE            // RESET CSDP FOR AUTO FORGET
 1061                           #ifdef ABORT_STOP_TILL_CO
 1062    00000078 ........              DC32    ABORT
 1063                           #else
 1065                           #endif
 1066                           //      DC32    QUIT    // FROM Error
 1067                           
 1068                           
 1069                           //      ' TICK: ( -- pfa ) IMMEDIATE
 1070                           //      Used in the form: .
 1071                           //      ' CCcc
 1072                           //      Leaves the parameter field address of dictionary word CCcc.
 1073                           //      If the word is not found after a search of CURRENT,
 1074                           //      an appropriate error message is given.
 1075                           //      As a compiler directive, executed in a colon-definition to compile
 1076                           //      the address as a literal.
 1077                           //      Pronounced "TICK".
 1078                           
 1079                            SECTION .text : CONST (2)
 1080                           TICK_NFA:
 1081    00000000 C1                    DC8     0x0C1
 1082    00000001 A7                    DC8     ''''+0x80
 1083    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1084    00000004 ........              DC32    ERROR_NFA
 1085                           TICK:
 1086    00000008 ........              DC32    DOCOL
 1087    0000000C ........              DC32    DFIND   // noop there for TIB entry
 1088    00000010 ........              DC32    ZEQU
 1089    00000014 .............         DC32    LIT, msg_word_error
                  ...          
 1090    0000001C ........              DC32    QERROR    // \ f nullstr-addr --
 1091    00000020 ........              DC32    DROP
 1092    00000024 ........              DC32    LITERAL
 1093    00000028 ........              DC32    SEMIS
 1094                           
 1095                           
 1096                           //      EXPECT EXPECT:  ( addr count -- )
 1097                           //      Transfer characters from the terminal to the buffer starting at addr+1,
 1098                           //      until a "return" or the count of characters have been received.
 1099                           //      One or two nulls are added at the end creating a null-terminated string.
 1100                           //      A count byte is placed at addr, the count being derived by $LEN
 1101                           //      Use COUNT with TYPE for strings saved this way.
 1102                           //      Strings longer that 255 will have an invalid count byte. Use $LEN:
 1103                           //      $LEN and TYPE can be used when the argument to $LEN is addr+1.
 1104                           
 1105                           //      Comments below use TIB input (QUERY in INTERPRET) as an example.
 1106                           
 1107                            SECTION .text : CONST (2)
 1108                           EXPECT_NFA:
 1109    00000000 86                    DC8     0x86
 1110    00000001 4558504543            DC8     'EXPEC'
 1111    00000006 D4                    DC8     'T'+0x80
 1112    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1113    00000008 ........              DC32    TICK_NFA
 1114                           EXPECT:                 // ( NOS TOS -- NOS TOS )
 1115    0000000C ........              DC32    DOCOL   // ( TIB LEN -- )
 1116    00000010 .............         DC32    zero_OUT, zero_IN
                  ...          
 1117    00000018 ........              DC32    ONEP    // ( TIB LEN+1 -- ) (Index and Limit)+1 for count byte
 1118    0000001C ........              DC32    OVER    // ( TIB LEN+1 TIB -- )
 1119    00000020 ........              DC32    PLUS    // ( TIB TIB+LEN+1 -- )
 1120    00000024 ........              DC32    OVER    // ( TIB TIB+LEN+1 TIB -- )
 1121    00000028 ........              DC32    ONEP    // ( TIB TIB+LEN+1 TIB+1 -- ) SKIP COUNT BYTE
 1122                           #ifdef XON_XOFF
 1123    0000002C ........              DC32    XON
 1124                           #endif
 1125                           // ( ORGIGINAL-TIB TIB+LEN+1 TIB+1 -- ORGIGINAL-TIB ) 
 1126                           //                (Index & Limit)+1 for count byte
 1127    00000030 ........              DC32    XDO     // DO   Index = addr, Limit = addr+cnt
 1128                           EXPE1:
 1129    00000034 ........              DC32    KEY     // CAN BREAKPOINT OR CHANGE TO BE 0x0D ONLY
 1130                           #ifdef XON_XOFF
 1131    00000038 ........              DC32    IF_EOL_SEND_XOFF        // IF CR QUICK XOFF!
 1132                           #endif
 1133                           // goto main branch (EL1:)if not tab
 1134    0000003C .............         DC32    DUP, LIT, 9, EQUAL      // ? TAB
                  ...09000000..
                  ......       
 1135    0000004C ........              DC32    ZBRAN                   // Not tab
 1136    00000050 0C000000              DC32     EL1-.                  // Goto MAIN LOOP
 1137                                   
 1138                           // REPLACE TAB WITH SPACE               // -- ch f
 1139    00000054 .............         DC32    DROP, BLANK             // Convert tab to space
                  ...          
 1140                           EL1:
 1141                           // MAIN LOOP ENTERED WITH CHAR ON TOS
 1142    0000005C ........              DC32    DUP             // ( TIB key key -- )
 1143                           // FALL THRU IF BACKSPACE OR DELETE KEY
 1144    00000060 ........              DC32    BACKSPACE_CHAR
 1145    00000064 ........              DC32    EQUAL
 1146    00000068 ........              DC32    OVER
 1147    0000006C ........7F000         DC32    LIT, 07Fh       // DEL KEY
                  000          
 1148    00000074 ........              DC32    EQUAL
 1149    00000078 ........              DC32    OR
 1150                           // BRANCH IF NOT BACKSPACE OR DELETE KEY
 1151    0000007C ........              DC32    ZBRAN           // If not backspace
 1152    00000080 50000000              DC32     EXPE2-.        // go here
 1153                           
 1154                           // CASE OF BACKSPACE/DELETE KEY
 1155    00000084 ........              DC32    DROP            // ( TOS> 8 TIB -- TIB ) Drop Backspace on stack
 1156    00000088 ........              DC32    DUP             // ( TOS> TIB -- TOS> TIB TIB )  Current TIB addr
 1157    0000008C ........              DC32    I               // ( TOS> TIB TIB -- I=TIB+? TIB TIB )
 1158                           // COMPENSATE FOR COUNT BYTE - BUMP ADDR+1 (NEXT CHAR LOCATION) BACK TO CURRENT
 1159    00000090 ........              DC32    ONEM
 1160    00000094 ........              DC32    EQUAL           // ( TOS> I=TIB+? TIB TIB -- f TIB )
 1161    00000098 ........              DC32    DUP             // ( TOS> f TIB -- f f TIB )
 1162                           // I AND RFROM STARTS AT TIB+1 
 1163                           // REMOVE INDEX FROM LOOP TO REPLACE IT WITH BACKSPACE CORRECTED ADDRESS
 1164    0000009C ........              DC32    RFROM           // ( TOS> f f TIB -- TIB+1 f f TIB )
 1165                           // ADDING 2 BECAUSE TIB+1 IS FROM I AND FLAG MAKES IT = TO 1
 1166                           // WHEN AT THE BEGIINING (ADDR+1) OF THE ADDR BUFFER
 1167    000000A0 ........              DC32    TWO
 1168    000000A4 ........              DC32    SUBB
 1169                           // ADD FLAG 
 1170    000000A8 ........              DC32    PLUS
 1171    000000AC ........              DC32    TOR
 1172    000000B0 ........              DC32    ZBRAN           // If not at beginning of line
 1173    000000B4 10000000              DC32     EXPE6-.        // Goto bsout
 1174                           
 1175    000000B8 ........              DC32    BELL            // At beginning of TIB issue bell
 1176    000000BC ........              DC32    BRAN            // Goto end of loop
 1177    000000C0 6C000000              DC32     EXPE33-.
 1178                           
 1179                           EXPE6:
 1180    000000C4 ........              DC32    BSOUT           // endif
 1181                           EXPE7:  // LABEL NOT USED BECAUSE BELL AND BSOUT Emit THEMSELVES
 1182    000000C8 ........              DC32    BRAN            // Goto end of loop
 1183    000000CC 60000000              DC32     EXPE33-.
 1184                           
 1185                           EXPE2:
 1186    000000D0 ........              DC32    DUP
 1187    000000D4 ........0D000         DC32    LIT, 0x0D       // cr
                  000          
 1188    000000DC ........              DC32    EQUAL
 1189    000000E0 ........              DC32    ZBRAN           // If not cr
 1190    000000E4 1C000000              DC32     EXPE4-.        // Goto save this char and loop again
 1191                                   
 1192    000000E8 ........              DC32    LEAVE           // ( TOS> ODh TIB --  )
 1193                           #ifdef  IOBUFS_DEBUG        
 1195                           #endif
 1196                                   // CR DROPPED HERE I USED AT END FOR CASE OF EXPECT COUNT REACHED
 1197    000000EC ........              DC32    DROP            // ( TOS> TIB -- )
 1198    000000F0 ........              DC32    BLANK           // ( TOS> 20h TIB -- ) space IS FOR EMIT!
 1199    000000F4 ........              DC32    ZERO            // ( TOS> 0 20h TIB -- ) null
 1200    000000F8 ........              DC32    BRAN            // Goto store these at end of loop
 1201    000000FC 08000000              DC32     EXPE5-.
 1202                           
 1203                           EXPE4:
 1204    00000100 ........              DC32    DUP             // Regular char 
 1205                           
 1206                           EXPE5:
 1207    00000104 ........              DC32    I               // I=TIB Store char
 1208    00000108 ........              DC32    CSTORE          // or 1rst null in CASE OF CR
 1209    0000010C .............         DC32    ONE, IN_SV, PSTORE
                  ...........  
 1210    00000118 ........              DC32    ZERO            // 1rst or second null if cr
 1211                                   // CASE OF CR ( TOS> 0 20h TIB -- )
 1212    0000011C ........              DC32    I
 1213    00000120 ........              DC32    ONEP
 1214    00000124 ........              DC32    CSTORE
 1215                           EXPE3:
 1216                                   // CASE OF CR ( TOS> 20H TIB -- )
 1217    00000128 ........              DC32    EMIT
 1218                           EXPE33:
 1219    0000012C ........              DC32    XLOOP
 1220    00000130 04FFFFFF              DC32     EXPE1-.        // Loop is LEAVE'd
 1221                           
 1222                           #ifdef XON_XOFF
 1223    00000134 ........              DC32    XOFF            // FOR CASE OF count reached befor cr
 1224                           #endif
 1225                           // Creat count byte        
 1226                                   // ( ORIGINAL ADDR -- )
 1227                                   // ORIGINAL ADDR (TIB) ON STACK HERE SO CORRECT FOR $LEN
 1228    00000138 ........              DC32    ONEP            // PAST COUNT BYTE FOR CORRECT COUNT
 1229                                   // NULLSTRLEN:          // ( addr -- addr len )
 1230    0000013C ........              DC32    NULLSTRLEN      // ( TOS> LEN TIB+1 -- )
 1231    00000140 .............         DC32    SWAP, ONEM      // BACK UP TO COUNT BYTE
                  ...          
 1232    00000148 ........              DC32    CSTORE
 1233    0000014C ........              DC32    SEMIS
 1234                           
 1235                           
 1236                           //      COUNT COUNT:    ( addr1 --- addr2 n )
 1237                           //      Leave the byte address addr2 and byte count n of a count byte string,
 1238                           //      beginning at address addr1. It is presumed that the first byte at
 1239                           //      addr1 contains the text byte count and the actual text starts with
 1240                           //      the second byte. NFA's may report SMUDGE'd byte counts, handled only
 1241                           //      by ID. User Strings may be up to 255 characters.
 1242                           //      Typically COUNT is followed by TYPE.
 1243                           //      See TYPE $LEN and EXPECT
 1244                           
 1245                            SECTION .text : CONST (2)
 1246                           COUNT_NFA:
 1247    00000000 85                    DC8     0x85
 1248    00000001 434F554E              DC8     'COUN'
 1249    00000005 D4                    DC8     'T'+0x80
 1250    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1251    00000008 ........              DC32    EXPECT_NFA
 1252                           COUNT:
 1253    0000000C ........              DC32    DOCOL
 1254    00000010 ........              DC32    DUP
 1255    00000014 ........              DC32    ONEP
 1256    00000018 ........              DC32    SWAP
 1257                           //        DC32    CATLT7F
 1258    0000001C ........              DC32    CAT     // n could be SMUDGE'd count from NFA's
 1259    00000020 ........              DC32    SEMIS   // Only internal usage is ID.
 1260                           
 1261                           
 1262                           //      $LEN NULLSTRLEN:        ( addr --- addr len )
 1263                           //      Count length of null terminated string like 'c' does,
 1264                           //      and return the string len after addr.
 1265                           //      TYPE can be used after this word.
 1266                           
 1267                            SECTION .text : CONST (2)
 1268                           NULLSTRLEN_NFA:
 1269    00000000 84                    DC8     0x84
 1270    00000001 244C45                DC8     '$LE'
 1271    00000004 CE                    DC8     'N'+0x80
 1272    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1273    00000008 ........              DC32    COUNT_NFA
 1274                           NULLSTRLEN:
 1275    0000000C ........              DC32    .+5
 1276                            SECTION .text : CODE (2)
 1277                                   NDPOP2w                 // Put addr in w_R2 yet leave addr on stack
 1277.1  00000000 3A68                  LDR     w, [p]
 1277.2                                 ENDM
 1278                                                           // Usually TIB.
 1279    00000002 4040                  EORS    t, t, t         // zero count
 1280                           
 1281                           NSLEN_LOOP:
 1282    00000004 115C                  LDRB            n, [w,t]
 1283    00000006 0943                  ORRS            n, n, n
 1284    00000008 01D0                  BEQ             NSLEN_DONE
 1285    0000000A 401C                  ADDS            t, t, #1
 1286    0000000C FAE7                  B               NSLEN_LOOP
 1287                           
 1288                           NSLEN_DONE:
 1289                                   TPUSH
 1289                                   PUSHt   // push t to p, pre decrement p
 1289.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1289.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1289.3                         //      STR     t, [p]
 1289.4                                 ENDM
 1289                                   NEXT
 1289.1                         // ARMv7-M Thumb = .+5
 1289.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1289.3                         // ARMv6-M Thumb = .+4
 1289.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1289                                   NEXT1
 1289.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1289.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1289.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1289.4                         // ARMv6-M Thumb = .+4
 1289.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1289.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1289.7                                 ENDM
 1289.8                                 ENDM
 1289.9                                 ENDM
 1290                           
 1291                           
 1292                           //      FORGET FORGET:  ( -- )
 1293                           //      PRINTS NEW HERE IF SUCCESSFUL. FIXED FIG VERSION MEMORY LEAK.
 1294                           //      Executed in the form:
 1295                           //      FORGET CCcc
 1296                           //      Deletes definition named CCcc from the dictionary with all entries
 1297                           //      physically following it. In fig-FORTH, an error message will occur
 1298                           //      if the CURRENT and CONTEXT vocabularies are not currently the same.
 1299                           //      MODIFIED: To update Current along with context and reset DP,
 1300                           //      and execute .DS and .VS
 1301                           
 1302                            SECTION .text : CONST (2)
 1303                           FORGET_NFA:
 1304    00000000 86                    DC8     0x86
 1305    00000001 464F524745            DC8     'FORGE'
 1306    00000006 D4                    DC8     'T'+0x80
 1307    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1308    00000008 ........              DC32    NULLSTRLEN_NFA
 1309                           FORGET:
 1310    0000000C ........              DC32    DOCOL
 1311    00000010 ........              DC32    TICK                    // \ -- pfa ELSE error message
 1312    00000014 ........              DC32    DUP
 1313    00000018 ........00000         DC32    LIT, FLASH_SPAGE        // DONT FORGET FISH WORDS SAVED IN FLASH
                  208          
 1314    00000020 ........              DC32    LESSTHAN
 1315    00000024 .............         DC32    LIT, msg_forget_fish
                  ...          
 1316    0000002C ........              DC32    QERROR                  // \ f nullstr-addr --
 1317    00000030 ........              DC32    DUP
 1318    00000034 ........00001         DC32    LIT, FLASH_PPAGE        // DONT FORGET USER WORDS IN FLASH
                  008          
 1319    0000003C ........              DC32    LESSTHAN
 1320    00000040 .............         DC32    LIT, msg_forget_saved
                  ...          
 1321    00000048 ........              DC32    QERROR                  // \ f nullstr-addr --
 1322                           //      MOVE NFA update of the DP to after Currrent and Context
 1323    0000004C ........              DC32    DUP                     // PFA PFA --
 1324    00000050 ........              DC32    LFA                     // PFA LFA --
 1325                           
 1326                           // VAR space reclamation starts here:
 1327                           // PFA LFA --
 1328    00000054 ........              DC32    TOR                     // LFA_BOT
 1329                           
 1330                           VS_RECVR_LOOP:
 1331    00000058 .............         DC32    LATEST, PFA, LFA        // LFA_TOP
                  ...........  
 1332    00000064 .............         DC32    DUP, AT                 // LFA NEXT_LFA
                  ...          
 1333    0000006C .............         DC32    CURRENT_SV, STORE       // SET NEXT WORD TO CHECK
                  ...          
 1334    00000074 .............         DC32    DUP, FOURP, AT          // GET CFA
                  ...........  
 1335    00000080 .............         DC32    LIT, DOVAR, EQUAL       // IS IT A DOVAR
                  ...........  
 1336    0000008C ........              DC32    ZBRAN
 1337    00000090 14000000              DC32     VS_RECVR_NEXT-.
 1338                                   
 1339    00000094 ........FCFFF         DC32    LIT, -4, UP_SV, PSTORE  // DECREMENT UP
                  FFF..........
                  ......       
 1340                           
 1341                           VS_RECVR_NEXT:
 1342    000000A4 .............         DC32    R, EQUAL
                  ...          
 1343    000000AC ........              DC32    ZBRAN
 1344    000000B0 A8FFFFFF              DC32     VS_RECVR_LOOP-.
 1345                           
 1346    000000B4 ........              DC32    RFROM
 1347                           // VAR SPACE RECLAMATION DONE
 1348                           
 1349                           // PFA LFA --
 1350    000000B8 ........              DC32    AT              // LFA
 1351    000000BC ........              DC32    CURRENT_SV
 1352    000000C0 ........              DC32    STORE
 1353    000000C4 ........              DC32    NFA             // FROM PFA
 1354    000000C8 ........              DC32    DP_SV
 1355    000000CC ........              DC32    STORE
 1356    000000D0 .............         DC32    DOTVARSPACE, DOTDICTSPACE
                  ...          
 1357    000000D8 ........              DC32    SEMIS
 1358                           
 1359                           
 1360                           //      BYE BYE: ( -- ) COLD RESTART WITH SERIAL INITIALIZATION
 1361                           
 1362                            SECTION .text : CONST (2)
 1363                           BYE_NFA:
 1364    00000000 83                    DC8     0x83
 1365    00000001 4259                  DC8     'BY'
 1366    00000003 C5                    DC8     'E'+0x80
 1367                            ALIGNROM 2,0xFFFFFFFF
 1368    00000004 ........              DC32    FORGET_NFA
 1369                           BYE:
 1370    00000008 ........              DC32    .+5
 1371                            SECTION .text : CODE (2)
 1372                           //        B       FM3_COLD      // __iar_program_start
 1373    00000000 ........              B       STM32Fx_COLD_FISH
 1374                            LTORG
 1375                           
 1376                           
 1377                           //      ABORT ABORT:    ( -- )
 1378                           //      Clear the stacks, zero out and execute RUN or QUIT
 1379                           //      DOES NOT RESET DICTIONAIRY. SEE COLD.
 1380                           
 1381                            SECTION .text : CONST (2)
 1382                           ABORT_NFA:
 1383    00000000 85                    DC8     0x85
 1384    00000001 41424F52              DC8     'ABOR'
 1385    00000005 D4                    DC8     'T'+0x80
 1386    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1387    00000008 ........              DC32    BYE_NFA
 1388                           ABORT:
 1389    0000000C ........              DC32    DOCOL
 1390    00000010 ........              DC32    SPSTO
 1391    00000014 ........              DC32    RPSTO
 1392                           #ifdef IO2TP
 1397                           #endif
 1398    00000018 ........              DC32    zero_OUT
 1399                           //      DC32    QSTACK  // IF STACK error abort using QERROR->ERROR
 1400                           
 1401                           // LOOK UP RUN AND EXEC IT
 1402    0000001C .............         DC32    LIT, msg_RUN
                  ...          
 1403    00000024 ........              DC32    LATEST
 1404                           //ABORT_BP1_B4_PFIND_RUN:
 1405                           // DC32 NOOP
 1406    00000028 ........              DC32    PFIND   // 0 OR pfa len 1
 1407    0000002C ........              DC32    ZBRAN
 1408    00000030 10000000              DC32      ABORT_QUIT-.
 1409                           
 1410    00000034 ........              DC32    DROP    // LEN
 1411    00000038 .............         DC32    CFA, EXEC
                  ...          
 1412                           ABORT_QUIT:
 1413                           //      DC32    SEMIC_CREATE // Use ERROR if need to recover from bad definition
 1414                           #ifdef ABORT_STOP_TILL_CO
 1415    00000040 .............         DC32    LIT, ERROR_HALT, AT
                  ...........  
 1416    0000004C ........              DC32    ZBRAN
 1417    00000050 6C000000              DC32      CO_END-.
 1418                           // halt on all errors until "CO" entered
 1419                           // BEGIN
 1420    00000054 .............         DC32    LIT, msg_CO, NULLSTRLEN, TYPE
                  .............
                  ......       
 1421                           NOT_CO:
 1422    00000064 ........              DC32    QKEY
 1423    00000068 ........              DC32    ZBRAN
 1424    0000006C F8FFFFFF              DC32      NOT_CO-.
 1425                           // IF KEY = "C'
 1426    00000070 .............         DC32    KEY, LIT, 43h, EQUAL
                  ...43000000..
                  ......       
 1427    00000080 ........              DC32    ZBRAN
 1428    00000084 E0FFFFFF              DC32      NOT_CO-.
 1429                           // NEXT KEY "0"
 1430    00000088 .............         DC32    KEY, LIT, 4Fh, EQUAL
                  ...4F000000..
                  ......       
 1431    00000098 ........              DC32    ZBRAN
 1432    0000009C C8FFFFFF              DC32      NOT_CO-.
 1433                           // NEXT KEY "Enter"
 1434    000000A0 .............         DC32    KEY, LIT, 0Dh, EQUAL
                  ...0D000000..
                  ......       
 1435    000000B0 ........              DC32    ZBRAN
 1436    000000B4 B0FFFFFF              DC32      NOT_CO-.
 1437                           // UNTIL
 1438    000000B8 ........              DC32    CR
 1439                           CO_END:
 1440                           #endif
 1441    000000BC ........              DC32    QUIT    // OI
 1442                           #ifdef ABORT_STOP_TILL_CO
 1443                           $FISH_CO_MSGS.h
 1444                           #endif
 1445                           
 1446                           //      COLD COLD:      ( -- )  MODIFIED:
 1447                           //      FIGISH SYSTEM COLD = WARM (INIT RAMVARSPACE) -> type signon MSG ->ABORT
 1448                           //      CLEARS DICTIONAIRY. SEE ABORT.
 1449                           
 1450                            SECTION .text : CONST (2)
 1451                           COLD_NFA:
 1452    00000000 84                    DC8     0x84
 1453    00000001 434F4C                DC8     'COL'
 1454    00000004 C4                    DC8     'D'+0x80
 1455    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1456    00000008 ........              DC32    ABORT_NFA
 1457                           COLD:
 1458    0000000C ........              DC32    DOCOL
 1459    00000010 ........              DC32    WARM            // FISH System VAR init.
 1460    00000014 ........              DC32    SIGNON
 1461                           #ifdef ABORT_STOP_TILL_CO
 1462    00000018 ........              DC32    QUIT
 1463                           #else
 1465                           #endif
 1466                           
 1467                           //=============================== WORDCAT ====================================//
 1468                           //NOEXEC HEADERFORWORDCATEGORIES
 1469                           //      WC_FISH_SYS: = FISH System: CATEGORY
 1470                           
 1471                            SECTION .text : CONST (2)
 1472                           WC_FISH_SYS_NFA:
 1473    00000000 90                    DC8     0x80+4+12        // +4 is format chars constant
 1474                                                           // +n is Name lenght
 1475    00000001 0D0A                  DC8     0x0D, 0x0A
 1476    00000003 4649534820537         DC8     'FISH System:'
                  97374656D3A  
 1477    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1478    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1479    00000014 ........              DC32    COLD_NFA
 1480                           
 1481                           
 1482                           //----------------------------- DOTSTACK SECTION -------------------------------
 1483                           
 1484                           //      .SH DOTSHEX:    ( -- )
 1485                           //      Nondestructively print items on stack in HEX, preserving base.
 1486                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1487                           
 1488                            SECTION .text : CONST (2)
 1489                           DOTSHEX_NFA:
 1490    00000000 83                    DC8     0x83
 1491    00000001 2E53                  DC8     '.S'
 1492    00000003 C8                    DC8     'H'+0x80
 1493                            ALIGNROM 2,0xFFFFFFFF
 1494    00000004 ........              DC32    WC_FISH_SYS_NFA
 1495                           DOTSHEX:
 1496    00000008 ........              DC32    DOCOL
 1497    0000000C ........10000         DC32    LIT, 16, DOTSBASE
                  000........  
 1498    00000018 ........              DC32    SEMIS
 1499                           
 1500                           
 1501                           //      .SD DOTSDEC:    ( -- )
 1502                           //      Nondestructively print items on stack in DECIMAL, preserving base.
 1503                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1504                           
 1505                            SECTION .text : CONST (2)
 1506                           DOTSDEC_NFA:
 1507    00000000 83                    DC8     0x83
 1508    00000001 2E53                  DC8     '.S'
 1509    00000003 C4                    DC8     'D'+0x80
 1510                            ALIGNROM 2,0xFFFFFFFF
 1511    00000004 ........              DC32    DOTSHEX_NFA
 1512                           DOTSDEC:
 1513    00000008 ........              DC32    DOCOL
 1514    0000000C ........0A000         DC32    LIT, 10, DOTSBASE
                  000........  
 1515    00000018 ........              DC32    SEMIS
 1516                           
 1517                           
 1518                           //      .SB DOTSBIN:    ( -- )
 1519                           //      Nondestructively print items on stack in BINARY, preserving base.
 1520                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1521                           
 1522                            SECTION .text : CONST (2)
 1523                           DOTSBIN_NFA:
 1524    00000000 83                    DC8     0x83
 1525    00000001 2E53                  DC8     '.S'
 1526    00000003 C2                    DC8     'B'+0x80
 1527                            ALIGNROM 2,0xFFFFFFFF
 1528    00000004 ........              DC32    DOTSDEC_NFA
 1529                           DOTSBIN:
 1530    00000008 ........              DC32    DOCOL
 1531    0000000C .............         DC32    TWO, DOTSBASE
                  ...          
 1532    00000014 ........              DC32    SEMIS
 1533                           
 1534                           
 1535                           //      .S DOTS:        ( -- )
 1536                           //      Nondestructively print items on stack in current base.
 1537                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1538                           
 1539                            SECTION .text : CONST (2)
 1540                           DOTS_NFA:
 1541    00000000 82                    DC8     0x82
 1542    00000001 2E                    DC8     '.'
 1543    00000002 D3                    DC8     'S'+0x80
 1544    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1545    00000004 ........              DC32    DOTSBIN_NFA
 1546                           DOTS:
 1547    00000008 ........              DC32    DOCOL
 1548    0000000C .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1549    0000001C .............         DC32    EQUAL, ZEQU, ZBRAN
                  ...........  
 1550    00000028 68000000              DC32    DOTSEND-.                       // IF NOTHING ON STACK
 1551                           
 1552    0000002C ........              DC32    PDOTQ
 1553    00000030 05                    DC8     5
 1554    00000031 544F533E20            DC8     'TOS> '
 1555    00000036 FFFF           ALIGNROM 2,0xFFFFFFFF
 1556                                 
 1557    00000038 .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1558    00000048 ........              DC32    XDO
 1559                           
 1560                           DOTSLOOP:
 1561    0000004C .............         DC32    I, AT
                  ...          
 1562    00000054 .............         DC32    BASE_SV, AT
                  ...          
 1563    0000005C ........0A000         DC32    LIT, 10, EQUAL                  // 
                  000........  
 1564    00000068 ........              DC32    ZBRAN                           // NOT = DECIMAL
 1565    0000006C 10000000              DC32    DBSUSEDUDOT-.
 1566    00000070 ........              DC32    DOT_BASE_SUFFIX
 1567    00000074 ........              DC32    BRAN
 1568    00000078 08000000              DC32    DBSUSEDOT-.
 1569                           
 1570                           DBSUSEDUDOT:
 1571    0000007C ........              DC32    UDOT_BASE_SUFFIX
 1572                           
 1573                           DBSUSEDOT:
 1574    00000080 ........              DC32    SPACE
 1575    00000084 .............         DC32    FOUR, XPLOOP
                  ...          
 1576    0000008C C0FFFFFF              DC32    DOTSLOOP-.
 1577                           
 1578                           DOTSEND:
 1579    00000090 ........              DC32    SEMIS
 1580                           
 1581                           
 1582                           //      2DUP TDUP:      ( n2 n1 -- n2 n1 n2 n1 )
 1583                           //      Duplicate top two stack items. The prefix 2 convention means
 1584                           //      an operation on the top two stack items.
 1585                           
 1586                            SECTION .text : CONST (2)
 1587                           TDUP_NFA:
 1588    00000000 84                    DC8     0x84
 1589    00000001 324455                DC8     '2DU'
 1590    00000004 D0                    DC8     'P'+0x80
 1591    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1592    00000008 ........              DC32    DOTS_NFA
 1593                           TDUP:
 1594    0000000C ........              DC32    .+5
 1595                            SECTION .text : CODE (2)
 1596                           // TDUP: OPT by picking pops
 1597    00000000 3868                  LDR     t, [p]          //
 1598    00000002 7A68                  LDR     w, [p, #4]      //
 1599                                   DPUSH                   // 
 1599                                   PUSHw   // push w to p, post decrement p
 1599.1  00000004 47F8042D              STR     w, [p, #-4]!
 1599.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1599.3                         //      STR     w, [p]
 1599.4                                 ENDM
 1599                                   TPUSH
 1599                                   PUSHt   // push t to p, pre decrement p
 1599.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1599.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1599.3                         //      STR     t, [p]
 1599.4                                 ENDM
 1599                                   NEXT
 1599.1                         // ARMv7-M Thumb = .+5
 1599.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1599.3                         // ARMv6-M Thumb = .+4
 1599.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1599                                   NEXT1
 1599.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1599.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1599.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1599.4                         // ARMv6-M Thumb = .+4
 1599.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1599.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1599.7                                 ENDM
 1599.8                                 ENDM
 1599.9                                 ENDM
 1599.10                                ENDM
 1600                           
 1601                           
 1602                           //      -DUP ZNDUP:     ( n1 -- n1 (if zero)
 1603                           //                      ( n1 -- n1 n1 (non-zero)
 1604                           //      Reproduce n1 only if it is non-zero. Used in type andSPACES.
 1605                           //      This is usually used to copy a value just before IF, to eliminate
 1606                           //      the need for an ELSE part to drop it. 
 1607                           
 1608                            SECTION .text : CONST (2)
 1609                           DDUP_NFA:
 1610    00000000 84                    DC8     0x84
 1611    00000001 2D4455                DC8     '-DU'
 1612    00000004 D0                    DC8     'P'+0x80
 1613    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1614    00000008 ........              DC32    TDUP_NFA
 1615                           ZNDUP:
 1616    0000000C ........              DC32    DOCOL
 1617    00000010 ........              DC32    DUP
 1618    00000014 ........              DC32    ZBRAN   // IF
 1619    00000018 08000000              DC32    DDUP1-.
 1620                           
 1621    0000001C ........              DC32    DUP     //endif
 1622                           DDUP1:
 1623    00000020 ........              DC32    SEMIS
 1624                           
 1625                           
 1626                           //      ROT ROT: ( nl n2 n3 --- n2 n3 nl )
 1627                           //      Rotate the top three values on the stack, bringing the third to the top.
 1628                           
 1629                            SECTION .text : CONST (2)
 1630                           ROT_NFA:
 1631    00000000 83                    DC8     0x83
 1632    00000001 524F                  DC8     'RO'
 1633    00000003 D4                    DC8     'T'+0x80
 1634                            ALIGNROM 2,0xFFFFFFFF
 1635    00000004 ........              DC32    DDUP_NFA
 1636                           ROT:
 1637    00000008 ........              DC32    .+5
 1638                            SECTION .text : CODE (2)
 1639                                   POP2w
 1639.1  00000000 57F8042B              LDR     w, [p],#4
 1639.2                         //      LDR     w, [p]
 1639.3                         //      ADDS    p, p, #4
 1639.4                                 ENDM
 1640                                   POP2n
 1640.1  00000004 57F8041B              LDR     n, [p],#4
 1640.2                         //      LDR     n, [p]
 1640.3                         //      ADDS    p, p, #4
 1640.4                                 ENDM
 1641                           #ifdef TOSCT
 1643                           #endif
 1644                                   POP2t
 1644.1  00000008 57F8040B              LDR     t, [p],#4       // Post-increment
 1644.2                         //#ifndef TOSCT
 1644.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1644.4                         //#endif
 1644.5                         //      ADDS    p, p, #4
 1644.6                                 ENDM
 1645                                   PUSHn
 1645.1  0000000C 47F8041D              STR     n, [p, #-4]!
 1645.2                         //      SUBS    p, p, #4        // push n to p, pre decrement p
 1645.3                         //      STR     n, [p]
 1645.4                                 ENDM
 1646                                   DPUSH                   //  --  LSW MSW )
 1646                                   PUSHw   // push w to p, post decrement p
 1646.1  00000010 47F8042D              STR     w, [p, #-4]!
 1646.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1646.3                         //      STR     w, [p]
 1646.4                                 ENDM
 1646                                   TPUSH
 1646                                   PUSHt   // push t to p, pre decrement p
 1646.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1646.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1646.3                         //      STR     t, [p]
 1646.4                                 ENDM
 1646                                   NEXT
 1646.1                         // ARMv7-M Thumb = .+5
 1646.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1646.3                         // ARMv6-M Thumb = .+4
 1646.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1646                                   NEXT1
 1646.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1646.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1646.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1646.4                         // ARMv6-M Thumb = .+4
 1646.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1646.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1646.7                                 ENDM
 1646.8                                 ENDM
 1646.9                                 ENDM
 1646.10                                ENDM
 1647                           
 1648                           
 1649                           //      I I:    ( -- n )
 1650                           //      Used within a DO-LOOP to copy the loop index to the stack. Other use
 1651                           //      is implementation dependent.
 1652                           //      See R.
 1653                           
 1654                            SECTION .text : CONST (2)
 1655                           I_NFA:
 1656    00000000 81                    DC8     0x81
 1657    00000001 C9                    DC8     'I'+0x80
 1658    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1659    00000004 ........              DC32    ROT_NFA
 1660                           I:
 1661    00000008 ........              DC32    .+5
 1662                            SECTION .text : CODE (2)
 1663    00000000 3068                  LDR     t, [r]  // GET INDEX VALUE
 1664                                   TPUSH
 1664                                   PUSHt   // push t to p, pre decrement p
 1664.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1664.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1664.3                         //      STR     t, [p]
 1664.4                                 ENDM
 1664                                   NEXT
 1664.1                         // ARMv7-M Thumb = .+5
 1664.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1664.3                         // ARMv6-M Thumb = .+4
 1664.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1664                                   NEXT1
 1664.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1664.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1664.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1664.4                         // ARMv6-M Thumb = .+4
 1664.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1664.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1664.7                                 ENDM
 1664.8                                 ENDM
 1664.9                                 ENDM
 1665                           
 1666                           
 1667                           //      SP@ SPAT:       ( -- addr )
 1668                           //      \ -- addr = Current TOP of the parameter stack (p) )
 1669                           //      Place the address of the TOP of the parameter stack (p)
 1670                           //      on the parameter stack (p) as it was before RP@ was executed.
 1671                           //      e.g.  1  2  SP@  @  .   .   .     would type 2  2  1
 1672                           
 1673                            SECTION .text : CONST (2)
 1674                           SPAT_NFA:
 1675    00000000 83                    DC8     0x83
 1676    00000001 5350                  DC8     'SP'
 1677    00000003 C0                    DC8     '@'+0x80
 1678                            ALIGNROM 2,0xFFFFFFFF
 1679    00000004 ........              DC32    I_NFA
 1680                           SPAT:
 1681    00000008 ........              DC32    .+5
 1682                            SECTION .text : CODE (2)
 1683    00000000 3846                  MOV     t, p
 1684                                   TPUSH
 1684                                   PUSHt   // push t to p, pre decrement p
 1684.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1684.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1684.3                         //      STR     t, [p]
 1684.4                                 ENDM
 1684                                   NEXT
 1684.1                         // ARMv7-M Thumb = .+5
 1684.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1684.3                         // ARMv6-M Thumb = .+4
 1684.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1684                                   NEXT1
 1684.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1684.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1684.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1684.4                         // ARMv6-M Thumb = .+4
 1684.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1684.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1684.7                                 ENDM
 1684.8                                 ENDM
 1684.9                                 ENDM
 1685                           
 1686                           
 1687                           //      RP@ RPAT:       ( -- addr )
 1688                           //      \ -- addr = Current TOP of the Return Stack (r) )
 1689                           //      Place the address of the TOP of the return stack (r)
 1690                           //      on the parameter stack (p) as it was before RP@ was executed.
 1691                           //      e.g.  1 >R  2 >R  RP@  @  .   .   . would type 2  2  1
 1692                           
 1693                            SECTION .text : CONST (2)
 1694                           RPAT_NFA:
 1695    00000000 83                    DC8     0x83
 1696    00000001 5250                  DC8     'RP'
 1697    00000003 C0                    DC8     '@'+0x80
 1698                            ALIGNROM 2,0xFFFFFFFF
 1699    00000004 ........              DC32    SPAT_NFA
 1700                           RPAT:
 1701    00000008 ........              DC32    .+5
 1702                            SECTION .text : CODE (2)
 1703    00000000 3046                  MOV     t, r
 1704                                   TPUSH
 1704                                   PUSHt   // push t to p, pre decrement p
 1704.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1704.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1704.3                         //      STR     t, [p]
 1704.4                                 ENDM
 1704                                   NEXT
 1704.1                         // ARMv7-M Thumb = .+5
 1704.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1704.3                         // ARMv6-M Thumb = .+4
 1704.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1704                                   NEXT1
 1704.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1704.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1704.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1704.4                         // ARMv6-M Thumb = .+4
 1704.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1704.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1704.7                                 ENDM
 1704.8                                 ENDM
 1704.9                                 ENDM
 1705                           
 1706                           
 1707                           //      LEAVE LEAVE:    ( -- )
 1708                           //      Force termination of a DO-LOOP at the next opportunity by setting
 1709                           //      the loop limit equal to the current value of the index. The index
 1710                           //      itself remains unchanged, and execution proceeds until LOOP
 1711                           //      or +LOOP is encountered.
 1712                           
 1713                            SECTION .text : CONST (2)
 1714                           LEAVE_NFA:
 1715    00000000 85                    DC8     0x85
 1716    00000001 4C454156              DC8     'LEAV'
 1717    00000005 C5                    DC8     'E'+0x80
 1718    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1719                           //      DC32    RPSTO_NFA
 1720    00000008 ........              DC32    RPAT_NFA
 1721                           LEAVE:
 1722    0000000C ........              DC32    .+5
 1723                            SECTION .text : CODE (2)
 1724    00000000 3268                  LDR     w, [r]          // GET Index
 1725    00000002 7260                  STR     w, [r, #4]  // Store it at Limit
 1726                                   NEXT
 1726.1                         // ARMv7-M Thumb = .+5
 1726.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1726.3                         // ARMv6-M Thumb = .+4
 1726.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1726                                   NEXT1
 1726.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1726.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1726.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1726.4                         // ARMv6-M Thumb = .+4
 1726.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1726.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1726.7                                 ENDM
 1726.8                                 ENDM
 1727                           
 1728                           
 1729                           //      R> RFROM:       ( -- n )
 1730                           //      Remove the top value from the return stack and leave it on the
 1731                           //      computation stack. See >R and R.
 1732                           
 1733                            SECTION .text : CONST (2)
 1734                           RFROM_NFA:
 1735    00000000 82                    DC8     0x82
 1736    00000001 52                    DC8     'R'
 1737    00000002 BE                    DC8     '>'+0x80
 1738    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1739    00000004 ........              DC32    LEAVE_NFA
 1740                           RFROM:
 1741    00000008 ........              DC32    .+5
 1742                            SECTION .text : CODE (2)
 1743                                   POPr2t
 1743.1  00000000 56F8040B              LDR     t, [r],#4
 1743.2                         //      LDR     t, [r]
 1743.3                         //      ADDS    r, r, #4
 1743.4                                 ENDM
 1744                                   TPUSH
 1744                                   PUSHt   // push t to p, pre decrement p
 1744.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1744.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1744.3                         //      STR     t, [p]
 1744.4                                 ENDM
 1744                                   NEXT
 1744.1                         // ARMv7-M Thumb = .+5
 1744.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1744.3                         // ARMv6-M Thumb = .+4
 1744.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1744                                   NEXT1
 1744.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1744.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1744.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1744.4                         // ARMv6-M Thumb = .+4
 1744.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1744.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1744.7                                 ENDM
 1744.8                                 ENDM
 1744.9                                 ENDM
 1745                           
 1746                           
 1747                           //      R R:    ( -- n )
 1748                           //      Copy the top of the return stack to the computation stack.
 1749                           
 1750                            SECTION .text : CONST (2)
 1751                           R_NFA:
 1752    00000000 81                    DC8     0x81
 1753    00000001 D2                    DC8     'R'+0x80
 1754    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1755    00000004 ........              DC32    RFROM_NFA
 1756                           R:
 1757    00000008 ........              DC32    .+5
 1758                            SECTION .text : CODE (2)
 1759    00000000 3068                  LDR     t, [r]  // Get Index
 1760                                   TPUSH
 1760                                   PUSHt   // push t to p, pre decrement p
 1760.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1760.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1760.3                         //      STR     t, [p]
 1760.4                                 ENDM
 1760                                   NEXT
 1760.1                         // ARMv7-M Thumb = .+5
 1760.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1760.3                         // ARMv6-M Thumb = .+4
 1760.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1760                                   NEXT1
 1760.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1760.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1760.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1760.4                         // ARMv6-M Thumb = .+4
 1760.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1760.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1760.7                                 ENDM
 1760.8                                 ENDM
 1760.9                                 ENDM
 1761                           
 1762                           //      >R TOR: ( n -- )
 1763                           //      Remove a number from the computation stack and place as the most
 1764                           //      accessable on the return stack. Use should be balanced with R> in
 1765                           //      the same definition.
 1766                           
 1767                            SECTION .text : CONST (2)
 1768                           TOR_NFA:
 1769    00000000 82                    DC8     0x82
 1770    00000001 3E                    DC8     '>'
 1771    00000002 D2                    DC8     'R'+0x80
 1772    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1773    00000004 ........              DC32    R_NFA
 1774                           TOR:
 1775    00000008 ........              DC32    .+5
 1776                            SECTION .text : CODE (2)
 1777                                   POP2n   // preserve TOS
 1777.1  00000000 57F8041B              LDR     n, [p],#4
 1777.2                         //      LDR     n, [p]
 1777.3                         //      ADDS    p, p, #4
 1777.4                                 ENDM
 1778                                   PUSHn2r
 1778.1  00000004 46F8041D              STR     n, [r, #-4]!
 1778.2                         //      SUBS    r, r, #4        //  push t to r, pre decrement r
 1778.3                         //      STR     n, [r]
 1778.4                                 ENDM
 1779                           #ifdef TOSCT
 1781                           #endif
 1782                                   NEXT
 1782.1                         // ARMv7-M Thumb = .+5
 1782.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1782.3                         // ARMv6-M Thumb = .+4
 1782.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1782                                   NEXT1
 1782.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1782.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1782.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1782.4                         // ARMv6-M Thumb = .+4
 1782.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1782.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1782.7                                 ENDM
 1782.8                                 ENDM
 1783                           
 1784                           
 1785                           //      OVER OVER:      ( nl n2 -- nl n2 n1 )
 1786                           //      Copy the second stack value, placing it as the new top.
 1787                           
 1788                            SECTION .text : CONST (2)
 1789                           OVER_NFA:
 1790    00000000 84                    DC8     0x84
 1791    00000001 4F5645                DC8     'OVE'
 1792    00000004 D2                    DC8     'R'+0x80
 1793    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1794    00000008 ........              DC32    TOR_NFA
 1795                           OVER:
 1796    0000000C ........              DC32    .+5
 1797                            SECTION .text : CODE (2)
 1798                                   POP2w           // n2
 1798.1  00000000 57F8042B              LDR     w, [p],#4
 1798.2                         //      LDR     w, [p]
 1798.3                         //      ADDS    p, p, #4
 1798.4                                 ENDM
 1799                           #ifdef TOSCT
 1803                           #else
 1804                                   POP2t           // n1
 1804.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1804.2                         //#ifndef TOSCT
 1804.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1804.4                         //#endif
 1804.5                         //      ADDS    p, p, #4
 1804.6                                 ENDM
 1805                           #endif
 1806                                   PUSHt           // -- n1 )
 1806.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1806.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1806.3                         //      STR     t, [p]
 1806.4                                 ENDM
 1807                                   DPUSH           //  --  LSW MSW )
 1807                                   PUSHw   // push w to p, post decrement p
 1807.1  0000000C 47F8042D              STR     w, [p, #-4]!
 1807.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1807.3                         //      STR     w, [p]
 1807.4                                 ENDM
 1807                                   TPUSH
 1807                                   PUSHt   // push t to p, pre decrement p
 1807.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1807.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1807.3                         //      STR     t, [p]
 1807.4                                 ENDM
 1807                                   NEXT
 1807.1                         // ARMv7-M Thumb = .+5
 1807.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1807.3                         // ARMv6-M Thumb = .+4
 1807.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1807                                   NEXT1
 1807.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1807.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1807.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1807.4                         // ARMv6-M Thumb = .+4
 1807.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1807.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1807.7                                 ENDM
 1807.8                                 ENDM
 1807.9                                 ENDM
 1807.10                                ENDM
 1808                           
 1809                           
 1810                           //      DROP DROP:      ( n1 -- )
 1811                           //      Drop n1 from the stack.
 1812                           
 1813                            SECTION .text : CONST (2)
 1814                           DROP_NFA:
 1815    00000000 84                    DC8     0x84
 1816    00000001 44524F                DC8     'DRO'
 1817    00000004 D0                    DC8     'P'+0x80
 1818    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1819    00000008 ........              DC32    OVER_NFA
 1820                           DROP:
 1821    0000000C ........              DC32    .+5
 1822                            SECTION .text : CODE (2)
 1823                           #ifdef TOSCT
 1827                           #else // DROP:
 1828                           //        POP2t         // Opt to just do p
 1829    00000000 3F1D                  ADDS    p, p, #4
 1830                           
 1831                           #endif
 1832                                   NEXT
 1832.1                         // ARMv7-M Thumb = .+5
 1832.2  00000002 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1832.3                         // ARMv6-M Thumb = .+4
 1832.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1832                                   NEXT1
 1832.1  00000006 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1832.2  0000000A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1832.3  0000000E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1832.4                         // ARMv6-M Thumb = .+4
 1832.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1832.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1832.7                                 ENDM
 1832.8                                 ENDM
 1833                           
 1834                           
 1835                           //      SWAP SWAP:      ( nl n2 -- n2 n1 )
 1836                           //      Exchange the top two values On the stack.
 1837                           
 1838                            SECTION .text : CONST (2)
 1839                           SWAP_NFA:
 1840    00000000 84                    DC8     0x84
 1841    00000001 535741                DC8     'SWA'
 1842    00000004 D0                    DC8     'P'+0x80
 1843    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1844    00000008 ........              DC32    DROP_NFA
 1845                           SWAP:
 1846    0000000C ........              DC32    .+5
 1847                            SECTION .text : CODE (2)
 1848                           #ifdef TOSCT
 1852                           #else // SWAP:
 1853                                   POP2w           // n2
 1853.1  00000000 57F8042B              LDR     w, [p],#4
 1853.2                         //      LDR     w, [p]
 1853.3                         //      ADDS    p, p, #4
 1853.4                                 ENDM
 1854                                   POP2t           // n1
 1854.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1854.2                         //#ifndef TOSCT
 1854.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1854.4                         //#endif
 1854.5                         //      ADDS    p, p, #4
 1854.6                                 ENDM
 1855                           #endif
 1856                                   DPUSH           //  --  LSW MSW )
 1856                                   PUSHw   // push w to p, post decrement p
 1856.1  00000008 47F8042D              STR     w, [p, #-4]!
 1856.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1856.3                         //      STR     w, [p]
 1856.4                                 ENDM
 1856                                   TPUSH
 1856                                   PUSHt   // push t to p, pre decrement p
 1856.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1856.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1856.3                         //      STR     t, [p]
 1856.4                                 ENDM
 1856                                   NEXT
 1856.1                         // ARMv7-M Thumb = .+5
 1856.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1856.3                         // ARMv6-M Thumb = .+4
 1856.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1856                                   NEXT1
 1856.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1856.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1856.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1856.4                         // ARMv6-M Thumb = .+4
 1856.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1856.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1856.7                                 ENDM
 1856.8                                 ENDM
 1856.9                                 ENDM
 1856.10                                ENDM
 1857                           
 1858                           
 1859                           //      DUP DUP:        ( n1 -- n1 n1 )
 1860                           //      Duplicate the value n1 on the stack.
 1861                           
 1862                            SECTION .text : CONST (2)
 1863                           DUP_NFA:
 1864    00000000 83                    DC8     0x83
 1865    00000001 4455                  DC8     'DU'
 1866    00000003 D0                    DC8     'P'+0x80
 1867                            ALIGNROM 2,0xFFFFFFFF
 1868    00000004 ........              DC32    SWAP_NFA
 1869                           DUP:
 1870    00000008 ........              DC32    .+5
 1871                            SECTION .text : CODE (2)
 1872                           //#ifdef TOSCT
 1873                           // NO NEED TO REFRESH t ?
 1874                           //#else DUP:
 1875                           // OPT by picking pops
 1876    00000000 3868                  LDR     t, [p]  //t_r0 p_r7
 1877                           //#endif
 1878                                   TPUSH   //// push t to p, pre decrement p
 1878                                   PUSHt   // push t to p, pre decrement p
 1878.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1878.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1878.3                         //      STR     t, [p]
 1878.4                                 ENDM
 1878                                   NEXT
 1878.1                         // ARMv7-M Thumb = .+5
 1878.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1878.3                         // ARMv6-M Thumb = .+4
 1878.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1878                                   NEXT1
 1878.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1878.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1878.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1878.4                         // ARMv6-M Thumb = .+4
 1878.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1878.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1878.7                                 ENDM
 1878.8                                 ENDM
 1878.9                                 ENDM
 1879                           
 1880                           //=============================== WORDCAT ====================================//
 1881                           //NOEXEC HEADERFORWORDCATEGORIES
 1882                           //      WC_STACK_NFA = Stack Stuff: CATEGORY
 1883                           
 1884                            SECTION .text : CONST (2)
 1885                           WC_STACK_NFA:
 1886    00000000 90                    DC8     0x80+4+12
 1887    00000001 0D0A                  DC8     0x0D, 0x0A
 1888    00000003 537461636B205         DC8     'Stack Stuff:'
                  3747566663A  
 1889    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1890    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1891    00000014 ........              DC32    DUP_NFA
 1892                           
 1893                           
 1894                           //      ANDBITS ANDBITS:        ( addr val -- )
 1895                           
 1896                            SECTION .text : CONST (2)
 1897                           ANDBITS_NFA:
 1898    00000000 87                    DC8     0x87
 1899    00000001 414E44424954          DC8     'ANDBIT'
 1900    00000007 D3                    DC8     'S'+0x80
 1901                            ALIGNROM 2,0xFFFFFFFF
 1902    00000008 ........              DC32    WC_STACK_NFA
 1903                           ANDBITS:
 1904    0000000C ........              DC32    .+5
 1905                            SECTION .text : CODE (2)
 1906                                   POPp2w          // val
 1906.1                                 // as in xeq token on ToS setup for exec
 1906.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1906.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1906.4                                 ENDM
 1907                                   POP2n           // addr
 1907.1  00000004 57F8041B              LDR     n, [p],#4
 1907.2                         //      LDR     n, [p]
 1907.3                         //      ADDS    p, p, #4
 1907.4                                 ENDM
 1908    00000008 0868                  LDR     t, [n]  // read [val]
 1909    0000000A 1040                  ANDS    t, t, w // modify val
 1910    0000000C 0860                  STR     t, [n]  // Write val
 1911                                   NEXT
 1911.1                         // ARMv7-M Thumb = .+5
 1911.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1911.3                         // ARMv6-M Thumb = .+4
 1911.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1911                                   NEXT1
 1911.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1911.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1911.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1911.4                         // ARMv6-M Thumb = .+4
 1911.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1911.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1911.7                                 ENDM
 1911.8                                 ENDM
 1912                           
 1913                           
 1914                           //      SETBITS SETBITS:        ( addr val -- ) OR val bits into addr.
 1915                           //      See also CLRBITS.
 1916                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1917                           
 1918                            SECTION .text : CONST (2)
 1919                           SETBITS_NFA:
 1920    00000000 87                    DC8     0x87
 1921    00000001 534554424954          DC8     'SETBIT'
 1922    00000007 D3                    DC8     'S'+0x80
 1923                            ALIGNROM 2,0xFFFFFFFF
 1924    00000008 ........              DC32    ANDBITS_NFA
 1925                           SETBITS:
 1926    0000000C ........              DC32    .+5
 1927                            SECTION .text : CODE (2)
 1928                                   POPp2w          // val
 1928.1                                 // as in xeq token on ToS setup for exec
 1928.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1928.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1928.4                                 ENDM
 1929                                   POP2n           // addr
 1929.1  00000004 57F8041B              LDR     n, [p],#4
 1929.2                         //      LDR     n, [p]
 1929.3                         //      ADDS    p, p, #4
 1929.4                                 ENDM
 1930    00000008 0868                  LDR     t, [n]  // read[val]
 1931    0000000A 1043                  ORRS    t, t, w // modify val
 1932    0000000C 0860                  STR     t, [n]  // Write val
 1933                                   NEXT
 1933.1                         // ARMv7-M Thumb = .+5
 1933.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1933.3                         // ARMv6-M Thumb = .+4
 1933.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1933                                   NEXT1
 1933.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1933.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1933.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1933.4                         // ARMv6-M Thumb = .+4
 1933.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1933.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1933.7                                 ENDM
 1933.8                                 ENDM
 1934                           
 1935                           
 1936                           //      CLRBITS CLRBITS:        ( addr val -- )
 1937                           //      XOR val bits into addr. See also SETBITS.
 1938                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1939                           
 1940                            SECTION .text : CONST (2)
 1941                           CLRBITS_NFA:
 1942    00000000 87                    DC8     0x87
 1943    00000001 434C52424954          DC8     'CLRBIT'
 1944    00000007 D3                    DC8     'S'+0x80
 1945                            ALIGNROM 2,0xFFFFFFFF
 1946    00000008 ........              DC32    SETBITS_NFA
 1947                           CLRBITS:
 1948    0000000C ........              DC32    .+5
 1949                            SECTION .text : CODE (2)
 1950                                   POPp2w                  // val
 1950.1                                 // as in xeq token on ToS setup for exec
 1950.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1950.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1950.4                                 ENDM
 1951                                   POP2n                   // addr
 1951.1  00000004 57F8041B              LDR     n, [p],#4
 1951.2                         //      LDR     n, [p]
 1951.3                         //      ADDS    p, p, #4
 1951.4                                 ENDM
 1952    00000008 0868                  LDR     t, [n]          // read [val]
 1953    0000000A 9043                  BICS    t, t, w         // modify val  - AND-NOT
 1954    0000000C 0860                  STR     t, [n]          // write val
 1955                                   NEXT
 1955.1                         // ARMv7-M Thumb = .+5
 1955.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1955.3                         // ARMv6-M Thumb = .+4
 1955.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1955                                   NEXT1
 1955.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1955.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1955.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1955.4                         // ARMv6-M Thumb = .+4
 1955.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1955.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1955.7                                 ENDM
 1955.8                                 ENDM
 1956                           
 1957                           
 1958                           //      CMOVE CMOVE:    ( from to count -- )
 1959                           //      Move the specified quantity of bytes beginning at address from to
 1960                           //      address to. The contents of address from is moved first proceeding
 1961                           //      toward high memory. Further specification is necessary on word
 1962                           //      addressing computers.
 1963                           
 1964                            SECTION .text : CONST (2)
 1965                           CMOVE_NFA:
 1966    00000000 85                    DC8     0x85
 1967    00000001 434D4F56              DC8     'CMOV'
 1968    00000005 C5                    DC8     'E'+0x80
 1969    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1970    00000008 ........              DC32    CLRBITS_NFA
 1971                           CMOVE:
 1972    0000000C ........              DC32    .+5
 1973                            SECTION .text : CODE (2)
 1974                                   POP2n //    ldr n, [p],#4      //COUNT
 1974.1  00000000 57F8041B              LDR     n, [p],#4
 1974.2                         //      LDR     n, [p]
 1974.3                         //      ADDS    p, p, #4
 1974.4                                 ENDM
 1975                                   POP2w //    ldr w, [p],#4      //DEST
 1975.1  00000004 57F8042B              LDR     w, [p],#4
 1975.2                         //      LDR     w, [p]
 1975.3                         //      ADDS    p, p, #4
 1975.4                                 ENDM
 1976                                   POP2x //    ldr x, [p],#4      //SOURCE
 1976.1  00000008 57F8043B              LDR     x, [p],#4
 1976.2                         //      LDR     x, [p]
 1976.3                         //      ADDS    p, p, #4
 1976.4                                 ENDM
 1977    0000000C 0029                  CMP     n, #0
 1978    0000000E 07D0                  BEQ     CM2
 1979                           CM1:
 1980                           //not for THUMB
 1981                           //strcpy  LDRB R2, [R1], #1
 1982                           //        STRB R2, [R0], #1
 1983                           //        TST R2, R2      // repeat if R2 is nonzero
 1984                           //        BNE strcpy
 1985    00000010 1878                  LDRB    t, [x]
 1986    00000012 1070                  STRB    t, [w]
 1987    00000014 491E                  SUBS    n, n, #1
 1988    00000016 0029                  CMP     n, #0
 1989    00000018 02D0                  BEQ     CM2
 1990                           
 1991    0000001A 521C                  ADDS    w, w, #1
 1992    0000001C 5B1C                  ADDS    x, x, #1
 1993    0000001E F7D1                  BNE     CM1
 1994                           CM2:
 1995                           #ifdef TOSCT
 1997                           #endif
 1998                                   NEXT
 1998.1                         // ARMv7-M Thumb = .+5
 1998.2  00000020 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1998.3                         // ARMv6-M Thumb = .+4
 1998.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1998                                   NEXT1
 1998.1  00000024 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1998.2  00000028 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1998.3  0000002C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1998.4                         // ARMv6-M Thumb = .+4
 1998.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1998.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1998.7                                 ENDM
 1998.8                                 ENDM
 1999                           
 2000                           
 2001                           //      FILL FILL:      ( addr quan b -- )
 2002                           //      Fill memory at the address with the specified quantity of bytes b.
 2003                           
 2004                            SECTION .text : CONST (2)
 2005                           FILL_NFA:
 2006    00000000 84                    DC8     0x84
 2007    00000001 46494C                DC8     'FIL'
 2008    00000004 CC                    DC8     'L'+0x80
 2009    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2010    00000008 ........              DC32    CMOVE_NFA
 2011                           FILL:
 2012    0000000C ........              DC32    .+5
 2013                            SECTION .text : CODE (2)
 2014                                   POP2t                   // Fill CHAR
 2014.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2014.2                         //#ifndef TOSCT
 2014.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2014.4                         //#endif
 2014.5                         //      ADDS    p, p, #4
 2014.6                                 ENDM
 2015                                   POP2n                   // Fill COUNT
 2015.1  00000004 57F8041B              LDR     n, [p],#4
 2015.2                         //      LDR     n, [p]
 2015.3                         //      ADDS    p, p, #4
 2015.4                                 ENDM
 2016                                   POP2w                   // Beginning ADDR
 2016.1  00000008 57F8042B              LDR     w, [p],#4
 2016.2                         //      LDR     w, [p]
 2016.3                         //      ADDS    p, p, #4
 2016.4                                 ENDM
 2017    0000000C 0029                  CMP     n, #0
 2018    0000000E 04D0                  BEQ     FEND            // Count is zero
 2019    00000010 8B18                  ADDS    x, n, w
 2020                           FLOOP:
 2021    00000012 1070                  STRB    t, [w]
 2022    00000014 521C                  ADDS    w, w, #1
 2023    00000016 9A42                  CMP     w, x
 2024    00000018 FBD1                  BNE     FLOOP
 2025                           FEND:
 2026                           #ifdef TOSCT
 2028                           #endif
 2029                                   NEXT
 2029.1                         // ARMv7-M Thumb = .+5
 2029.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2029.3                         // ARMv6-M Thumb = .+4
 2029.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2029                                   NEXT1
 2029.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2029.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2029.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2029.4                         // ARMv6-M Thumb = .+4
 2029.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2029.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2029.7                                 ENDM
 2029.8                                 ENDM
 2030                           
 2031                           
 2032                           //      ERASE ERASE:    ( addr n -- )
 2033                           //      Clear a region of memory to zero from addr over n addresses.
 2034                           
 2035                            SECTION .text : CONST (2)
 2036                           ERASE_NFA:
 2037    00000000 85                    DC8     0x85
 2038    00000001 45524153              DC8     'ERAS'
 2039    00000005 C5                    DC8     'E'+0x80
 2040    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2041    00000008 ........              DC32    FILL_NFA
 2042                           ERASE:
 2043    0000000C ........              DC32    DOCOL
 2044    00000010 ........              DC32    ZERO
 2045    00000014 ........              DC32    FILL
 2046    00000018 ........              DC32    SEMIS
 2047                           
 2048                           
 2049                           //      BLANKS BLANKS:  ( addr count -- )
 2050                           //      Fill an area of memory beginning at addr with blanks (0x20).
 2051                           
 2052                            SECTION .text : CONST (2)
 2053                           BLANKS_NFA:
 2054    00000000 86                    DC8     0x86
 2055    00000001 424C414E4B            DC8     'BLANK'
 2056    00000006 D3                    DC8     'S'+0x80
 2057    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2058    00000008 ........              DC32    ERASE_NFA
 2059                           BLANKS:
 2060    0000000C ........              DC32    DOCOL
 2061    00000010 ........              DC32    BLANK
 2062    00000014 ........              DC32    FILL
 2063    00000018 ........              DC32    SEMIS
 2064                           
 2065                           
 2066                           //      +! PSTORE:      ( n addr -- )
 2067                           //      Add n to the value at the address.
 2068                           //      Pronounced Plus Store
 2069                           
 2070                            SECTION .text : CONST (2)
 2071                           PSTORE_NFA:
 2072    00000000 82                    DC8     0x82
 2073    00000001 2B                    DC8     '+'
 2074    00000002 A1                    DC8     '!'+0x80
 2075    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2076    00000004 ........              DC32    BLANKS_NFA
 2077                           PSTORE:
 2078    00000008 ........              DC32    .+5
 2079                            SECTION .text : CODE (2)
 2080                                   POP2n                   // ADDRESS
 2080.1  00000000 57F8041B              LDR     n, [p],#4
 2080.2                         //      LDR     n, [p]
 2080.3                         //      ADDS    p, p, #4
 2080.4                                 ENDM
 2081                           #ifdef TOSCT
 2083                           #endif
 2084                                   POP2t                   // INCREMENT
 2084.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 2084.2                         //#ifndef TOSCT
 2084.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2084.4                         //#endif
 2084.5                         //      ADDS    p, p, #4
 2084.6                                 ENDM
 2085    00000008 0A68                  LDR     w, [n]
 2086    0000000A 8018                  ADDS    t, t, w
 2087    0000000C 0860                  STR     t, [n]
 2088                                   NEXT
 2088.1                         // ARMv7-M Thumb = .+5
 2088.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2088.3                         // ARMv6-M Thumb = .+4
 2088.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2088                                   NEXT1
 2088.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2088.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2088.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2088.4                         // ARMv6-M Thumb = .+4
 2088.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2088.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2088.7                                 ENDM
 2088.8                                 ENDM
 2089                           
 2090                           
 2091                           //      @ AT:   ( addr -- n )
 2092                           //      Read 32 bit contents of address to TOS.
 2093                           //      Pronounced Fetch, as in Fetch word at addr.
 2094                           
 2095                            SECTION .text : CONST (2)
 2096                           AT_NFA:
 2097    00000000 81                    DC8     0x81
 2098    00000001 C0                    DC8     '@'+0x80 //C0H
 2099    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2100                           //      DC32    TOGGLE_NFA
 2101    00000004 ........              DC32    PSTORE_NFA
 2102                           AT:
 2103    00000008 ........              DC32    .+5
 2104                            SECTION .text : CODE (2)
 2105                           //#ifdef TOSCT
 2106                           //        LDR     t, [t]
 2107                           //        STR     t, [p]
 2108                           //        NEXT
 2109                           //#else AT:
 2110                                   POP2n
 2110.1  00000000 57F8041B              LDR     n, [p],#4
 2110.2                         //      LDR     n, [p]
 2110.3                         //      ADDS    p, p, #4
 2110.4                                 ENDM
 2111    00000004 0868                  LDR     t, [n]
 2112                                   TPUSH
 2112                                   PUSHt   // push t to p, pre decrement p
 2112.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 2112.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 2112.3                         //      STR     t, [p]
 2112.4                                 ENDM
 2112                                   NEXT
 2112.1                         // ARMv7-M Thumb = .+5
 2112.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2112.3                         // ARMv6-M Thumb = .+4
 2112.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2112                                   NEXT1
 2112.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2112.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2112.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2112.4                         // ARMv6-M Thumb = .+4
 2112.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2112.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2112.7                                 ENDM
 2112.8                                 ENDM
 2112.9                                 ENDM
 2113                           //#endif
 2114                                   
 2115                           //      C@ CAT: ( addr -- b )
 2116                           //      Leave the 8 bit contents of addr on the stack.
 2117                           //      Pronounced "Char Fetch", as in Fetch byte at addr.
 2118                           
 2119                            SECTION .text : CONST (2)
 2120                           CAT_NFA:
 2121    00000000 82                    DC8     0x82
 2122    00000001 43                    DC8     'C'
 2123    00000002 C0                    DC8     '@'+0x80 //C0H
 2124    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2125    00000004 ........              DC32    AT_NFA
 2126                           CAT:
 2127    00000008 ........              DC32    .+5
 2128                            SECTION .text : CODE (2)
 2129                                   POP2n
 2129.1  00000000 57F8041B              LDR     n, [p],#4
 2129.2                         //      LDR     n, [p]
 2129.3                         //      ADDS    p, p, #4
 2129.4                                 ENDM
 2130    00000004 0878                  LDRB    t, [n]
 2131                                   TPUSH
 2131                                   PUSHt   // push t to p, pre decrement p
 2131.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 2131.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 2131.3                         //      STR     t, [p]
 2131.4                                 ENDM
 2131                                   NEXT
 2131.1                         // ARMv7-M Thumb = .+5
 2131.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2131.3                         // ARMv6-M Thumb = .+4
 2131.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2131                                   NEXT1
 2131.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2131.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2131.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2131.4                         // ARMv6-M Thumb = .+4
 2131.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2131.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2131.7                                 ENDM
 2131.8                                 ENDM
 2131.9                                 ENDM
 2132                           
 2133                           
 2134                           //      ! STORE:        ( n addr -- )
 2135                           //      Store n at address. Pronounced "Store".
 2136                           
 2137                            SECTION .text : CONST (2)
 2138                           STORE_NFA:
 2139    00000000 81                    DC8     0x81
 2140    00000001 A1                    DC8     '!'+0x80
 2141    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2142    00000004 ........              DC32    CAT_NFA
 2143                           STORE:
 2144    00000008 ........              DC32    .+5
 2145                            SECTION .text : CODE (2)
 2146                                   POP2t           // ADDR
 2146.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2146.2                         //#ifndef TOSCT
 2146.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2146.4                         //#endif
 2146.5                         //      ADDS    p, p, #4
 2146.6                                 ENDM
 2147                                   POP2n           // DATA
 2147.1  00000004 57F8041B              LDR     n, [p],#4
 2147.2                         //      LDR     n, [p]
 2147.3                         //      ADDS    p, p, #4
 2147.4                                 ENDM
 2148    00000008 0160                  STR     n, [t]
 2149                                   NEXT
 2149.1                         // ARMv7-M Thumb = .+5
 2149.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2149.3                         // ARMv6-M Thumb = .+4
 2149.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2149                                   NEXT1
 2149.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2149.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2149.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2149.4                         // ARMv6-M Thumb = .+4
 2149.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2149.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2149.7                                 ENDM
 2149.8                                 ENDM
 2150                           
 2151                           
 2152                           //      C! CSTORE:      ( n addr -- )
 2153                           //      Store LS 8 bits of n at address. Pronounced "Char Store".
 2154                           
 2155                            SECTION .text : CONST (2)
 2156                           CSTORE_NFA:
 2157    00000000 82                    DC8     0x82
 2158    00000001 43                    DC8     'C'
 2159    00000002 A1                    DC8     '!'+0x80
 2160    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2161    00000004 ........              DC32    STORE_NFA
 2162                           CSTORE:
 2163    00000008 ........              DC32    .+5
 2164                            SECTION .text : CODE (2)
 2165                                   POP2t
 2165.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2165.2                         //#ifndef TOSCT
 2165.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2165.4                         //#endif
 2165.5                         //      ADDS    p, p, #4
 2165.6                                 ENDM
 2166                                   POP2n
 2166.1  00000004 57F8041B              LDR     n, [p],#4
 2166.2                         //      LDR     n, [p]
 2166.3                         //      ADDS    p, p, #4
 2166.4                                 ENDM
 2167    00000008 0170                  STRB    n, [t]
 2168                                   NEXT
 2168.1                         // ARMv7-M Thumb = .+5
 2168.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2168.3                         // ARMv6-M Thumb = .+4
 2168.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2168                                   NEXT1
 2168.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2168.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2168.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2168.4                         // ARMv6-M Thumb = .+4
 2168.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2168.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2168.7                                 ENDM
 2168.8                                 ENDM
 2169                           
 2170                           
 2171                           //=============================== WORDCAT ====================================//
 2172                           //NOEXEC HEADERFORWORDCATEGORIES
 2173                           //      WC_RWMEMORY_NFA = Read and Write Memory With: CATEGORY
 2174                           
 2175                            SECTION .text : CONST (2)
 2176                           WC_RWMEMORY_NFA:
 2177    00000000 9F                    DC8     0x80+31
 2178    00000001 0D0A                  DC8     0x0D, 0x0A
 2179    00000003 5265616420616         DC8     'Read and Write Memory With:'
                  E642057726974
                  65204D656D6F7
                  2792057697468
                  3A           
 2180    0000001E 0D8A                  DC8     0x0D, 0x0A+0x80
 2181                            ALIGNROM 2,0xFFFFFFFF
 2182    00000020 ........              DC32    CSTORE_NFA
 2183                           
 2184                           
 2185                           //      ] RBRAC:        ( -- )
 2186                           //      Resume compilation, by STATE back to 0xC0 (zero is interpreting)
 2187                           //      0xC0 STATE  used in INTERPRET to execute Immediate words while compiling
 2188                           //      See [.
 2189                           
 2190                            SECTION .text : CONST (2)
 2191                           RBRAC_NFA:
 2192    00000000 81                    DC8     0x81
 2193    00000001 DD                    DC8     ']'+0x80
 2194    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2195                           //      DC32    SMUDGE_NFA
 2196    00000004 ........              DC32    WC_RWMEMORY_NFA
 2197                           RBRAC:
 2198    00000008 ........              DC32    DOCOL
 2199    0000000C ........C0000         DC32    strva, 0xC0, CSTATE
                  000........  
 2200    00000018 ........              DC32    SEMIS
 2201                           
 2202                           
 2203                           //      [ LBRAC:        ( -- ) IMMEDIATE
 2204                           //      Used in a colon-definition in form
 2205                           //              xxx    [  words   ]    more
 2206                           //      Suspend compilation by setting STATE to zero (0xC0 is compiling).
 2207                           //      The words after [ are executed, not compiled. This allows calculation
 2208                           //      or compilation exceptions before resuming compilation with ] .
 2209                           //      See LITERAL and ]
 2210                           
 2211                            SECTION .text : CONST (2)
 2212                           LBRAC_NFA:
 2213    00000000 C1                    DC8     0x0C1
 2214    00000001 DB                    DC8     '['+0x80
 2215    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2216    00000004 ........              DC32    RBRAC_NFA
 2217                           LBRAC:
 2218    00000008 ........              DC32    DOCOL
 2219    0000000C ........00000         DC32    strva, 0, CSTATE
                  000........  
 2220    00000018 ........              DC32    SEMIS
 2221                           
 2222                           
 2223                           //      [COMPILE] BCOMP:        ( -- ) IMMEDIATE
 2224                           //      Used in a colon-definition in form:
 2225                           //              :  xxx    [COMPILE]   immediate_word   ;
 2226                           //      [COMPILE] will force the compilation of an IMMEDIATE WORD
 2227                           //      that would otherwise execute during compilation. The above example
 2228                           //      will select the FORTH vocabulary then xxx executes, rather than at
 2229                           //      compile time.
 2230                           
 2231                            SECTION .text : CONST (2)
 2232                           BCOMP_NFA:
 2233    00000000 C9                    DC8     0x0C9
 2234    00000001 5B434F4D50494         DC8     '[COMPILE'
                  C45          
 2235    00000009 DD                    DC8     ']'+0x80
 2236    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2237    0000000C ........              DC32    LBRAC_NFA
 2238                           BCOMP:
 2239    00000010 ........              DC32    DOCOL
 2240    00000014 ........              DC32    DFIND   // noop there for TIB entry
 2241                           //      -FIND \ --- pfa len tf (found) \ --- ff (not found)
 2242    00000018 ........              DC32    ZEQU
 2243    0000001C .............         DC32    LIT, msg_qstack
                  ...          
 2244    00000024 ........              DC32    QERROR    // \ f nullstr-addr --
 2245    00000028 ........              DC32    DROP
 2246    0000002C ........              DC32    CFA
 2247    00000030 ........              DC32    COMMA   // alighned, INCREMENTS DP REFLECTED by HERE
 2248    00000034 ........              DC32    SEMIS
 2249                           
 2250                           
 2251                           //      DLITERAL DLITERAL:      ( d -- d ) IMMEDIATE
 2252                           //                              ( d -- )   (compiling)
 2253                           //      If compiling, compile a stack double number into a literal. Later
 2254                           //      execution of the definition containing the literal will push it to
 2255                           //      the stack. If executing, the number will remain on the stack.
 2256                           //      : xxx    [ calculate ]  DLITERAL  ; //
 2257                           
 2258                            SECTION .text : CONST (2)
 2259                           DLITERAL_NFA:
 2260    00000000 C8                    DC8     0x0C8
 2261    00000001 444C495445524         DC8     'DLITERA'
                  1            
 2262    00000008 CC                    DC8     'L'+0x80
 2263    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2264    0000000C ........              DC32    BCOMP_NFA
 2265                           DLITERAL:
 2266    00000010 ........              DC32    DOCOL
 2267    00000014 ........              DC32    STATE_SV
 2268    00000018 ........              DC32    AT
 2269    0000001C ........              DC32    ZBRAN   // IF
 2270    00000020 10000000              DC32     DLIT1-.
 2271                           
 2272    00000024 ........              DC32    SWAP
 2273    00000028 ........              DC32    LITERAL
 2274    0000002C ........              DC32    LITERAL // endif
 2275                           DLIT1:
 2276    00000030 ........              DC32    SEMIS
 2277                           
 2278                           
 2279                           //      LITERAL LITERAL:        ( n -- ) IMMEDIATE
 2280                           //      If compiling, then compile the stack value n as a 32 bit literal.
 2281                           //      This definition is immediate so that it will execute during a colon
 2282                           //      definition. The intended use is:
 2283                           //      : xxx    [ calculate ]  LITERAL  ; //
 2284                           //      Compilation is suspended for the compile time calculation of value.
 2285                           //      Compilation is resumed and LITERAL compiles this value.
 2286                           
 2287                            SECTION .text : CONST (2)
 2288                           LITERAL_NFA:
 2289    00000000 C7                    DC8     0x0C7
 2290    00000001 4C4954455241          DC8     'LITERA'
 2291    00000007 CC                    DC8     'L'+0x80
 2292                            ALIGNROM 2,0xFFFFFFFF
 2293    00000008 ........              DC32    DLITERAL_NFA
 2294                           LITERAL:
 2295    0000000C ........              DC32    DOCOL
 2296    00000010 ........              DC32    STATE_SV
 2297    00000014 ........              DC32    AT
 2298    00000018 ........              DC32    ZBRAN           // If not compiling
 2299    0000001C 10000000              DC32     LITE1-.        // go here
 2300                           
 2301    00000020 ........              DC32    COMP            // Compile
 2302    00000024 ........              DC32    LIT             // Literal
 2303    00000028 ........              DC32    COMMA           // Then COMPILE THE LITERAL VALUE
 2304                           LITE1:
 2305    0000002C ........              DC32    SEMIS
 2306                           
 2307                           
 2308                           //      #> EDIGS:       ( d=(LSW MSW) -- addr count )
 2309                           //      Terminates numeric output conversion by dropping dnum,
 2310                           //      leaving the text address and character count suitable for type.
 2311                           
 2312                            SECTION .text : CONST (2)
 2313                           EDIGS_NFA:
 2314    00000000 82                    DC8     0x82
 2315    00000001 23                    DC8     '#'
 2316    00000002 BE                    DC8     '>'+0x80
 2317    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2318    00000004 ........              DC32    LITERAL_NFA
 2319                           EDIGS:
 2320    00000008 ........              DC32    DOCOL
 2321    0000000C ........              DC32    DROP
 2322    00000010 ........              DC32    DROP
 2323    00000014 ........              DC32    HLD_SV
 2324    00000018 ........              DC32    AT
 2325    0000001C ........              DC32    PAD_SV
 2326    00000020 ........              DC32    OVER
 2327    00000024 ........              DC32    SUBB
 2328    00000028 ........              DC32    SEMIS
 2329                           
 2330                           
 2331                           //      HOLD HOLD:      ( c -- )
 2332                           //      Used between <# and #> to insert an ascii character into a pictured
 2333                           //      numeric output string.
 2334                           //      e.g. 0x2E HOLD will place a decimal point.
 2335                           
 2336                            SECTION .text : CONST (2)
 2337                           HOLD_NFA:
 2338    00000000 84                    DC8     0x84
 2339    00000001 484F4C                DC8     'HOL'
 2340    00000004 C4                    DC8     'D'+0x80
 2341    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2342    00000008 ........              DC32    EDIGS_NFA
 2343                           HOLD:
 2344    0000000C ........              DC32    DOCOL
 2345    00000010 ........FFFFF         DC32    LIT,-1
                  FFF          
 2346    00000018 ........              DC32    HLD_SV
 2347    0000001C ........              DC32    PSTORE
 2348    00000020 ........              DC32    HLD_SV
 2349    00000024 ........              DC32    AT
 2350    00000028 ........              DC32    CSTORE
 2351    0000002C ........              DC32    SEMIS
 2352                           
 2353                           
 2354                           //      SIGN SIGN:      ( n d=<LSW MSW> -- d=<LSW MSW> )
 2355                           //      Place an ascii "-" sign just before a converted numeric output
 2356                           //      string in the text output buffer when n is negative. n is discarded
 2357                           //      but double number dnum is maintained. Must be used between <# and #>.
 2358                           
 2359                            SECTION .text : CONST (2)
 2360                           SIGN_NFA:
 2361    00000000 84                    DC8     0x84
 2362    00000001 534947                DC8     'SIG'
 2363    00000004 CE                    DC8     'N'+0x80
 2364    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2365    00000008 ........              DC32    HOLD_NFA
 2366                           SIGN:
 2367    0000000C ........              DC32    DOCOL
 2368    00000010 ........              DC32    ROT
 2369    00000014 ........              DC32    ZLESS
 2370    00000018 ........              DC32    ZBRAN           // If
 2371    0000001C 10000000              DC32     SIGN1-.
 2372                           
 2373    00000020 ........2D000         DC32    LIT, '-'        // 0x2D
                  000          
 2374    00000028 ........              DC32    HOLD            // Endif
 2375                           SIGN1:
 2376    0000002C ........              DC32    SEMIS
 2377                           
 2378                           
 2379                           //      #S DIGS:        ( d1=<LSW MSW> -- d2=<LSW MSW> )
 2380                           //      Generates ascii text in the text output buffer, by the use of #,
 2381                           //      until a zero double number d2 results.
 2382                           //      Used between <# and #>.
 2383                           //      EACH NUMBER = BASE*number+(character-'0')
 2384                           
 2385                            SECTION .text : CONST (2)
 2386                           DIGS_NFA:
 2387    00000000 82                    DC8     0x82
 2388    00000001 23                    DC8     '#'
 2389    00000002 D3                    DC8     'S'+0x80
 2390    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2391    00000004 ........              DC32    SIGN_NFA
 2392                           DIGS:
 2393    00000008 ........              DC32    DOCOL
 2394                           DIGS1:                          // Begin generating ascii chars by DIG
 2395    0000000C ........              DC32    DIG             //\ d1=<LSW MSW> -- d2=QUO=<LSW MSW>
 2396    00000010 ........              DC32    OVER
 2397    00000014 ........              DC32    OVER
 2398    00000018 ........              DC32    OR
 2399    0000001C ........              DC32    ZEQU
 2400    00000020 ........              DC32    ZBRAN           //UNTIL
 2401    00000024 E8FFFFFF              DC32     DIGS1-.
 2402    00000028 ........              DC32    SEMIS
 2403                           
 2404                           
 2405                           //      # DIG:  ( d1=<LSW MSW> -- d2=QUO=<LSW MSW> ) BASE MUST BE SET!
 2406                           //      Generate from a double number d1, the next ascii character which is
 2407                           //      placed in an output string. Result d2 is the quotient after division
 2408                           //      by base, and is maintained for further processing.
 2409                           //      Used between <# and #>.
 2410                           //      See #S.
 2411                           //      EACH NUMBER = BASE*number+(character-'0')
 2412                           
 2413                            SECTION .text : CONST (2)
 2414                           DIG_NFA:
 2415    00000000 81                    DC8     0x81
 2416    00000001 A3                    DC8     '#'+0x80
 2417    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2418    00000004 ........              DC32    DIGS_NFA
 2419                           DIG:
 2420    00000008 ........              DC32    DOCOL
 2421    0000000C ........              DC32    BASE_SV         // EX 0 1 0
 2422    00000010 ........              DC32    AT              // -- 0 1 0 A
 2423    00000014 ........              DC32    MSMOD           // -- 0 1 0 0
 2424    00000018 ........              DC32    ROT             // -- 0 0 0 1
 2425    0000001C ........09000         DC32    LIT,9
                  000          
 2426    00000024 ........              DC32    OVER
 2427    00000028 ........              DC32    LESSTHAN
 2428    0000002C ........              DC32    ZBRAN           // If
 2429    00000030 10000000              DC32     DIG1-.
 2430                           
 2431    00000034 ........07000         DC32    LIT,7
                  000          
 2432    0000003C ........              DC32    PLUS            // Endif
 2433                           DIG1:
 2434    00000040 ........30000         DC32    LIT, 0x30
                  000          
 2435    00000048 ........              DC32    PLUS
 2436    0000004C ........              DC32    HOLD
 2437    00000050 ........              DC32    SEMIS
 2438                           
 2439                           
 2440                           //      <# BDIGS:       ( -- )
 2441                           //      Setup for pictured numeric output formatting using the words:
 2442                           //              <# # #S SIGN HOLD #>
 2443                           //      The conversion is done on a double number producing text at Pad
 2444                           
 2445                            SECTION .text : CONST (2)
 2446                           BDIGS_NFA:
 2447    00000000 82                    DC8     0x82
 2448    00000001 3C                    DC8     '<'
 2449    00000002 A3                    DC8     '#'+0x80
 2450    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2451    00000004 ........              DC32    DIG_NFA
 2452                           BDIGS:
 2453    00000008 ........              DC32    DOCOL
 2454    0000000C .............         DC32    strva, PAD, NHLD
                  ...........  
 2455    00000018 ........              DC32    SEMIS
 2456                           
 2457                           
 2458                           //      DOES> DOES:     ( pfa -- ) MODIFIED:
 2459                           //      A word which defines the run-time action within a high-level
 2460                           //      defining word. DOES> alters the code field and first parameter of
 2461                           //      the new word to execute the sequence of compiled word addresses
 2462                           //      following DOES>. Used in combination with <BUILDS. When the DOES>
 2463                           //      part executes it begins with the address of the first parameter of
 2464                           //      the new word on the stack. This allows interpretation using this
 2465                           //      area or its contents. Typical uses include the Forth assembler,
 2466                           //      multidimensional arrays, and compiler generation.
 2467                           
 2468                            SECTION .text : CONST (2)
 2469                           DOES_NFA:
 2470    00000000 85                    DC8     0x85
 2471    00000001 444F4553              DC8     'DOES'
 2472    00000005 BE                    DC8     '>'+0x80
 2473    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2474    00000008 ........              DC32    BDIGS_NFA
 2475                           DOES:
 2476    0000000C ........              DC32    DOCOL
 2477    00000010 ........              DC32    RFROM   // Get the addr of the first word after DOES>
 2478    00000014 ........              DC32    LATEST  // ( -- addr ) nfa OF the current <creator> word
 2479    00000018 ........              DC32    PFA     // Use the pfa to store a run-time cfa
 2480    0000001C .............         DC32    DUP, CFA
                  ...          
 2481    00000024 .............         DC32    LIT, CREATE_DOES_GOTO
                  ...          
 2482    0000002C .............         DC32    SWAP, STORE     // STORE GOTO
                  ...          
 2483    00000034 ........              DC32    STORE   // Store the run-time cfa as 1rst pfa Parameter.
 2484    00000038 ........              DC32    SEMIS
 2485                           
 2486                           
 2487                           //      <BUILDS BUILDS: ( -- )  MODIFIED: See CREATE and DOES>
 2488                           //      Used within a colon-definition
 2489                           //              CCcc  <BUILDS  ...  DOES>     ...
 2490                           //      Each time CCcc is executed, <BUILDS defines a new word with a
 2491                           //      high-level execution proceedure. Executing CCcc in the form
 2492                           //              CCcc nnnn
 2493                           //      uses <BUILDS to create a dictionary entry for nnnn with a call to
 2494                           //      the DOES> part for nnnn. When nnnn is later executed, it has the
 2495                           //      address of its parameter area on the stack and executes the words
 2496                           //      after DOES> in CCcc. <BUILDS and DOES> allow runtime proceedures to
 2497                           //      written in high-level code.
 2498                           
 2499                            SECTION .text : CONST (2)
 2500                           BUILDS_NFA:
 2501    00000000 87                    DC8     0x87
 2502    00000001 3C4255494C44          DC8     '<BUILD'
 2503    00000007 D3                    DC8     'S'+0x80
 2504                            ALIGNROM 2,0xFFFFFFFF
 2505    00000008 ........              DC32    DOES_NFA
 2506                           BUILDS:
 2507    0000000C ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 2508    00000010 ........              DC32    CREATE                  // CREATE's A CON POINTING TO IT'S PFA
 2509    00000014 ........              DC32    SEMIS
 2510                           
 2511                           
 2512                           //      +LOOP PLOOP:    ( n1 -- ) IMMEDIATE
 2513                           //                      ( addr n2 -- ) COMPILE
 2514                           //      At run time, DO begins a sequence with repetitive execution
 2515                           //      controlled by a loop limit n1 and an index with initial value n2. DO
 2516                           //      removes these from the stack. Upon reaching LOOP the index is
 2517                           //      incremented by one.
 2518                           //      Until the new index equals or exceeds the limit, execution loops
 2519                           //      back to just after DO// otherwise the loop parameters are discarded
 2520                           //      and execution continues ahead. Both n1 and n2 are determined at
 2521                           //      run-time and may be the result of other operations.
 2522                           //      Within a loop 'I' will copy the current value of the index to the
 2523                           //      stack. See I, LOOP, +LOOP, LEAVE.
 2524                           //
 2525                           //      When compiling within the colon definition, DO compiles (DO), leaves
 2526                           //      the following address addr and n for later error checking.
 2527                           
 2528                            SECTION .text : CONST (2)
 2529                           PLOOP_NFA:
 2530    00000000 C5                    DC8     0x0C5
 2531    00000001 2B4C4F4F              DC8     '+LOO'
 2532    00000005 D0                    DC8     'P'+0x80
 2533    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2534    00000008 ........              DC32    BUILDS_NFA
 2535                           PLOOP:
 2536    0000000C ........              DC32    DOCOL
 2537    00000010 ........              DC32    THREE
 2538    00000014 ........              DC32    QPAIR
 2539    00000018 ........              DC32    COMP
 2540    0000001C ........              DC32    XPLOOP
 2541    00000020 ........              DC32    BACK
 2542    00000024 ........              DC32    SEMIS
 2543                           
 2544                           
 2545                           //      LOOP LOOP:      ( addr n -- ) IMMEDIATE
 2546                           //      Occurs in a colon-definition in form:
 2547                           //              DO ... LOOP
 2548                           //      At run-time, LOOP selectively controls branching back to the
 2549                           //      corresponding DO based on the loop index and limit. The loop index
 2550                           //      is incremented by one and compared to the limit. The branch back to
 2551                           //      DO occurs until the index equals or exceeds the limit, then
 2552                           //      the parameters are discarded and execution continues ahead.
 2553                           //
 2554                           //      At compile-time. LOOP compiles (LOOP) and uses addr to calculate an
 2555                           //      offset to DO. n is used for error testing.
 2556                           
 2557                            SECTION .text : CONST (2)
 2558                           LOOP_NFA:
 2559    00000000 C4                    DC8     0x0C4
 2560    00000001 4C4F4F                DC8     'LOO'
 2561    00000004 D0                    DC8     'P'+0x80
 2562    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2563    00000008 ........              DC32    PLOOP_NFA
 2564                           LOOP:
 2565    0000000C ........              DC32    DOCOL
 2566    00000010 ........              DC32    THREE
 2567    00000014 ........              DC32    QPAIR
 2568    00000018 ........              DC32    COMP
 2569    0000001C ........              DC32    XLOOP
 2570    00000020 ........              DC32    BACK
 2571    00000024 ........              DC32    SEMIS
 2572                           
 2573                           
 2574                           //      DO DO:  ( n1 n2 -- ) IMMEDIATE
 2575                           //              (addr n -- ) COMPILE
 2576                           //      Occurs in a colon-definition in form:
 2577                           //      DO ... LOOP
 2578                           
 2579                            SECTION .text : CONST (2)
 2580                           DO_NFA:
 2581    00000000 C2                    DC8     0x0C2
 2582    00000001 44                    DC8     'D'
 2583    00000002 CF                    DC8     'O'+0x80
 2584    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2585    00000004 ........              DC32    LOOP_NFA
 2586                           DO:
 2587    00000008 ........              DC32    DOCOL
 2588    0000000C ........              DC32    COMP
 2589    00000010 ........              DC32    XDO
 2590    00000014 ........              DC32    HERE
 2591    00000018 ........              DC32    THREE
 2592    0000001C ........              DC32    SEMIS
 2593                           
 2594                           
 2595                           //      ENDIF ENDIF:    ( addr n -- ) IMMEDIATE
 2596                           //      Occurs in a colon-definition in form:
 2597                           //              IF ... ENDIF
 2598                           //              IF ... ELSE ... ENDIF
 2599                           //      At run-time, ENDIF serves only as the destination of a forward
 2600                           //      branch from IF or ELSE. It marks the conclusion of the conditional
 2601                           //      structure. THEN is another name for ENDIF. Both names are supported
 2602                           //      in fig-FORTH. See also IF and ELSE.
 2603                           //
 2604                           //      At compile-time, ENDIF computes the forward branch offset from addr
 2605                           //      to HERE and stores it at addr. n is used for error tests.
 2606                           
 2607                            SECTION .text : CONST (2)
 2608                           ENDIF_NFA:
 2609    00000000 C5                    DC8     0x0C5
 2610    00000001 454E4449              DC8     'ENDI'
 2611    00000005 C6                    DC8     'F'+0x80
 2612    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2613    00000008 ........              DC32    DO_NFA
 2614                           ENDIF:
 2615    0000000C ........              DC32    DOCOL
 2616    00000010 ........              DC32    QCOMP
 2617    00000014 ........              DC32    TWO     // 2 is the Error checking number for if.
 2618    00000018 ........              DC32    QPAIR
 2619    0000001C ........              DC32    HERE
 2620    00000020 ........              DC32    OVER
 2621    00000024 ........              DC32    SUBB
 2622    00000028 ........              DC32    SWAP
 2623    0000002C ........              DC32    STORE
 2624    00000030 ........              DC32    SEMIS
 2625                           
 2626                           
 2627                           //      THEN THEN:      ( -- ) IMMEDIATE
 2628                           //      An alias for ENDIF.
 2629                           
 2630                            SECTION .text : CONST (2)
 2631                           THEN_NFA:
 2632    00000000 C4                    DC8     0x0C4
 2633    00000001 544845                DC8     'THE'
 2634    00000004 CE                    DC8     'N'+0x80
 2635    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2636    00000008 ........              DC32    ENDIF_NFA
 2637                           THEN:
 2638    0000000C ........              DC32    DOCOL
 2639    00000010 ........              DC32    ENDIF
 2640    00000014 ........              DC32    SEMIS
 2641                           
 2642                           
 2643                           //      ELSE ELSE:      ( addr1 n1 -- ) IMMEDIATE
 2644                           //                      ( addr2 n2 -- ) COMPILING
 2645                           //      Occurs within a colon-definition in the form:
 2646                           //              IF ... ELSE ... ENDIF
 2647                           //      At run-time, ELSE executes after the true part following IF. ELSE
 2648                           //      forces execution to skip over the following false part and resumes
 2649                           //      execution after the ENDIF. It has no stack effect.
 2650                           //
 2651                           //      At compile-time ELSE emplaces BRANCH reserving a branch offset,
 2652                           //      leaves the address addr2 and n2 for error testing. ELSE also
 2653                           //      resolves the pending forward branch from IF by calculating the
 2654                           //      offset from addr1 to HERE and storing at addr1.
 2655                           
 2656                            SECTION .text : CONST (2)
 2657                           ELSE_NFA:
 2658    00000000 C4                    DC8     0x0C4
 2659    00000001 454C53                DC8     'ELS'
 2660    00000004 C5                    DC8     'E'+0x80
 2661    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2662    00000008 ........              DC32    THEN_NFA
 2663                           ELSE:
 2664    0000000C ........              DC32    DOCOL
 2665    00000010 ........              DC32    TWO
 2666    00000014 ........              DC32    QPAIR
 2667    00000018 ........              DC32    COMP
 2668    0000001C ........              DC32    BRAN
 2669    00000020 ........              DC32    HERE
 2670    00000024 ........              DC32    ZERO
 2671    00000028 ........              DC32    COMMA   // aligned, INCREMENTS DP REFLECTED by HERE
 2672    0000002C ........              DC32    SWAP
 2673    00000030 ........              DC32    TWO
 2674    00000034 ........              DC32    ENDIF
 2675    00000038 ........              DC32    TWO
 2676    0000003C ........              DC32    SEMIS
 2677                           
 2678                           
 2679                           //      IF IF:  ( f -- ) IMMEDIATE
 2680                           //              ( -- addr n ) COMPILE
 2681                           //      Occurs is a colon-definition in form:
 2682                           //              IF (tp) ...  ENDIF      .
 2683                           //              IF (tp) ... ELSE (fp) ... ENDIF
 2684                           //      At run-time, IF selects execution based on a boolean flag. If f is
 2685                           //      true (non-zero), execution continues ahead thru the true part. If f
 2686                           //      is false (zero), execution skips till just after ELSE to execute
 2687                           //      the false part. After either part, execution resumes after ENDIF.
 2688                           //      ELSE and its false part are optional.; if missing, false execution
 2689                           //      skips to just after ENDIF..
 2690                           //
 2691                           //      At compile-time IF compiles 0BRANCH and reserves space for an offset
 2692                           //      at addr. addr and n are used later for resolution of the offset and
 2693                           //      error testing.
 2694                           
 2695                            SECTION .text : CONST (2)
 2696                           IF_NFA:
 2697    00000000 C2                    DC8     0x0C2
 2698    00000001 49                    DC8     'I'
 2699    00000002 C6                    DC8     'F'+0x80
 2700    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2701    00000004 ........              DC32    ELSE_NFA
 2702                           IF:
 2703    00000008 ........              DC32    DOCOL
 2704    0000000C ........              DC32    COMP
 2705    00000010 ........              DC32    ZBRAN
 2706    00000014 ........              DC32    HERE
 2707    00000018 ........              DC32    ZERO
 2708    0000001C ........              DC32    COMMA
 2709    00000020 ........              DC32    TWO     // 2 is the Error checking number for if.
 2710    00000024 ........              DC32    SEMIS
 2711                           
 2712                           
 2713                           //      UNTIL UNTIL:    ( f -- ) IMMEDIATE
 2714                           //                      ( addr n -- ) COMPILE:
 2715                           //      Occurs within a colon-definition in the form:
 2716                           //              BEGIN ... UNTIL
 2717                           //      At run-time, UNTIL controls the conditional branch back to the
 2718                           //      corresponding BEGIN. If f is false, execution returns to just after.
 2719                           //      BEGIN:  if true, execution continues ahead.
 2720                           //      At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to
 2721                           //      addr. n is used for error tests.
 2722                           
 2723                            SECTION .text : CONST (2)
 2724                           UNTIL_NFA:
 2725    00000000 C5                    DC8     0x0C5
 2726    00000001 554E5449              DC8     'UNTI'
 2727    00000005 CC                    DC8     'L'+0x80
 2728    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2729    00000008 ........              DC32    IF_NFA
 2730                           UNTIL:
 2731    0000000C ........              DC32    DOCOL
 2732    00000010 ........              DC32    ONE
 2733    00000014 ........              DC32    QPAIR
 2734    00000018 ........              DC32    COMP
 2735    0000001C ........              DC32    ZBRAN
 2736    00000020 ........              DC32    BACK
 2737    00000024 ........              DC32    SEMIS
 2738                           
 2739                           
 2740                           //      AGAIN AGAIN:    ( addr n -- ) IMMEDIATE
 2741                           //      Used in a colon-definition in the form:
 2742                           //                      BEGIN ... AGAIN
 2743                           //      At run-time, AGAIN forces execution to return to corresponding BEGIN.
 2744                           //      There is no effect on the stack. Execution cannot leave this loop
 2745                           //      (unless R> DROP is executed one level below).
 2746                           //
 2747                           //      At compile time, AGAIN compiles BRANCH with an offset from HERE to
 2748                           //      addr. n is used for compile-time error checking.
 2749                           
 2750                            SECTION .text : CONST (2)
 2751                           AGAIN_NFA:
 2752    00000000 C5                    DC8     0x0C5
 2753    00000001 41474149              DC8     'AGAI'
 2754    00000005 CE                    DC8     'N'+0x80
 2755    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2756    00000008 ........              DC32    UNTIL_NFA
 2757                           AGAIN:
 2758    0000000C ........              DC32    DOCOL
 2759    00000010 ........              DC32    ONE
 2760    00000014 ........              DC32    QPAIR
 2761    00000018 ........              DC32    COMP
 2762    0000001C ........              DC32    BRAN
 2763    00000020 ........              DC32    BACK
 2764    00000024 ........              DC32    SEMIS
 2765                           
 2766                           
 2767                           //      REPEAT REPEAT:  ( addr n -- ) IMMEDIATE
 2768                           //      Used within a colon-definition in the form:
 2769                           //              BEGIN ... WHILE ... REPEAT
 2770                           //      At run-time, REPEAT forces an unconditional branch back to just
 2771                           //      after the corresponding BEGIN.
 2772                           //
 2773                           //      At compile-time, REPEAT compiles BRANCH and the offset from HERE to
 2774                           //      addr. n is used for error testing.
 2775                           
 2776                            SECTION .text : CONST (2)
 2777                           REPEAT_NFA:
 2778    00000000 C6                    DC8     0x0C6
 2779    00000001 5245504541            DC8     'REPEA'
 2780    00000006 D4                    DC8     'T'+0x80
 2781    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2782    00000008 ........              DC32    AGAIN_NFA
 2783                           REPEAT:
 2784    0000000C ........              DC32    DOCOL
 2785    00000010 ........              DC32    TOR
 2786    00000014 ........              DC32    TOR
 2787    00000018 ........              DC32    AGAIN
 2788    0000001C ........              DC32    RFROM
 2789    00000020 ........              DC32    RFROM
 2790    00000024 ........              DC32    TWO
 2791    00000028 ........              DC32    SUBB
 2792    0000002C ........              DC32    ENDIF
 2793    00000030 ........              DC32    SEMIS
 2794                           
 2795                           
 2796                           //      WHILE WHILE:    ( f -- ) IMMEDIATE
 2797                           //                      (ad1 nl -- ad1 n1 ad2 n2 ) COMPILE
 2798                           //      Occurs in a colon-definition in the form:
 2799                           //              BEGIN ... WHILE (tp) ... REPEAT
 2800                           //      At run-time, WHILE selects conditional execution based on boolean
 2801                           //      flag f. If f is true (non-zero), WHILE continues execution of the
 2802                           //      true part thru to REPEAT, which then branches back to BEGIN. If f is
 2803                           //      false (zero), execution skips to just after REPEAT, exiting the
 2804                           //      structure.
 2805                           //
 2806                           //      At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the
 2807                           //      reserved offset. The stack values will be resolved by REPEAT.
 2808                           
 2809                            SECTION .text : CONST (2)
 2810                           WHILE_NFA:
 2811    00000000 C5                    DC8     0x0C5
 2812    00000001 5748494C              DC8     'WHIL'
 2813    00000005 C5                    DC8     'E'+0x80
 2814    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2815    00000008 ........              DC32    REPEAT_NFA
 2816                           WHILE:
 2817    0000000C ........              DC32    DOCOL
 2818    00000010 ........              DC32    IF
 2819    00000014 ........              DC32    TWOP
 2820    00000018 ........              DC32    SEMIS
 2821                           
 2822                           
 2823                           //      BEGIN BEGIN:    ( -- addr n ) IMMEDIATE
 2824                           //      Occurs in a colon-definition in form:
 2825                           //      BEGIN ... UNTIL
 2826                           //      BEGIN ... AGAIN
 2827                           //      BEGIN ... WHILE ... REPEAT
 2828                           //      At run-time, BEGIN marks the start of a sequence that may be
 2829                           //      repetitively executed. It serves as a return point from the
 2830                           //      corresponding UNTIL, AGAIN or REPEAT. When executing UNTIL, a return
 2831                           //      to BEGIN will occur if the top of the stack is false//
 2832                           //      for AGAIN and REPEAT a return to BEGIN always occurs.
 2833                           //
 2834                           //      At compile time BEGIN leaves its return address and n for compiler
 2835                           //      error checking.
 2836                           
 2837                            SECTION .text : CONST (2)
 2838                           BEGIN_NFA:
 2839    00000000 C5                    DC8     0x0C5
 2840    00000001 42454749              DC8     'BEGI'
 2841    00000005 CE                    DC8     'N'+0x80
 2842    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2843    00000008 ........              DC32    WHILE_NFA
 2844                           BEGIN:
 2845    0000000C ........              DC32    DOCOL
 2846    00000010 ........              DC32    QCOMP
 2847    00000014 ........              DC32    HERE
 2848    00000018 ........              DC32    ONE
 2849    0000001C ........              DC32    SEMIS
 2850                           
 2851                           
 2852                           //=============================== WORDCAT ====================================//
 2853                           //NOEXEC HEADERFORWORDCATEGORIES
 2854                           //      WC_COMPILE_NFA = Inside Colon WORDS: CATEGORY
 2855                           
 2856                            SECTION .text : CONST (2)
 2857                           WC_COMPILE_NFA:
 2858    00000000 97                    DC8     0x80+4+19
 2859    00000001 0D0A                  DC8     0x0D, 0x0A
 2860    00000003 496E736964652         DC8     'Inside Colon WORDS:'
                  0436F6C6F6E20
                  574F5244533A 
 2861    00000016 0D8A                  DC8     0x0D, 0x0A+0x80
 2862                            ALIGNROM 2,0xFFFFFFFF
 2863    00000018 ........              DC32    BEGIN_NFA
 2864                           
 2865                           
 2866                           //      IMMEDIATE IMMED:        ( -- )
 2867                           //      Mark the most recently made definition so that when encountered at
 2868                           //      compile time, it will be executed rather than being compiled. i.e.
 2869                           //      the precedence bit in its header is set.
 2870                           //      This method allows definitions to handle unusual compiling
 2871                           //      situations, rather. than build them into the fundamental compiler.
 2872                           //      The system may force compilation of an immediate definition by
 2873                           //      preceeding it with [COMPILE].
 2874                           
 2875                            SECTION .text : CONST (2)
 2876                           IMMED_NFA:
 2877    00000000 89                    DC8     0x89
 2878    00000001 494D4D4544494         DC8     'IMMEDIAT'
                  154          
 2879    00000009 C5                    DC8     'E'+0x80
 2880    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2881    0000000C ........              DC32    WC_COMPILE_NFA
 2882                           IMMED:
 2883    00000010 ........              DC32    DOCOL
 2884    00000014 ........              DC32    LATEST
 2885    00000018 ........40000         DC32    LIT, 0x40
                  000          
 2886    00000020 ........              DC32    TOGGLE
 2887    00000024 ........              DC32    SEMIS
 2888                           
 2889                           
 2890                           //      CREATE CREATE:  ( -- )
 2891                           //      Create a word in The Dictionary.
 2892                           //      Make searchable and forgetable NFA/LFA, DOCON, ADDR->PFA
 2893                           //      USE <BUILDS with DOES> instead of CREATE.
 2894                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2895                           //
 2896                           //      Saves HERE in CSDP in case there's an error creating a word.
 2897                           //      CSDP is reset when a word is completed, by ; <BUILDS (?) CON and VAR.
 2898                           //
 2899                           //      A defining word used in the form:
 2900                           //              CREATE CCcc
 2901                           //      by such words as VAR, CON AND <BUILDS to create a dictionary header for
 2902                           //      a new word. The code field contains the address of the words
 2903                           //      parameter field.
 2904                           
 2905                            SECTION .text : CONST (2)
 2906                           CREATE_NFA:
 2907    00000000 86                    DC8     0x86
 2908    00000001 4352454154            DC8     'CREAT'
 2909    00000006 C5                    DC8     'E'+0x80
 2910    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2911    00000008 ........              DC32    IMMED_NFA
 2912                           CREATE:
 2913    0000000C ........              DC32    DOCOL
 2914    00000010 ........              DC32    DICTSPACE       //      \ -- n
 2915    00000014 ........0F000         DC32    LIT, 15, SUBB   // One less than smallest definition
                  000........  
 2916    00000020 ........              DC32    ZLESS
 2917    00000024 ........              DC32    ZBRAN
 2918    00000028 08000000              DC32    CREATEOK-.
 2919                           
 2920    0000002C ........              DC32    DICTFULL_ABORT
 2921                           
 2922                           CREATEOK:
 2923    00000030 ........              DC32    DFIND                   // Parse nfa
 2924                           //      -FIND DFIND \ --- pfa len tf (found) \ --- ff (not found)
 2925    00000034 ........              DC32    ZBRAN
 2926    00000038 24000000              DC32     CREA1-.
 2927                           
 2928                           #ifdef IO2TP
 2932                           #endif
 2933    0000003C ........              DC32    DROP
 2934    00000040 ........              DC32    NFA
 2935    00000044 ........              DC32    IDDOT
 2936    00000048 .............         DC32    LIT, msg_wordexists
                  ...          
 2937                           // Nothing created yet so ABORT is correct.
 2938                           //        DC32    ERROR
 2939    00000050 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 2940    00000058 ........              DC32    ABORT
 2941                           
 2942                           CREA1:
 2943                           // Save HERE in CSDP so ERROR can reset DP if this definition fails.
 2944                           // CSDP is reset by SEMIC_CREATE when this definition is completed.
 2945                           // SEMIC_CREATE used in ; CON and VAR to reset CSDP.
 2946                           
 2947                           // This new definitions cstring name has been moved to HERE 
 2948    0000005C .............         DC32    HERE, DUP       // This will become the new CURRENT (this NFA).
                  ...          
 2949    00000064 .............         DC32    CSDP_SV, STORE  // HERE to CSDP to restore in case of error.
                  ...          
 2950                           // Dup HERE-NFA to allot NFAx
 2951    0000006C ........              DC32    DUP
 2952                           // Limit NFA allot to maxwordlen. DOES NOT CHANGE actual count!
 2953                           // If count is larger than MAXWORDLEN behaviour of this def is unpredictable!
 2954    00000070 ........              DC32    CAT
 2955    00000074 ........1F000         DC32    LIT, MAXWORDLEN // ELIMINATED WIDTH AND WIDTH_SV 
                  000          
 2956    0000007C ........              DC32    MIN
 2957    00000080 ........              DC32    ALLOT_PRIM      // HERE (DP) at end of NFA with padding.
 2958                           // Dup HERE-NFA to set count byte, and to be consumed later
 2959                           // for setting CURRENT after previous CURRENT compiled into LFA.
 2960    00000084 ........              DC32    DUP
 2961                           // Make regular (not immediate) NFA count byte
 2962    00000088 ........80000         DC32    LIT, 0x80
                  000          
 2963    00000090 ........              DC32    TOGGLE          // Count Byte = 80+count
 2964                           // HERE is new now. Mark end of NFA for PFIND search
 2965    00000094 ........              DC32    HERE            // DP after allot of NFA
 2966    00000098 ........80000         DC32    LIT,0x80        // Set last character in NFA
                  000          
 2967    000000A0 ........              DC32    TOGGLE          // smudge bit
 2968                           // Bump DP to LFA
 2969    000000A4 .............         DC32    ONE, DP_SV      // MOVE HERE (DP)
                  ...          
 2970    000000AC ........              DC32    PSTORE          // TO LFA
 2971                           // Set LFA
 2972    000000B0 ........              DC32    LATEST          // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
 2973    000000B4 ........              DC32    COMMA           // Compile last words NFA into this link field.
 2974                                                           // DUP'd HERE should be on stack
 2975                           // Have to set CURRENT with last dup's HERE-NFA after LATEST is compiled
 2976    000000B8 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
 2977    000000BC ........              DC32    STORE           // so storing NEWWORD_NFA into CURRENT.
 2978    000000C0 .............         DC32    COMP, DOCON     // Compile DOCON as CFA
                  ...          
 2979    000000C8 .............         DC32    HERE, FOURP     // Compute and
                  ...          
 2980    000000D0 ........              DC32    COMMA           // COMPILE Addr of PFA
 2981                           //      DC32    SMUDGE          // ELIMINATED
 2982                           //      DC32    SEMIC_CREATE    // USED IN CALLERS OF CREATE, NOT HERE!
 2983    000000D4 ........              DC32    SEMIS
 2984                           
 2985                           
 2986                           //      CON CON:        ( n -- )  MODIFIED: and CONSTANT renamed CON
 2987                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2988                           //      A defining word used in the form:
 2989                           //              n CONSTANT CCcc
 2990                           //      to create word CCcc, with its parameter field containing n. When
 2991                           //      CCcc is later executed, it will push the value of n to the stack.
 2992                           
 2993                            SECTION .text : CONST (2)
 2994                           CONSTANT_NFA:
 2995    00000000 88                    DC8     0x88
 2996    00000001 434F4E5354414         DC8     'CONSTAN'
                  E            
 2997    00000008 D4                    DC8     'T'+0x80
 2998    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2999    0000000C ........              DC32    CREATE_NFA
 3000                           CONSTANT:
 3001    00000010 .............         DC32    DOCOL, CON, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3002                           
 3003                           
 3004                            SECTION .text : CONST (2)
 3005                           CON_NFA:
 3006    00000000 83                    DC8     0x83
 3007    00000001 434F                  DC8     'CO'
 3008    00000003 CE                    DC8     'N'+0x80
 3009                            ALIGNROM 2,0xFFFFFFFF
 3010                           //      DC32    CREATE_NFA
 3011    00000004 ........              DC32    CONSTANT_NFA
 3012                           CON:
 3013    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3014    0000000C ........              DC32    CREATE  // Make Header NFA/LFA, DOCON, ADDR->PFA
 3015    00000010 ........FCFFF         DC32    LIT, -4, DP_SV, PSTORE  // back up to ADDR->PFA
                  FFF..........
                  ......       
 3016    00000020 ........              DC32    COMMA                   // Replace with Con value
 3017    00000024 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3018                           //        DC32    DOTDICTSPACE
 3019    00000028 ........              DC32    SEMIS
 3020                           
 3021                           
 3022                           //      VAR VAR:        ( -- ) RENAMED: VARIABLE to VAR
 3023                           //      IF RAMVARSPACE FULL PRINT Error MESSAGE AND Abort.
 3024                           //      A defining word used in the form:
 3025                           //              VARIABLE CCcc
 3026                           //      When VARIABLE is executed, it creates the definition CCcc with its
 3027                           //      with its cell space uninitialized. When CCcc is executed,
 3028                           //      its cell space address is put on the stack. Use with @ or !
 3029                           //      NOTE: VAR's cell space is allocated in ram. See UP and VARALLOT.
 3030                           
 3031                            SECTION .text : CONST (2)
 3032                           VARIABLE_NFA:
 3033    00000000 88                    DC8     0x88
 3034    00000001 5641524941424         DC8     'VARIABL'
                  C            
 3035    00000008 C5                    DC8     'E'+0x80
 3036    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3037    0000000C ........              DC32    CON_NFA
 3038                           VARIABLE:
 3039    00000010 .............         DC32    DOCOL, VAR_, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3040                           
 3041                            SECTION .text : CONST (2)
 3042                           VAR_NFA:
 3043    00000000 83                    DC8     0x83
 3044    00000001 5641                  DC8     'VA'
 3045    00000003 D2                    DC8     'R'+0x80
 3046                            ALIGNROM 2,0xFFFFFFFF
 3047                           //      DC32    CON_NFA
 3048    00000004 ........              DC32    VARIABLE_NFA
 3049                           VAR_:
 3050    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3051    0000000C ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3052    00000010 ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3053    00000020 .............         DC32    COMP, DOVAR     // CFA of VAR's
                  ...          
 3054                           //        DC32    COMP, DOCON     // CFA of VAR's
 3055                           // aligned, INCREMENTS DP REFLECTED by HERE
 3056                           // compile the value \ v --
 3057    00000028 ........              DC32    ONE
 3058    0000002C ........              DC32    VARALLOT        // Do .VS check and return VAR addr.
 3059    00000030 ........              DC32    COMMA           // Compile address of the ram allotment.
 3060    00000034 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3061                           //        DC32    DOTDICTSPACE
 3062                           //        DC32    DOTVARSPACE
 3063    00000038 ........              DC32    SEMIS
 3064                           
 3065                           
 3066                           //      ; SEMI: ( -- ) IMMEDIATE
 3067                           //      Terminate a colon-definition and stop further compilation.
 3068                           //      Compiles the run-time ;S.
 3069                           
 3070                            SECTION .text : CONST (2)
 3071                           SEMI_NFA:
 3072    00000000 C1                    DC8     0x0C1
 3073    00000001 BB                    DC8     ';'+0x80
 3074    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3075    00000004 ........              DC32    VAR_NFA
 3076                           SEMI:
 3077    00000008 ........              DC32    DOCOL
 3078    0000000C ........              DC32    QCSP
 3079    00000010 ........              DC32    COMP
 3080    00000014 ........              DC32    SEMIS
 3081    00000018 ........              DC32    LBRAC
 3082    0000001C ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3083                           //        DC32    DOTDICTSPACE
 3084    00000020 ........              DC32    SEMIS
 3085                           
 3086                           
 3087                           //      : COLON:        ( -- ) IMMEDIATE
 3088                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 3089                           //      Used in the form called a colon-definition:
 3090                           //              : CCcc     ...     //
 3091                           //      Creates a dictionary entry defining CCcc as equivalent to the
 3092                           //      following sequence of Forth word definitions '...' until the next
 3093                           //      ';' or ';CODE'.
 3094                           //      The compiling process is done by the text interpreter as long as
 3095                           //      STATE is non-zero. Other details are that the CONTEXT vocabulary is
 3096                           //      set to the CURRENT vocabulary and that words with the precedence bit
 3097                           //      set (P) are executed rather than being compiled.
 3098                           
 3099                            SECTION .text : CONST (2)
 3100                           COLON_NFA:
 3101    00000000 C1                    DC8     0x0C1
 3102    00000001 BA                    DC8     ':'+0x80
 3103    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3104    00000004 ........              DC32    SEMI_NFA
 3105                           COLON:
 3106    00000008 ........              DC32    DOCOL
 3107                           //      DICTSPACE TEST DONE IN CREATE
 3108    0000000C ........              DC32    QEXEC
 3109    00000010 ........              DC32    SCSP    // Save the stack position in CSP. Compiler security.
 3110    00000014 ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3111    00000018 ........              DC32    RBRAC   // Resume compiliting by setting STATE_SV to 0xC0
 3112    0000001C ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3113    0000002C .............         DC32    COMP, DOCOL     // aligned, INCREMENTS DP REFLECTED by HERE
                  ...          
 3114    00000034 ........              DC32    SEMIS
 3115                           
 3116                           
 3117                           //=============================== WORDCAT ====================================//
 3118                           //NOEXEC HEADERFORWORDCATEGORIES
 3119                           //      WC_CREATE_NFA = CREATE WORDS With: CATEGORY
 3120                           
 3121                            SECTION .text : CONST (2)
 3122                           WC_CREATE_NFA:
 3123    00000000 96                    DC8     0x80+22
 3124    00000001 0D0A                  DC8     0x0D, 0x0A
 3125    00000003 4352454154452         DC8     'CREATE WORDS With:'
                  0574F52445320
                  576974683A   
 3126    00000015 0D8A                  DC8     0x0D, 0x0A+0x80
 3127    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 3128    00000018 ........              DC32    COLON_NFA
 3129                           
 3130                           //      DABS DABS: ( sd=(LSW MSW) -- ud=(LSW MSW) )
 3131                           //      Leave the absolute value ud of a signed double number.
 3132                           
 3133                            SECTION .text : CONST (2)
 3134                           DABS_NFA:
 3135    00000000 84                    DC8     0x84
 3136    00000001 444142                DC8     'DAB'
 3137    00000004 D3                    DC8     'S'+0x80
 3138    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3139    00000008 ........              DC32    WC_CREATE_NFA
 3140                           DABSF:
 3141                           DABS:
 3142    0000000C ........              DC32    DOCOL
 3143    00000010 ........              DC32    DUP
 3144    00000014 ........              DC32    DPM
 3145    00000018 ........              DC32    SEMIS
 3146                           
 3147                           
 3148                           //      DNEGATE DNEGATE: ( d1 -- d<2>=(LSW MSW) ) RENAMED: DMINUS to DNEGATE
 3149                           //      Convert d1 to its double number two's complement d2.
 3150                           
 3151                            SECTION .text : CONST (2)
 3152                           DNEGATE_NFA:
 3153    00000000 87                    DC8     0x87
 3154    00000001 444E45474154          DC8     'DNEGAT'
 3155    00000007 C5                    DC8     'E'+0x80
 3156                            ALIGNROM 2,0xFFFFFFFF
 3157    00000008 ........              DC32    DABS_NFA
 3158                           DNEGATE:
 3159    0000000C ........              DC32    .+5
 3160                            SECTION .text : CODE (2)
 3161                                   POP2t                   // MSW   //POP  BX
 3161.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3161.2                         //#ifndef TOSCT
 3161.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3161.4                         //#endif
 3161.5                         //      ADDS    p, p, #4
 3161.6                                 ENDM
 3162                                   POP2w                   // LSW   //POP  CX
 3162.1  00000004 57F8042B              LDR     w, [p],#4
 3162.2                         //      LDR     w, [p]
 3162.3                         //      ADDS    p, p, #4
 3162.4                                 ENDM
 3163    00000008 C043                  MVNS    t, t            // negate MSW
 3164    0000000A D243                  MVNS    w, w            // negate LSW
 3165    0000000C 521C                  ADDS    w, w, #1        // add 1 to LSW
 3166                                   DPUSH                   //  --  LSW MSW )
 3166                                   PUSHw   // push w to p, post decrement p
 3166.1  0000000E 47F8042D              STR     w, [p, #-4]!
 3166.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3166.3                         //      STR     w, [p]
 3166.4                                 ENDM
 3166                                   TPUSH
 3166                                   PUSHt   // push t to p, pre decrement p
 3166.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3166.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3166.3                         //      STR     t, [p]
 3166.4                                 ENDM
 3166                                   NEXT
 3166.1                         // ARMv7-M Thumb = .+5
 3166.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3166.3                         // ARMv6-M Thumb = .+4
 3166.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3166                                   NEXT1
 3166.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3166.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3166.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3166.4                         // ARMv6-M Thumb = .+4
 3166.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3166.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3166.7                                 ENDM
 3166.8                                 ENDM
 3166.9                                 ENDM
 3166.10                                ENDM
 3167                           
 3168                           
 3169                           //      DPL_SV: ( -- addr of NDPL ) Contains # of digits after . in double number
 3170                           //      A system variable containing the number of digits to the right of the
 3171                           //      decimal on double integer input. It may also be used to hold output
 3172                           //      column location of a decimal point, in system generated formating. The
 3173                           //      default value on single number input is -1.
 3174                            SECTION .text : CONST (2)
 3175                           DPL_NFA:
 3176    00000000 83                    DC8     0x83
 3177    00000001 4450                  DC8     'DP'
 3178    00000003 CC                    DC8     'L'+0x80
 3179                            ALIGNROM 2,0xFFFFFFFF
 3180    00000004 ........              DC32    DNEGATE_NFA
 3181                           DPL_SV:
 3182    00000008 .............         DC32    DOCON, NDPL
                  ...          
 3183                           
 3184                           
 3185                           //      D.R DDOTR:      ( sd=<LSW MSW> n -- ) SIGNED:
 3186                           //      Print a signed double number sd right aligned
 3187                           //      in a field n characters wide.
 3188                           
 3189                            SECTION .text : CONST (2)
 3190                           DDOTR_NFA:
 3191    00000000 83                    DC8     0x83
 3192    00000001 442E                  DC8     'D.'
 3193    00000003 D2                    DC8     'R'+0x80
 3194                            ALIGNROM 2,0xFFFFFFFF
 3195    00000004 ........              DC32    DPL_NFA
 3196                           DDOTR:
 3197    00000008 ........              DC32    DOCOL
 3198    0000000C ........              DC32    TOR     // N CHAR FIELD LEN to r
 3199    00000010 ........              DC32    SWAP    // ( LSW MSW -- MSW LSW )
 3200    00000014 ........              DC32    OVER    // ( MSW LSW -- MSW LSW MSW )
 3201    00000018 ........              DC32    DABS    // ( MSW LSW MSW -- MSW uLSW uMSW )
 3202    0000001C ........              DC32    BDIGS   // <# SET HLD to Pad
 3203    00000020 ........              DC32    DIGS    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3204    00000024 ........              DC32    SIGN    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3205    00000028 ........              DC32    EDIGS   //      #>  ( d=<LSW MSW>  ---  addr  count )
 3206    0000002C ........              DC32    RFROM   // GET THE N CHAR FIELD LEN
 3207    00000030 ........              DC32    OVER    // ( addr count n -- addr count n count )
 3208    00000034 ........              DC32    SUBB    // ( n addr count addr -- n addr count-n )
 3209    00000038 ........              DC32    SPACES  // SPACES  ( n -- )
 3210    0000003C ........              DC32    TYPE    // ( n addr -- )
 3211    00000040 ........              DC32    SEMIS
 3212                           
 3213                           
 3214                           //      D. DDOT:        ( S32-2'S COMPLEMET = (d=<LSW MSW> -- )
 3215                           //      Print a signed double number from a 32 bit two's complement value.
 3216                           //      The high-order 32 bits are most accessable on the stack. Conversion
 3217                           //      is performed according to the current base. A blank follows.
 3218                           
 3219                            SECTION .text : CONST (2)
 3220                           DDOT_NFA:
 3221    00000000 82                    DC8     0x82
 3222    00000001 44                    DC8     'D'
 3223    00000002 AE                    DC8     '.'+0x80
 3224    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3225    00000004 ........              DC32    DDOTR_NFA
 3226                           DDOT:
 3227    00000008 ........              DC32    DOCOL
 3228    0000000C ........              DC32    ZERO
 3229    00000010 ........              DC32    DDOTR
 3230    00000014 ........              DC32    SPACE
 3231    00000018 ........              DC32    SEMIS
 3232                           
 3233                           
 3234                           //      D+ DPLUS:       ( LSW1 MSW1 LSW2 MSW2 --- LSW MSW )  SIGNED:
 3235                           //      Leave the signed double number sum of two signed double numbers.
 3236                           
 3237                            SECTION .text : CONST (2)
 3238                           DPLUS_NFA:
 3239    00000000 82                    DC8     0x82
 3240    00000001 44                    DC8     'D'
 3241    00000002 AB                    DC8     '+'+0x80
 3242    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3243    00000004 ........              DC32    DDOT_NFA
 3244                           DPLUS:
 3245    00000008 ........              DC32    .+5
 3246                            SECTION .text : CODE (2)
 3247                                   POP2t   //    ldr     t, [p],#4       // MS
 3247.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3247.2                         //#ifndef TOSCT
 3247.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3247.4                         //#endif
 3247.5                         //      ADDS    p, p, #4
 3247.6                                 ENDM
 3248                                   POP2n   //    ldr     n, [p],#4       // LS
 3248.1  00000004 57F8041B              LDR     n, [p],#4
 3248.2                         //      LDR     n, [p]
 3248.3                         //      ADDS    p, p, #4
 3248.4                                 ENDM
 3249                                   POP2x   //    ldr     x, [p],#4       // MS
 3249.1  00000008 57F8043B              LDR     x, [p],#4
 3249.2                         //      LDR     x, [p]
 3249.3                         //      ADDS    p, p, #4
 3249.4                                 ENDM
 3250                                   POP2w   //    ldr     w, [p],#4       // LS
 3250.1  0000000C 57F8042B              LDR     w, [p],#4
 3250.2                         //      LDR     w, [p]
 3250.3                         //      ADDS    p, p, #4
 3250.4                                 ENDM
 3251    00000010 5218                  ADDS    w, w, n         // LS sum, set status flags
 3252    00000012 5841                  ADCS    t, t, x         // MS sum + carry
 3253                                   DPUSH                   //  --  LSW MSW )
 3253                                   PUSHw   // push w to p, post decrement p
 3253.1  00000014 47F8042D              STR     w, [p, #-4]!
 3253.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3253.3                         //      STR     w, [p]
 3253.4                                 ENDM
 3253                                   TPUSH
 3253                                   PUSHt   // push t to p, pre decrement p
 3253.1  00000018 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3253.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3253.3                         //      STR     t, [p]
 3253.4                                 ENDM
 3253                                   NEXT
 3253.1                         // ARMv7-M Thumb = .+5
 3253.2  0000001C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3253.3                         // ARMv6-M Thumb = .+4
 3253.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3253                                   NEXT1
 3253.1  00000020 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3253.2  00000024 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3253.3  00000028 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3253.4                         // ARMv6-M Thumb = .+4
 3253.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3253.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3253.7                                 ENDM
 3253.8                                 ENDM
 3253.9                                 ENDM
 3253.10                                ENDM
 3254                           
 3255                           
 3256                           //      S->D STOD:      ( n -- d=<LSW MSW> ) SIGNED:
 3257                           //      Sign extend a single number to form a double number.
 3258                           //      : S->D DUP 0< NEGATE // hi level equivalent
 3259                           
 3260                            SECTION .text : CONST (2)
 3261                           STOD_NFA:
 3262    00000000 84                    DC8     0x84
 3263    00000001 532D3E                DC8     'S->'
 3264    00000004 C4                    DC8     'D'+0x80
 3265    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3266    00000008 ........              DC32    DPLUS_NFA
 3267                           STOD:
 3268    0000000C ........              DC32    .+5
 3269                            SECTION .text : CODE (2)
 3270                                   POP2w                   // POP LSW
 3270.1  00000000 57F8042B              LDR     w, [p],#4
 3270.2                         //      LDR     w, [p]
 3270.3                         //      ADDS    p, p, #4
 3270.4                                 ENDM
 3271    00000004 4040                  EORS    t, t            // Zero MSW
 3272    00000006 1243                  ORRS    w, w, w         // OR LSW
 3273    00000008 00D5                  BPL     STOD1           // LSW is POS
 3274                           
 3275    0000000A 401E                  SUBS     t, t, #1       // LSW is NEG
 3276                           STOD1:
 3277                                   DPUSH                   //  --  LSW MSW )
 3277                                   PUSHw   // push w to p, post decrement p
 3277.1  0000000C 47F8042D              STR     w, [p, #-4]!
 3277.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3277.3                         //      STR     w, [p]
 3277.4                                 ENDM
 3277                                   TPUSH
 3277                                   PUSHt   // push t to p, pre decrement p
 3277.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3277.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3277.3                         //      STR     t, [p]
 3277.4                                 ENDM
 3277                                   NEXT
 3277.1                         // ARMv7-M Thumb = .+5
 3277.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3277.3                         // ARMv6-M Thumb = .+4
 3277.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3277                                   NEXT1
 3277.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3277.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3277.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3277.4                         // ARMv6-M Thumb = .+4
 3277.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3277.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3277.7                                 ENDM
 3277.8                                 ENDM
 3277.9                                 ENDM
 3277.10                                ENDM
 3278                           
 3279                           
 3280                           //      2* TWOSTAR:     ( n -- n*2 ) LSL 1
 3281                           
 3282                            SECTION .text : CONST (2)
 3283                           TWOSTAR_NFA:
 3284    00000000 82                    DC8     0x82
 3285    00000001 32                    DC8     '2'
 3286    00000002 AA                    DC8     '*'+0x80
 3287    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3288    00000004 ........              DC32    STOD_NFA
 3289                           TWOSTAR:
 3290    00000008 ........              DC32    .+5
 3291                            SECTION .text : CODE (2)
 3292                                   POP2t
 3292.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3292.2                         //#ifndef TOSCT
 3292.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3292.4                         //#endif
 3292.5                         //      ADDS    p, p, #4
 3292.6                                 ENDM
 3293    00000004 4000                  LSLS    t, t, #1        //
 3294                                   TPUSH
 3294                                   PUSHt   // push t to p, pre decrement p
 3294.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3294.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3294.3                         //      STR     t, [p]
 3294.4                                 ENDM
 3294                                   NEXT
 3294.1                         // ARMv7-M Thumb = .+5
 3294.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3294.3                         // ARMv6-M Thumb = .+4
 3294.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3294                                   NEXT1
 3294.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3294.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3294.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3294.4                         // ARMv6-M Thumb = .+4
 3294.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3294.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3294.7                                 ENDM
 3294.8                                 ENDM
 3294.9                                 ENDM
 3295                           
 3296                           
 3297                           //      2/ TWOSLASH:    ( n -- n/1 ) ASR 1 (FLOORED)
 3298                           
 3299                            SECTION .text : CONST (2)
 3300                           TWOSLASH_NFA:
 3301    00000000 82                    DC8     0x82
 3302    00000001 32                    DC8     '2'
 3303    00000002 AF                    DC8     '/'+0x80
 3304    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3305    00000004 ........              DC32    TWOSTAR_NFA
 3306                           TWOSLASH:
 3307    00000008 ........              DC32    .+5
 3308                            SECTION .text : CODE (2)
 3309                                   POP2t
 3309.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3309.2                         //#ifndef TOSCT
 3309.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3309.4                         //#endif
 3309.5                         //      ADDS    p, p, #4
 3309.6                                 ENDM
 3310    00000004 4010                  ASRS    t, t, #1        //
 3311                                   TPUSH
 3311                                   PUSHt   // push t to p, pre decrement p
 3311.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3311.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3311.3                         //      STR     t, [p]
 3311.4                                 ENDM
 3311                                   NEXT
 3311.1                         // ARMv7-M Thumb = .+5
 3311.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3311.3                         // ARMv6-M Thumb = .+4
 3311.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3311                                   NEXT1
 3311.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3311.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3311.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3311.4                         // ARMv6-M Thumb = .+4
 3311.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3311.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3311.7                                 ENDM
 3311.8                                 ENDM
 3311.9                                 ENDM
 3312                                   
 3313                           
 3314                           //      1- ONEM:        ( n -- n-1 )
 3315                           
 3316                            SECTION .text : CONST (2)
 3317                           ONEM_NFA:
 3318    00000000 82                    DC8     0x82
 3319    00000001 31                    DC8     '1'
 3320    00000002 AD                    DC8     '-'+0x80
 3321    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3322    00000004 ........              DC32    TWOSLASH_NFA
 3323                           ONEM:
 3324    00000008 ........              DC32    .+5
 3325                            SECTION .text : CODE (2)
 3326                                   POP2t
 3326.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3326.2                         //#ifndef TOSCT
 3326.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3326.4                         //#endif
 3326.5                         //      ADDS    p, p, #4
 3326.6                                 ENDM
 3327    00000004 401E                  SUBS    t, t, #1        //
 3328                                   TPUSH
 3328                                   PUSHt   // push t to p, pre decrement p
 3328.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3328.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3328.3                         //      STR     t, [p]
 3328.4                                 ENDM
 3328                                   NEXT
 3328.1                         // ARMv7-M Thumb = .+5
 3328.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3328.3                         // ARMv6-M Thumb = .+4
 3328.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3328                                   NEXT1
 3328.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3328.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3328.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3328.4                         // ARMv6-M Thumb = .+4
 3328.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3328.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3328.7                                 ENDM
 3328.8                                 ENDM
 3328.9                                 ENDM
 3329                           
 3330                           
 3331                           //      1+ ONEP:        ( n -- n+1 )
 3332                           
 3333                            SECTION .text : CONST (2)
 3334                           ONEP_NFA:
 3335    00000000 82                    DC8     0x82
 3336    00000001 31                    DC8     '1'
 3337    00000002 AB                    DC8     '+'+0x80
 3338    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3339    00000004 ........              DC32    ONEM_NFA
 3340                           ONEP:
 3341    00000008 ........              DC32    .+5
 3342                            SECTION .text : CODE (2)
 3343                                   POP2t
 3343.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3343.2                         //#ifndef TOSCT
 3343.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3343.4                         //#endif
 3343.5                         //      ADDS    p, p, #4
 3343.6                                 ENDM
 3344    00000004 401C                  ADDS    t, t, #1        //
 3345                                   TPUSH
 3345                                   PUSHt   // push t to p, pre decrement p
 3345.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3345.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3345.3                         //      STR     t, [p]
 3345.4                                 ENDM
 3345                                   NEXT
 3345.1                         // ARMv7-M Thumb = .+5
 3345.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3345.3                         // ARMv6-M Thumb = .+4
 3345.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3345                                   NEXT1
 3345.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3345.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3345.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3345.4                         // ARMv6-M Thumb = .+4
 3345.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3345.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3345.7                                 ENDM
 3345.8                                 ENDM
 3345.9                                 ENDM
 3346                           
 3347                           
 3348                           //      2+ TWOP:        ( n -- n+2 )
 3349                           
 3350                            SECTION .text : CONST (2)
 3351                           TWOP_NFA:
 3352    00000000 82                    DC8     0x82
 3353    00000001 32                    DC8     '2'
 3354    00000002 AB                    DC8     '+'+0x80
 3355    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3356    00000004 ........              DC32    ONEP_NFA
 3357                           TWOP:
 3358    00000008 ........              DC32    .+5
 3359                            SECTION .text : CODE (2)
 3360                                   POP2t
 3360.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3360.2                         //#ifndef TOSCT
 3360.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3360.4                         //#endif
 3360.5                         //      ADDS    p, p, #4
 3360.6                                 ENDM
 3361    00000004 801C                  ADDS    t, t, #2
 3362                                   TPUSH
 3362                                   PUSHt   // push t to p, pre decrement p
 3362.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3362.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3362.3                         //      STR     t, [p]
 3362.4                                 ENDM
 3362                                   NEXT
 3362.1                         // ARMv7-M Thumb = .+5
 3362.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3362.3                         // ARMv6-M Thumb = .+4
 3362.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3362                                   NEXT1
 3362.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3362.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3362.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3362.4                         // ARMv6-M Thumb = .+4
 3362.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3362.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3362.7                                 ENDM
 3362.8                                 ENDM
 3362.9                                 ENDM
 3363                           
 3364                           
 3365                           //      4+ FOURP:       ( n -- n+4 )
 3366                           
 3367                            SECTION .text : CONST (2)
 3368                           FOURP_NFA:
 3369    00000000 82                    DC8     0x82
 3370    00000001 34                    DC8     '4'
 3371    00000002 AB                    DC8     '+'+0x80
 3372    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3373    00000004 ........              DC32    TWOP_NFA
 3374                           FOURP:
 3375    00000008 ........              DC32    .+5
 3376                            SECTION .text : CODE (2)
 3377                                   POP2t
 3377.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3377.2                         //#ifndef TOSCT
 3377.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3377.4                         //#endif
 3377.5                         //      ADDS    p, p, #4
 3377.6                                 ENDM
 3378    00000004 001D                  ADDS    t, t, #4
 3379                                   TPUSH
 3379                                   PUSHt   // push t to p, pre decrement p
 3379.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3379.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3379.3                         //      STR     t, [p]
 3379.4                                 ENDM
 3379                                   NEXT
 3379.1                         // ARMv7-M Thumb = .+5
 3379.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3379.3                         // ARMv6-M Thumb = .+4
 3379.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3379                                   NEXT1
 3379.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3379.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3379.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3379.4                         // ARMv6-M Thumb = .+4
 3379.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3379.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3379.7                                 ENDM
 3379.8                                 ENDM
 3379.9                                 ENDM
 3380                           
 3381                           
 3382                           //      4- FOURM:       ( n -- n-4 )
 3383                           
 3384                            SECTION .text : CONST (2)
 3385                           FOURM_NFA:
 3386    00000000 82                    DC8     0x82
 3387    00000001 34                    DC8     '4'
 3388    00000002 AD                    DC8     '-'+0x80
 3389    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3390    00000004 ........              DC32    FOURP_NFA
 3391                           FOURM:
 3392    00000008 ........              DC32    .+5
 3393                            SECTION .text : CODE (2)
 3394                                   POP2t
 3394.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3394.2                         //#ifndef TOSCT
 3394.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3394.4                         //#endif
 3394.5                         //      ADDS    p, p, #4
 3394.6                                 ENDM
 3395    00000004 001F                  SUBS    t, t, #4
 3396                                   TPUSH
 3396                                   PUSHt   // push t to p, pre decrement p
 3396.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3396.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3396.3                         //      STR     t, [p]
 3396.4                                 ENDM
 3396                                   NEXT
 3396.1                         // ARMv7-M Thumb = .+5
 3396.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3396.3                         // ARMv6-M Thumb = .+4
 3396.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3396                                   NEXT1
 3396.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3396.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3396.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3396.4                         // ARMv6-M Thumb = .+4
 3396.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3396.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3396.7                                 ENDM
 3396.8                                 ENDM
 3396.9                                 ENDM
 3397                           
 3398                           
 3399                           //      0 ZERO: ( -- 0 )
 3400                           
 3401                            SECTION .text : CONST (2)
 3402                           ZERO_NFA:
 3403    00000000 81                    DC8     0x81
 3404    00000001 B0                    DC8     '0'+0x80
 3405    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3406    00000004 ........              DC32    FOURM_NFA
 3407                           ZERO:
 3408    00000008 ........00000         DC32    DOCON, 0
                  000          
 3409                           
 3410                           
 3411                           //      1 ONE: ( -- 1 )
 3412                           
 3413                            SECTION .text : CONST (2)
 3414                           ONE_NFA:
 3415    00000000 81                    DC8     0x81
 3416    00000001 B1                    DC8     '1'+0x80
 3417    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3418    00000004 ........              DC32    ZERO_NFA
 3419                           ONE:
 3420    00000008 ........01000         DC32    DOCON, 1
                  000          
 3421                           
 3422                           
 3423                           //      2 TWO: ( -- 2 )
 3424                           
 3425                            SECTION .text : CONST (2)
 3426                           TWO_NFA:
 3427    00000000 81                    DC8     0x81
 3428    00000001 B2                    DC8     '2'+0x80
 3429    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3430    00000004 ........              DC32    ONE_NFA
 3431                           TWO:
 3432    00000008 ........02000         DC32    DOCON, 2
                  000          
 3433                           
 3434                           
 3435                           //      3 THREE: ( -- 3 )
 3436                           
 3437                            SECTION .text : CONST (2)
 3438                           THREE_NFA:
 3439    00000000 81                    DC8     0x81
 3440    00000001 B3                    DC8     '3'+0x80
 3441    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3442    00000004 ........              DC32    TWO_NFA
 3443                           THREE:
 3444    00000008 ........03000         DC32    DOCON, 3
                  000          
 3445                           
 3446                           
 3447                           //      4 FOUR: ( -- 4 )
 3448                           
 3449                            SECTION .text : CONST (2)
 3450                           FOUR_NFA:
 3451    00000000 81                    DC8     0x81
 3452    00000001 B4                    DC8     '4'+0x80
 3453    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3454    00000004 ........              DC32    THREE_NFA
 3455                           FOUR:
 3456    00000008 ........04000         DC32    DOCON, 4
                  000          
 3457                           
 3458                           
 3459                           //      M* MSTAR:       ( n1 n2 -- d=<S32LSW S32MSW> )  SIGNED:
 3460                           //      A mixed magnitude math operation which leaves the double number
 3461                           //      signed product of two signed number.
 3462                           
 3463                            SECTION .text : CONST (2)
 3464                           MSTAR_NFA:
 3465    00000000 82                    DC8     0x82
 3466    00000001 4D                    DC8     'M'
 3467    00000002 AA                    DC8     '*'+0x80
 3468    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3469    00000004 ........              DC32    FOUR_NFA
 3470                           MSTAR:
 3471    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3472    00000010 ........              DC32    XORR
 3473    00000014 ........              DC32    TOR
 3474    00000018 ........              DC32    ABS
 3475    0000001C ........              DC32    SWAP
 3476    00000020 ........              DC32    ABS
 3477    00000024 ........              DC32    USTAR
 3478    00000028 ........              DC32    RFROM
 3479    0000002C ........              DC32    DPM
 3480    00000030 ........              DC32    SEMIS
 3481                           
 3482                           
 3483                           //      M/ MSLASH:      ( sd  n1  ---  d=<s32REM  S32QUO> )
 3484                           //      A mixed magnitude math operator which leaves the signed remainder
 3485                           //      and signed quotient from sd, a double number dividend and divisor n1.
 3486                           //      The remainder takes its sign from the dividend.
 3487                           
 3488                            SECTION .text : CONST (2)
 3489                           MSLASH_NFA:
 3490    00000000 82                    DC8     0x82
 3491    00000001 4D                    DC8     'M'
 3492    00000002 AF                    DC8     '/'+0x80
 3493    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3494    00000004 ........              DC32    MSTAR_NFA
 3495                           MSLASH:
 3496    00000008 ........              DC32    DOCOL
 3497    0000000C ........              DC32    OVER
 3498    00000010 ........              DC32    TOR
 3499    00000014 ........              DC32    TOR
 3500    00000018 ........              DC32    DABS    // ( LSW MSW -- uLSW uMSW )
 3501    0000001C ........              DC32    R
 3502    00000020 ........              DC32    ABS
 3503    00000024 ........              DC32    USLASH
 3504    00000028 ........              DC32    RFROM
 3505    0000002C ........              DC32    R
 3506    00000030 ........              DC32    XORR
 3507    00000034 ........              DC32    PM
 3508    00000038 ........              DC32    SWAP
 3509    0000003C ........              DC32    RFROM
 3510    00000040 ........              DC32    PM
 3511    00000044 ........              DC32    SWAP
 3512    00000048 ........              DC32    SEMIS
 3513                           
 3514                           
 3515                           //      * STAR: ( n1 n2 -- prod=n3 )
 3516                           //      Leave the signed product n3 of two (32bit) signed numbers n1 and n2.
 3517                           
 3518                            SECTION .text : CONST (2)
 3519                           STAR_NFA:
 3520    00000000 81                    DC8     0x81
 3521    00000001 AA                    DC8     '*'+0x80
 3522    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3523    00000004 ........              DC32    MSLASH_NFA
 3524                           STAR:
 3525    00000008 ........              DC32    DOCOL
 3526    0000000C ........              DC32    MSTAR
 3527    00000010 ........              DC32    DROP
 3528    00000014 ........              DC32    SEMIS
 3529                           
 3530                           
 3531                           //      /MOD SLMOD:     ( n1 n2 -- rem quot )   SIGNED:
 3532                           //      Leave the remainder and signed quotient of n1/n2. The remainder has
 3533                           //      the sign of the dividend.
 3534                           
 3535                            SECTION .text : CONST (2)
 3536                           SLMOD_NFA:
 3537    00000000 84                    DC8     0x84
 3538    00000001 2F4D4F                DC8     '/MO'
 3539    00000004 C4                    DC8     'D'+0x80
 3540    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3541    00000008 ........              DC32    STAR_NFA
 3542                           SLMOD:
 3543    0000000C ........              DC32    DOCOL
 3544    00000010 ........              DC32    TOR
 3545    00000014 ........              DC32    STOD
 3546    00000018 ........              DC32    RFROM
 3547    0000001C ........              DC32    MSLASH
 3548    00000020 ........              DC32    SEMIS
 3549                           
 3550                           
 3551                           //      / SLASH:        ( sn1 sn2 -- sn ) SIGNED:
 3552                           //      Leave the signed quotient sn of sn1/sn2.
 3553                           
 3554                            SECTION .text : CONST (2)
 3555                           SLASH_NFA:
 3556    00000000 81                    DC8     0x81
 3557    00000001 AF                    DC8     '/'+0x80
 3558    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3559    00000004 ........              DC32    SLMOD_NFA
 3560                           SLASH:
 3561    00000008 ........              DC32    DOCOL
 3562    0000000C ........              DC32    SLMOD
 3563    00000010 ........              DC32    SWAP
 3564    00000014 ........              DC32    DROP
 3565    00000018 ........              DC32    SEMIS
 3566                           
 3567                           
 3568                           //      MOD MOD:        ( sn1 n2 -- modulo )
 3569                           //      Leave the remainder of sn1/n2, with the same sign as sn1.
 3570                           
 3571                            SECTION .text : CONST (2)
 3572                           MODD_NFA:
 3573    00000000 83                    DC8     0x83
 3574    00000001 4D4F                  DC8     'MO'
 3575    00000003 C4                    DC8     'D'+0x80
 3576                            ALIGNROM 2,0xFFFFFFFF
 3577    00000004 ........              DC32    SLASH_NFA
 3578                           MOD:
 3579    00000008 ........              DC32    DOCOL
 3580    0000000C ........              DC32    SLMOD
 3581    00000010 ........              DC32    DROP
 3582    00000014 ........              DC32    SEMIS
 3583                           
 3584                           
 3585                           //      */MOD SSMOD:    ( n1 n2 n3 -- n4 n5 )
 3586                           //      Leave the quotient n5 and remainder n4 of the operation n1*n2/n3 A
 3587                           //      31 bit intermediate product is used as for */.
 3588                           
 3589                            SECTION .text : CONST (2)
 3590                           SSMOD_NFA:
 3591    00000000 85                    DC8     0x85
 3592    00000001 2A2F4D4F              DC8     '*/MO'
 3593    00000005 C4                    DC8     'D'+0x80
 3594    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 3595    00000008 ........              DC32    MODD_NFA
 3596                           SSMOD:
 3597    0000000C ........              DC32    DOCOL
 3598    00000010 ........              DC32    TOR
 3599    00000014 ........              DC32    MSTAR
 3600    00000018 ........              DC32    RFROM
 3601    0000001C ........              DC32    MSLASH
 3602    00000020 ........              DC32    SEMIS
 3603                           
 3604                           
 3605                           //      */ SSLASH:      ( n1 n2 n3 -- n4 )
 3606                           //      Leave the ratio n4 = n1*n2/n3 where all are signed numbers.
 3607                           //      Retention of an intermediate 31 bit product permits greater accuracy
 3608                           //      than would. be available with the sequence:
 3609                           //              n1  n2  *  n3  /
 3610                           
 3611                            SECTION .text : CONST (2)
 3612                           SSLASH_NFA:
 3613    00000000 82                    DC8     0x82
 3614    00000001 2A                    DC8     '*'
 3615    00000002 AF                    DC8     '/'+0x80
 3616    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3617    00000004 ........              DC32    SSMOD_NFA
 3618                           SSLASH:
 3619    00000008 ........              DC32    DOCOL
 3620    0000000C ........              DC32    SSMOD
 3621    00000010 ........              DC32    SWAP
 3622    00000014 ........              DC32    DROP
 3623    00000018 ........              DC32    SEMIS
 3624                           
 3625                           
 3626                           //      + PLUS: ( n1 n2 -- n3 )
 3627                           //      Add n1 and n2, leaving sum n3
 3628                           
 3629                            SECTION .text : CONST (2)
 3630                           PLUS_NFA:
 3631    00000000 81                    DC8     0x81
 3632    00000001 AB                    DC8     0xAB    // '+' + 0x80
 3633    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3634    00000004 ........              DC32    SSLASH_NFA
 3635                           PLUS:
 3636    00000008 ........              DC32    .+5
 3637                            SECTION .text : CODE (2)
 3638                                   POP2t
 3638.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3638.2                         //#ifndef TOSCT
 3638.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3638.4                         //#endif
 3638.5                         //      ADDS    p, p, #4
 3638.6                                 ENDM
 3639                                   POP2n
 3639.1  00000004 57F8041B              LDR     n, [p],#4
 3639.2                         //      LDR     n, [p]
 3639.3                         //      ADDS    p, p, #4
 3639.4                                 ENDM
 3640    00000008 4018                  ADDS    t, t, n
 3641                                   TPUSH
 3641                                   PUSHt   // push t to p, pre decrement p
 3641.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3641.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3641.3                         //      STR     t, [p]
 3641.4                                 ENDM
 3641                                   NEXT
 3641.1                         // ARMv7-M Thumb = .+5
 3641.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3641.3                         // ARMv6-M Thumb = .+4
 3641.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3641                                   NEXT1
 3641.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3641.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3641.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3641.4                         // ARMv6-M Thumb = .+4
 3641.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3641.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3641.7                                 ENDM
 3641.8                                 ENDM
 3641.9                                 ENDM
 3642                           
 3643                           
 3644                           //      - SUBB: ( n1 n2 -- n3 )
 3645                           //      Leave the difference of n1-n2 as n3.
 3646                           //      1 2 - . -1
 3647                           //      2 1 - .  1
 3648                           
 3649                            SECTION .text : CONST (2)
 3650                           SUB_NFA:
 3651    00000000 81                    DC8     0x81
 3652    00000001 AD                    DC8     '-'+0x80
 3653    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3654    00000004 ........              DC32    PLUS_NFA
 3655                           SUBB:
 3656    00000008 ........              DC32    .+5
 3657                            SECTION .text : CODE (2)
 3658                                   POP2t
 3658.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3658.2                         //#ifndef TOSCT
 3658.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3658.4                         //#endif
 3658.5                         //      ADDS    p, p, #4
 3658.6                                 ENDM
 3659                                   POP2n
 3659.1  00000004 57F8041B              LDR     n, [p],#4
 3659.2                         //      LDR     n, [p]
 3659.3                         //      ADDS    p, p, #4
 3659.4                                 ENDM
 3660    00000008 081A                  SUBS    t, n, t
 3661                                   TPUSH
 3661                                   PUSHt   // push t to p, pre decrement p
 3661.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3661.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3661.3                         //      STR     t, [p]
 3661.4                                 ENDM
 3661                                   NEXT
 3661.1                         // ARMv7-M Thumb = .+5
 3661.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3661.3                         // ARMv6-M Thumb = .+4
 3661.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3661                                   NEXT1
 3661.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3661.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3661.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3661.4                         // ARMv6-M Thumb = .+4
 3661.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3661.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3661.7                                 ENDM
 3661.8                                 ENDM
 3661.9                                 ENDM
 3662                           
 3663                           
 3664                           //      = EQUAL:        (n1 n2 -- f )
 3665                           //      Leave a true flag if n1=n2// otherwise leave a false flag.
 3666                           
 3667                            SECTION .text : CONST (2)
 3668                           EQUAL_NFA:
 3669    00000000 81                    DC8     0x81
 3670    00000001 BD                    DC8     '='+0x80
 3671    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3672    00000004 ........              DC32    SUB_NFA
 3673                           EQUAL:
 3674    00000008 ........              DC32    .+5
 3675                            SECTION .text : CODE (2)
 3676                           #ifdef TRUE_EQU_NEG_ONE
 3677    00000000 4040                  EORS    t, t
 3678                           #endif
 3679                                   POP2t
 3679.1  00000002 57F8040B              LDR     t, [p],#4       // Post-increment
 3679.2                         //#ifndef TOSCT
 3679.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3679.4                         //#endif
 3679.5                         //      ADDS    p, p, #4
 3679.6                                 ENDM
 3680                                   POP2n
 3680.1  00000006 57F8041B              LDR     n, [p],#4
 3680.2                         //      LDR     n, [p]
 3680.3                         //      ADDS    p, p, #4
 3680.4                                 ENDM
 3681    0000000A 401A                  SUBS    t, t, n
 3682    0000000C 09D0                  BEQ     EQUAL_TRUE
 3683    0000000E 4040                  EORS    t, t
 3684                                   TPUSH
 3684                                   PUSHt   // push t to p, pre decrement p
 3684.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3684.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3684.3                         //      STR     t, [p]
 3684.4                                 ENDM
 3684                                   NEXT
 3684.1                         // ARMv7-M Thumb = .+5
 3684.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3684.3                         // ARMv6-M Thumb = .+4
 3684.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3684                                   NEXT1
 3684.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3684.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3684.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3684.4                         // ARMv6-M Thumb = .+4
 3684.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3684.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3684.7                                 ENDM
 3684.8                                 ENDM
 3684.9                                 ENDM
 3685                           
 3686                           EQUAL_TRUE:
 3687                           #ifdef TRUE_EQU_NEG_ONE
 3688    00000022 0138                  SUBS    t, #1 // -1
 3689                           #else
 3691                           #endif
 3692                                   TPUSH
 3692                                   PUSHt   // push t to p, pre decrement p
 3692.1  00000024 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3692.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3692.3                         //      STR     t, [p]
 3692.4                                 ENDM
 3692                                   NEXT
 3692.1                         // ARMv7-M Thumb = .+5
 3692.2  00000028 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3692.3                         // ARMv6-M Thumb = .+4
 3692.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3692                                   NEXT1
 3692.1  0000002C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3692.2  00000030 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3692.3  00000034 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3692.4                         // ARMv6-M Thumb = .+4
 3692.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3692.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3692.7                                 ENDM
 3692.8                                 ENDM
 3692.9                                 ENDM
 3693                           /*
 3694                                   DC32    DOCOL
 3695                                   DC32    SUBB
 3696                                   DC32    ZEQU
 3697                                   DC32    SEMIS
 3698                           */
 3699                           
 3700                           
 3701                           //      < LESSTHAN:     ( n1 n2 -- f ) SIGNED:
 3702                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3703                           //      C0 1 < . 0  -1 C0 < . 1
 3704                           
 3705                            SECTION .text : CONST (2)
 3706                           LESSTHAN_NFA:
 3707    00000000 81                    DC8     0x81
 3708    00000001 BC                    DC8     '<'+0x80
 3709    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3710    00000004 ........              DC32    EQUAL_NFA
 3711                           LESSTHAN:
 3712    00000008 ........              DC32    .+5
 3713                            SECTION .text : CODE (2)
 3714                           #ifdef TRUE_EQU_NEG_ONE
 3715    00000000 4040                  EORS    t, t    // zero t
 3716    00000002 0138                  SUBS    t, #1   // -1
 3717                           #else
 3719                           #endif
 3720                                   POP2n                           // n2
 3720.1  00000004 57F8041B              LDR     n, [p],#4
 3720.2                         //      LDR     n, [p]
 3720.3                         //      ADDS    p, p, #4
 3720.4                                 ENDM
 3721                                   POP2w                           // n1
 3721.1  00000008 57F8042B              LDR     w, [p],#4
 3721.2                         //      LDR     w, [p]
 3721.3                         //      ADDS    p, p, #4
 3721.4                                 ENDM
 3722    0000000C 9142                  CMP     n, w        // n1 < n2
 3723    0000000E 00DC                  BGT     LESS1
 3724                           
 3725    00000010 4040                  EORS    t, t    // zero t =< n
 3726                           LESS1:
 3727                                   TPUSH
 3727                                   PUSHt   // push t to p, pre decrement p
 3727.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3727.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3727.3                         //      STR     t, [p]
 3727.4                                 ENDM
 3727                                   NEXT
 3727.1                         // ARMv7-M Thumb = .+5
 3727.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3727.3                         // ARMv6-M Thumb = .+4
 3727.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3727                                   NEXT1
 3727.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3727.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3727.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3727.4                         // ARMv6-M Thumb = .+4
 3727.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3727.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3727.7                                 ENDM
 3727.8                                 ENDM
 3727.9                                 ENDM
 3728                           
 3729                           
 3730                           //      U< ULESSTHAN:   ( n1 n2 -- f )  UNSIGNED:
 3731                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3732                           //      -1 -2 U< . 0  -1 2 U< . 0  1 2 U< . 1
 3733                           
 3734                            SECTION .text : CONST (2)
 3735                           ULESSTHAN_NFA:
 3736    00000000 82                    DC8     0x82
 3737    00000001 55                    DC8     'U'
 3738    00000002 BC                    DC8     '<'+0x80
 3739    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3740    00000004 ........              DC32    LESSTHAN_NFA
 3741                           ULESSTHAN:
 3742    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3743    00000010 .............         DC32    XORR, ZLESS
                  ...          
 3744    00000018 ........              DC32    ZBRAN
 3745    0000001C 18000000              DC32    ULES1-. //IF
 3746                           
 3747    00000020 .............         DC32    DROP, ZLESS
                  ...          
 3748    00000028 ........              DC32    ZEQU
 3749    0000002C ........              DC32    BRAN
 3750    00000030 0C000000              DC32    ULES2-.
 3751                           
 3752                           ULES1:
 3753    00000034 .............         DC32    SUBB,ZLESS      //ELSE
                  ...          
 3754                           
 3755                           ULES2:
 3756    0000003C ........              DC32    SEMIS           //endif
 3757                           
 3758                           
 3759                           //      > GREATERTHAN:  ( n1 n2 --  f ) SIGNED: L0
 3760                           //      Leave a true flag if n1 is greater than n2 otherwise a false flag.
 3761                           //      -1 1 > . 0  1 -1 > . 1
 3762                           
 3763                            SECTION .text : CONST (2)
 3764                           GREATERTHAN_NFA:
 3765    00000000 81                    DC8     0x81
 3766    00000001 BE                    DC8     '>'+0x80
 3767    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3768    00000004 ........              DC32    ULESSTHAN_NFA
 3769                           GREATERTHAN:
 3770    00000008 ........              DC32    DOCOL
 3771    0000000C ........              DC32    SWAP
 3772    00000010 ........              DC32    LESSTHAN
 3773    00000014 ........              DC32    SEMIS
 3774                           
 3775                           
 3776                           //      0= ZEQU:        ( n -- f )
 3777                           //      Leave a true flag is the number is equal to zero, otherwise leave a
 3778                           //      false flag. CHANGED Code dependent on true flag being 1 FOR -1 TRUE
 3779                           
 3780                            SECTION .text : CONST (2)
 3781                           ZEQU_NFA:
 3782    00000000 82                    DC8     0x82
 3783    00000001 30                    DC8     '0'
 3784    00000002 BD                    DC8     '='+0x80
 3785    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3786    00000004 ........              DC32    GREATERTHAN_NFA
 3787                           ZEQU:
 3788    00000008 ........              DC32    .+5
 3789                            SECTION .text : CODE (2)
 3790    00000000 4040                  EORS    t, t
 3791                                   POP2n
 3791.1  00000002 57F8041B              LDR     n, [p],#4
 3791.2                         //      LDR     n, [p]
 3791.3                         //      ADDS    p, p, #4
 3791.4                                 ENDM
 3792    00000006 0029                  CMP     n, #0
 3793    00000008 00D1                  BNE     ZEQU_ZERO
 3794                           
 3795                           #ifdef TRUE_EQU_NEG_ONE
 3796    0000000A 401E                  SUBS    t, t, #1
 3797                           #else
 3799                           #endif
 3800                           
 3801                           ZEQU_ZERO:
 3802                                   TPUSH
 3802                                   PUSHt   // push t to p, pre decrement p
 3802.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3802.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3802.3                         //      STR     t, [p]
 3802.4                                 ENDM
 3802                                   NEXT
 3802.1                         // ARMv7-M Thumb = .+5
 3802.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3802.3                         // ARMv6-M Thumb = .+4
 3802.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3802                                   NEXT1
 3802.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3802.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3802.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3802.4                         // ARMv6-M Thumb = .+4
 3802.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3802.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3802.7                                 ENDM
 3802.8                                 ENDM
 3802.9                                 ENDM
 3803                           
 3804                           
 3805                           //      0< ZLESS:       ( n -- f )
 3806                           //      Leave a true flag if the number is less than zero (negative),
 3807                           //      otherwise leave a false flag.
 3808                           
 3809                            SECTION .text : CONST (2)
 3810                           ZLESS_NFA:
 3811    00000000 82                    DC8     0x82
 3812    00000001 30                    DC8     '0'
 3813    00000002 BC                    DC8     '<'+0x80
 3814    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3815    00000004 ........              DC32    ZEQU_NFA
 3816                           ZLESS:
 3817    00000008 ........              DC32    .+5
 3818                            SECTION .text : CODE (2)
 3819                           #ifdef TOSCT    // REPLACING t SO THIS IS FASTER THAN POP2n
 3822                           #else
 3823                                   POP2n
 3823.1  00000000 57F8041B              LDR     n, [p],#4
 3823.2                         //      LDR     n, [p]
 3823.3                         //      ADDS    p, p, #4
 3823.4                                 ENDM
 3824                           #endif
 3825                           #ifdef TRUE_EQU_NEG_ONE
 3826    00000004 4040                  EORS    t, t
 3827    00000006 0138                  SUBS    t, #1   // TRUE -1
 3828                           #else
 3830                           #endif
 3831    00000008 0943                  ORRS    n, n, n // SET FLAGS
 3832    0000000A 00D4                  BMI     ZLESS1  // JS   ZLESS1
 3833                           
 3834    0000000C 4040                  EORS    t, t    // FALSE
 3835                           ZLESS1:
 3836                                   TPUSH
 3836                                   PUSHt   // push t to p, pre decrement p
 3836.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3836.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3836.3                         //      STR     t, [p]
 3836.4                                 ENDM
 3836                                   NEXT
 3836.1                         // ARMv7-M Thumb = .+5
 3836.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3836.3                         // ARMv6-M Thumb = .+4
 3836.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3836                                   NEXT1
 3836.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3836.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3836.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3836.4                         // ARMv6-M Thumb = .+4
 3836.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3836.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3836.7                                 ENDM
 3836.8                                 ENDM
 3836.9                                 ENDM
 3837                           
 3838                           
 3839                           //      BIN BIN:        ( -- )
 3840                           //      Set the numeric conversion base to TWO (bianry).
 3841                           
 3842                            SECTION .text : CONST (2)
 3843                           BIN_NFA:
 3844    00000000 83                    DC8     0x83
 3845    00000001 4249                  DC8     'BI'
 3846    00000003 CE                    DC8     'N'+0x80
 3847                            ALIGNROM 2,0xFFFFFFFF
 3848    00000004 ........              DC32    ZLESS_NFA
 3849                           BIN:
 3850    00000008 ........              DC32    DOCOL
 3851    0000000C ........02000         DC32    STRVA, 2, NBASE
                  000........  
 3852    00000018 ........              DC32    SEMIS
 3853                           
 3854                           
 3855                           //      HEX HEX:        ( -- )
 3856                           //      Set the numeric conversion base to sixteen (hexadecimal).
 3857                           
 3858                            SECTION .text : CONST (2)
 3859                           HEX_NFA:
 3860    00000000 83                    DC8     0x83
 3861    00000001 4845                  DC8     'HE'
 3862    00000003 D8                    DC8     'X'+0x80
 3863                            ALIGNROM 2,0xFFFFFFFF
 3864    00000004 ........              DC32    BIN_NFA
 3865                           HEX:
 3866    00000008 ........              DC32    DOCOL
 3867    0000000C ........10000         DC32    STRVA, 16, NBASE
                  000........  
 3868    00000018 ........              DC32    SEMIS
 3869                           
 3870                           
 3871                           //      DECIMAL DECIMAL:        ( -- )
 3872                           //      Set the numeric conversion base to TEN (decimal).
 3873                           //      DEC IS A NUMBER!
 3874                           
 3875                            SECTION .text : CONST (2)
 3876                           DECIMAL_NFA:
 3877    00000000 87                    DC8     0x87
 3878    00000001 444543494D41          DC8     'DECIMA'
 3879    00000007 CC                    DC8     'L'+0x80
 3880                            ALIGNROM 2,0xFFFFFFFF
 3881    00000008 ........              DC32    HEX_NFA
 3882                           DECIMAL:
 3883    0000000C ........              DC32    DOCOL
 3884    00000010 ........0A000         DC32    STRVA, 10, NBASE
                  000........  
 3885    0000001C ........              DC32    SEMIS
 3886                           
 3887                           
 3888                           //      NEGATE NEGATE: ( n1 -- n2 ) RENAMED: MINUS to NEGATE
 3889                           //      Leave the two's complement of a number.
 3890                           
 3891                            SECTION .text : CONST (2)
 3892                           NEGATE_NFA:
 3893    00000000 86                    DC8     0x86
 3894    00000001 4E45474154            DC8     'NEGAT'
 3895    00000006 C5                    DC8     'E'+0x80
 3896    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 3897    00000008 ........              DC32    DECIMAL_NFA
 3898                           NEGATE:
 3899    0000000C ........              DC32    .+5
 3900                            SECTION .text : CODE (2)
 3901                                   POP2t                   // MVN YES
 3901.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3901.2                         //#ifndef TOSCT
 3901.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3901.4                         //#endif
 3901.5                         //      ADDS    p, p, #4
 3901.6                                 ENDM
 3902    00000004 C043                  MVNS     t, t           // 1's compliment
 3903    00000006 401C                  ADDS     t, t, #1       // 2's compliment
 3904                                   TPUSH
 3904                                   PUSHt   // push t to p, pre decrement p
 3904.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3904.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3904.3                         //      STR     t, [p]
 3904.4                                 ENDM
 3904                                   NEXT
 3904.1                         // ARMv7-M Thumb = .+5
 3904.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3904.3                         // ARMv6-M Thumb = .+4
 3904.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3904                                   NEXT1
 3904.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3904.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3904.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3904.4                         // ARMv6-M Thumb = .+4
 3904.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3904.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3904.7                                 ENDM
 3904.8                                 ENDM
 3904.9                                 ENDM
 3905                           
 3906                           
 3907                           //      ABS ABS:        ( n -- ub )
 3908                           //      Leave the absolute value of n as un.
 3909                           
 3910                            SECTION .text : CONST (2)
 3911                           ABS1_NFA:
 3912    00000000 83                    DC8     0x83
 3913    00000001 4142                  DC8     'AB'
 3914    00000003 D3                    DC8     'S'+0x80
 3915                            ALIGNROM 2,0xFFFFFFFF
 3916    00000004 ........              DC32    NEGATE_NFA
 3917                           ABS:
 3918    00000008 ........              DC32    DOCOL
 3919    0000000C ........              DC32    DUP
 3920    00000010 ........              DC32    PM
 3921    00000014 ........              DC32    SEMIS
 3922                           
 3923                           
 3924                           //      MIN MIN:        ( n1 n2 -- min )
 3925                           //      Leave the smaller of two numbers.
 3926                           
 3927                            SECTION .text : CONST (2)
 3928                           MIN_NFA:
 3929    00000000 83                    DC8     0x83
 3930    00000001 4D49                  DC8     'MI'
 3931    00000003 CE                    DC8     'N'+0x80
 3932                            ALIGNROM 2,0xFFFFFFFF
 3933    00000004 ........              DC32    ABS1_NFA
 3934                           MIN:
 3935    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3936    00000010 ........              DC32    GREATERTHAN
 3937    00000014 ........              DC32    ZBRAN   //IF
 3938    00000018 08000000              DC32     MIN1-.
 3939                           
 3940    0000001C ........              DC32    SWAP    //endif
 3941                           MIN1:
 3942    00000020 ........              DC32    DROP
 3943    00000024 ........              DC32    SEMIS
 3944                           
 3945                           
 3946                           //      MAX MAX:        ( n1 n2 -- max )
 3947                           //      Leave the greater of two numbers.
 3948                           
 3949                            SECTION .text : CONST (2)
 3950                           MAX_NFA:
 3951    00000000 83                    DC8     0x83
 3952    00000001 4D41                  DC8     'MA'
 3953    00000003 D8                    DC8     'X'+0x80
 3954                            ALIGNROM 2,0xFFFFFFFF
 3955    00000004 ........              DC32    MIN_NFA
 3956                           MAX:
 3957    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3958    00000010 ........              DC32    LESSTHAN
 3959    00000014 ........              DC32    ZBRAN   //IF
 3960    00000018 08000000              DC32     MAX1-.
 3961                           
 3962    0000001C ........              DC32    SWAP    //endif
 3963                           MAX1:
 3964    00000020 ........              DC32    DROP
 3965    00000024 ........              DC32    SEMIS
 3966                           
 3967                           
 3968                           //      AND ANDD:       ( n1 n2 -- n2 )
 3969                           //      Leave the bitwise logical and of n1 and n2 as n3.
 3970                           
 3971                            SECTION .text : CONST (2)
 3972                           ANDD_NFA:
 3973    00000000 83                    DC8     0x83
 3974    00000001 414E                  DC8     'AN'
 3975    00000003 C4                    DC8     'D'+0x80
 3976                            ALIGNROM 2,0xFFFFFFFF
 3977    00000004 ........              DC32    MAX_NFA
 3978                           ANDD:
 3979    00000008 ........              DC32    .+5
 3980                            SECTION .text : CODE (2)
 3981                                   POP2t
 3981.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3981.2                         //#ifndef TOSCT
 3981.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3981.4                         //#endif
 3981.5                         //      ADDS    p, p, #4
 3981.6                                 ENDM
 3982                                   POP2n
 3982.1  00000004 57F8041B              LDR     n, [p],#4
 3982.2                         //      LDR     n, [p]
 3982.3                         //      ADDS    p, p, #4
 3982.4                                 ENDM
 3983    00000008 0840                  ANDS     t, t, n
 3984                                   TPUSH
 3984                                   PUSHt   // push t to p, pre decrement p
 3984.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3984.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3984.3                         //      STR     t, [p]
 3984.4                                 ENDM
 3984                                   NEXT
 3984.1                         // ARMv7-M Thumb = .+5
 3984.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3984.3                         // ARMv6-M Thumb = .+4
 3984.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3984                                   NEXT1
 3984.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3984.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3984.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3984.4                         // ARMv6-M Thumb = .+4
 3984.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3984.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3984.7                                 ENDM
 3984.8                                 ENDM
 3984.9                                 ENDM
 3985                           
 3986                           
 3987                           //      OR OR:  ( n1 n2 -- n3 )
 3988                           //      Leave the bit-wise logical or of n1 and n2 as n3.
 3989                           
 3990                            SECTION .text : CONST (2)
 3991                           OR_NFA:
 3992    00000000 82                    DC8     0x82
 3993    00000001 4F                    DC8     'O'
 3994    00000002 D2                    DC8     'R'+0x80
 3995    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3996    00000004 ........              DC32    ANDD_NFA
 3997                           OR:
 3998    00000008 ........              DC32    .+5
 3999                            SECTION .text : CODE (2)
 4000                                   POP2t
 4000.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4000.2                         //#ifndef TOSCT
 4000.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4000.4                         //#endif
 4000.5                         //      ADDS    p, p, #4
 4000.6                                 ENDM
 4001                                   POP2n
 4001.1  00000004 57F8041B              LDR     n, [p],#4
 4001.2                         //      LDR     n, [p]
 4001.3                         //      ADDS    p, p, #4
 4001.4                                 ENDM
 4002    00000008 0843                  ORRS     t, t, n
 4003                                   TPUSH
 4003                                   PUSHt   // push t to p, pre decrement p
 4003.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4003.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4003.3                         //      STR     t, [p]
 4003.4                                 ENDM
 4003                                   NEXT
 4003.1                         // ARMv7-M Thumb = .+5
 4003.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4003.3                         // ARMv6-M Thumb = .+4
 4003.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4003                                   NEXT1
 4003.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4003.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4003.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4003.4                         // ARMv6-M Thumb = .+4
 4003.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4003.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4003.7                                 ENDM
 4003.8                                 ENDM
 4003.9                                 ENDM
 4004                           
 4005                           
 4006                           //      NOT NOT: ( nl -- n2 )
 4007                           //      Leave the bitwise logical not of n1 as n2
 4008                           
 4009                            SECTION .text : CONST (2)
 4010                           NOT_NFA:
 4011    00000000 83                    DC8     0x83
 4012    00000001 4E4F                  DC8     'NO'
 4013    00000003 D4                    DC8     'T'+0x80
 4014                            ALIGNROM 2,0xFFFFFFFF
 4015    00000004 ........              DC32    OR_NFA
 4016                           NOT:
 4017    00000008 ........              DC32    .+5
 4018                            SECTION .text : CODE (2)
 4019                                   POP2t
 4019.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4019.2                         //#ifndef TOSCT
 4019.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4019.4                         //#endif
 4019.5                         //      ADDS    p, p, #4
 4019.6                                 ENDM
 4020    00000004 C043                  MVNS            t, t    // 1's compliment
 4021                                   TPUSH
 4021                                   PUSHt   // push t to p, pre decrement p
 4021.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4021.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4021.3                         //      STR     t, [p]
 4021.4                                 ENDM
 4021                                   NEXT
 4021.1                         // ARMv7-M Thumb = .+5
 4021.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4021.3                         // ARMv6-M Thumb = .+4
 4021.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4021                                   NEXT1
 4021.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4021.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4021.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4021.4                         // ARMv6-M Thumb = .+4
 4021.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4021.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4021.7                                 ENDM
 4021.8                                 ENDM
 4021.9                                 ENDM
 4022                           
 4023                           
 4024                           //      XORR XOR:       ( nl n2 -- n3 )
 4025                           //      Leave the bitwise logical exclusive or n1 and n2 as n3
 4026                           
 4027                            SECTION .text : CONST (2)
 4028                           XORR_NFA:
 4029    00000000 83                    DC8     0x83
 4030    00000001 584F                  DC8     'XO'
 4031    00000003 D2                    DC8     'R'+0x80
 4032                            ALIGNROM 2,0xFFFFFFFF
 4033    00000004 ........              DC32    NOT_NFA
 4034                           XORR:
 4035    00000008 ........              DC32    .+5
 4036                            SECTION .text : CODE (2)
 4037                                   POP2t
 4037.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4037.2                         //#ifndef TOSCT
 4037.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4037.4                         //#endif
 4037.5                         //      ADDS    p, p, #4
 4037.6                                 ENDM
 4038                                   POP2n
 4038.1  00000004 57F8041B              LDR     n, [p],#4
 4038.2                         //      LDR     n, [p]
 4038.3                         //      ADDS    p, p, #4
 4038.4                                 ENDM
 4039    00000008 4840                  EORS     t, t, n
 4040                                   TPUSH
 4040                                   PUSHt   // push t to p, pre decrement p
 4040.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4040.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4040.3                         //      STR     t, [p]
 4040.4                                 ENDM
 4040                                   NEXT
 4040.1                         // ARMv7-M Thumb = .+5
 4040.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4040.3                         // ARMv6-M Thumb = .+4
 4040.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4040                                   NEXT1
 4040.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4040.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4040.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4040.4                         // ARMv6-M Thumb = .+4
 4040.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4040.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4040.7                                 ENDM
 4040.8                                 ENDM
 4040.9                                 ENDM
 4041                           
 4042                           //      SXTH SXH:       ( nl -- n3 )
 4043                           //      Sign extend HALFWORD on the stack
 4044                           
 4045                            SECTION .text : CONST (2)
 4046                           SXTH_NFA:
 4047    00000000 84                    DC8     0x84
 4048    00000001 535854                DC8     'SXT'
 4049    00000004 C8                    DC8     'H'+0x80
 4050    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4051    00000008 ........              DC32    XORR_NFA
 4052                           SXH:
 4053    0000000C ........              DC32    .+5
 4054                            SECTION .text : CODE (2)
 4055                                   POP2t
 4055.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4055.2                         //#ifndef TOSCT
 4055.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4055.4                         //#endif
 4055.5                         //      ADDS    p, p, #4
 4055.6                                 ENDM
 4056    00000004 00B2                  SXTH     t, t
 4057                                   TPUSH
 4057                                   PUSHt   // push t to p, pre decrement p
 4057.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4057.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4057.3                         //      STR     t, [p]
 4057.4                                 ENDM
 4057                                   NEXT
 4057.1                         // ARMv7-M Thumb = .+5
 4057.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4057.3                         // ARMv6-M Thumb = .+4
 4057.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4057                                   NEXT1
 4057.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4057.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4057.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4057.4                         // ARMv6-M Thumb = .+4
 4057.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4057.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4057.7                                 ENDM
 4057.8                                 ENDM
 4057.9                                 ENDM
 4058                           
 4059                           
 4060                           //      SXTB SXB:       ( nl -- n3 )
 4061                           //      Signe extend byte in the word on the stack
 4062                           
 4063                            SECTION .text : CONST (2)
 4064                           SXTB_NFA:
 4065    00000000 84                    DC8     0x84
 4066    00000001 535854                DC8     'SXT'
 4067    00000004 C2                    DC8     'B'+0x80
 4068    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4069    00000008 ........              DC32    SXTH_NFA
 4070                           SXB:
 4071    0000000C ........              DC32    .+5
 4072                            SECTION .text : CODE (2)
 4073                                   POP2t
 4073.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4073.2                         //#ifndef TOSCT
 4073.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4073.4                         //#endif
 4073.5                         //      ADDS    p, p, #4
 4073.6                                 ENDM
 4074    00000004 40B2                  SXTB     t, t
 4075                                   TPUSH
 4075                                   PUSHt   // push t to p, pre decrement p
 4075.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4075.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4075.3                         //      STR     t, [p]
 4075.4                                 ENDM
 4075                                   NEXT
 4075.1                         // ARMv7-M Thumb = .+5
 4075.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4075.3                         // ARMv6-M Thumb = .+4
 4075.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4075                                   NEXT1
 4075.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4075.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4075.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4075.4                         // ARMv6-M Thumb = .+4
 4075.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4075.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4075.7                                 ENDM
 4075.8                                 ENDM
 4075.9                                 ENDM
 4076                           
 4077                           
 4078                           //      REVW REVW:      ( n -- n )
 4079                           //      Reverse bytes in n.
 4080                           
 4081                            SECTION .text : CONST (2)
 4082                           REVW_NFA:
 4083    00000000 84                    DC8     0x84
 4084    00000001 524556                DC8     'REV'
 4085    00000004 D7                    DC8     'W'+0x80
 4086    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4087    00000008 ........              DC32    SXTB_NFA
 4088                           REVW:
 4089    0000000C ........              DC32    .+5
 4090                            SECTION .text : CODE (2)
 4091                                   POP2t
 4091.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4091.2                         //#ifndef TOSCT
 4091.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4091.4                         //#endif
 4091.5                         //      ADDS    p, p, #4
 4091.6                                 ENDM
 4092    00000004 00BA                  REV     t, t
 4093                                   TPUSH
 4093                                   PUSHt   // push t to p, pre decrement p
 4093.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4093.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4093.3                         //      STR     t, [p]
 4093.4                                 ENDM
 4093                                   NEXT
 4093.1                         // ARMv7-M Thumb = .+5
 4093.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4093.3                         // ARMv6-M Thumb = .+4
 4093.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4093                                   NEXT1
 4093.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4093.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4093.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4093.4                         // ARMv6-M Thumb = .+4
 4093.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4093.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4093.7                                 ENDM
 4093.8                                 ENDM
 4093.9                                 ENDM
 4094                           
 4095                           
 4096                           //      ASR ASR:   ( sn count -- sn' )  
 4097                           //      Shift sn (sign-extended) right by count.
 4098                           //      Valid count values are 0 to 31.
 4099                           
 4100                            SECTION .text : CONST (2)
 4101                           ASR_NFA:
 4102    00000000 83                    DC8     0x83
 4103    00000001 4153                  DC8     'AS'
 4104    00000003 D2                    DC8     'R'+0x80
 4105                            ALIGNROM 2,0xFFFFFFFF
 4106    00000004 ........              DC32    REVW_NFA
 4107                           ASR:
 4108    00000008 ........              DC32    .+5
 4109                            SECTION .text : CODE (2)
 4110                                   POP2w           ; shift count
 4110.1  00000000 57F8042B              LDR     w, [p],#4
 4110.2                         //      LDR     w, [p]
 4110.3                         //      ADDS    p, p, #4
 4110.4                                 ENDM
 4111                                   POP2t           ; original data
 4111.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4111.2                         //#ifndef TOSCT
 4111.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4111.4                         //#endif
 4111.5                         //      ADDS    p, p, #4
 4111.6                                 ENDM
 4112    00000008 1041                  ASRS    t, t, w
 4113                                   TPUSH           ; shifted data
 4113                                   PUSHt   // push t to p, pre decrement p
 4113.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4113.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4113.3                         //      STR     t, [p]
 4113.4                                 ENDM
 4113                                   NEXT
 4113.1                         // ARMv7-M Thumb = .+5
 4113.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4113.3                         // ARMv6-M Thumb = .+4
 4113.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4113                                   NEXT1
 4113.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4113.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4113.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4113.4                         // ARMv6-M Thumb = .+4
 4113.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4113.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4113.7                                 ENDM
 4113.8                                 ENDM
 4113.9                                 ENDM
 4114                           
 4115                           
 4116                           //      LSR LSR:   ( n count -- n' )
 4117                           //      Logical (zero-extended) shift right by count.
 4118                           //      Valid count values are 0 to 31.
 4119                           
 4120                            SECTION .text : CONST (2)
 4121                           LSR_NFA:
 4122    00000000 83                    DC8     0x83
 4123    00000001 4C53                  DC8     'LS'
 4124    00000003 D2                    DC8     'R'+0x80
 4125                            ALIGNROM 2,0xFFFFFFFF
 4126    00000004 ........              DC32    ASR_NFA
 4127                           LSR:
 4128    00000008 ........              DC32    .+5
 4129                            SECTION .text : CODE (2)
 4130                                   POP2w           ; shift count
 4130.1  00000000 57F8042B              LDR     w, [p],#4
 4130.2                         //      LDR     w, [p]
 4130.3                         //      ADDS    p, p, #4
 4130.4                                 ENDM
 4131                                   POP2t           ; original data
 4131.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4131.2                         //#ifndef TOSCT
 4131.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4131.4                         //#endif
 4131.5                         //      ADDS    p, p, #4
 4131.6                                 ENDM
 4132    00000008 D040                  LSRS    t, t, w
 4133                                   TPUSH           ; shifted data
 4133                                   PUSHt   // push t to p, pre decrement p
 4133.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4133.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4133.3                         //      STR     t, [p]
 4133.4                                 ENDM
 4133                                   NEXT
 4133.1                         // ARMv7-M Thumb = .+5
 4133.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4133.3                         // ARMv6-M Thumb = .+4
 4133.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4133                                   NEXT1
 4133.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4133.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4133.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4133.4                         // ARMv6-M Thumb = .+4
 4133.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4133.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4133.7                                 ENDM
 4133.8                                 ENDM
 4133.9                                 ENDM
 4134                           
 4135                           
 4136                           //      LSL LSL:   ( n count -- n' )
 4137                           //      Logical (zero-extended) shift left by count.
 4138                           //      Valid count values are 0 to 31.
 4139                           
 4140                            SECTION .text : CONST (2)
 4141                           LSL_NFA:
 4142    00000000 83                    DC8     0x83
 4143    00000001 4C53                  DC8     'LS'
 4144    00000003 CC                    DC8     'L'+0x80
 4145                            ALIGNROM 2,0xFFFFFFFF
 4146    00000004 ........              DC32    LSR_NFA
 4147                           LSL:
 4148    00000008 ........              DC32    .+5
 4149                            SECTION .text : CODE (2)
 4150                                   POP2w           ; shift count
 4150.1  00000000 57F8042B              LDR     w, [p],#4
 4150.2                         //      LDR     w, [p]
 4150.3                         //      ADDS    p, p, #4
 4150.4                                 ENDM
 4151                                   POP2t           ; original data
 4151.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4151.2                         //#ifndef TOSCT
 4151.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4151.4                         //#endif
 4151.5                         //      ADDS    p, p, #4
 4151.6                                 ENDM
 4152    00000008 9040                  LSLS    t, t, w
 4153                                   TPUSH           ; shifted data---
 4153                                   PUSHt   // push t to p, pre decrement p
 4153.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4153.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4153.3                         //      STR     t, [p]
 4153.4                                 ENDM
 4153                                   NEXT
 4153.1                         // ARMv7-M Thumb = .+5
 4153.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4153.3                         // ARMv6-M Thumb = .+4
 4153.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4153                                   NEXT1
 4153.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4153.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4153.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4153.4                         // ARMv6-M Thumb = .+4
 4153.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4153.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4153.7                                 ENDM
 4153.8                                 ENDM
 4153.9                                 ENDM
 4154                           
 4155                           
 4156                           //      .R DOTR:        ( sn1 n2 -- ) SIGNED:
 4157                           //      Print the signed number sn1 right aligned in a field whose width is n2.
 4158                           //      No following blank is printed.
 4159                           
 4160                            SECTION .text : CONST (2)
 4161                           DOTR_NFA:
 4162    00000000 82                    DC8     0x82
 4163    00000001 2E                    DC8     '.'
 4164    00000002 D2                    DC8     'R'+0x80
 4165    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4166    00000004 ........              DC32    LSL_NFA
 4167                           DOTR:
 4168    00000008 ........              DC32    DOCOL
 4169    0000000C ........              DC32    TOR
 4170    00000010 ........              DC32    STOD
 4171    00000014 ........              DC32    RFROM
 4172    00000018 ........              DC32    DDOTR
 4173    0000001C ........              DC32    SEMIS
 4174                           
 4175                           
 4176                           //      .RU DOTRU:      ( n1 n2 -- ) UNSIGNED:
 4177                           //      Print the unsigned number n1 right aligned in a field whose width is n2.
 4178                           //      No following blank is printed.
 4179                           
 4180                            SECTION .text : CONST (2)
 4181                           DOTRU_NFA:
 4182    00000000 83                    DC8     0x83
 4183    00000001 2E52                  DC8     '.R'
 4184    00000003 D5                    DC8     'U'+0x80
 4185                            ALIGNROM 2,0xFFFFFFFF
 4186    00000004 ........              DC32    DOTR_NFA
 4187                           DOTRU:
 4188    00000008 ........              DC32    DOCOL
 4189    0000000C ........              DC32    TOR
 4190    00000010 ........              DC32    ZERO
 4191    00000014 .............         DC32    BDIGS, DIGS, EDIGS
                  ...........  
 4192    00000020 .............         DC32    DUP, RFROM
                  ...          
 4193    00000028 .............         DC32    SWAP, SUBB, SPACES, TYPE
                  .............
                  ......       
 4194                           #ifdef IO2TP
 4197                           #endif
 4198    00000038 ........              DC32    SEMIS
 4199                           
 4200                           
 4201                           //      U. UDOT:        ( n -- ) USIGNED DOT
 4202                           
 4203                            SECTION .text : CONST (2)
 4204                           UDOT_NFA:
 4205    00000000 82                    DC8     0x82
 4206    00000001 55                    DC8     'U'
 4207    00000002 AE                    DC8     '.'+0x80
 4208    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4209    00000004 ........              DC32    DOTRU_NFA
 4210                           UDOT:
 4211    00000008 ........              DC32    DOCOL
 4212    0000000C ........              DC32    ZERO
 4213    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4214    00000014 ........              DC32    SEMIS
 4215                           
 4216                           
 4217                           //      ? QUES: ( addr -- )
 4218                           //      Print the value contained at the address in free format according to
 4219                           //      the current base using DOT.
 4220                           
 4221                            SECTION .text : CONST (2)
 4222                           QUES_NFA:
 4223    00000000 81                    DC8     0x81
 4224    00000001 BF                    DC8     '?'+0x80
 4225    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4226    00000004 ........              DC32    UDOT_NFA
 4227                           QUES:
 4228    00000008 ........              DC32    DOCOL
 4229    0000000C ........              DC32    AT
 4230    00000010 ........              DC32    DOT
 4231    00000014 ........              DC32    SEMIS
 4232                           
 4233                           
 4234                           //      . DOT:  ( n -- ) SIGNED 2'S COMPLEMENT:
 4235                           //      Print a number from a signed 32 bit two's complement value,
 4236                           //      converted according to the numeric base.
 4237                           //      A trailing blanks follows.
 4238                           
 4239                            SECTION .text : CONST (2)
 4240                           DOT_NFA:
 4241    00000000 81                    DC8     0x81
 4242    00000001 AE                    DC8     '.'+0x80
 4243    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4244    00000004 ........              DC32    QUES_NFA
 4245                           DOT:
 4246    00000008 ........              DC32    DOCOL
 4247    0000000C ........              DC32    STOD
 4248    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4249    00000014 ........              DC32    SEMIS
 4250                           
 4251                           
 4252                           //------------------------------ DOTBASE SECTION -------------------------------
 4253                           //      .H DOTHEX:      ( n -- )
 4254                           //      Prints TOS in Hex using DOT, not affecting Base in the system
 4255                           
 4256                           #ifndef SRM
 4257                           //      .B DOTBIN:      ( n -- )
 4258                           //      Prints TOS in BINARY using DOT, not affecting Base in the system
 4259                           
 4260                            SECTION .text : CONST (2)
 4261                           DOTBIN_NFA:
 4262    00000000 82                    DC8     0x82
 4263    00000001 2E                    DC8     '.'
 4264    00000002 C2                    DC8     'B'+0x80
 4265    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4266    00000004 ........              DC32    DOT_NFA
 4267                           DOTBIN:
 4268    00000008 ........              DC32    DOCOL
 4269    0000000C .............         DC32    TWO, DOTBASE
                  ...          
 4270    00000014 ........              DC32    SEMIS
 4271                           #endif  // not SRM
 4272                           
 4273                           
 4274                            SECTION .text : CONST (2)
 4275                           DOTHEX_NFA:
 4276    00000000 82                    DC8     0x82
 4277    00000001 2E                    DC8     '.'
 4278    00000002 C8                    DC8     'H'+0x80
 4279    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4280    00000004 ........              DC32    DOTBIN_NFA
 4281                           DOTHEX:
 4282    00000008 ........              DC32    DOCOL
 4283                           #ifdef SRM
 4285                           #else
 4286    0000000C ........10000         DC32    LIT, 16, DOTBASE        // this version appends BASE Suffix
                  000........  
 4287                           #endif
 4288    00000018 ........              DC32    SEMIS
 4289                           
 4290                           
 4291                           #ifndef SRM
 4292                           //      .D DOTDEC:      ( n -- )
 4293                           //      Prints TOS in DECIMAL using DOT, not affecting Base in the system
 4294                           
 4295                            SECTION .text : CONST (2)
 4296                           DOTDEC_NFA:
 4297    00000000 82                    DC8     0x82
 4298    00000001 2E                    DC8     '.'
 4299    00000002 C4                    DC8     'D'+0x80
 4300    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4301    00000004 ........              DC32    DOTHEX_NFA
 4302                           DOTDEC:
 4303    00000008 ........              DC32    DOCOL
 4304    0000000C ........0A000         DC32    LIT, 10, DOTBASE
                  000........  
 4305    00000018 ........              DC32    SEMIS
 4306                           #endif  // not SRM
 4307                           
 4308                           
 4309                           //=============================== WORDCAT ====================================//
 4310                           //NOEXEC HEADERFORWORDCATEGORIES
 4311                           //      WC_NUMBERS_NFA = NUMBER Stuff: CATEGORY
 4312                           
 4313                            SECTION .text : CONST (2)
 4314                           WC_NUMBERS_NFA:
 4315    00000000 91                    DC8     0x80+4+13
 4316    00000001 0D0A                  DC8     0x0D, 0x0A
 4317    00000003 4E554D4245522         DC8     'NUMBER Stuff:'
                  053747566663A
 4318    00000010 0D8A                  DC8     0x0D, 0x0A+0x80
 4319    00000012 FFFF           ALIGNROM 2,0xFFFFFFFF
 4320    00000014 ........              DC32    DOTDEC_NFA
 4321                           
 4322                           
 4323                           //=============================== UART0_INIT =================================//
 4324                           
 4325                           // LFA ABOVE NEEDS TO BE WC_NUMBERS_NFA
 4326                           $FISH_STM32F4_UART3_INIT.s
 4327                           // LFA BELOW NEEDS TO BE UART3_INIT_NFA
 4328                           
 4329                           //=============================== UART0_INIT =================================//
 4330                           
 4331                           //      MYBAUD MYBAUD: ( n -- ) BAUD MUST BE IN DECIMAL or EQUIVALENT!!!
 4332                           //      MUST BE USED BEFORE USING UART0_INIT!!!
 4333                           //      Because FISH does a reset if you invoke a HARD FAULT RESET
 4334                           //      THIS MECHANISM IS ESSENTIAL TO STAYING AT USER SET BAUDRATE THRU A RESET!
 4335                           //      SET NON-INIT RAM VARIABLES DBAUD TO ZERO AND UBAUD n.
 4336                           //      See UART0_INIT
 4337                           
 4338                            SECTION .text : CONST (2)
 4339                           MYBAUD_NFA:
 4340    00000000 86                    DC8     0x86
 4341    00000001 4D59424155            DC8     'MYBAU'
 4342    00000006 C4                    DC8     'D'+0x80
 4343    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4344    00000008 ........              DC32    UART3_INIT_NFA
 4345                           MYBAUD:
 4346    0000000C ........              DC32    DOCOL
 4347    00000010 ........00000         DC32    strva, 0, DBAUD
                  000........  
 4348    0000001C .............         DC32    LIT, UBAUD, STORE       // SET UBAUD TO NEW BAUD FOR UART0_INIT
                  ...........  
 4349    00000028 ........              DC32    SEMIS
 4350                           
 4351                           
 4352                           //      STM32F4 UART3_LSR UART3_LSR: ( -- value )
 4353                           
 4354                            SECTION .text : CONST (2)
 4355                           UART3_LSR_NFA:
 4356    00000000 89                    DC8     0x89
 4357    00000001 55415254335F4         DC8     'UART3_LS'
                  C53          
 4358    00000009 D2                    DC8     'R'+0x80
 4359    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 4360    0000000C ........              DC32    MYBAUD_NFA
 4361                           UART3_LSR:
 4362    00000010 ........              DC32    .+5
 4363                            SECTION .text : CODE (2)
 4364    00000000 0549                  LDR     n, = USART3_SR
 4365    00000002 0878                  LDRB    t, [n]
 4366                                   TPUSH
 4366                                   PUSHt   // push t to p, pre decrement p
 4366.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4366.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4366.3                         //      STR     t, [p]
 4366.4                                 ENDM
 4366                                   NEXT
 4366.1                         // ARMv7-M Thumb = .+5
 4366.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4366.3                         // ARMv6-M Thumb = .+4
 4366.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4366                                   NEXT1
 4366.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4366.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4366.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4366.4                         // ARMv6-M Thumb = .+4
 4366.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4366.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4366.7                                 ENDM
 4366.8                                 ENDM
 4366.9                                 ENDM
 4367    00000016 0000           LTORG
 4367.1                                  TABLE
 4367.2  00000018 00480040              Reference on line 4364
 4368                           
 4369                           
 4370                           //      STM32F4 UART3_RX UART3_RX: ( -- addr )
 4371                           //      This is the serial terminal.
 4372                           
 4373                            SECTION .text : CONST (2)
 4374                           UART3_RX_NFA:
 4375    00000000 88                    DC8     0x88
 4376    00000001 55415254335F5         DC8     'UART3_R'
                  2            
 4377    00000008 D8                    DC8     'X'+0x80
 4378    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4379    0000000C ........              DC32    UART3_LSR_NFA
 4380                           UART0_RX:
 4381    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4382                           
 4383                           //      STM32F4 UART3_TX UART3_TX: ( -- addr )
 4384                           //      This is the serial terminal.
 4385                           
 4386                            SECTION .text : CONST (2)
 4387                           UART3_TX_NFA:
 4388    00000000 88                    DC8     0x88
 4389    00000001 55415254335F5         DC8     'UART3_T'
                  4            
 4390    00000008 D8                    DC8     'X'+0x80
 4391    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4392    0000000C ........              DC32    UART3_RX_NFA
 4393                           UART3_TX:
 4394    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4395                           
 4396                           
 4397                           #ifdef XON_XOFF
 4398                           //      XOFF XOFF: ( -- ) Send XOFF
 4399                           
 4400                            SECTION .text : CONST (2)
 4401                           XOFF_NFA:
 4402    00000000 84                    DC8     0x84
 4403    00000001 584F46                DC8     'XOF'
 4404    00000004 C6                    DC8     'F'+0x80
 4405    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4406    00000008 ........              DC32    UART3_TX_NFA
 4407                           XOFF:
 4408    0000000C ........              DC32    .+5
 4409                            SECTION .text : CODE (2)       // Does not incr OUT and wait for line status
 4410                           #ifdef IO2TP
 4412                           #else
 4413    00000000 ........              BL      TXRDY_SUBR
 4414    00000004 ........              BL      XOFF_SUBR
 4415                                   NEXT
 4415.1                         // ARMv7-M Thumb = .+5
 4415.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4415.3                         // ARMv6-M Thumb = .+4
 4415.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4415                                   NEXT1
 4415.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4415.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4415.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4415.4                         // ARMv6-M Thumb = .+4
 4415.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4415.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4415.7                                 ENDM
 4415.8                                 ENDM
 4416                           #endif // #else IO2TP
 4417                           //#endif // XON_XOFF after XON:
 4418                           
 4419                           
 4420                           //      XON XON: ( -- ) Send XON
 4421                           
 4422                            SECTION .text : CONST (2)
 4423                           XON_NFA:
 4424    00000000 83                    DC8     0x83
 4425    00000001 584F                  DC8     'XO'
 4426    00000003 CE                    DC8     'N'+0x80
 4427                            ALIGNROM 2,0xFFFFFFFF
 4428    00000004 ........              DC32    XOFF_NFA
 4429                           XON:
 4430    00000008 ........              DC32    .+5
 4431                            SECTION .text : CODE (2)       // Does not incr OUT or wait for line status.
 4432                           #ifdef IO2TP
 4434                           #else
 4435                           // Required, no 'quick send'
 4436    00000000 ........              BL      TXRDY_SUBR
 4437    00000004 ........              BL      XON_SUBR
 4438                                   NEXT
 4438.1                         // ARMv7-M Thumb = .+5
 4438.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4438.3                         // ARMv6-M Thumb = .+4
 4438.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4438                                   NEXT1
 4438.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4438.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4438.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4438.4                         // ARMv6-M Thumb = .+4
 4438.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4438.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4438.7                                 ENDM
 4438.8                                 ENDM
 4439                           #endif // #else IO2TP
 4440                           #endif // XON_XOFF
 4441                           
 4442                           //---------------- EMIT KEY ?KEY CR SECTION ------------------------------
 4443                           
 4444                           //      SPACES SPACES:  ( n -- )
 4445                           //      Transmit n ascii blanks (0x20) to the output device.
 4446                           
 4447                            SECTION .text : CONST (2)
 4448                           SPACES_NFA:
 4449    00000000 86                    DC8     0x86
 4450    00000001 5350414345            DC8     'SPACE'
 4451    00000006 D3                    DC8     'S'+0x80
 4452    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4453                           #ifdef XON_XOFF
 4454    00000008 ........              DC32    XON_NFA
 4455                           #else
 4457                           #endif
 4458                           SPACES:
 4459    0000000C ........              DC32    DOCOL
 4460    00000010 ........              DC32    ZERO
 4461    00000014 ........              DC32    MAX
 4462    00000018 ........              DC32    ZNDUP
 4463    0000001C ........              DC32    ZBRAN
 4464    00000020 18000000              DC32     SPACES_DONE-.
 4465                           
 4466    00000024 ........              DC32    ZERO
 4467    00000028 ........              DC32    XDO     //DO
 4468                           
 4469                           SPACES_DO:
 4470    0000002C ........              DC32    SPACE
 4471    00000030 ........              DC32    XLOOP   //LOOP
 4472    00000034 F8FFFFFF              DC32     SPACES_DO-.
 4473                           
 4474                           SPACES_DONE:
 4475    00000038 ........              DC32    SEMIS
 4476                           
 4477                           
 4478                           //      SPACE SPACE: ( -- )
 4479                           //      Emit a space character, 0x20.
 4480                           
 4481                            SECTION .text : CONST (2)
 4482                           SPACE_NFA:
 4483    00000000 85                    DC8     0x85
 4484    00000001 53504143              DC8     'SPAC'
 4485    00000005 C5                    DC8     'E'+0x80
 4486    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4487    00000008 ........              DC32    SPACES_NFA
 4488                           SPACE:
 4489    0000000C ........              DC32    DOCOL
 4490    00000010 ........              DC32    BLANK
 4491    00000014 ........              DC32    EMIT
 4492    00000018 ........              DC32    SEMIS
 4493                           
 4494                           
 4495                           //      ID. IDDOT:      ( NFA-addr -- ) ?RENAME .NFA
 4496                           //      Print a definition's name from its name field address.
 4497                           
 4498                            SECTION .text : CONST (2)
 4499                           IDDOT_NFA:
 4500    00000000 83                    DC8     0x83
 4501    00000001 4944                  DC8     'ID'
 4502    00000003 AE                    DC8     '.'+0x80
 4503                            ALIGNROM 2,0xFFFFFFFF
 4504    00000004 ........              DC32    SPACE_NFA
 4505                           IDDOT:
 4506    00000008 ........              DC32    DOCOL
 4507                           //      NOW COUNT is on NFA, fig code copied it out to pad
 4508    0000000C ........              DC32    COUNT   // Count could be SMUDGE'd.
 4509    00000010 ........1F000         DC32    LIT, MAXWORDLEN // Strip SMUDGEing from count
                  000          
 4510    00000018 ........              DC32    ANDD            // only time 
 4511    0000001C ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4512    00000020 ........              DC32    SPACE
 4513    00000024 ........              DC32    SEMIS
 4514                           
 4515                           
 4516                           //      ." DOTQ:        ( -- ) IMMEDIATE
 4517                           //      Type quoted string out or compile inline string to be typed at runtime
 4518                           //      CHANGED COMPILE TIME ACTION TO WORK WITH 4 byte alighment REQUIREMENT.
 4519                           //      Used in the form:
 4520                           //              .' CCcc"
 4521                           //      Compiles an in-line string CCcc (delimited by the trailing ") with
 4522                           //      an execution proceedure to transmit the text to the output device.
 4523                           //      If executed outside a definition, ." will immediately print the text
 4524                           //      until the final ',. The maximum number of characters may be an
 4525                           //      installation dependent value. See (.").
 4526                           
 4527                            SECTION .text : CONST (2)
 4528                           DOTQ_NFA:
 4529    00000000 C2                    DC8     0x0C2
 4530    00000001 2E                    DC8     '.'
 4531    00000002 A2                    DC8     '"'+0x80
 4532    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4533    00000004 ........              DC32    IDDOT_NFA
 4534                           DOTQ:
 4535    00000008 ........              DC32    DOCOL
 4536    0000000C ........22000         DC32    LIT, '"'        // 0x22 ending qoute delimiter for WORD
                  000          
 4537    00000014 ........              DC32    STATE_SV
 4538    00000018 ........              DC32    AT
 4539    0000001C ........              DC32    ZBRAN   // IF Not COMPILING
 4540    00000020 2C000000              DC32     DOTQ1-.
 4541                           
 4542    00000024 ........              DC32    COMP    // COMPILING
 4543    00000028 ........              DC32    PDOTQ   // compile LIT, cnt-str-addr, count, type
 4544    0000002C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4545    00000030 ........              DC32    HERE
 4546    00000034 ........              DC32    CAT
 4547    00000038 ........              DC32    ONEP
 4548    0000003C ........              DC32    ALIGNED
 4549    00000040 ........              DC32    ALLOT_PRIM
 4550    00000044 ........              DC32    BRAN    // ELSE
 4551    00000048 14000000              DC32     DOTQ2-.
 4552                           DOTQ1:
 4553    0000004C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4554    00000050 ........              DC32    HERE
 4555    00000054 ........              DC32    COUNT
 4556    00000058 ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4557                                                   // endif
 4558                           #ifdef IO2TP
 4562                           #endif
 4563                           DOTQ2:
 4564    0000005C ........              DC32    SEMIS
 4565                           
 4566                           
 4567                           //      TYPE TYPE:      ( addr count -- )
 4568                           //      ADDR must be ALIGNED!
 4569                           //      OUT MUST BE INITIALIZED!!
 4570                           //      EMIT COUNT OF 8-bits in a string, preferably ascii characters,
 4571                           //      (last nfa char (+80h)ok!) from addr thru count,
 4572                           
 4573                            SECTION .text : CONST (2)
 4574                           TYPE_NFA:
 4575    00000000 84                    DC8     0x84
 4576    00000001 545950                DC8     'TYP'
 4577    00000004 C5                    DC8     'E'+0x80
 4578    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4579    00000008 ........              DC32    DOTQ_NFA
 4580                           TYPE:
 4581    0000000C ........              DC32    DOCOL
 4582    00000010 ........              DC32    ZNDUP
 4583    00000014 ........              DC32    ZBRAN   // IF NOTHING TO TYPE
 4584    00000018 34000000              DC32     TYPE1-.
 4585                           
 4586                           #ifdef XON_XOFF
 4587    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 4588                           #endif
 4589    00000020 ........              DC32    OVER
 4590    00000024 ........              DC32    PLUS
 4591    00000028 ........              DC32    SWAP
 4592    0000002C ........              DC32    XDO     // DO
 4593                           TYPE2:
 4594    00000030 ........              DC32    I
 4595    00000034 ........              DC32    CATLT7F // Limit output to ASCII characters under 80h
 4596    00000038 ........              DC32    EMIT
 4597                           tt1:
 4598    0000003C ........              DC32    XLOOP   // LOOP
 4599                           tt2:
 4600    00000040 F0FFFFFF              DC32     TYPE2-.
 4601                           
 4602    00000044 ........              DC32    BRAN    // ELSE
 4603    00000048 08000000              DC32     TYPE3-.
 4604                           TYPE1:
 4605    0000004C ........              DC32    DROP    // endif
 4606                           TYPE3:
 4607    00000050 ........              DC32    SEMIS
 4608                           
 4609                           
 4610                           //      EMIT EMIT:      ( c -- )
 4611                           //      Transmit ascii character c to the selected output device. OUT is
 4612                           //      incremented for each character output.
 4613                           
 4614                            SECTION .text : CONST (2)
 4615                           EMIT_NFA:
 4616    00000000 84                    DC8     0x84
 4617    00000001 454D49                DC8     'EMI'
 4618    00000004 D4                    DC8     'T'+0x80
 4619    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4620    00000008 ........              DC32    TYPE_NFA
 4621                           EMIT:
 4622                           #ifndef IO2TP
 4623                           // NOT IO2TP SECTION:
 4624    0000000C ........              DC32    .+5
 4625                            SECTION .text : CODE (2)
 4626                                   POP2t                   // GET CHAR
 4626.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4626.2                         //#ifndef TOSCT
 4626.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4626.4                         //#endif
 4626.5                         //      ADDS    p, p, #4
 4626.6                                 ENDM
 4627    00000004 ........              BL      TXRDY_SUBR
 4628    00000008 0649                  LDR     n, = USART3_DR // 
 4629                           // BSOUT handles negative out issue
 4630    0000000A 0870                  STRB    t, [n]          // EMIT (Send) Char
 4631    0000000C 0649                  LDR     n, = OUT        // Increment Out
 4632    0000000E 0868                  LDR     t, [n]
 4633    00000010 401C                  ADDS    t, t, #1
 4634    00000012 0860                  STR     t, [n]
 4635                                   NEXT
 4635.1                         // ARMv7-M Thumb = .+5
 4635.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4635.3                         // ARMv6-M Thumb = .+4
 4635.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4635                                   NEXT1
 4635.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4635.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4635.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4635.4                         // ARMv6-M Thumb = .+4
 4635.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4635.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4635.7                                 ENDM
 4635.8                                 ENDM
 4636                           #else // if IO2TP Transmit char to PAD, increment OUT
 4651                           #endif  // IO2TP
 4652    00000022 0000           LTORG
 4652.1                                  TABLE
 4652.2  00000024 04480040              Reference on line 4628
 4652.3  00000028 ........              Reference on line 4631
 4653                           
 4654                           
 4655                           //      KEY KEY:        (  -- ch )
 4656                           
 4657                            SECTION .text : CONST (2)
 4658                           KEY_NFA:
 4659    00000000 83                    DC8     0x83
 4660    00000001 4B45                  DC8     'KE'
 4661    00000003 D9                    DC8     'Y'+0x80
 4662                            ALIGNROM 2,0xFFFFFFFF
 4663    00000004 ........              DC32    EMIT_NFA
 4664                           KEY_INTERPRETED_ENTRY:
 4665                           #ifndef IO2TP
 4666    00000008 ........              DC32    DOCOL
 4667    0000000C ........              DC32    XON     // EXEC SETS XOFF SO UNDO IT
 4668    00000010 ........              DC32    KEY     // TE GET KEY!
 4669    00000014 ........              DC32    SEMIS
 4670                           
 4671                           
 4672                           //:NONAME KEY KEY:      ( -- CH ) 0-7Fh
 4673                           KEY:
 4674    00000018 ........              DC32    .+5
 4675                            SECTION .text : CODE (2)
 4676    00000000 074A                  LDR     w, = USART3_DR // Data Register w_r2
 4677    00000002 084B                  LDR     x, = USART3_SR // Status Register x_r3
 4678                           rxRDY?:
 4679    00000004 1968                  LDR     n, [x]         // Get Line Status value from [x_r3], put in n_r2 
 4680                           //      LSRS    n, n, #5       // Bit 5 RXNE: Read data register not empty
 4681                           // THIS IS ___ AND FAILS TEXT DOWNLOAD
 4682    00000006 8909                  LSRS    n, n, #6       // Bit 6 ORIG - REQ'D FOR TEXT FILE DOWNLOAD
 4683    00000008 FCD3                  BCC     rxRDY?         // sets carry flag to fall thru
 4684                           
 4685    0000000A 1068                  LDR     t, [w]         // t_r0 w_r2 should be uart data register
 4686                                   TPUSH
 4686                                   PUSHt   // push t to p, pre decrement p
 4686.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4686.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4686.3                         //      STR     t, [p]
 4686.4                                 ENDM
 4686                                   NEXT
 4686.1                         // ARMv7-M Thumb = .+5
 4686.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4686.3                         // ARMv6-M Thumb = .+4
 4686.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4686                                   NEXT1
 4686.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4686.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4686.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4686.4                         // ARMv6-M Thumb = .+4
 4686.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4686.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4686.7                                 ENDM
 4686.8                                 ENDM
 4686.9                                 ENDM
 4687                           #else
 4689                           #endif  // IO2TP
 4690    0000001E 0000           LTORG
 4690.1                                  TABLE
 4690.2  00000020 04480040              Reference on line 4676
 4690.3  00000024 00480040              Reference on line 4677
 4691                           
 4692                           
 4693                           //      ?KEY QKEY: ( -- f )
 4694                           //      Return zero unless key in fifo - key is not consumed.
 4695                           //      : TB BEGIN ?KEY UNTIL ; Will execute until any key is entered.
 4696                           
 4697                            SECTION .text : CONST (2)
 4698                           QKEY_NFA:
 4699    00000000 84                    DC8     0x84
 4700    00000001 3F4B45                DC8     '?KE'
 4701    00000004 D9                    DC8     'Y'+0x80
 4702    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4703    00000008 ........              DC32    KEY_NFA // -1
 4704                           QKEY:
 4705    0000000C ........              DC32    .+5
 4706                            SECTION .text : CODE (2)
 4707                           #ifdef IO2TP
 4709                           #else
 4710                           #ifdef XON_XOFF // XON IN QKEY
 4711    00000000 ........              BL      TXRDY_SUBR
 4712    00000004 ........              BL      XON_SUBR
 4713                           #endif
 4714    00000008 4040                  EORS    t, t    // zero t
 4715    0000000A 074B                  LDR     x, = USART3_SR
 4716    0000000C 1968                  LDR     n, [x]          // Get Line Status
 4717    0000000E 8909                  LSRS    n, n, #6        // Char available
 4718    00000010 00D3                  BCC     NO_KEY          // No char, not Ready
 4719                           
 4720                           // HAVE A KEY - DON'T CONSUME IT
 4721                           #ifdef TRUE_EQU_NEG_ONE
 4722    00000012 0138                  SUBS    t, #1   // -1
 4723                           #else
 4725                           #endif
 4726                           #endif  // DEFAULT TO NO KEY IF IO2TP
 4727                           NO_KEY:
 4728                                   TPUSH
 4728                                   PUSHt   // push t to p, pre decrement p
 4728.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4728.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4728.3                         //      STR     t, [p]
 4728.4                                 ENDM
 4728                                   NEXT
 4728.1                         // ARMv7-M Thumb = .+5
 4728.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4728.3                         // ARMv6-M Thumb = .+4
 4728.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4728                                   NEXT1
 4728.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4728.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4728.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4728.4                         // ARMv6-M Thumb = .+4
 4728.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4728.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4728.7                                 ENDM
 4728.8                                 ENDM
 4728.9                                 ENDM
 4729    00000026 0000           LTORG
 4729.1                                  TABLE
 4729.2  00000028 00480040              Reference on line 4715
 4730                           
 4731                           
 4732                           //      CRS CRS:        ( n -- )
 4733                           //      Emit n cr'S (0x0d) and lf (0x0A)
 4734                           
 4735                            SECTION .text : CONST (2)
 4736                           CRS_NFA:
 4737    00000000 83                    DC8     0x83
 4738    00000001 4352                  DC8     'CR'
 4739    00000003 D3                    DC8     'S'+0x80
 4740                            ALIGNROM 2,0xFFFFFFFF
 4741    00000004 ........              DC32    QKEY_NFA
 4742                           CRS:
 4743    00000008 ........              DC32    DOCOL
 4744    0000000C ........              DC32    ZERO
 4745    00000010 ........              DC32    XDO
 4746                           CRS_BEGIN:
 4747    00000014 ........              DC32    CR
 4748    00000018 ........              DC32    XLOOP
 4749    0000001C F8FFFFFF              DC32     CRS_BEGIN-.
 4750    00000020 ........              DC32    SEMIS
 4751                           
 4752                           
 4753                           //      CR CR:  ( -- )
 4754                           //      Emit cr (0x0d) and lf (0x0A)
 4755                           
 4756                            SECTION .text : CONST (2)
 4757                           CR_NFA:
 4758    00000000 82                    DC8     0x82
 4759    00000001 43                    DC8     'C'
 4760    00000002 D2                    DC8     'R'+0x80
 4761    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4762    00000004 ........              DC32    CRS_NFA
 4763                           CR:
 4764                           #ifdef IO2TP
 4767                           #else
 4768    00000008 ........              DC32    DOCOL
 4769    0000000C ........              DC32    zero_OUT
 4770    00000010 ........              DC32    PDOTQ
 4771    00000014 02                    DC8     2
 4772    00000015 0D0A                  DC8     0x0D, 0x0A
 4773    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 4774    00000018 ........              DC32    SEMIS
 4775                           #endif
 4776                           
 4777                           
 4778                           //=============================== WORDCAT ====================================//
 4779                           //NOEXEC HEADERFORWORDCATEGORIES
 4780                           //      WC_UART0_NFA = FISH IO: CATEGORY
 4781                           
 4782                            SECTION .text : CONST (2)
 4783                           WC_UARTx_NFA:
 4784    00000000 8C                    DC8     0x80+4+8
 4785    00000001 0D0A                  DC8     0x0D, 0x0A
 4786    00000003 4649534820494         DC8     'FISH IO:'
                  F3A          
 4787    0000000B 0D8A                  DC8     0x0D, 0x0A+0x80
 4788    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4789    00000010 ........              DC32    CR_NFA
 4790                           
 4791                           //      CMSIS_ENABLE_IRQS IRQS_RESUME:  ( -- )
 4792                            SECTION .text : CONST (2)
 4793                           IRQS_RESUME_NFA:
 4794    00000000 8B                    DC8     0x8B
 4795    00000001 495251535F524         DC8     'IRQS_RESUM'
                  553554D      
 4796    0000000B C5                    DC8     'E'+0x80
 4797                            ALIGNROM 2,0xFFFFFFFF
 4798    0000000C ........              DC32    WC_UARTx_NFA
 4799                           CMSIS_ENABLE_IRQS:
 4800    00000010 ........              DC32 .+5
 4801                            SECTION .text : CODE (2)
 4802                            ALIGNROM 2,0xFFFFFFFF
 4803                            IMPORT C_CMSIS_ENABLE_IRQS
 4804    00000000 ........              BL      C_CMSIS_ENABLE_IRQS
 4805                                   NEXT
 4805.1                         // ARMv7-M Thumb = .+5
 4805.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4805.3                         // ARMv6-M Thumb = .+4
 4805.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4805                                   NEXT1
 4805.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4805.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4805.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4805.4                         // ARMv6-M Thumb = .+4
 4805.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4805.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4805.7                                 ENDM
 4805.8                                 ENDM
 4806                           
 4807                           //      CMSIS_DISABLE_IRQS IRQS_SUSPEND:        ( -- )
 4808                            SECTION .text : CONST (2)
 4809                           IRQS_SUSPEND_NFA:
 4810    00000000 8C                    DC8     0x8C
 4811    00000001 495251535F535         DC8     'IRQS_SUSPEN'
                  55350454E    
 4812    0000000C C4                    DC8     'D'+0x80
 4813    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4814    00000010 ........              DC32    IRQS_RESUME_NFA
 4815                           CMSIS_DISABLE_IRQS:
 4816    00000014 ........              DC32 .+5
 4817                            SECTION .text : CODE (2)
 4818                            ALIGNROM 2,0xFFFFFFFF
 4819                            IMPORT C_CMSIS_DISABLE_IRQS
 4820    00000000 ........              BL      C_CMSIS_DISABLE_IRQS
 4821                                   NEXT
 4821.1                         // ARMv7-M Thumb = .+5
 4821.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4821.3                         // ARMv6-M Thumb = .+4
 4821.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4821                                   NEXT1
 4821.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4821.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4821.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4821.4                         // ARMv6-M Thumb = .+4
 4821.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4821.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4821.7                                 ENDM
 4821.8                                 ENDM
 4822                           
 4823                           
 4824                           //      SYSTICK_IRQ_OFF SYSTICK_IRQ_OFF:        ( -- )
 4825                           //      Turn SYSTICK interrupt off.
 4826                           //      STCTR only incremented when SYSTICK interrupt is on.
 4827                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4828                            SECTION .text : CONST (2)
 4829                           SYSTICK_IRQ_OFF_NFA:
 4830    00000000 8F                    DC8     0x8F
 4831    00000001 5359535449434         DC8     'SYSTICK_IRQ_OF'
                  B5F4952515F4F
                  46           
 4832    0000000F C6                    DC8     'F'+0x80
 4833                            ALIGNROM 2,0xFFFFFFFF
 4834    00000010 ........              DC32    IRQS_SUSPEND_NFA
 4835                           SYSTICK_IRQ_OFF:
 4836    00000014 ........              DC32    .+5
 4837                            SECTION .text : CODE (2)
 4838    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4839    00000002 0520                  MOVS    t, #5
 4840    00000004 0860                  STR     t, [n]
 4841                                   NEXT
 4841.1                         // ARMv7-M Thumb = .+5
 4841.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4841.3                         // ARMv6-M Thumb = .+4
 4841.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4841                                   NEXT1
 4841.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4841.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4841.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4841.4                         // ARMv6-M Thumb = .+4
 4841.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4841.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4841.7                                 ENDM
 4841.8                                 ENDM
 4842                           // LTORG         //Always outside of code, else data in words
 4843                           
 4844                           
 4845                           //      SYSTICK_IRQ_ON SYSTICK_IRQ_ON:  ( -- )
 4846                           //      Turn SYSTICK interrupt on.
 4847                           //      STCTR only incremented when SYSTICK interrupt is on.
 4848                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4848.1                                  TABLE
 4848.2  00000014 10E000E0              Reference on line 4838
 4849                            SECTION .text : CONST (2)
 4850                           SYSTICK_IRQ_ON_NFA:
 4851    00000000 8E                    DC8     0x8E
 4852    00000001 5359535449434         DC8     'SYSTICK_IRQ_O'
                  B5F4952515F4F
 4853    0000000E CE                    DC8     'N'+0x80
 4854    0000000F FF             ALIGNROM 2,0xFFFFFFFF
 4855    00000010 ........              DC32    SYSTICK_IRQ_OFF_NFA
 4856                           SYSTICK_IRQ_ON:
 4857    00000014 ........              DC32    .+5
 4858                            SECTION .text : CODE (2)
 4859    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4860    00000002 0720                  MOVS    t, #7
 4861    00000004 0860                  STR     t, [n]
 4862                                   NEXT
 4862.1                         // ARMv7-M Thumb = .+5
 4862.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4862.3                         // ARMv6-M Thumb = .+4
 4862.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4862                                   NEXT1
 4862.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4862.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4862.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4862.4                         // ARMv6-M Thumb = .+4
 4862.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4862.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4862.7                                 ENDM
 4862.8                                 ENDM
 4863                            LTORG   //Always outside of code, else data in words
 4863.1                                  TABLE
 4863.2  00000014 10E000E0              Reference on line 4859
 4864                           
 4865                           //=============================== WORDCAT ====================================//
 4866                           //NOEXEC HEADERFORWORDCATEGORIES
 4867                           //      WC_IRQ_NFA = INTERRUPTS: CATEGORY
 4868                           
 4869                            SECTION .text : CONST (2)
 4870                           WC_IRQ_NFA:
 4871    00000000 8F                    DC8     0x80+4+11
 4872    00000001 0D0A                  DC8     0x0D, 0x0A
 4873    00000003 494E544552525         DC8     'INTERRUPTS:'
                  55054533A    
 4874    0000000E 0D8A                  DC8     0x0D, 0x0A+0x80
 4875                            ALIGNROM 2,0xFFFFFFFF
 4876    00000010 ........              DC32    SYSTICK_IRQ_ON_NFA
 4877                           
 4878                           
 4879                           //------------------------------------------------------------------------------
 4880                           $FISH_STM32F4_FLASH.s       // FLASH_SAVE and FLASH_FORGET Words
 4881                           // LFA BELOW NEEDS TO BE FLASH_FORGET_NFA
 4882                           //------------------------------------------------------------------------------
 4883                           
 4884                           //-------------------------- PROMPT VECTOR SECTION -----------------------------
 4885                           
 4886                           //      POFF ( -- )   Set NULL$ address in PROMPT to zero so quit does CR only.
 4887                           
 4888                            SECTION .text : CONST (2)
 4889                           POFF_NFA:
 4890    00000000 84                    DC8     0x84
 4891    00000001 504F46                DC8     'POF'
 4892    00000004 C6                    DC8     'F'+0x80
 4893    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4894    00000008 ........              DC32    FLASH_FORGET_NFA
 4895                           POFF:
 4896    0000000C ........              DC32    DOCOL
 4897    00000010 ........00000         DC32    STRVA, 0, PROMPT
                  000........  
 4898    0000001C ........              DC32    SEMIS
 4899                           
 4900                           //      PON ( -- )   Set NULL$ address in PROMPT to msg_MY_OK
 4901                           
 4902                            SECTION .text : CONST (2)
 4903                           PON_NFA:
 4904    00000000 83                    DC8     0x83
 4905    00000001 504F                  DC8     'PO'
 4906    00000003 CE                    DC8     'N'+0x80
 4907                            ALIGNROM 2,0xFFFFFFFF
 4908    00000004 ........              DC32    POFF_NFA
 4909                           PON:
 4910    00000008 ........              DC32    DOCOL
 4911    0000000C .............         DC32    STRVA, msg_MY_OK, PROMPT
                  ...........  
 4912    00000018 ........              DC32    SEMIS
 4913                           
 4914                           //      P ( -- addr )   Address of PROMPT, contains 0 or NULL$ address.
 4915                           
 4916                            SECTION .text : CONST (2)
 4917                           P_NFA:
 4918    00000000 81                    DC8     0x81
 4919    00000001 D0                    DC8     'P'+0x80
 4920    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4921    00000004 ........              DC32    PON_NFA
 4922                           P:
 4923    00000008 .............         DC32    DOCON, PROMPT
                  ...          
 4924                           
 4925                           //-------------------------- ERROR_HALT SECTION -----------------------------
 4926                           
 4927                           //      EHOFF ( -- )   Set ERROR_HALT to 0
 4928                           
 4929                            SECTION .text : CONST (2)
 4930                           EHOFF_NFA:
 4931    00000000 85                    DC8     0x85
 4932    00000001 45484F46              DC8     'EHOF'
 4933    00000005 C6                    DC8     'F'+0x80
 4934    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4935    00000008 ........              DC32    P_NFA
 4936                           EHOFF:
 4937    0000000C .............         DC32    DOCOL, ZERO, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 4938                           
 4939                           //      EHON ( -- )   Set ERROR_HALT to 1
 4940                           
 4941                            SECTION .text : CONST (2)
 4942                           EHON_NFA:
 4943    00000000 84                    DC8     0x84
 4944    00000001 45484F                DC8     'EHO'
 4945    00000004 CE                    DC8     'N'+0x80
 4946    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4947    00000008 ........              DC32    EHOFF_NFA
 4948                           EHON:
 4949    0000000C .............         DC32    DOCOL, ONE, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 4950                           
 4951                           //-------------------------- DOTDICTSPACE SECTION ------------------------------
 4952                           
 4953                           //      .DS DOTDICTSPACE:       ( n -- )
 4954                           //      Prints number of bytes availble in dictionary in DECIMAL using DOT,
 4955                           //      not affecting Base in the system
 4956                           
 4957                            SECTION .text : CONST (2)
 4958                           DOTDICTSPACE_NFA:
 4959    00000000 83                    DC8     0x83
 4960    00000001 2E44                  DC8     '.D'
 4961    00000003 D3                    DC8     'S'+0x80
 4962                            ALIGNROM 2,0xFFFFFFFF
 4963                           //      DC32    FLASH_FORGET_NFA
 4964                           //      DC32    P_NFA
 4965    00000004 ........              DC32    EHON_NFA
 4966                           DOTDICTSPACE:
 4967    00000008 ........              DC32    DOCOL
 4968    0000000C ........              DC32    DICTSPACE
 4969    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 4970    00000014 ........              DC32    DOTDEC
 4971    00000018 ........              DC32    BASE_FROM_R12   // Restore BASE
 4972    0000001C .............         DC32    LIT, msg_dictspace
                  ...          
 4973    00000024 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 4974                           #ifdef IO2TP
 4978                           #endif
 4979    0000002C ........              DC32    SEMIS
 4980                           
 4981                           
 4982                           //-------------------------- DOTVARSPACE SECTION -------------------------------
 4983                           
 4984                           //      .VS DOTVARSPACE:        ( n -- )
 4985                           //      Prints number of bytes availble in RAM VAR SPACE in DECIMAL using DOT,
 4986                           //      not affecting Base in the system.
 4987                           
 4988                            SECTION .text : CONST (2)
 4989                           DOTVARSPACE_NFA:
 4990    00000000 83                    DC8     0x83
 4991    00000001 2E56                  DC8     '.V'
 4992    00000003 D3                    DC8     'S'+0x80
 4993                            ALIGNROM 2,0xFFFFFFFF
 4994    00000004 ........              DC32    DOTDICTSPACE_NFA
 4995                           DOTVARSPACE:
 4996    00000008 ........              DC32    DOCOL
 4997    0000000C ........              DC32    VARSPACE
 4998    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 4999    00000014 .............         DC32    FOUR, SLASH
                  ...          
 5000    0000001C ........              DC32    DOTDEC
 5001    00000020 ........              DC32    BASE_FROM_R12   // Restore BASE
 5002    00000024 .............         DC32    LIT, msg_uvspace
                  ...          
 5003    0000002C .............         DC32    NULLSTRLEN, TYPE
                  ...          
 5004                           #ifdef IO2TP
 5008                           #endif
 5009    00000034 ........              DC32    SEMIS
 5010                           
 5011                           
 5012                           //      DUMP DUMP:      ( addr n -- )
 5013                           //      Print adrr and n lines of 4 columns of memory values in hexadecimal.
 5014                           //      Address must be even and a multiple of 4 else error message issued.
 5015                           //      Any key presssed will stop DUMP.
 5016                           
 5017                            SECTION .text : CONST (2)
 5018                           DUMP_NFA:
 5019    00000000 84                    DC8     0x84
 5020    00000001 44554D                DC8     'DUM'
 5021    00000004 D0                    DC8     'P'+0x80
 5022    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5023    00000008 ........              DC32    DOTVARSPACE_NFA
 5024                           DUMP:
 5025    0000000C ........              DC32    DOCOL
 5026                           
 5027    00000010 .............         DC32    OVER, QALIGNED  // \ -- addr n
                  ...          
 5028                           // DON'T SAVE BASE UNTIL AFTER ALIGNED TEST
 5029    00000018 ........              DC32    BASE_TO_R12     // Save current BASE
 5030    0000001C ........              DC32    HEX
 5031    00000020 .............         DC32    ZERO, XDO
                  ...          
 5032                           DUMP_ADDR_LINE:
 5033    00000028 ........              DC32    CR
 5034    0000002C .............         DC32    DUP, LIT, 10, DOTRU     // Print addr in Field
                  ...0A000000..
                  ......       
 5035    0000003C .............         DC32    FOUR, ZERO, XDO         // Four colum loop
                  ...........  
 5036                           DUMP_EACH_LOC:
 5037    00000048 .............         DC32    DUP, AT
                  ...          
 5038                           // Little Endian means addresses will print correctly
 5039                           // but to see character strings REVW is needed
 5040                           // but the addresses are scrambled!
 5041                           //        DC32    REVW                    // Reverse bytes in word
 5042    00000050 ........0E000         DC32    LIT, 14, DOTRU          // Diplay in Field
                  000........  
 5043    0000005C ........              DC32    FOURP
 5044    00000060 ........              DC32    XLOOP
 5045    00000064 E4FFFFFF              DC32     DUMP_EACH_LOC-.
 5046                           
 5047                           #ifdef IO2TP
 5051                           #endif
 5052    00000068 ........              DC32    QKEY
 5053    0000006C ........              DC32    ZBRAN
 5054    00000070 08000000              DC32     DUMP_CONT-.
 5055    00000074 ........              DC32    LEAVE
 5056                           DUMP_CONT:
 5057    00000078 ........              DC32    XLOOP
 5058    0000007C ACFFFFFF              DC32    DUMP_ADDR_LINE-.
 5059                           
 5060    00000080 .............         DC32    DROP, CR
                  ...          
 5061    00000088 ........              DC32    BASE_FROM_R12   // Restore BASE
 5062    0000008C ........              DC32    SEMIS
 5063                           
 5064                           
 5065                           //      VBASE VBASE:    ( -- addr )
 5066                           //      Return base addr of VAR's .
 5067                           
 5068                            SECTION .text : CONST (2)
 5069                           VBASE_NFA:
 5070    00000000 85                    DC8     0x85
 5071    00000001 56424153              DC8     'VBAS'
 5072    00000005 C5                    DC8     'E'+0x80
 5073    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5074    00000008 ........              DC32    DUMP_NFA
 5075                           VBASE:
 5076    0000000C .............         DC32    DOCON,  RAMVARSPACE_START
                  ...          
 5077                           
 5078                           
 5079                           //      DBASE DBASE:    ( -- addr )
 5080                           //      Return base addr of the dictionary.
 5081                           
 5082                            SECTION .text : CONST (2)
 5083                           DBASE_NFA:
 5084    00000000 85                    DC8     0x85
 5085    00000001 44424153              DC8     'DBAS'
 5086    00000005 C5                    DC8     'E'+0x80
 5087    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5088    00000008 ........              DC32    VBASE_NFA
 5089                           DBASE:
 5090    0000000C .............         DC32    DOCON,  ORIG
                  ...          
 5091                           
 5092                           
 5093                           //      RBASE RBASE:    ( -- addr )
 5094                           //      Return base addr of RAM THE DICTIONARY IS IN!.
 5095                           
 5096                            SECTION .text : CONST (2)
 5097                           RBASE_NFA:
 5098    00000000 85                    DC8     0x85
 5099    00000001 52424153              DC8     'RBAS'
 5100    00000005 C5                    DC8     'E'+0x80
 5101    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5102    00000008 ........              DC32    DBASE_NFA
 5103                           RBASE:
 5104    0000000C .............         DC32    DOCON,  RAM_START    // RAM WHERE DICT ALLOACTED IN MEMMAP
                  ...          
 5105                           
 5106                           
 5107                           //      CLS CLS:        ( -- )
 5108                           //      Clear serial terminal screen using a formfeed character
 5109                           
 5110                            SECTION .text : CONST (2)
 5111                           CLS_NFA:
 5112    00000000 83                    DC8     0x83
 5113    00000001 434C                  DC8     'CL'
 5114    00000003 D3                    DC8     'S'+0x80
 5115                            ALIGNROM 2,0xFFFFFFFF
 5116    00000004 ........              DC32    RBASE_NFA
 5117                           CLS:
 5118    00000008 ........              DC32    DOCOL
 5119    0000000C ........              DC32    PDOTQ
 5120    00000010 04                    DC8     4
 5121    00000011 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT100 ESC SETUP
 5122    00000013 324A                  DC8     '2J'            // Clearscreen
 5123    00000015 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5124    00000018 ........              DC32    PDOTQ
 5125    0000001C 04                    DC8     4
 5126    0000001D 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT00 ESC SETUP
 5127    0000001F 3B48                  DC8     ';H'            // CURSORHOME \ upper left corner
 5128    00000021 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5129    00000024 ........              DC32    CR              // Reset OUT
 5130    00000028 ........              DC32    SEMIS
 5131                           
 5132                           
 5133                           //      ( PAREN:        ( -- ) IMMEDIATE
 5134                           //      Used in the form:
 5135                           //              ( CCcc )
 5136                           //      Ignore comments within parenthesis. A right parenthesis ends comment.
 5137                           //      The comments may be multi-line but a space or tab is required
 5138                           //      for any line that is otherwise empty for formatting purposes,
 5139                           //      else a comment error will be printed. May occur during execution or in a
 5140                           //      colon-definition. A blank after the leading parenthesis is required.
 5141                           
 5142                            SECTION .text : CONST (2)
 5143                           PAREN_NFA:
 5144    00000000 C1                    DC8     0x0C1
 5145    00000001 A8                    DC8     '('+0x80
 5146    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5147    00000004 ........              DC32    CLS_NFA
 5148                           PAREN:
 5149                           // Slow Single line comment
 5150                           //      DC32    DOCOL, LIT, ')', WORD, SEMIS
 5151    00000008 ........              DC32    DOCOL
 5152                           PML_LOOP:
 5153    0000000C ........29000         DC32    LIT, ')'
                  000          
 5154    00000014 ........              DC32    TIB_CHAR_SCAN   // ( c -- f )
 5155                           //
 5156    00000018 ........              DC32    ZEQU            // If null
 5157    0000001C ........              DC32    ZBRAN           // found fall thru
 5158    00000020 34000000              DC32      PE_DONE-.     // else were done
 5159                           
 5160                           // Acting like the outer interpreter here, signal DLE
 5161    00000024 .............         DC32    CR, LIT, 0x10, EMIT
                  ...10000000..
                  ......       
 5162    00000034 ........              DC32    QUERY
 5163                           //  AND IF ONLY CR (null) ERR
 5164                           //        DC32    TIB_SV, CAT
 5165    00000038 .............         DC32    LIT, TIB+1, CAT // PAST COUNT BYTE
                  ...........  
 5166    00000044 ........              DC32    ZBRAN
 5167    00000048 10000000              DC32      PAREN_ERR-.
 5168                           
 5169                           //  If closing paren not in this line LOOP
 5170    0000004C ........              DC32    BRAN
 5171    00000050 BCFFFFFF              DC32      PML_LOOP-.
 5172                           
 5173                           PE_DONE:
 5174    00000054 ........              DC32    SEMIS
 5175                           
 5176                           PAREN_ERR:
 5177    00000058 .............         DC32    LIT, msg_paren_err
                  ...          
 5178    00000060 .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 5179    00000068 ........              DC32    SEMIS
 5180                           
 5181                           
 5182                           //      BACKSLASH BACKSLASH:    ( --  )
 5183                           //      After a trailing space treat the rest of the line as a comment.
 5184                           //      By setting a null terminator in TIB
 5185                           
 5186                            SECTION .text : CONST (2)
 5187                           BACKSLASH_NFA:
 5188    00000000 C1                    DC8     0x0C1
 5189    00000001 DC                    DC8     '\\'+0x80
 5190    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5191    00000004 ........              DC32    PAREN_NFA
 5192                           BACKSLASH:
 5193    00000008 ........              DC32    DOCOL
 5194    0000000C .............         DC32    ZERO, TIB_SV, IN_SV, AT, PLUS, CSTORE
                  .............
                  .............
                  .........    
 5195    00000024 ........              DC32    SEMIS
 5196                           
 5197                           
 5198                           //      SYSCLK SYSCLK:  ( -- value )
 5199                           //      Returns system clock value in Hz, i.e. 48000000 = 48Mhz.
 5200                           
 5201                            SECTION .text : CONST (2)
 5202                           SYSCLK_NFA:
 5203    00000000 86                    DC8     0x86
 5204    00000001 535953434C            DC8     'SYSCL'
 5205    00000006 CB                    DC8     'K'+0x80
 5206    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 5207    00000008 ........              DC32    BACKSLASH_NFA
 5208                           SYSCLK:
 5209    0000000C ........              DC32    .+5
 5210                            SECTION .text : CODE (2)
 5211    00000000 0549                  LDR     n, = SYSCLOCK   // SystemCoreClock
 5212    00000002 0868                  LDR     t, [n]
 5213                                   TPUSH   // Push -- t
 5213                                   PUSHt   // push t to p, pre decrement p
 5213.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 5213.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 5213.3                         //      STR     t, [p]
 5213.4                                 ENDM
 5213                                   NEXT
 5213.1                         // ARMv7-M Thumb = .+5
 5213.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5213.3                         // ARMv6-M Thumb = .+4
 5213.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5213                                   NEXT1
 5213.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5213.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5213.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5213.4                         // ARMv6-M Thumb = .+4
 5213.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5213.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5213.7                                 ENDM
 5213.8                                 ENDM
 5213.9                                 ENDM
 5214    00000016 0000           LTORG   //Always outside of code, else data in words
 5214.1                                  TABLE
 5214.2  00000018 ........              Reference on line 5211
 5215                           
 5216                           
 5217                           //      STCTR   ( -- addr ) SYSTICK Interrupt increments this with 32but wrap.
 5218                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5219                            SECTION .text : CONST (2)
 5220                           STCTR_NFA:
 5221    00000000 85                    DC8     0x85
 5222    00000001 53544354              DC8     'STCT'
 5223    00000005 D2                    DC8     'R'+0x80
 5224    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5225                           //      DC32    STI_ON_NFA
 5226    00000008 ........              DC32    SYSCLK_NFA
 5227                           STCTR:
 5228    0000000C .............         DC32    DOCON, STICKER
                  ...          
 5229                           
 5230                           
 5231                           //      DELAY ( n value -- ) 7 E000E010h !   5 E000E010h !
 5232                            SECTION .text : CONST (2)
 5233                           DELAY_NFA:
 5234    00000000 85                    DC8     0x85
 5235    00000001 44454C41              DC8     'DELA'
 5236    00000005 D9                    DC8     'Y'+0x80
 5237    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5238    00000008 ........              DC32    STCTR_NFA
 5239                           DELAY:
 5240    0000000C ........              DC32    .+5
 5241                            SECTION .text : CODE (2)
 5242                                   POP2n   // Reload value in n
 5242.1  00000000 57F8041B              LDR     n, [p],#4
 5242.2                         //      LDR     n, [p]
 5242.3                         //      ADDS    p, p, #4
 5242.4                                 ENDM
 5243                                   POP2t   // loop count in t
 5243.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 5243.2                         //#ifndef TOSCT
 5243.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 5243.4                         //#endif
 5243.5                         //      ADDS    p, p, #4
 5243.6                                 ENDM
 5244                           // SET STCTR TO NEGATIVE LOOP COUNT TO END AT ZERO
 5245    00000008 0C4C                  LDR     y, = STICKER
 5246    0000000A C043                  MVNS    t, t            // 1's compliment
 5247    0000000C 401C                  ADDS    t, t, #1        // 2's compliment
 5248    0000000E 2060                  STR     t, [y]
 5249                           // Load SYST_RVR with countdown value
 5250    00000010 0B4A                  LDR     w, = SYST_RVR
 5251    00000012 1160                  STR     n, [w]
 5252                           // and reset SYST_CVR to start countdown.
 5253    00000014 0B4A                 LDR     w, = SYST_CVR
 5254                           // Writing it clears the System Tick counter and the COUNTFLAG bit in STCTRL.
 5255    00000016 1160                  STR     n, [w]
 5256                           // If n=0 in t user is just setting reload value
 5257    00000018 0028                  CMP     t, #0           // LOOP OF ZERO
 5258    0000001A 06D0                  BEQ     DELAY_DONE
 5259                           // INTERRUPT VERSION: negate n to STCTR and leave when STCTR = 0
 5260                           // STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5261                           // Save and restore user interrupt setting
 5262                           // y = STICKER
 5263    0000001C 0A4A                  LDR     w, = SYST_CSR
 5264    0000001E 1068                  LDR     t, [w]          // Save user SYSTICK interrupt setting
 5265    00000020 0721                  MOVS    n, #7
 5266    00000022 1160                  STR     n, [w]          // Turn SYSTICK interrupt on in case it's off
 5267                           DELAY_LOOP:
 5268    00000024 2168                  LDR     n, [y]
 5269    00000026 0029                  CMP     n, #0
 5270    00000028 FCD1                  BNE     DELAY_LOOP
 5271                           DELAY_DONE:
 5272    0000002A 1060                  STR     t, [w]  // Restore user SYSTICK interrupt setting
 5273                                   NEXT
 5273.1                         // ARMv7-M Thumb = .+5
 5273.2  0000002C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5273.3                         // ARMv6-M Thumb = .+4
 5273.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5273                                   NEXT1
 5273.1  00000030 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5273.2  00000034 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5273.3  00000038 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5273.4                         // ARMv6-M Thumb = .+4
 5273.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5273.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5273.7                                 ENDM
 5273.8                                 ENDM
 5274    0000003A 0000           LTORG
 5274.1                                  TABLE
 5274.2  0000003C ........              Reference on line 5245
 5274.3  00000040 14E000E0              Reference on line 5250
 5274.4  00000044 18E000E0              Reference on line 5253
 5274.5  00000048 10E000E0              Reference on line 5263
 5275                           
 5276                           
 5277                           //      MS MS: ( n -- ) n * 1 millisecond execution time
 5278                           //      SYSTICK_IRQ_ON/OFF  STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! 
 5279                           
 5280                            SECTION .text : CONST (2)
 5281                           MS_NFA:
 5282    00000000 82                    DC8     0x82
 5283    00000001 4D                    DC8     'M'
 5284    00000002 D3                    DC8     'S'+0x80
 5285    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 5286    00000004 ........              DC32    DELAY_NFA
 5287                           MS:
 5288    00000008 ........              DC32    DOCOL
 5289                           #ifdef STM32F4_IRC16_48MHZ
 5291                           #endif
 5292                           #ifdef STM32F205RC_XRC10_118MHZ
 5294                           #endif
 5295                           #ifdef STM32F4_XRC08_168MHZ
 5296    0000000C ........3F900         DC32    LIT, 167999d    // 2903Fh 1ms @ 168mhz RELOAD COUNTER VALUE
                  200          
 5297                           #endif
 5298    00000014 ........              DC32    DELAY
 5299    00000018 ........              DC32    SEMIS
 5300                           
 5301                           
 5302                           //      WORDCAT WORDCAT: ( -- )
 5303                           //      Creates a Word Category NFA and LFA that cannot be searched for,
 5304                           //      but is displayed by WORDS and MYWORDS to label a group of Words.
 5305                           //      Define a group of Words and then add a category name with WORDCAT.
 5306                           //      EX: WORDCAT MY APP WORDS:
 5307                           //      It must be on a line of it's own.
 5308                           //      The colon at the end is FISH convention.
 5309                            SECTION .text : CONST (2)
 5310                           WORDCAT_NFA:
 5311    00000000 87                    DC8     0x87
 5312    00000001 574F52444341          DC8     'WORDCA'
 5313    00000007 D4                    DC8     'T'+0x80
 5314                            ALIGNROM 2,0xFFFFFFFF
 5315    00000008 ........              DC32    MS_NFA
 5316                           WORDCAT:
 5317    0000000C ........              DC32    DOCOL
 5318    00000010 .............         DC32    HERE, TOR
                  ...          
 5319    00000018 .............         DC32    ZERO, CCOMMA    // Count byte place holder
                  ...          
 5320    00000020 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5321    0000002C ........              DC32    HERE
 5322    00000030 ........0D000         DC32    LIT, 0Dh, WORD
                  000........  
 5323    0000003C .............         DC32    DUP, CAT
                  ...          
 5324    00000044 ........0A000         DC32    LIT, 0Ah, ROT, CSTORE
                  000..........
                  ......       
 5325    00000054 .............         DC32    DUP, ONEP, ALLOT
                  ...........  
 5326    00000060 ........84000         DC32    LIT, 084h        // Count before system text
                  000          
 5327    00000068 .............         DC32    PLUS, R, CSTORE
                  ...........  
 5328    00000074 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5329    00000080 ........8A000         DC32    LIT, 08Ah, CCOMMA
                  000........  
 5330    0000008C ........              DC32    ALIGN32_DP_FF_PAD
 5331    00000090 .............         DC32    LATEST, COMMA
                  ...          
 5332    00000098 ........              DC32    RFROM
 5333    0000009C .............         DC32    LIT, CURRENT
                  ...          
 5334    000000A4 ........              DC32    STORE
 5335    000000A8 ........              DC32    SEMIS
 5336                           
 5337                           
 5338                           //      WORDS WORDS:    ( -- ) RENAMED: VLIST to WORDS
 5339                           //      Output list of Words in the dictionary in search order.
 5340                           //      Uses WC_ nfa's to format Word Categories.
 5341                           //      Uses FENCE for where to stop.
 5342                           //      See MYWORDS.
 5343                           
 5344                            SECTION .text : CONST (2)
 5345                           WORDS_NFA:
 5346    00000000 85                    DC8     0x85
 5347    00000001 574F5244              DC8     'WORD'
 5348    00000005 D3                    DC8     'S'+0x80
 5349    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5350    00000008 ........              DC32    WORDCAT_NFA
 5351                           WORDS:
 5352    0000000C ........              DC32    DOCOL
 5353    00000010 .............         DC32    THREE, SPACES
                  ...          
 5354    00000018 ........              DC32    LATEST
 5355                           #ifdef XON_XOFF
 5356    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 5357                           #endif
 5358                           WORDS1:  // ADD nfa length to current out_uv & verify it doesn't violate csll.
 5359                           
 5360    00000020 .............         DC32    ZERO, OVER      // -- nfa zero nfa
                  ...          
 5361    00000028 .............         DC32    ONEP, CAT       // If wc_ header skip
                  ...          
 5362    00000030 ........0D000         DC32    LIT, 0x0D       // -- nfa zero (c@) 0x0D
                  000          
 5363    00000038 .............         DC32    EQUAL, ZEQU     // -- nfa zerro flag
                  ...          
 5364    00000040 ........              DC32    ZBRAN           // -- nfa zero
 5365    00000044 1C000000              DC32     WORDS2-.       // wc_ goto
 5366                                   
 5367    00000048 ........              DC32    DROP            // -- nfa
 5368    0000004C .............         DC32    DUP, PFA, LFA   // -- nfa lfa
                  ...........  
 5369    00000058 .............         DC32    OVER, SUBB      // -- nfa (lfa - nfa)
                  ...          
 5370                           
 5371                           WORDS2: // -- nfa n
 5372                           
 5373    00000060 .............         DC32    OUT_SV, AT      // Use OUT to regulate line length.
                  ...          
 5374    00000068 ........              DC32    PLUS
 5375    0000006C ........4A000         DC32    LIT, 74         // was :NONAME CSLL - WORDS line length constant.
                  000          
 5376    00000074 ........              DC32    GREATERTHAN
 5377    00000078 ........              DC32    ZBRAN           // If not at end of line
 5378    0000007C 10000000              DC32     WORD21-.        // skip cr and out reset
 5379                           
 5380    00000080 ........              DC32    CR              // Start another line
 5381    00000084 .............         DC32    THREE, SPACES
                  ...          
 5382                           
 5383                           WORD21:
 5384                           #ifdef  IO2TP
 5387                           #endif
 5388                           // For MYWORDS test FENCE and stop if less
 5389    0000008C ........              DC32    DUP             // nfa
 5390    00000090 .............         DC32    FENCE_SV, AT
                  ...          
 5391    00000098 ........              DC32    LESSTHAN
 5392    0000009C ........              DC32    ZBRAN
 5393    000000A0 0C000000              DC32     WORDSCONT-.
 5394                           
 5395    000000A4 ........              DC32    BRAN
 5396    000000A8 54000000              DC32     WORDSDONE-.
 5397                           
 5398                           WORDSCONT:
 5399    000000AC ........              DC32    DUP             // nfa
 5400    000000B0 ........              DC32    IDDOT
 5401    000000B4 .............         DC32    TWO, SPACES
                  ...          
 5402                           
 5403    000000BC .............         DC32    DUP, ONEP, CAT  // Take nfa and look for WORDCAT signature
                  ...........  
 5404    000000C8 ........0D000         DC32    LIT, 0x0D       // which is cr
                  000          
 5405    000000D0 ........              DC32    EQUAL
 5406    000000D4 ........              DC32    ZBRAN           // If not wordcat
 5407    000000D8 08000000              DC32     NOT_WC-.       // skip
 5408                           
 5409    000000DC ........              DC32    zero_OUT
 5410                           
 5411                           NOT_WC:
 5412    000000E0 ........              DC32    PFA             // \ nfa -- pfa
 5413    000000E4 ........              DC32    LFA             // \ pfa -- lfa
 5414    000000E8 ........              DC32    AT              // Is next lfa
 5415    000000EC ........              DC32    DUP
 5416    000000F0 ........              DC32    ZEQU            // Zero = end of dictionary
 5417                           
 5418                           // REMOVED SO WORDS AND MYWORDS CAN BE USED IN DOWNLOAD FILES
 5419                           //      DC32    QKEY           // Zero or break key \ ^C = 0x03
 5420                           //      DC32    OR
 5421                           
 5422    000000F4 ........              DC32    ZBRAN           // Until break key or end of dictionary
 5423    000000F8 28FFFFFF              DC32     WORDS1-.
 5424                           
 5425                           #ifdef  IO2TP
 5428                           #endif
 5429                           WORDSDONE:
 5430    000000FC .............         DC32    DROP, CR
                  ...          
 5431    00000104 ........              DC32    SEMIS
 5432                           
 5433                           
 5434                           //      MYWORDS MYWORDS: ( -- )
 5435                           //      Print only system defined words by manipulating FENCE.
 5436                           
 5437                            SECTION .text : CONST (2)
 5438                           MYWORDS_NFA:
 5439    00000000 87                    DC8     0x87
 5440    00000001 4D59574F5244          DC8     'MYWORD'
 5441    00000007 D3                    DC8     'S'+0x80
 5442                            ALIGNROM 2,0xFFFFFFFF
 5443    00000008 ........              DC32    WORDS_NFA
 5444                           MYWORDS:
 5445    0000000C ........              DC32    DOCOL
 5446    00000010 ........00000         DC32    strva , FLASH_SPAGE, FENCE
                  208........  
 5447    0000001C ........              DC32    WORDS                   // now print words in ram
 5448    00000020 ........00000         DC32    strva, 0 , FENCE
                  000........  
 5449    0000002C ........              DC32    SEMIS
 5450                           
 5451                           
 5452                           //      FISH_ONLY FISH_ONLY     ( -- ) MODIFIED:
 5453                           //      RESET DP, UP AND CURRENT TO ORIGINAL FLASH IMAGE
 5454                           
 5455                            SECTION .text : CONST (2)
 5456                           FISH_ONLY_NFA:
 5457    00000000 89                    DC8     0x80+9
 5458    00000001 464953485F4F4         DC8     'FISH_ONL'
                  E4C          
 5459    00000009 D9                    DC8     'Y'+0x80
 5460    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 5461    0000000C ........              DC32    MYWORDS_NFA
 5462                           FISH_ONLY:
 5463    00000010 ........              DC32    .+5
 5464                            SECTION .text : CODE (2)
 5465                           //      LDR     n, = TASK_NFA           // preserve TOS
 5466                           #ifdef FISH_PubRel_WORDSET
 5467    00000000 0949                  LDR     n, = WC_FISH_PubRel_NFA
 5468                           #endif
 5469                           #ifdef FISH_STM32M407vg_PRO_WORDCAT
 5471                           #endif
 5472    00000002 0A4C                  LDR     y, = CURRENT            // CURRENT SETTING
 5473    00000004 2160                  STR     n, [y]
 5474    00000006 0A4C                  LDR     y, = FPC                // FLASH CURRENT
 5475    00000008 2160                  STR     n, [y]
 5476    0000000A 0A49                  LDR     n, = RAMVARSPACE_START
 5477    0000000C 0A4C                  LDR     y, = UP                 // UP SETTING
 5478    0000000E 2160                  STR     n, [y]
 5479    00000010 0A4C                  LDR     y, = FPSV                // FLASH USER VARS
 5480    00000012 2160                  STR     n, [y]
 5481    00000014 0A49                  LDR     n, = ORIG
 5482    00000016 0B4C                  LDR     y, = DP                 // DP SETTING
 5483    00000018 2160                  STR     n, [y]
 5484                                   NEXT
 5484.1                         // ARMv7-M Thumb = .+5
 5484.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5484.3                         // ARMv6-M Thumb = .+4
 5484.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5484                                   NEXT1
 5484.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5484.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5484.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5484.4                         // ARMv6-M Thumb = .+4
 5484.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5484.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5484.7                                 ENDM
 5484.8                                 ENDM
 5485                            LTORG
 5485.1                                  TABLE
 5485.2  00000028 ........              Reference on line 5467
 5485.3  0000002C ........              Reference on line 5472
 5485.4  00000030 ........              Reference on line 5474
 5485.5  00000034 ........              Reference on line 5476
 5485.6  00000038 ........              Reference on line 5477
 5485.7  0000003C ........              Reference on line 5479
 5485.8  00000040 ........              Reference on line 5481
 5485.9  00000044 ........              Reference on line 5482
 5486                           
 5487                           
 5488                           //      FISH FISH:      ( -- )
 5489                           //      Print Flash Status and FISH Signon Message.
 5490                           
 5491                           
 5492                            SECTION .text : CONST (2)
 5493                           FISH_NFA:
 5494    00000000 84                    DC8     0x84
 5495    00000001 464953                DC8     'FIS'
 5496    00000004 C8                    DC8     'H'+0x80
 5497    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5498    00000008 ........              DC32    FISH_ONLY_NFA
 5499                           FISH:
 5500    0000000C ........              DC32    DOCOL
 5501    00000010 ........              DC32    FLASH_SCAN
 5502    00000014 ........              DC32    SIGNON
 5503    00000018 ........              DC32    SEMIS
 5504                           
 5505                           //=============================== WORDCAT ====================================//
 5506                           //NOEXEC HEADERFORWORDCATEGORIES
 5507                           //      WC_FISH_PubRel: = FISH Reference Model: CATEGORY
 5508                            SECTION .text : CONST (2)
 5509                           WC_FISH_PubRel_NFA:
 5510    00000000 99                    DC8     0x80+4+21        // +4 is format chars constant
 5511                                                           // +n is Name lenght
 5512    00000001 0D0A                  DC8     0x0D, 0x0A
 5513    00000003 4649534820526         DC8     'FISH Reference Model:'
                  5666572656E63
                  65204D6F64656
                  C3A          
 5514    00000018 0D8A                  DC8     0x0D, 0x0A+0x80
 5515    0000001A FFFF           ALIGNROM 2,0xFFFFFFFF
 5516    0000001C ........              DC32    FISH_NFA
 5517                           
 5518                           ;**** FIRST WORD LISTED****
 5519                           
 5520                           //=============================== WORDCAT ====================================//
 5521                           
 5522                           #ifdef FISH_STM_M3_PRO_WORDCAT
 5524                           #endif
 5525                           //=============================== WORDCAT ====================================//
 5526                           
 5527                           #ifdef FISH_STM32F4_GPIO
 5529                           #endif
 5530                           // FIRST WORDCAT
 5531                           
 5532                           //------------------------------------------------------------------------------
 5533                           // FOR MULTI TASKING MUST BE PLACED IN RAM AND OFFSET USED IN SYSTEM VARS!!!!!!
 5534                           //            T A S K 
 5535                           //
 5536                           ;.data          // Place TASK at beginning of RAM, or not.
 5537                           /*
 5538                            SECTION .text : CONST (2)
 5539                           TASK_NFA:
 5540                                   DC8     0x84
 5541                                   DC8     'TAS'
 5542                                   DC8     'K'+0x80
 5543                            ALIGNROM 2,0xFFFFFFFF
 5544                           //      TASK Is top of dictionary until new definitionsa added
 5545                           //      PATCH CONTEXT or LATEST else LFA in TASK FROM SYM TABLE
 5546                           //      To debug dictionary searches - see - PFIND & DFIND
 5547                           //      DC32    ZEQU_NFA        // 4 (no match) bombing at +
 5548                           //      DC32    NOOP_NFA        // Patch here to shorten test of PFIND
 5549                           //      DC32    CAT_NFA         // C@ before @
 5550                           //      DC32    LESS_NFA        // < before =
 5551                           //       DC32   SoCinit_NFA     //XON_NFA               // FULL DICT SEARCH
 5552                                   DC32    MS_NFA
 5553                           TASK:
 5554                                   DC32    DOCOL
 5555                                   DC32    SEMIS
 5556                           */
 5557                           
 5558                           //------------------------------------------------------------------------------
 5559                           //:NONAME SECTION:
 5560                           // THESE STAY HERE (INSTEAD OF SLLIB) BECAUSE THEY ARE CONDITIONALLY INCLUDED
 5561                           // HI-LEVEL THEM ASM SECTIONS
 5562                           #ifdef IO2TP
 5571                           #endif
 5572                           
 5573                           #ifdef IO2TP
 5582                           #endif
 5583                           
 5584                           #ifdef USE_CMAIN
 5594                           #endif
 5595                           
 5596                           #ifdef TESTRAM
 5702                           #endif  // TESTRAM
 5703                           //------------------------------------------------------------------------------
 5704                           // Placing blocks that can change at end of link map
 5705                           // Place :NONAME for static Library first in FISH_STM_M3_SLIB.s
 5706                           
 5707                           // $PROJ_DIR$\..\FISH_RM_COMMON
 5708                           // $PROJ_DIR$\..\FISH_RM_CORTEX_M_COMMON_CODE
 5709                           // In Assembler preprocessor set additional include directories 
 5710                           $FISH_RM_MSGS.h
 5711                           // equals below
 5712                           //#include ".\..\FISH_COMMON_CODE\FISH_RM_MSGS.h"
 5713                           
 5714                           // SYSTEMCLOCK #define set in FISH_M0_EQUATES.s for SYSCLOCK value.
 5715                           // THIS IS A :NONAME WORDSET
 5716                           
 5717                           $FISH_STM32F4_SOC_INIT.s
 5718                           
 5719                            END
##############################
#           CRC:0            #
#        Errors:   0         #
#        Warnings: 0         #
#        Bytes: 83963        #
##############################




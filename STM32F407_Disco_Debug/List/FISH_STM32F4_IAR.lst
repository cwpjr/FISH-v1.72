###################################################################################################
#                                                                                                 #
#     IAR Assembler V8.22.1.15669/W32 for ARM 24/Apr/2018  15:00:24                               #
#     Copyright 1999-2018 IAR Systems AB.                                                         #
#                                                                                                 #
#           Source file   =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\FISH_STM32F4_IAR.s   #
#           List file     =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\List\FISH_STM32F4_IAR.lst#
#           Object file   =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\Obj\FISH_STM32F4_IAR.o#
#           Command line  =  -f C:\Users\CLYDEW~1\AppData\Local\Temp\EW31A0.tmp                   #
#                            (C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\FISH_STM32F4_IAR.s  #
#                            -OC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\Obj #
#                            -s+ -M<> -w+ -r -DFISH_PubRel_WORDSET -DFISH_Debug_WORDSET           #
#                            -DSTM32F4_XRC08_168MHZ                                               #
#                            -LC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\List #
#                            -t8 --cpu Cortex-M4 --fpu VFPv4_sp                                   #
#                            -IC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\..\FISH_Libs\FISH_RM_COMMON\ #
#                            -IC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\..\FISH_Libs\FISH_RM_COMMON_CODE_CORTEX_M\) #
#                                                                                                 #
###################################################################################################

    1                           // FISH_STM32F4_IAR.s - FULL WORD v1.7.2
    2                           // FISH FOR THE STM IS CURRENTLY SUPPORTING F2 TO F4
    3                           // Code is common, seperate linker files used for memory map differences.
    4                           $FISH_STM32F4_MAIN_INCLUDES.h
    5                           //------------------------------------------------------------------------------
    6                           
    7                           // 2DO: Add VIO_UARTX, VIO_KEY, VIO_?KEY and VIO_EMIT
    8                           // (EMIT), (KEY?), and (KEY).
    9                           
   10                           // v1.8 4th tos/nos caching
   11                           
   12                           // v1.7.2 Fixed backspace issue
   13                           
   14                           // v1.7.1:
   15                           
   16                           // Fix NUMBER by merge with NXP which works correctly!
   17                           // 2DO: Restore SYSTICK ISR to ASM version
   18                           // 2DO: Signon updated. (FOR TEST - FIX B4 SHIP)
   19                           // 2DO: Updated .hex .out and sym.bat
   20                           
   21                           // #define EOL_DLE // DLE 0x10/16d in QUIT>CR after last word interpreted.
   22                           // #define EOL_NAK // NAK 0x15/21d in error messages for STDLED editor highlight
   23                           // The EOL_NAK makes SPACE NAK end of string in FISH_RM_MSGS.h
   24                           
   25                           // Split out files to FISH_RM_COMMON and FISH_RM_COMMON_CODE_CORTEX_M
   26                           
   27                           // ADDED EHON and EHOFF to FISH RM
   28                           // Changes iar.s COLD, ERROR and ABORT
   29                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM:
   30                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - ERROR_HALT: SV 
   31                           
   32                           // ADDED P(PROMPT), PON(PROMPTON) and POFF(PROMPTOFF) to FISH RM
   33                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM: & QUIT:
   34                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - PROMPT: SV 
   35                           
   36                           // Added #define TRUE_EQU_NEG_ONE
   37                           // Changed all user visible true flags to -1
   38                           
   39                           // Added SXTB Rd, Rm  and SXTH Rd, Rm
   40                           
   41                           // Number Stuff Wordcat reorganized (search NOEXEC or WC_NUMBERS_NFA)
   42                           // EXPECT does counted null strings:
   43                           // NUMBER to look for null terminatiion instead of BLANK.
   44                           // WORD changed to expect null string and elimated BLANKS fill of HERE.
   45                           //      SPEEDS UP TOKENIZATION OF TIB INPUT!
   46                           // ALL IN AND IN_SV INIT SET TO 1 in QUERY SV_INIT_VALUES CLRTIB
   47                           // NUMBERSUFFIX changed to replace suffix with null
   48                           // PAREN ( changed to use TIB+1
   49                           // DPL restored to dictionairy.
   50                           
   51                           //------------------------------------------------------------------------------
   52                            SECTION .text : CONST (2)
   53                           msg_FISH:
   54                           // DC8 "?" IS A NULL TERMINATED STRING
   55                           // DC8 '?' IS NOT
   56                           //#if FISH_PubRel_WORDSET | FISH_DebugSrc_WORDSET
   57    00000000 4649534820415         DC8     'FISH ARM '
                  24D20        
   58                           //#endif
   59                           #if FISH_PubRel_WORDSET & FISH_Debug_WORDSET
   60    00000009 20313031302C3         DC8     ' 1010,1100 - EHON/EHOFF '
                  1313030202D20
                  45484F4E2F454
                  84F464620    
   61                           //        DC8     '-1 True Flag '
   62                           #endif
   63                           #if VTOR_PATCH & STM32F205RC
   65                           #endif
   66                           #ifdef FISH_Debug_WORDSET
   67    00000021 4465627567537         DC8     'DebugSrc '
                  26320        
   68                           #endif
   69                           #ifdef  STM32F4_XRC08_168MHZ
   70    0000002A 53544D3332463         DC8     'STM32F407VG DISCO @168Mhz '
                  4303756472044
                  4953434F20403
                  136384D687A20
   71                           #endif
   72                           #ifdef STM32F205RC_XRC10_118MHZ
   74                           #endif
   75                           #ifdef FISH_PRO_WORDCAT
   77                           #endif
   78    00000044 524D2056312E3         DC8     'RM V1.7.2 (C)2014-2018 A-TEAM FORTH : '
                  72E3220284329
                  323031342D323
                  0313820412D54
                  45414D20464F5
                  25448203A20  
   79    0000006A 4170722032342         DC8     __DATE__        // Null string
                  03230313800  
   80                           msg_FISH_TIMESTAMP:
   81    00000076 20617420              DC8     ' at '
   82    0000007A 31353A30303A3         DC8     __TIME__        // Null string
                  23400        
   83                           #ifdef EOL_NAK
   84                           msg_SIGNON_DLE:
   85    00000083 1500                  DC8     0x15, 0
   86                           #endif
   87                           msg_MY_OK:
   88    00000085 206F6B2C20676         DC8     " ok, go fish in BASE "
                  F206669736820
                  696E204241534
                  52000        
   89                           //-----------------START OF DICTIONARY = Last word in search--------------------
   90                           // Conditionally include FISH_STM32F4_Peripheral_Register_ADDRS.h include here
   91                           #ifdef FISH_STM32F4_Peripheral_Register_ADDRS
   92                           $FISH_STM32F4_Peripheral_Register_ADDRS.h
   93                           // If included link below will point to the GPIO WORDCAT
   94                           #endif
   95                           // 
   96                           //      NOOP NOOP:      ( -- )
   97                            SECTION .text : CONST (2)
   98                           NOOP_NFA:
   99    00000000 84                    DC8     0x84
  100    00000001 4E4F4F                DC8     'NOO'
  101    00000004 D0                    DC8     'P'+0x80
  102    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  103                           #ifdef FISH_STM32F4_Peripheral_Register_ADDRS
  104    00000008 ........              DC32    WC_FISH_Peripheral_REG_ADDR_GPIO
  105                           #else
  107                           #endif
  108                           NOOP:
  109    0000000C ........              DC32    .+5
  110                            SECTION .text : CODE (2)
  111                                   NEXT
  111.1                         // ARMv7-M Thumb = .+5
  111.2  00000000 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  111.3                         // ARMv6-M Thumb = .+4
  111.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  111                                   NEXT1
  111.1  00000004 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  111.2  00000008 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  111.3  0000000C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  111.4                         // ARMv6-M Thumb = .+4
  111.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  111.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  111.7                                 ENDM
  111.8                                 ENDM
  112                           
  113                           
  114                           //      EXECUTE EXEC:   ( cfa -- ) RENAMED: EXECUTE to EXEC
  115                           //      Execute a single word whose cfa is on the stack
  116                           
  117                            SECTION .text : CONST (2)
  118                           EXEC_NFA:
  119    00000000 87                    DC8     0x87
  120    00000001 455845435554          DC8     'EXECUT'
  121    00000007 C5                    DC8     'E'+0x80
  122                            ALIGNROM 2,0xFFFFFFFF
  123    00000008 ........              DC32    NOOP_NFA
  124                           EXEC:
  125    0000000C ........              DC32    .+5
  126                            SECTION .text : CODE (2)
  127                           #ifndef IO2TP
  128                           #ifdef XON_XOFF
  129    00000000 ........              BL      TXRDY_SUBR
  130    00000004 ........              BL      XOFF_SUBR
  131                           #endif
  132                           #endif
  133                           EXEC_ACTION:
  134                                   POPp2w // as in xeq token at ToS setup for exec LDM     p!, {w}
  134.1                                 // as in xeq token on ToS setup for exec
  134.2  00000008 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
  134.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
  134.4                                 ENDM
  135                                   NEXT1
  135.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  135.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  135.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  135.4                         // ARMv6-M Thumb = .+4
  135.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  135.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  135.7                                 ENDM
  136                           
  137                           #ifndef IO2TP
  138                           // TXRDY_SUBR:
  139                            SECTION .text : CODE (2)
  140                           TXRDY_SUBR:
  141    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  142    00000002 024C                  LDR     y, = USART3_SR  // Line Status Register
  143                           txRDY?:
  144    00000004 2168                  LDR     n, [y]          // Get Line Status
  145                           // THIS IS TXE TEST AND FAILS IN TEXT DOWNLOAD
  146                           //        LSRS    n, n, #7      // 80h Bit 7 TXE: Transmit data register empty
  147                           // THIS IS ___ AND WORKS IN TEXT DOWNLOAD
  148    00000006 090A                  LSRS    n, n, #8        // 100h Bit 8 ORIG
  149    00000008 FCD3                  BCC     txRDY?          // Ready
  150    0000000A 1047                  BX      w               // lr  - SUBR RETURN
  151                           
  152                           // XOFF_SUBR:
  153                           #ifdef XON_XOFF
  153.1                                  TABLE
  153.2  0000000C 00480040              Reference on line 142
  154                            SECTION .text : CODE (2)
  155                           XOFF_SUBR:
  156    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  157    00000002 0249                  LDR     n,= USART3_DR
  158    00000004 1324                  LDR     y,  = XOFF_CHAR
  159    00000006 0C70                  STRB    y, [n]
  160    00000008 1047                  BX      w               // lr  - SUBR RETURN
  161                           #endif // XON_XOFF
  162                           
  163                           // XON_SUBR:
  164                           #ifdef XON_XOFF
  164.1                                  TABLE
  164.2  0000000C 04480040              Reference on line 157
  165                            SECTION .text : CODE (2)
  166                           XON_SUBR:
  167    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  168    00000002 0249                  LDR     n,= USART3_DR
  169    00000004 1124                  LDR     y, = XON_CHAR   // preserve TOS 11 24 01 49
  170    00000006 0C70                  STRB    y, [n]
  171    00000008 1047                  BX      w       //lr              // SUBR RETURN
  172                           #endif // XON_XOFF
  173                           #endif // IO2TP
  174    0000000A 0000           LTORG
  174.1                                  TABLE
  174.2  0000000C 04480040              Reference on line 168
  175                           
  176                           //      BL BLANK:       ( -- n )
  177                           //      Push ascii space character as n to TOS.
  178                           
  179                            SECTION .text : CONST (2)
  180                           BLANK_NFA:
  181    00000000 82                    DC8     0x82
  182    00000001 42                    DC8     'B'
  183    00000002 CC                    DC8     'L'+0x80
  184    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  185    00000004 ........              DC32    EXEC_NFA
  186                           BLANK:
  187    00000008 ........20000         DC32    DOCON, 0x20
                  000          
  188                           
  189                           
  190                           //========================= START SYSTEM VARIABLES ===========================//
  191                           // _SV IS cfa label of WORD's that return their address.
  192                           // MODIFIED ALL to be label based vs. offset based.
  193                           
  194                           
  195                           //      UP UP_SV:       ( -- addr of UP ) Value stored here is ALIGNED
  196                           //      A system variable, the RAM VAR pointer, which contains
  197                           //      the address of the next free memory above in the USERRAMSPACE.
  198                           //      The value may be read by .UV and altered by VAR.
  199                           
  200                            SECTION .text : CONST (2)
  201                           UP_NFA:
  202    00000000 82                    DC8     0x82
  203    00000001 55                    DC8     'U'
  204    00000002 D0                    DC8     'P'+0x80
  205    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  206    00000004 ........              DC32    BLANK_NFA
  207                           UP_SV:
  208    00000008 .............         DC32    DOCON, UP
                  ...          
  209                           
  210                           
  211                           //      FENCE FENCE_SV: ( -- addr of FENCE )
  212                           //      A system variable containing an address below which FORGET ting is
  213                           //      trapped. To forget below this point the system must alter the contents
  214                           //      of FENCE.
  215                           
  216                            SECTION .text : CONST (2)
  217                           FENCE_NFA:
  218    00000000 85                    DC8     0x85
  219    00000001 46454E43              DC8     'FENC'
  220    00000005 C5                    DC8     'E'+0x80
  221    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  222    00000008 ........              DC32    UP_NFA
  223                           FENCE_SV:
  224    0000000C .............         DC32    DOCON, FENCE
                  ...          
  225                           
  226                           
  227                           //      DP DP_SV:       ( -- addr of DP ) Value stored here is ALIGNED
  228                           //      A system variable, the dictionary pointer, which contains the address
  229                           //      of the next free memory above the dictionary. The value may be read
  230                           //      by HERE and altered by COMMA (ALIGNED) , ALLOT and CALLOT (UNALIGNED) .
  231                           
  232                            SECTION .text : CONST (2)
  233                           DP_NFA:
  234    00000000 82                    DC8     0x82
  235    00000001 44                    DC8     'D'
  236    00000002 D0                    DC8     'P'+0x80
  237    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  238    00000004 ........              DC32    FENCE_NFA
  239                           DP_SV:
  240    00000008 .............         DC32    DOCON, DP
                  ...          
  241                           
  242                           
  243                           //      BASE BASE_SV:   ( -- addr of NBASE )
  244                           //      A system variable containing the current number base used for input
  245                           //      and output conversion.
  246                           
  247                            SECTION .text : CONST (2)
  248                           BASE_NFA:
  249    00000000 84                    DC8     0x84
  250    00000001 424153                DC8     'BAS'
  251    00000004 C5                    DC8     'E'+0x80
  252    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  253    00000008 ........              DC32    DP_NFA
  254                           BASE_SV:
  255    0000000C .............         DC32    DOCON, NBASE
                  ...          
  256                           
  257                           
  258                           //      CURRENT CURRENT_SV:     ( -- addr of CURRENT )
  259                           //      CURRENT searched everytime. CONTEXT is not used
  260                           //      Used by Create, Definitions, etc and by Latest
  261                           //      to leave the nfa of the topmost word in the CURRENT
  262                           //      vocabulary.  See LATEST NOTE:(FIG) CURR @ @ this CURR @
  263                           
  264                            SECTION .text : CONST (2)
  265                           CURRENT_NFA:
  266    00000000 87                    DC8     0x87
  267    00000001 43555252454E          DC8     'CURREN'
  268    00000007 D4                    DC8     'T'+0x80
  269                            ALIGNROM 2,0xFFFFFFFF
  270    00000008 ........              DC32    BASE_NFA
  271                           CURRENT_SV:
  272    0000000C .............         DC32    DOCON, CURRENT  // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
                  ...          
  273                           
  274                           
  275                           //      STATE STATE_SV: ( -- addr of CSTATE )
  276                           //      A system variable containing the compilation state. A non-zero value
  277                           //      indicates compilation. The value itself may be implementation
  278                           //      dependent. 0xC0 must be used for INTERPRET to execute IMMEDIATE words.
  279                           
  280                            SECTION .text : CONST (2)
  281                           STATE_NFA:
  282    00000000 85                    DC8     0x85
  283    00000001 53544154              DC8     'STAT'
  284    00000005 C5                    DC8     'E'+0x80
  285    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  286    00000008 ........              DC32    CURRENT_NFA
  287                           STATE_SV:
  288    0000000C .............         DC32    DOCON, CSTATE       //Compile STATE
                  ...          
  289                           
  290                           
  291                           //      OUT OUT_SV:     ( -- addr of OUT )
  292                           //      A system variable that contains a value incremented by EMIT. The system
  293                           //      may alter and examine OUT to control display formating.
  294                           
  295                            SECTION .text : CONST (2)
  296                           OUT_NFA:
  297    00000000 83                    DC8     0x83
  298    00000001 4F55                  DC8     'OU'
  299    00000003 D4                    DC8     'T'+0x80
  300                            ALIGNROM 2,0xFFFFFFFF
  301    00000004 ........              DC32    STATE_NFA
  302                           OUT_SV:
  303    00000008 .............         DC32    DOCON, OUT
                  ...          
  304                           
  305                           
  306                           //      IN IN_SV:       ( -- addr of IN )
  307                           //      A system variable containing the byte offset within (TIB),
  308                           //      from which the tokens are parsed by WORD and moved to HERE,
  309                           //      as a counted null terminated string (created by EXPECT).
  310                           //      Initialized to 1 to skip count byte produced by EXPECT.
  311                           
  312                            SECTION .text : CONST (2)
  313                           IN_NFA:
  314    00000000 82                    DC8     0x82
  315    00000001 49                    DC8     'I'
  316    00000002 CE                    DC8     'N'+0x80
  317    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  318    00000004 ........              DC32    OUT_NFA
  319                           IN_SV:
  320    00000008 .............          DC32   DOCON, IN
                  ...          
  321                           
  322                           
  323                           //      PAD PAD_SV:     ( -- addr of PAD )
  324                           //      Leave the address of the text output buffer PAD on the stack.
  325                           //      Typically at least 82 bytes long.
  326                           
  327                            SECTION .text : CONST (2)
  328                           PAD_NFA:
  329    00000000 83                    DC8     0x83
  330    00000001 5041                  DC8     'PA'
  331    00000003 C4                    DC8     'D'+0x80
  332                            ALIGNROM 2,0xFFFFFFFF
  333    00000004 ........              DC32    IN_NFA
  334                           PAD_SV:
  335    00000008 .............         DC32    DOCON, PAD
                  ...          
  336                           
  337                           
  338                           //      TIB TIB_SV:     ( -- addr of INITTIB )
  339                           //      Leave the address of the text input buffer TIB on the stack.
  340                           //      Typically at least 82 bytes long.
  341                           
  342                            SECTION .text : CONST (2)
  343                           TIB_NFA:
  344    00000000 83                    DC8     0x83
  345    00000001 5449                  DC8     'TI'
  346    00000003 C2                    DC8     'B'+0x80
  347                            ALIGNROM 2,0xFFFFFFFF
  348    00000004 ........              DC32    PAD_NFA
  349                           TIB_SV:
  350    00000008 .............         DC32    DOCON, TIB
                  ...          
  351                           
  352                           
  353                           //======================== END SYSTEM VARIABLES ==============================//
  354                           
  355                           
  356                           //      HERE HERE:      ( -- addr ) Value stored here is ALIGNED
  357                           //      Leave the address of the next available dictionary location.
  358                           
  359                            SECTION .text : CONST (2)
  360                           HERE_NFA:
  361    00000000 84                    DC8     0x84
  362    00000001 484552                DC8     'HER'
  363    00000004 C5                    DC8     'E'+0x80
  364    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  365    00000008 ........              DC32    TIB_NFA
  366                           HERE:
  367    0000000C ........              DC32    DOCOL
  368    00000010 ........              DC32    DP_SV
  369    00000014 ........              DC32    AT
  370    00000018 ........              DC32    SEMIS
  371                           
  372                           
  373                           //      ALLOT ALLOT:    ( sn -- ) Warning: UNALIGNED:
  374                           //      IF DICTIONAIRY FULL PRINT error MESSAGE AND abort.
  375                           //      Add the signed number to the dictionary pointer DP. May be used to
  376                           //      reserve dictionary space or re-origin memory.
  377                           //      CAUTION!
  378                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  379                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  380                           
  381                            SECTION .text : CONST (2)
  382                           ALLOT_NFA:
  383    00000000 85                    DC8     0x85
  384    00000001 414C4C4F              DC8     'ALLO'
  385    00000005 D4                    DC8     'T'+0x80
  386    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  387    00000008 ........              DC32    HERE_NFA
  388                           ALLOT:
  389    0000000C ........              DC32    DOCOL
  390    00000010 ........              DC32    DICTSPACE       // \ -- n
  391    00000014 .............         DC32    OVER, SUBB
                  ...          
  392    0000001C ........              DC32    ZLESS
  393    00000020 ........              DC32    ZBRAN
  394    00000024 08000000              DC32    ALLOTOK-.
  395                           
  396    00000028 ........              DC32    DICTFULL_ABORT
  397                           
  398                           ALLOTOK:
  399    0000002C ........              DC32    DP_SV
  400    00000030 ........              DC32    PSTORE
  401    00000034 ........              DC32    SEMIS
  402                           
  403                           
  404                           //      ALIGNED ALIGNED:        ( addr -- a-addr ) DPANS94
  405                           
  406                            SECTION .text : CONST (2)
  407                           ALIGNED_NFA:
  408    00000000 87                    DC8     0x87
  409    00000001 414C49474E45          DC8     'ALIGNE'
  410    00000007 C4                    DC8     'D'+0x80
  411                            ALIGNROM 2,0xFFFFFFFF
  412    00000008 ........              DC32    ALLOT_NFA
  413                           ALIGNED:
  414    0000000C ........              DC32    .+5
  415                            SECTION .text : CODE (2)
  416                                   POP2t
  416.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  416.2                         //#ifndef TOSCT
  416.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  416.4                         //#endif
  416.5                         //      ADDS    p, p, #4
  416.6                                 ENDM
  417    00000004 C01C                  ADDS    t, t, #3
  418    00000006 0549                  LDR     n, =-4
  419    00000008 0840                  ANDS    t, t, n
  420                                   TPUSH
  420                                   PUSHt   // push t to p, pre decrement p
  420.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  420.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  420.3                         //      STR     t, [p]
  420.4                                 ENDM
  420                                   NEXT
  420.1                         // ARMv7-M Thumb = .+5
  420.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  420.3                         // ARMv6-M Thumb = .+4
  420.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  420                                   NEXT1
  420.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  420.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  420.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  420.4                         // ARMv6-M Thumb = .+4
  420.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  420.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  420.7                                 ENDM
  420.8                                 ENDM
  420.9                                 ENDM
  421                            LTORG
  421.1                                  TABLE
  421.2  0000001C FCFFFFFF              Reference on line 418
  422                           
  423                           
  424                           //      ALIGN32_DP_FF_PAD ALIGN:        ( -- ) DPANS94
  425                           //      Align DP_SV primitive. Pads current DP with 0xFF until aligned.
  426                           //      USED IN , (COMMA:) .  Reflected by HERE .
  427                           //      CAUTION! USE AFTER ALLOT or C, (CCOMMA:) .
  428                           //      See , (COMMA:) which is ALIGNED.
  429                           
  430                            SECTION .text : CONST (2)
  431                           ALIGN_NFA:
  432    00000000 85                    DC8     0x85
  433    00000001 414C4947              DC8     'ALIG'
  434    00000005 CE                    DC8     'N'+0x80
  435    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  436    00000008 ........              DC32    ALIGNED_NFA
  437                           ALIGN:
  438                           ALIGN32_DP_FF_PAD:
  439    0000000C ........              DC32    DOCOL
  440    00000010 ........              DC32    HERE
  441                                   // COULD ADD CODE TO SEE IF ALIGNED ALREADY
  442    00000014 .............         DC32    THREE, PLUS             // 3PLUS
                  ...          
  443    0000001C .............         DC32    DUP, TOR
                  ...          
  444    00000024 ........              DC32    HERE
  445    00000028 ........              DC32    XDO
  446                           ALIGN_PAD_DO:
  447    0000002C ........FF000         DC32    LIT, 0xFF, I, CSTORE
                  000..........
                  ......       
  448    0000003C ........              DC32    XLOOP
  449    00000040 ECFFFFFF              DC32    ALIGN_PAD_DO-.
  450                           
  451    00000044 ........              DC32    RFROM
  452    00000048 ........FCFFF         DC32    LIT, 0xFFFFFFFC // -4
                  FFF          
  453    00000050 ........              DC32    ANDD
  454    00000054 .............         DC32    DP_SV, STORE
                  ...          
  455    0000005C ........              DC32    SEMIS
  456                           
  457                           
  458                           //      , COMMA:        ( n -- ) ALIGNED
  459                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  460                           //      Write n into next ALIGNED dictionary memory cell, DP reflected by HERE
  461                           
  462                            SECTION .text : CONST (2)
  463                           COMMA_NFA:
  464    00000000 81                    DC8     0x81
  465    00000001 AC                    DC8     ','+0x80
  466    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  467    00000004 ........              DC32    ALIGN_NFA
  468                           COMMA:
  469    00000008 ........              DC32    DOCOL
  470    0000000C ........              DC32    DICTSPACE       // \ -- n
  471    00000010 ........              DC32    ZLESS
  472    00000014 ........              DC32    ZBRAN
  473    00000018 08000000              DC32    COMMA_OK-.
  474                           
  475    0000001C ........              DC32    DICTFULL_ABORT
  476                           
  477                           COMMA_OK:
  478    00000020 ........              DC32    COMMA_PRIM
  479    00000024 ........              DC32    SEMIS
  480                           
  481                           
  482                           //      C, CCOMMA:      ( n -- ) Warning: UNALIGNED:
  483                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  484                           //      Store LS 8 bits of n into the next available dictionary byte, advancing
  485                           //      the dictionary pointer.
  486                           //      CAUTION!
  487                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  488                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  489                           //      See , (COMMA:) which is ALIGNED.
  490                           
  491                            SECTION .text : CONST (2)
  492                           CCOMMA_NFA:
  493    00000000 82                    DC8     0x82
  494    00000001 43                    DC8     'C'
  495    00000002 AC                    DC8     ','+0x80
  496    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  497    00000004 ........              DC32    COMMA_NFA
  498                           CCOMMA:
  499    00000008 ........              DC32    DOCOL
  500    0000000C ........              DC32    DICTSPACE       // \ -- n
  501    00000010 ........              DC32    ZLESS
  502    00000014 ........              DC32    ZBRAN
  503    00000018 08000000              DC32    CCOMMA_OK-.
  504                           
  505    0000001C ........              DC32    DICTFULL_ABORT
  506                           
  507                           CCOMMA_OK:
  508    00000020 ........              DC32    HERE
  509    00000024 ........              DC32    CSTORE
  510    00000028 ........              DC32    ONE
  511    0000002C ........              DC32    ALLOT_PRIM
  512    00000030 ........              DC32    SEMIS
  513                           
  514                           
  515                           //      VARALLOT VARALLOT:      ( n -- addr ) Value stored here is ALIGNED
  516                           //      IF USERVAR SPACE FULL PRINT Error MESSAGE AND Abort.
  517                           //      Add n * 32 bits to the RAMVARSPACE pointer UP.
  518                           //      Used to allocate space in Ram for VAR's and other system data structures
  519                           
  520                            SECTION .text : CONST (2)
  521                           VARALLOT_NFA:
  522    00000000 88                    DC8     0x88
  523    00000001 564152414C4C4         DC8     'VARALLO'
                  F            
  524    00000008 D4                    DC8     'T'+0x80
  525    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  526    0000000C ........              DC32    CCOMMA_NFA
  527                           VARALLOT:
  528    00000010 ........              DC32    DOCOL
  529    00000014 ........              DC32    VARSPACE                // \ -- n
  530    00000018 .............         DC32    FOUR, SLASH, OVER, SUBB
                  .............
                  ......       
  531    00000028 ........              DC32    ZLESS
  532    0000002C ........              DC32    ZBRAN
  533    00000030 18000000              DC32    VALLOT_OK-.
  534                           
  535    00000034 .............         DC32    LIT, msg_uvfull
                  ...          
  536    0000003C .............         DC32    NULLSTRLEN, TYPE
                  ...          
  537                           #ifdef IO2TP
  541                           #endif
  542    00000044 ........              DC32    ABORT
  543                           
  544                           VALLOT_OK:
  545    00000048 .............         DC32    UP_SV, AT       // Address of this allotment
                  ...          
  546    00000050 ........              DC32    SWAP            // n
  547    00000054 .............         DC32    FOUR, STAR      // n = 4 bytes
                  ...          
  548    0000005C ........              DC32    UP_SV
  549    00000060 ........              DC32    PSTORE          // Address of next var available
  550    00000064 ........              DC32    SEMIS
  551                           
  552                           
  553                           //      LATEST LATEST: ( -- nfa )
  554                           //      Initially ADDR OF LAST WORD IN THE DICTIONARY
  555                           //      Leave the nfa of the topmost word in the dictionary.
  556                           
  557                            SECTION .text : CONST (2)
  558                           LATEST_NFA:
  559    00000000 86                    DC8     0x86
  560    00000001 4C41544553            DC8     'LATES'
  561    00000006 D4                    DC8     'T'+0x80
  562    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  563    00000008 ........              DC32    VARALLOT_NFA
  564                           LATEST:
  565    0000000C ........              DC32    DOCOL
  566    00000010 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
  567    00000014 ........              DC32    AT
  568    00000018 ........              DC32    SEMIS
  569                           
  570                           
  571                           //      LFA LFA:        ( pfa -- lfa )
  572                           //      Convert the parameter field address of a dictionary definition to
  573                           //      its link field address.
  574                           
  575                            SECTION .text : CONST (2)
  576                           LFA_NFA:
  577    00000000 83                    DC8     0x83
  578    00000001 4C46                  DC8     'LF'
  579    00000003 C1                    DC8     'A'+0x80
  580                            ALIGNROM 2,0xFFFFFFFF
  581    00000004 ........              DC32    LATEST_NFA
  582                           LFA:
  583    00000008 ........              DC32    .+5
  584                            SECTION .text : CODE (2)
  585                                   POP2t
  585.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  585.2                         //#ifndef TOSCT
  585.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  585.4                         //#endif
  585.5                         //      ADDS    p, p, #4
  585.6                                 ENDM
  586    00000004 0838                  SUBS     t, t, #8
  587                                   TPUSH
  587                                   PUSHt   // push t to p, pre decrement p
  587.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  587.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  587.3                         //      STR     t, [p]
  587.4                                 ENDM
  587                                   NEXT
  587.1                         // ARMv7-M Thumb = .+5
  587.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  587.3                         // ARMv6-M Thumb = .+4
  587.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  587                                   NEXT1
  587.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  587.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  587.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  587.4                         // ARMv6-M Thumb = .+4
  587.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  587.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  587.7                                 ENDM
  587.8                                 ENDM
  587.9                                 ENDM
  588                           
  589                           
  590                           //      CFA CFA:        ( pfa -- cfa )
  591                           //      Convert the parameter field address of a dictionary definition to
  592                           //      its code field address. <if thumb2 execution addr smudged>
  593                           
  594                            SECTION .text : CONST (2)
  595                           CFA_NFA:
  596    00000000 83                    DC8     0x83
  597    00000001 4346                  DC8     'CF'
  598    00000003 C1                    DC8     'A'+0x80
  599                            ALIGNROM 2,0xFFFFFFFF
  600    00000004 ........              DC32    LFA_NFA
  601                           CFA:
  602    00000008 ........              DC32    .+5
  603                            SECTION .text : CODE (2)
  604                                   POP2t
  604.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  604.2                         //#ifndef TOSCT
  604.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  604.4                         //#endif
  604.5                         //      ADDS    p, p, #4
  604.6                                 ENDM
  605    00000004 001F                  SUBS     t, t, #4
  606                                   TPUSH
  606                                   PUSHt   // push t to p, pre decrement p
  606.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  606.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  606.3                         //      STR     t, [p]
  606.4                                 ENDM
  606                                   NEXT
  606.1                         // ARMv7-M Thumb = .+5
  606.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  606.3                         // ARMv6-M Thumb = .+4
  606.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  606                                   NEXT1
  606.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  606.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  606.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  606.4                         // ARMv6-M Thumb = .+4
  606.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  606.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  606.7                                 ENDM
  606.8                                 ENDM
  606.9                                 ENDM
  607                           
  608                           
  609                           //      NFA NFA:        ( pfa -- nfa )
  610                           //      Convert the parameter field address of a definition to its name
  611                           //      field. Modified for nfa alighnment padding
  612                           
  613                            SECTION .text : CONST (2)
  614                           NFA_NFA:
  615    00000000 83                    DC8     0x83
  616    00000001 4E46                  DC8     'NF'
  617    00000003 C1                    DC8     'A'+0x80
  618                            ALIGNROM 2,0xFFFFFFFF
  619    00000004 ........              DC32    CFA_NFA
  620                           NFA:
  621    00000008 ........              DC32    DOCOL
  622    0000000C .............         DC32    EIGHT, SUBB     // Addr OF lfa, DUPED TO TRAVERSE Padding
                  ...          
  623                           
  624                           NFA_ALIGN_BEGIN:
  625    00000014 .............         DC32    ONE, SUBB       // ADDR 1 BEFORE lfa, eliminate padding
                  ...          
  626    0000001C .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  627    00000024 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  628    00000030 ........              DC32    ZBRAN           // UNTIL
  629    00000034 E0FFFFFF              DC32    NFA_ALIGN_BEGIN-.
  630                                       
  631    00000038 ........FFFFF         DC32    LIT,-1          // DIRECTION FOR TRAVERSE = Toward nfa
                  FFF          
  632    00000040 ........              DC32    TRAVERSE                // \ -- addr2
  633    00000044 ........              DC32    SEMIS
  634                           
  635                           
  636                           //      PFA PFA:        ( nfa -- pfa )
  637                           //      Convert the name field address of a compiled definition to its
  638                           //      parameter field address.
  639                           
  640                            SECTION .text : CONST (2)
  641                           PFA_NFA:
  642    00000000 83                    DC8     0x83
  643    00000001 5046                  DC8     'PF'
  644    00000003 C1                    DC8     'A'+0x80
  645                            ALIGNROM 2,0xFFFFFFFF
  646    00000004 ........              DC32    NFA_NFA
  647                           PFA:
  648    00000008 ........              DC32    DOCOL           // \ NFA --
  649    0000000C ........              DC32    ONE             // DIRECTION FOR TRAVERSE = Toward CFA
  650    00000010 ........              DC32    TRAVERSE        // \ NFA 1 -- addr2
  651                           
  652                           PFA_ALIGN_BEGIN:
  653    00000014 ........              DC32    ONEP            // ADDR 1 BEFORE lfa, eliminate padding
  654    00000018 .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  655    00000020 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  656    0000002C ........              DC32    ZBRAN           // UNTIL
  657    00000030 E4FFFFFF              DC32    PFA_ALIGN_BEGIN-.
  658                           
  659    00000034 ........              DC32    EIGHT
  660    00000038 ........              DC32    PLUS
  661    0000003C ........              DC32    SEMIS
  662                           
  663                           
  664                           //      ?ALIGNED QALIGNED: ( value -- )
  665                           //      If value not aligned by 4 issue message and ABORT.
  666                           
  667                            SECTION .text : CONST (2)
  668                           QALIGNED_NFA:
  669    00000000 88                    DC8     0x88
  670    00000001 3F414C49474E4         DC8     '?ALIGNE'
                  5            
  671    00000008 C4                    DC8     'D'+0x80
  672    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  673    0000000C ........              DC32    PFA_NFA
  674                           QALIGNED:
  675    00000010 ........              DC32    DOCOL
  676    00000014 ........03000         DC32    LIT, 3, ANDD
                  000........  
  677    00000020 ........              DC32    ZBRAN           //IF no err leave
  678    00000024 3C000000              DC32     QALIGN_OK-.
  679                           
  680    00000028 ........              DC32    PDOTQ
  681    0000002C 2E                    DC8     46
  682    0000002D 56414C5545204         DC8     'VALUE MUST BE EVEN NOT ODD AND MULTIPLE OF 4! '
                  D555354204245
                  204556454E204
                  E4F54204F4444
                  20414E44204D5
                  54C5449504C45
                  204F462034212
                  0            
  683    0000005B FF             ALIGNROM 2,0xFFFFFFFF
  684    0000005C ........              DC32    ABORT
  685                           
  686                           QALIGN_OK:
  687    00000060 ........              DC32    SEMIS
  688                           
  689                           
  690                           //      ?ERROR QERROR: ( f nullstr -- )
  691                           //      If f NON ZERO type error message (nullstr) and ABORT.
  692                           
  693                            SECTION .text : CONST (2)
  694                           QERROR_NFA:
  695    00000000 86                    DC8     0x86
  696    00000001 3F4552524F            DC8     '?ERRO'
  697    00000006 D2                    DC8     'R'+0x80
  698    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  699    00000008 ........              DC32    QALIGNED_NFA
  700                           QERROR:
  701    0000000C ........              DC32    DOCOL
  702    00000010 ........              DC32    SWAP
  703    00000014 ........              DC32    ZBRAN   //IF no err leave
  704    00000018 10000000              DC32     QERROR_FINISH-.
  705                           
  706    0000001C ........              DC32    ERROR   // nullstr-addr ---  ABORT's
  707    00000020 ........              DC32    BRAN    // ELSE
  708    00000024 08000000              DC32     QERROR_DONE-.
  709                           
  710                           QERROR_FINISH:
  711    00000028 ........              DC32    DROP    //endif
  712                           
  713                           QERROR_DONE:
  714    0000002C ........              DC32    SEMIS
  715                           
  716                           
  717                           //      DIGIT DIGIT:    ( c base -- digit 1 ) (ok)
  718                           //                      ( c base -- 0 (bad)
  719                           //      Converts the ascii character c using base to its binary
  720                           //      equivalent digit, accompanied by a true flag. If the conversion is
  721                           //      invalid, leaves only a false flag.
  722                           
  723                           //      If digit gets 0, space, dot, comma or any non number it returns 0 
  724                           
  725                            SECTION .text : CONST (2)
  726                           DIGIT_NFA:
  727    00000000 85                    DC8     0x85
  728    00000001 44494749              DC8     'DIGI'
  729    00000005 D4                    DC8     'T'+0x80
  730    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  731    00000008 ........              DC32    QERROR_NFA
  732                           DIGIT:
  733    0000000C ........              DC32    .+5
  734                            SECTION .text : CODE (2)
  735                                   POP2w                   // Number base
  735.1  00000000 57F8042B              LDR     w, [p],#4
  735.2                         //      LDR     w, [p]
  735.3                         //      ADDS    p, p, #4
  735.4                                 ENDM
  736                                   POP2t                   // ASCII DIGIT
  736.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
  736.2                         //#ifndef TOSCT
  736.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  736.4                         //#endif
  736.5                         //      ADDS    p, p, #4
  736.6                                 ENDM
  737    00000008 3038                  SUBS   t, t, #'0'
  738    0000000A 13D4                  BMI   DIGI2             // Number error
  739                           
  740    0000000C 0928                  CMP   t, #9
  741    0000000E 02DD                  BLE   DIGI1             // Number = 0 THRU 9
  742                           
  743                                   // Combine?
  744    00000010 C01F                  SUBS   t, t, #7
  745    00000012 0A28                  CMP   t, #10            // Number 'A' THRU 'Z'?
  746    00000014 0EDB                  BLT   DIGI2             // NO
  747                           
  748                           DIGI1:
  749    00000016 9042                  CMP     t, w            // COMPARE Number TO base
  750    00000018 0CDA                  BGE     DIGI2
  751                           
  752    0000001A 0246                  MOV     w, t            // NEW BINARY Number
  753    0000001C 0120                  MOVS    t, #1           // TRUE FLAG
  754                                   DPUSH
  754                                   PUSHw   // push w to p, post decrement p
  754.1  0000001E 47F8042D              STR     w, [p, #-4]!
  754.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  754.3                         //      STR     w, [p]
  754.4                                 ENDM
  754                                   TPUSH
  754                                   PUSHt   // push t to p, pre decrement p
  754.1  00000022 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  754.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  754.3                         //      STR     t, [p]
  754.4                                 ENDM
  754                                   NEXT
  754.1                         // ARMv7-M Thumb = .+5
  754.2  00000026 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  754.3                         // ARMv6-M Thumb = .+4
  754.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  754                                   NEXT1
  754.1  0000002A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  754.2  0000002E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  754.3  00000032 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  754.4                         // ARMv6-M Thumb = .+4
  754.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  754.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  754.7                                 ENDM
  754.8                                 ENDM
  754.9                                 ENDM
  754.10                                ENDM
  755                           
  756                                   // Number error
  757                           DIGI2:
  758    00000034 0020                  MOVS   t, #0            // FALSE FLAG
  759                                   TPUSH
  759                                   PUSHt   // push t to p, pre decrement p
  759.1  00000036 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  759.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  759.3                         //      STR     t, [p]
  759.4                                 ENDM
  759                                   NEXT
  759.1                         // ARMv7-M Thumb = .+5
  759.2  0000003A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  759.3                         // ARMv6-M Thumb = .+4
  759.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  759                                   NEXT1
  759.1  0000003E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  759.2  00000042 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  759.3  00000046 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  759.4                         // ARMv6-M Thumb = .+4
  759.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  759.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  759.7                                 ENDM
  759.8                                 ENDM
  759.9                                 ENDM
  760                           
  761                           
  762                           //      ENCLOSE ENCL:   ( addr1 c -- addr1 n1 n2 n3 )
  763                           //      A text scanning iterative primitive used only in WORD.
  764                           //      IN is used before and after callS for the iteration
  765                           //      Typically TIB + IN = addr1
  766                           //      noop EX: \ TIB   32 -- TIB   0 4 5
  767                           //      NULL EX: \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  768                           //      NULL EX: \ WORD/ENCL -> TIB 1, 0, 20'S
  769                           //      From the text address addr1 and an ascii delimiting character c,
  770                           //      is determined the byte offset to the first non-delimiter character n1,
  771                           //      the offset to the first delimiter after the text n2,
  772                           //      and the offset to the first character not included.
  773                           //      This procedure will not process past an ASCII 'null', treating it
  774                           //      as an unconditional delimiter. NULL termination by EXPECT in QUERY.
  775                           
  776                            SECTION .text : CONST (2)
  777                           ENCL_NFA:
  778    00000000 87                    DC8     0x87
  779    00000001 454E434C4F53          DC8     'ENCLOS'
  780    00000007 C5                    DC8     'E'+0x80
  781                            ALIGNROM 2,0xFFFFFFFF
  782    00000008 ........              DC32    DIGIT_NFA
  783                           ENCL:
  784    0000000C ........              DC32    .+5
  785                            SECTION .text : CODE (2)
  786                                   POP2t                   // TERMINATOR CHAR
  786.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  786.2                         //#ifndef TOSCT
  786.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  786.4                         //#endif
  786.5                         //      ADDS    p, p, #4
  786.6                                 ENDM
  787    00000004 3968                  LDR     n, [p]          // get text address but leave on stack
  788    00000006 0022                  MOVS    w, #0
  789    00000008 521E                  SUBS    w, w, #1        // CHAR  COUNTER
  790    0000000A 491E                  SUBS    n, n, #1        // ADDR -1
  791                           
  792                           //  SCAN TO FIRST NON-TERMINATOR CHARACTER
  793                           //      and PUSH count to stack leaving last 2 params to compute
  794                           ENCL1:
  795    0000000C 491C                  ADDS    n, n, #1        // ADDR+1
  796    0000000E 521C                  ADDS    w, w, #1        // COUNT+1
  797    00000010 0B78                  LDRB    x, [n]
  798    00000012 9842                  CMP     t, x            //CMP   AL,[BX]
  799    00000014 FAD0                  BEQ     ENCL1           //JZ    ENCL1   // WAIT FOR NON-TERMINATOR
  800                                   PUSHw                   //offset to the first non-delimiter character
  800.1  00000016 47F8042D              STR     w, [p, #-4]!
  800.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  800.3                         //      STR     w, [p]
  800.4                                 ENDM
  801                                                           //EXiT is now only DPUSH
  802    0000001A 002B                  CMP     x, #0           //CMP   AH,[BX] // null CHAR?
  803    0000001C 0CD1                  BNE     ENCL2           //JNZ   ENCL2   // NO
  804                           
  805                           // FOUND null BEFORE 1ST NON-TERM CHAR
  806                           // RETURN ok args = NULL EX//
  807                           // \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  808                           //
  809    0000001E 1846                  MOV     t, x
  810    00000020 521C                  ADDS    w, w, #1        // w = offset to the delimiter after the text
  811                                   DPUSH
  811                                   PUSHw   // push w to p, post decrement p
  811.1  00000022 47F8042D              STR     w, [p, #-4]!
  811.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  811.3                         //      STR     w, [p]
  811.4                                 ENDM
  811                                   TPUSH
  811                                   PUSHt   // push t to p, pre decrement p
  811.1  00000026 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  811.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  811.3                         //      STR     t, [p]
  811.4                                 ENDM
  811                                   NEXT
  811.1                         // ARMv7-M Thumb = .+5
  811.2  0000002A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  811.3                         // ARMv6-M Thumb = .+4
  811.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  811                                   NEXT1
  811.1  0000002E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  811.2  00000032 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  811.3  00000036 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  811.4                         // ARMv6-M Thumb = .+4
  811.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  811.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  811.7                                 ENDM
  811.8                                 ENDM
  811.9                                 ENDM
  811.10                                ENDM
  812                           
  813                           //   FOUND FIRST TEXT CHAR - COUNT THE CHARS
  814                           ENCL2:
  815    00000038 491C                  ADDS    n, n, #1        // ADDR+1
  816    0000003A 521C                  ADDS    w, w, #1        //COUNT+1
  817    0000003C 0B78                  LDRB    x, [n]
  818    0000003E 9842                  CMP     t, x            //TERMINATOR CHAR?
  819    00000040 01D0                  BEQ     ENCL4           //YES
  820                           
  821    00000042 002B                  CMP     x, #0           //null CHAR?
  822    00000044 F8D1                  BNE     ENCL2           //NO, LOOP AGAIN
  823                           
  824                           ENCL3:  //   FOUND null AT END OF TEXT
  825                           ENCL4:  //   FOUND TERMINATOR CHARACTER
  826    00000046 1046                  MOV     t, w            // COUNT+1 =
  827    00000048 401C                  ADDS    t, t, #1        // offset to the first character not included
  828                                   DPUSH
  828                                   PUSHw   // push w to p, post decrement p
  828.1  0000004A 47F8042D              STR     w, [p, #-4]!
  828.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  828.3                         //      STR     w, [p]
  828.4                                 ENDM
  828                                   TPUSH
  828                                   PUSHt   // push t to p, pre decrement p
  828.1  0000004E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  828.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  828.3                         //      STR     t, [p]
  828.4                                 ENDM
  828                                   NEXT
  828.1                         // ARMv7-M Thumb = .+5
  828.2  00000052 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  828.3                         // ARMv6-M Thumb = .+4
  828.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  828                                   NEXT1
  828.1  00000056 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  828.2  0000005A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  828.3  0000005E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  828.4                         // ARMv6-M Thumb = .+4
  828.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  828.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  828.7                                 ENDM
  828.8                                 ENDM
  828.9                                 ENDM
  828.10                                ENDM
  829                           
  830                           
  831                           //      0 NULL: ( -- ) IMMEDIATE
  832                           //      Don't return to Interpret, return to Quit at end of a line of input.
  833                           //      Executed at end of TIB when QUERY lenght or CR entered.
  834                           
  835                            SECTION .text : CONST (2)
  836                           NULL_NFA:
  837    00000000 C1                    DC8     0x0C1                   // A BINARY ZER
  838    00000001 80                    DC8     0x80
  839    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  840    00000004 ........              DC32    ENCL_NFA
  841                           NULL:
  842                           //      DC32    SEMIS                   // Actual Semis code below
  843    00000008 ........              DC32    .+5
  844                            SECTION .text : CODE (2)
  845                                   POPr2i  // pop docol saved IP from Rstack
  845.1  00000000 56F8045B              LDR     i, [r],#4       ; pop DOCOL'd IP from Rstack
  845.2                         //      LDR i, [r]              //  pop r to i, post increment r
  845.3                         //      ADDS    r, r, #4
  845.4                                 ENDM
  846                                   NEXT
  846.1                         // ARMv7-M Thumb = .+5
  846.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  846.3                         // ARMv6-M Thumb = .+4
  846.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  846                                   NEXT1
  846.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  846.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  846.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  846.4                         // ARMv6-M Thumb = .+4
  846.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  846.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  846.7                                 ENDM
  846.8                                 ENDM
  847                           
  848                           
  849                           //      WORD WORD:      ( c -- )
  850                           //      Parse the text in TIB , until a delimiter c is found, tokenizing input.
  851                           //      Move the token to HERE, with a count byte and 2 nulls at the end.
  852                           //      Leading occurrences of c are ignored. IN is incremented.
  853                           //      See IN. Usually used inside a definition.
  854                           
  855                            SECTION .text : CONST (2)
  856                           WORD_NFA:
  857    00000000 84                    DC8     0x84
  858    00000001 574F52                DC8     'WOR'
  859    00000004 C4                    DC8     'D'+0x80
  860    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  861    00000008 ........              DC32    NULL_NFA
  862                           WORD:
  863    0000000C ........              DC32    DOCOL
  864                           WORD1:
  865                           //      This is required for number suffix's at least ???
  866                           // NOT WITH NEW COUNTED NULL STRING EXPECT
  867                           //      DC32    HERE, LIT, MAXWORDLEN+2, BLANKS
  868    00000010 ........              DC32    TIB_SV
  869                           WORD2:
  870    00000014 ........              DC32    IN_SV
  871    00000018 ........              DC32    AT
  872    0000001C ........              DC32    PLUS
  873    00000020 ........              DC32    SWAP    // ( TIB+IN CH-DELIM -- )
  874    00000024 ........              DC32    ENCL    // ( TIB+IN 32 -- TIB+IN   0 4 5 )
  875                           WENCL:
  876    00000028 ........              DC32    IN_SV   // encl TOS = end of word offset to be added to IN
  877    0000002C ........              DC32    PSTORE  // TIB+IN   0 4
  878    00000030 ........              DC32    OVER    // 
  879    00000034 ........              DC32    SUBB    // Char cnt going to R and HERE
  880    00000038 ........              DC32    TOR
  881    0000003C ........              DC32    R
  882    00000040 ........              DC32    HERE
  883    00000044 ........              DC32    CSTORE   // CHAR CNT OF word
  884    00000048 ........              DC32    PLUS
  885    0000004C ........              DC32    HERE
  886    00000050 ........              DC32    ONEP
  887                           //      DC32    RFROM
  888                           // MOVE word TO DICT FOR finding ENDING WITH NULLS
  889    00000054 ........              DC32    R
  890    00000058 ........              DC32    CMOVE   // ( from to count -- )
  891                           // add null to end of token - NUMBER adjusted        
  892    0000005C .............         DC32    ZERO, HERE, ONEP, RFROM, PLUS, CSTORE
                  .............
                  .............
                  .........    
  893                           #ifdef  IOBUFS_DEBUG
  895                           #endif        
  896    00000074 ........              DC32    SEMIS
  897                           
  898                           
  899                           //      NUMBER NUMBER:  ( addr -- sd )
  900                           //      If error print message and ABORT.
  901                           //      Convert a character string left at addr with a preceeding count,
  902                           //      and a terminating null, to a signed number, in the current numeric base.
  903                           //      If a decimal point is encountered in the text, its position will be
  904                           //      given in DPL, but no other effect occurs. If numeric conversion is
  905                           //      not possible, an error message will be given.
  906                           
  907                           //      Added support for , as a single number formatter.
  908                           
  909                           #define comma_test
  910                           
  911                            SECTION .text : CONST (2)
  912                           NUMBER_NFA:
  913    00000000 86                    DC8     0x86
  914    00000001 4E554D4245            DC8     'NUMBE'
  915    00000006 D2                    DC8     'R'+0x80
  916    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  917    00000008 ........              DC32    WORD_NFA
  918                           NUMBER:
  919    0000000C ........              DC32    DOCOL
  920    00000010 ........              DC32    BASE_TO_R12     // Save current BASE.
  921    00000014 ........              DC32    NUMBERSUFFIX    // (addr -- sddr) Change BASE if suffix used.
  922                           
  923                           // SETUP: stack arguments for PNUMBER.
  924    00000018 .............         DC32    ZERO, ZERO
                  ...          
  925    00000020 ........              DC32    ROT             // ( 0 0 addr -- )
  926                           
  927                           // SETUP: reeturn stack with sign flag
  928                           // NONAME CANDIDATE!
  929                           // START: Handle minus sign by saving status on Return Stack.
  930                           // and incrementing to addr after it.
  931    00000024 .............         DC32    DUP, ONEP       // ( 0 0 addr addr+1 -- )
                  ...          
  932    0000002C ........              DC32    CAT             // ( 0 0 addr 1rstchar -- )
  933    00000030 ........2D000         DC32    LIT, '-'        // ( 0 0 addr 1rstchar 0x2D --- )
                  000          
  934    00000038 ........              DC32    EQUAL           // ( 0 0 addr f -- )
  935                           #ifdef TRUE_EQU_NEG_ONE         // EQUAL returns -1 NEED 0 or 1 here!
  936    0000003C .............         DC32    ONE, ANDD       // ( 0 0 addr f -- ) MAKE FLAG ONE OR ZERO!
                  ...          
  937                           #endif
  938    00000044 .............         DC32    DUP, TOR        // ( 0 0 addr f -- ) copy of f >R
                  ...          
  939                           // END: Handle - by saving status on Return Stack.
  940                           
  941                           // SETUP: addr pointing to 1rst digit.
  942                           // If minus sign, flag from above will increment to next char.
  943    0000004C ........              DC32    PLUS            // Increment (OR NOT) addr to next char
  944                           
  945                           // So could be at 1rst OR 2nd character in string here!
  946                           
  947                           // ENTER LOOP WITH -1 DPL = single number and sign flag on return stack.
  948    00000050 ........FFFFF         DC32    LIT, -1
                  FFF          
  949                           // PNUMBER is used in loop to convert string segment until non-mumeric chracter.
  950                           // A period in the string manipulates DPL to create a double number.
  951                           // A comma in the string resets DPL to create a single number.
  952                           // A null indicates the end of the string.
  953                           NUMB1:                          // Begin
  954    00000058 .............         DC32    DPL_SV, STORE   // PNUMBER creates whole, dot or comma number segment
                  ...          
  955                           
  956                           // PNUMBER converts one or more characters until first unconvertable digit.
  957                           // ud and addr in string is maintained while in loop.
  958    00000060 ........              DC32    PNUMBER         // ( 0 0 addr -- ud=(LSW MSW) ADDR=PAST#)
  959                           // Perform check for period, comma and null.
  960                           // Any other character here invalidates this number conversion.
  961                           
  962                           // Null Test: = end of string.
  963    00000064 .............         DC32    DUP, CAT
                  ...          
  964    0000006C ........              DC32    ZERO            // End of string used to be BLANK, is now Null.
  965    00000070 ........              DC32    SUBB
  966    00000074 ........              DC32    ZBRAN           // IF emd of number string conversion is
  967    00000078 6C000000              DC32      NUMB2-.       // DONE UNLESS IT NEEDS TO BE NEGATED.
  968                           
  969                           // Period Test: = increment DPL.
  970    0000007C .............         DC32    DUP, CAT
                  ...          
  971    00000084 ........2E000         DC32    LIT, '.'        // 2Eh = period.
                  000          
  972    0000008C ........              DC32    SUBB
  973    00000090 ........              DC32    ZBRAN
  974    00000094 44000000              DC32      DPL_ZERO_INCR-.
  975                           
  976                           #ifdef  comma_test
  977                           // Comma Test: = reset DPL.
  978    00000098 .............         DC32    DUP, CAT
                  ...          
  979    000000A0 ........2C000         DC32    LIT, ','        // 2CH comma
                  000          
  980    000000A8 ........              DC32    EQUAL
  981    000000AC ........              DC32    ZBRAN
  982    000000B0 14000000              DC32      BASE_RESET_THEN_ERROR-.
  983                           
  984                           // Fall thru if comma so reset DPL to create a single number.
  985                           DPL_RESET:        
  986    000000B4 ........FFFFF         DC32    LIT, -1
                  FFF          
  987    000000BC ........              DC32    BRAN
  988    000000C0 98FFFFFF              DC32      NUMB1-.
  989                           #endif
  990                           
  991                           BASE_RESET_THEN_ERROR:
  992                           // GOING TO ERROR SO RESTORE BASE!
  993    000000C4 ........              DC32    BASE_FROM_R12   // Restore BASE
  994                           //NO_BASE_RESTORE:
  995    000000C8 ........              DC32    ONE     // provide non zero flag for error
  996    000000CC .............         DC32    LIT, msg_number_error
                  ...          
  997    000000D4 ........              DC32    QERROR // ( f nullstr-addr -- ) IF f TRUE EXECUTE ERROR!
  998                           
  999                           DPL_ZERO_INCR:      // set DPL to zero
 1000    000000D8 ........              DC32    ZERO
 1001    000000DC ........              DC32    BRAN
 1002    000000E0 78FFFFFF              DC32      NUMB1-.
 1003                           
 1004                           NUMB2:
 1005    000000E4 ........              DC32    DROP
 1006    000000E8 ........              DC32    RFROM           // FLAG OF "-" TEST
 1007                                                           // IF
 1008    000000EC ........              DC32    ZBRAN
 1009    000000F0 08000000              DC32      NUMB3-.
 1010                           
 1011    000000F4 ........              DC32    DNEGATE
 1012                           
 1013                           NUMB3:                          // endif
 1014    000000F8 ........              DC32    BASE_FROM_R12   // Restore BASE
 1015    000000FC ........              DC32    SEMIS
 1016                           
 1017                           
 1018                           //      ERROR ERROR:    ( nullstr --- )
 1019                           //      Execute error notification and restart of system.
 1020                           //      IN_SV is saved to assist in determining the location of the error.
 1021                           
 1022                            SECTION .text : CONST (2)
 1023                           ERROR_NFA:
 1024    00000000 85                    DC8     0x85
 1025    00000001 4552524F              DC8     'ERRO'
 1026    00000005 D2                    DC8     'R'+0x80
 1027    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1028                           //      DC32    DFIND_NFA
 1029    00000008 ........              DC32    NUMBER_NFA
 1030                           ERROR:
 1031    0000000C ........              DC32    DOCOL
 1032    00000010 .............         DC32    HERE, COUNT, TYPE       // Offending item
                  ...........  
 1033    0000001C .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 1034                           #ifdef IO2TP
 1038                           #endif
 1039                           #ifdef XON_XOFF
 1040    00000024 ........              DC32    XOFF    // TEMP TEST THRE
 1041                           #endif
 1042                                   
 1043                           //      DO THIS WHERE STATE IS SET BACK TO ZERO
 1044    00000028 .............         DC32    STATE_SV, AT
                  ...          
 1045    00000030 ........              DC32    ZBRAN
 1046    00000034 40000000              DC32     CREATED_OK-.
 1047                           
 1048                           //      NON-ZERO CSDP = RESTORE DP TO forget DAMAGED WORDS
 1049    00000038 .............         DC32    CSDP_SV, AT   // Create saves dp here for if word exists err
                  ...          
 1050    00000040 ........              DC32    ZBRAN
 1051    00000044 30000000              DC32     CREATED_OK-.
 1052                           
 1053                           // assume ITS A CREATE'd WORD!!!!
 1054                           ERROR_FIXUP:     // CSDP_SV contains NFA of definition that has error.
 1055    00000048 .............         DC32    CSDP_SV, AT     // SHOULD BE AT NFA!!
                  ...          
 1056    00000050 ........              DC32    PFA     // \ nfa -- pfa
 1057    00000054 .............         DC32    LFA, AT // \ pfa --- lfa
                  ...          
 1058    0000005C .............         DC32    CURRENT_SV, STORE       // Has to be NFA of last good word
                  ...          
 1059                           // RESET DP!
 1060    00000064 .............         DC32    CSDP_SV, AT
                  ...          
 1061    0000006C .............         DC32    DP_SV, STORE
                  ...          
 1062                           
 1063                           CREATED_OK:
 1064    00000074 ........              DC32    SEMIC_CREATE            // RESET CSDP FOR AUTO FORGET
 1065                           #ifdef ABORT_STOP_TILL_CO
 1066    00000078 ........              DC32    ABORT
 1067                           #else
 1069                           #endif
 1070                           //      DC32    QUIT    // FROM Error
 1071                           
 1072                           
 1073                           //      ' TICK: ( -- pfa ) IMMEDIATE
 1074                           //      Used in the form: .
 1075                           //      ' CCcc
 1076                           //      Leaves the parameter field address of dictionary word CCcc.
 1077                           //      If the word is not found after a search of CURRENT,
 1078                           //      an appropriate error message is given.
 1079                           //      As a compiler directive, executed in a colon-definition to compile
 1080                           //      the address as a literal.
 1081                           //      Pronounced "TICK".
 1082                           
 1083                            SECTION .text : CONST (2)
 1084                           TICK_NFA:
 1085    00000000 C1                    DC8     0x0C1
 1086    00000001 A7                    DC8     ''''+0x80
 1087    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1088    00000004 ........              DC32    ERROR_NFA
 1089                           TICK:
 1090    00000008 ........              DC32    DOCOL
 1091    0000000C ........              DC32    DFIND   // noop there for TIB entry
 1092    00000010 ........              DC32    ZEQU
 1093    00000014 .............         DC32    LIT, msg_word_error
                  ...          
 1094    0000001C ........              DC32    QERROR    // \ f nullstr-addr --
 1095    00000020 ........              DC32    DROP
 1096    00000024 ........              DC32    LITERAL
 1097    00000028 ........              DC32    SEMIS
 1098                           
 1099                           
 1100                           //      EXPECT EXPECT:  ( addr count -- )
 1101                           //      Transfer characters from the terminal to the buffer starting at addr+1,
 1102                           //      until a "return" or the count of characters have been received.
 1103                           //      One or two nulls are added at the end creating a null-terminated string.
 1104                           //      A count byte is placed at addr, the count being derived by $LEN
 1105                           //      Use COUNT with TYPE for strings saved this way.
 1106                           //      Strings longer that 255 will have an invalid count byte. Use $LEN:
 1107                           //      $LEN and TYPE can be used when the argument to $LEN is addr+1.
 1108                           
 1109                           //      Comments below use TIB input (QUERY in INTERPRET) as an example.
 1110                           
 1111                            SECTION .text : CONST (2)
 1112                           EXPECT_NFA:
 1113    00000000 86                    DC8     0x86
 1114    00000001 4558504543            DC8     'EXPEC'
 1115    00000006 D4                    DC8     'T'+0x80
 1116    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1117    00000008 ........              DC32    TICK_NFA
 1118                           EXPECT:                 // ( NOS TOS -- NOS TOS )
 1119    0000000C ........              DC32    DOCOL   // ( TIB LEN -- )
 1120    00000010 .............         DC32    zero_OUT, zero_IN
                  ...          
 1121    00000018 ........              DC32    ONEP    // ( TIB LEN+1 -- ) (Index and Limit)+1 for count byte
 1122    0000001C ........              DC32    OVER    // ( TIB LEN+1 TIB -- )
 1123    00000020 ........              DC32    PLUS    // ( TIB TIB+LEN+1 -- )
 1124    00000024 ........              DC32    OVER    // ( TIB TIB+LEN+1 TIB -- )
 1125    00000028 ........              DC32    ONEP    // ( TIB TIB+LEN+1 TIB+1 -- ) SKIP COUNT BYTE
 1126                           #ifdef XON_XOFF
 1127    0000002C ........              DC32    XON
 1128                           #endif
 1129                           // ( ORGIGINAL-TIB TIB+LEN+1 TIB+1 -- ORGIGINAL-TIB ) 
 1130                           //                (Index & Limit)+1 for count byte
 1131    00000030 ........              DC32    XDO     // DO   Index = addr, Limit = addr+cnt
 1132                           EXPE1:
 1133    00000034 ........              DC32    KEY     // CAN BREAKPOINT OR CHANGE TO BE 0x0D ONLY
 1134                           #ifdef XON_XOFF
 1135    00000038 ........              DC32    IF_EOL_SEND_XOFF        // IF CR QUICK XOFF!
 1136                           #endif
 1137                           // goto main branch (EL1:)if not tab
 1138    0000003C .............         DC32    DUP, LIT, 9, EQUAL      // ? TAB
                  ...09000000..
                  ......       
 1139    0000004C ........              DC32    ZBRAN                   // Not tab
 1140    00000050 0C000000              DC32     EL1-.                  // Goto MAIN LOOP
 1141                                   
 1142                           // REPLACE TAB WITH SPACE               // -- ch f
 1143    00000054 .............         DC32    DROP, BLANK             // Convert tab to space
                  ...          
 1144                           EL1:
 1145                           // MAIN LOOP ENTERED WITH CHAR ON TOS
 1146    0000005C ........              DC32    DUP             // ( TIB key key -- )
 1147                           // FALL THRU IF BACKSPACE OR DELETE KEY
 1148    00000060 ........              DC32    BACKSPACE_CHAR
 1149    00000064 ........              DC32    EQUAL
 1150    00000068 ........              DC32    OVER
 1151    0000006C ........7F000         DC32    LIT, 07Fh       // DEL KEY
                  000          
 1152    00000074 ........              DC32    EQUAL
 1153    00000078 ........              DC32    OR
 1154                           // BRANCH IF NOT BACKSPACE OR DELETE KEY
 1155    0000007C ........              DC32    ZBRAN           // If not backspace
 1156    00000080 50000000              DC32     EXPE2-.        // go here
 1157                           
 1158                           // CASE OF BACKSPACE/DELETE KEY
 1159    00000084 ........              DC32    DROP            // ( TOS> 8 TIB -- TIB ) Drop Backspace on stack
 1160    00000088 ........              DC32    DUP             // ( TOS> TIB -- TOS> TIB TIB )  Current TIB addr
 1161    0000008C ........              DC32    I               // ( TOS> TIB TIB -- I=TIB+? TIB TIB )
 1162                           // COMPENSATE FOR COUNT BYTE - BUMP ADDR+1 (NEXT CHAR LOCATION) BACK TO CURRENT
 1163    00000090 ........              DC32    ONEM
 1164    00000094 ........              DC32    EQUAL           // ( TOS> I=TIB+? TIB TIB -- f TIB )
 1165    00000098 ........              DC32    DUP             // ( TOS> f TIB -- f f TIB )
 1166                           // I AND RFROM STARTS AT TIB+1 
 1167                           // REMOVE INDEX FROM LOOP TO REPLACE IT WITH BACKSPACE CORRECTED ADDRESS
 1168    0000009C ........              DC32    RFROM           // ( TOS> f f TIB -- TIB+1 f f TIB )
 1169                           // ADDING 2 BECAUSE TIB+1 IS FROM I AND FLAG MAKES IT = TO 1
 1170                           // WHEN AT THE BEGIINING (ADDR+1) OF THE ADDR BUFFER
 1171    000000A0 ........              DC32    TWO
 1172    000000A4 ........              DC32    SUBB
 1173                           // ADD FLAG 
 1174    000000A8 ........              DC32    PLUS
 1175    000000AC ........              DC32    TOR
 1176    000000B0 ........              DC32    ZBRAN           // If not at beginning of line
 1177    000000B4 10000000              DC32     EXPE6-.        // Goto bsout
 1178                           
 1179    000000B8 ........              DC32    BELL            // At beginning of TIB issue bell
 1180    000000BC ........              DC32    BRAN            // Goto end of loop
 1181    000000C0 6C000000              DC32     EXPE33-.
 1182                           
 1183                           EXPE6:
 1184    000000C4 ........              DC32    BSOUT           // endif
 1185                           EXPE7:  // LABEL NOT USED BECAUSE BELL AND BSOUT Emit THEMSELVES
 1186    000000C8 ........              DC32    BRAN            // Goto end of loop
 1187    000000CC 60000000              DC32     EXPE33-.
 1188                           
 1189                           EXPE2:
 1190    000000D0 ........              DC32    DUP
 1191    000000D4 ........0D000         DC32    LIT, 0x0D       // cr
                  000          
 1192    000000DC ........              DC32    EQUAL
 1193    000000E0 ........              DC32    ZBRAN           // If not cr
 1194    000000E4 1C000000              DC32     EXPE4-.        // Goto save this char and loop again
 1195                                   
 1196    000000E8 ........              DC32    LEAVE           // ( TOS> ODh TIB --  )
 1197                           #ifdef  IOBUFS_DEBUG        
 1199                           #endif
 1200                                   // CR DROPPED HERE I USED AT END FOR CASE OF EXPECT COUNT REACHED
 1201    000000EC ........              DC32    DROP            // ( TOS> TIB -- )
 1202    000000F0 ........              DC32    BLANK           // ( TOS> 20h TIB -- ) space IS FOR EMIT!
 1203    000000F4 ........              DC32    ZERO            // ( TOS> 0 20h TIB -- ) null
 1204    000000F8 ........              DC32    BRAN            // Goto store these at end of loop
 1205    000000FC 08000000              DC32     EXPE5-.
 1206                           
 1207                           EXPE4:
 1208    00000100 ........              DC32    DUP             // Regular char 
 1209                           
 1210                           EXPE5:
 1211    00000104 ........              DC32    I               // I=TIB Store char
 1212    00000108 ........              DC32    CSTORE          // or 1rst null in CASE OF CR
 1213    0000010C .............         DC32    ONE, IN_SV, PSTORE
                  ...........  
 1214    00000118 ........              DC32    ZERO            // 1rst or second null if cr
 1215                                   // CASE OF CR ( TOS> 0 20h TIB -- )
 1216    0000011C ........              DC32    I
 1217    00000120 ........              DC32    ONEP
 1218    00000124 ........              DC32    CSTORE
 1219                           EXPE3:
 1220                                   // CASE OF CR ( TOS> 20H TIB -- )
 1221    00000128 ........              DC32    EMIT
 1222                           EXPE33:
 1223    0000012C ........              DC32    XLOOP
 1224    00000130 04FFFFFF              DC32     EXPE1-.        // Loop is LEAVE'd
 1225                           
 1226                           #ifdef XON_XOFF
 1227    00000134 ........              DC32    XOFF            // FOR CASE OF count reached befor cr
 1228                           #endif
 1229                           // Creat count byte        
 1230                                   // ( ORIGINAL ADDR -- )
 1231                                   // ORIGINAL ADDR (TIB) ON STACK HERE SO CORRECT FOR $LEN
 1232    00000138 ........              DC32    ONEP            // PAST COUNT BYTE FOR CORRECT COUNT
 1233                                   // NULLSTRLEN:          // ( addr -- addr len )
 1234    0000013C ........              DC32    NULLSTRLEN      // ( TOS> LEN TIB+1 -- )
 1235    00000140 .............         DC32    SWAP, ONEM      // BACK UP TO COUNT BYTE
                  ...          
 1236    00000148 ........              DC32    CSTORE
 1237    0000014C ........              DC32    SEMIS
 1238                           
 1239                           
 1240                           //      COUNT COUNT:    ( addr1 --- addr2 n )
 1241                           //      Leave the byte address addr2 and byte count n of a count byte string,
 1242                           //      beginning at address addr1. It is presumed that the first byte at
 1243                           //      addr1 contains the text byte count and the actual text starts with
 1244                           //      the second byte. NFA's may report SMUDGE'd byte counts, handled only
 1245                           //      by ID. User Strings may be up to 255 characters.
 1246                           //      Typically COUNT is followed by TYPE.
 1247                           //      See TYPE $LEN and EXPECT
 1248                           
 1249                            SECTION .text : CONST (2)
 1250                           COUNT_NFA:
 1251    00000000 85                    DC8     0x85
 1252    00000001 434F554E              DC8     'COUN'
 1253    00000005 D4                    DC8     'T'+0x80
 1254    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1255    00000008 ........              DC32    EXPECT_NFA
 1256                           COUNT:
 1257    0000000C ........              DC32    DOCOL
 1258    00000010 ........              DC32    DUP
 1259    00000014 ........              DC32    ONEP
 1260    00000018 ........              DC32    SWAP
 1261                           //        DC32    CATLT7F
 1262    0000001C ........              DC32    CAT     // n could be SMUDGE'd count from NFA's
 1263    00000020 ........              DC32    SEMIS   // Only internal usage is ID.
 1264                           
 1265                           
 1266                           //      $LEN NULLSTRLEN:        ( addr --- addr len )
 1267                           //      Count length of null terminated string like 'c' does,
 1268                           //      and return the string len after addr.
 1269                           //      TYPE can be used after this word.
 1270                           
 1271                            SECTION .text : CONST (2)
 1272                           NULLSTRLEN_NFA:
 1273    00000000 84                    DC8     0x84
 1274    00000001 244C45                DC8     '$LE'
 1275    00000004 CE                    DC8     'N'+0x80
 1276    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1277    00000008 ........              DC32    COUNT_NFA
 1278                           NULLSTRLEN:
 1279    0000000C ........              DC32    .+5
 1280                            SECTION .text : CODE (2)
 1281                                   NDPOP2w                 // Put addr in w_R2 yet leave addr on stack
 1281.1  00000000 3A68                  LDR     w, [p]
 1281.2                                 ENDM
 1282                                                           // Usually TIB.
 1283    00000002 4040                  EORS    t, t, t         // zero count
 1284                           
 1285                           NSLEN_LOOP:
 1286    00000004 115C                  LDRB            n, [w,t]
 1287    00000006 0943                  ORRS            n, n, n
 1288    00000008 01D0                  BEQ             NSLEN_DONE
 1289    0000000A 401C                  ADDS            t, t, #1
 1290    0000000C FAE7                  B               NSLEN_LOOP
 1291                           
 1292                           NSLEN_DONE:
 1293                                   TPUSH
 1293                                   PUSHt   // push t to p, pre decrement p
 1293.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1293.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1293.3                         //      STR     t, [p]
 1293.4                                 ENDM
 1293                                   NEXT
 1293.1                         // ARMv7-M Thumb = .+5
 1293.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1293.3                         // ARMv6-M Thumb = .+4
 1293.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1293                                   NEXT1
 1293.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1293.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1293.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1293.4                         // ARMv6-M Thumb = .+4
 1293.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1293.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1293.7                                 ENDM
 1293.8                                 ENDM
 1293.9                                 ENDM
 1294                           
 1295                           
 1296                           //      FORGET FORGET:  ( -- )
 1297                           //      PRINTS NEW HERE IF SUCCESSFUL. FIXED FIG VERSION MEMORY LEAK.
 1298                           //      Executed in the form:
 1299                           //      FORGET CCcc
 1300                           //      Deletes definition named CCcc from the dictionary with all entries
 1301                           //      physically following it. In fig-FORTH, an error message will occur
 1302                           //      if the CURRENT and CONTEXT vocabularies are not currently the same.
 1303                           //      MODIFIED: To update Current along with context and reset DP,
 1304                           //      and execute .DS and .VS
 1305                           
 1306                            SECTION .text : CONST (2)
 1307                           FORGET_NFA:
 1308    00000000 86                    DC8     0x86
 1309    00000001 464F524745            DC8     'FORGE'
 1310    00000006 D4                    DC8     'T'+0x80
 1311    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1312    00000008 ........              DC32    NULLSTRLEN_NFA
 1313                           FORGET:
 1314    0000000C ........              DC32    DOCOL
 1315    00000010 ........              DC32    TICK                    // \ -- pfa ELSE error message
 1316    00000014 ........              DC32    DUP
 1317    00000018 ........00000         DC32    LIT, FLASH_SPAGE        // DONT FORGET FISH WORDS SAVED IN FLASH
                  208          
 1318    00000020 ........              DC32    LESSTHAN
 1319    00000024 .............         DC32    LIT, msg_forget_fish
                  ...          
 1320    0000002C ........              DC32    QERROR                  // \ f nullstr-addr --
 1321    00000030 ........              DC32    DUP
 1322    00000034 ........00001         DC32    LIT, FLASH_PPAGE        // DONT FORGET USER WORDS IN FLASH
                  008          
 1323    0000003C ........              DC32    LESSTHAN
 1324    00000040 .............         DC32    LIT, msg_forget_saved
                  ...          
 1325    00000048 ........              DC32    QERROR                  // \ f nullstr-addr --
 1326                           //      MOVE NFA update of the DP to after Currrent and Context
 1327    0000004C ........              DC32    DUP                     // PFA PFA --
 1328    00000050 ........              DC32    LFA                     // PFA LFA --
 1329                           
 1330                           // VAR space reclamation starts here:
 1331                           // PFA LFA --
 1332    00000054 ........              DC32    TOR                     // LFA_BOT
 1333                           
 1334                           VS_RECVR_LOOP:
 1335    00000058 .............         DC32    LATEST, PFA, LFA        // LFA_TOP
                  ...........  
 1336    00000064 .............         DC32    DUP, AT                 // LFA NEXT_LFA
                  ...          
 1337    0000006C .............         DC32    CURRENT_SV, STORE       // SET NEXT WORD TO CHECK
                  ...          
 1338    00000074 .............         DC32    DUP, FOURP, AT          // GET CFA
                  ...........  
 1339    00000080 .............         DC32    LIT, DOVAR, EQUAL       // IS IT A DOVAR
                  ...........  
 1340    0000008C ........              DC32    ZBRAN
 1341    00000090 14000000              DC32     VS_RECVR_NEXT-.
 1342                                   
 1343    00000094 ........FCFFF         DC32    LIT, -4, UP_SV, PSTORE  // DECREMENT UP
                  FFF..........
                  ......       
 1344                           
 1345                           VS_RECVR_NEXT:
 1346    000000A4 .............         DC32    R, EQUAL
                  ...          
 1347    000000AC ........              DC32    ZBRAN
 1348    000000B0 A8FFFFFF              DC32     VS_RECVR_LOOP-.
 1349                           
 1350    000000B4 ........              DC32    RFROM
 1351                           // VAR SPACE RECLAMATION DONE
 1352                           
 1353                           // PFA LFA --
 1354    000000B8 ........              DC32    AT              // LFA
 1355    000000BC ........              DC32    CURRENT_SV
 1356    000000C0 ........              DC32    STORE
 1357    000000C4 ........              DC32    NFA             // FROM PFA
 1358    000000C8 ........              DC32    DP_SV
 1359    000000CC ........              DC32    STORE
 1360    000000D0 .............         DC32    DOTVARSPACE, DOTDICTSPACE
                  ...          
 1361    000000D8 ........              DC32    SEMIS
 1362                           
 1363                           
 1364                           //      BYE BYE: ( -- ) COLD RESTART WITH SERIAL INITIALIZATION
 1365                           
 1366                            SECTION .text : CONST (2)
 1367                           BYE_NFA:
 1368    00000000 83                    DC8     0x83
 1369    00000001 4259                  DC8     'BY'
 1370    00000003 C5                    DC8     'E'+0x80
 1371                            ALIGNROM 2,0xFFFFFFFF
 1372    00000004 ........              DC32    FORGET_NFA
 1373                           BYE:
 1374    00000008 ........              DC32    .+5
 1375                            SECTION .text : CODE (2)
 1376                           //        B       FM3_COLD      // __iar_program_start
 1377    00000000 ........              B       STM32Fx_COLD_FISH
 1378                            LTORG
 1379                           
 1380                           
 1381                           //      ABORT ABORT:    ( -- )
 1382                           //      Clear the stacks, zero out and execute RUN or QUIT
 1383                           //      DOES NOT RESET DICTIONAIRY. SEE COLD.
 1384                           
 1385                            SECTION .text : CONST (2)
 1386                           ABORT_NFA:
 1387    00000000 85                    DC8     0x85
 1388    00000001 41424F52              DC8     'ABOR'
 1389    00000005 D4                    DC8     'T'+0x80
 1390    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1391    00000008 ........              DC32    BYE_NFA
 1392                           ABORT:
 1393    0000000C ........              DC32    DOCOL
 1394    00000010 ........              DC32    SPSTO
 1395    00000014 ........              DC32    RPSTO
 1396                           #ifdef IO2TP
 1401                           #endif
 1402    00000018 ........              DC32    zero_OUT
 1403                           //      DC32    QSTACK  // IF STACK error abort using QERROR->ERROR
 1404                           
 1405                           // LOOK UP RUN AND EXEC IT
 1406    0000001C .............         DC32    LIT, msg_RUN
                  ...          
 1407    00000024 ........              DC32    LATEST
 1408                           //ABORT_BP1_B4_PFIND_RUN:
 1409                           // DC32 NOOP
 1410    00000028 ........              DC32    PFIND   // 0 OR pfa len 1
 1411    0000002C ........              DC32    ZBRAN
 1412    00000030 10000000              DC32      ABORT_QUIT-.
 1413                           
 1414    00000034 ........              DC32    DROP    // LEN
 1415    00000038 .............         DC32    CFA, EXEC
                  ...          
 1416                           ABORT_QUIT:
 1417                           //      DC32    SEMIC_CREATE // Use ERROR if need to recover from bad definition
 1418                           #ifdef ABORT_STOP_TILL_CO
 1419    00000040 .............         DC32    LIT, ERROR_HALT, AT
                  ...........  
 1420    0000004C ........              DC32    ZBRAN
 1421    00000050 6C000000              DC32      CO_END-.
 1422                           // halt on all errors until "CO" entered
 1423                           // BEGIN
 1424    00000054 .............         DC32    LIT, msg_CO, NULLSTRLEN, TYPE
                  .............
                  ......       
 1425                           NOT_CO:
 1426    00000064 ........              DC32    QKEY
 1427    00000068 ........              DC32    ZBRAN
 1428    0000006C F8FFFFFF              DC32      NOT_CO-.
 1429                           // IF KEY = "C'
 1430    00000070 .............         DC32    KEY, LIT, 43h, EQUAL
                  ...43000000..
                  ......       
 1431    00000080 ........              DC32    ZBRAN
 1432    00000084 E0FFFFFF              DC32      NOT_CO-.
 1433                           // NEXT KEY "0"
 1434    00000088 .............         DC32    KEY, LIT, 4Fh, EQUAL
                  ...4F000000..
                  ......       
 1435    00000098 ........              DC32    ZBRAN
 1436    0000009C C8FFFFFF              DC32      NOT_CO-.
 1437                           // NEXT KEY "Enter"
 1438    000000A0 .............         DC32    KEY, LIT, 0Dh, EQUAL
                  ...0D000000..
                  ......       
 1439    000000B0 ........              DC32    ZBRAN
 1440    000000B4 B0FFFFFF              DC32      NOT_CO-.
 1441                           // UNTIL
 1442    000000B8 ........              DC32    CR
 1443                           CO_END:
 1444                           #endif
 1445    000000BC ........              DC32    QUIT    // OI
 1446                           #ifdef ABORT_STOP_TILL_CO
 1447                           $FISH_CO_MSGS.h
 1448                           #endif
 1449                           
 1450                           //      COLD COLD:      ( -- )  MODIFIED:
 1451                           //      FIGISH SYSTEM COLD = WARM (INIT RAMVARSPACE) -> type signon MSG ->ABORT
 1452                           //      CLEARS DICTIONAIRY. SEE ABORT.
 1453                           
 1454                            SECTION .text : CONST (2)
 1455                           COLD_NFA:
 1456    00000000 84                    DC8     0x84
 1457    00000001 434F4C                DC8     'COL'
 1458    00000004 C4                    DC8     'D'+0x80
 1459    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1460    00000008 ........              DC32    ABORT_NFA
 1461                           COLD:
 1462    0000000C ........              DC32    DOCOL
 1463    00000010 ........              DC32    WARM            // FISH System VAR init.
 1464    00000014 ........              DC32    SIGNON
 1465                           #ifdef ABORT_STOP_TILL_CO
 1466    00000018 ........              DC32    QUIT
 1467                           #else
 1469                           #endif
 1470                           
 1471                           //=============================== WORDCAT ====================================//
 1472                           //NOEXEC HEADERFORWORDCATEGORIES
 1473                           //      WC_FISH_SYS: = FISH System: CATEGORY
 1474                           
 1475                            SECTION .text : CONST (2)
 1476                           WC_FISH_SYS_NFA:
 1477    00000000 90                    DC8     0x80+4+12
 1478    00000001 0D0A                  DC8     0x0D, 0x0A
 1479    00000003 4649534820537         DC8     'FISH System:'
                  97374656D3A  
 1480    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1481    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1482    00000014 ........              DC32    COLD_NFA
 1483                           
 1484                           
 1485                           //----------------------------- DOTSTACK SECTION -------------------------------
 1486                           
 1487                           //      .SH DOTSHEX:    ( -- )
 1488                           //      Nondestructively print items on stack in HEX, preserving base.
 1489                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1490                           
 1491                            SECTION .text : CONST (2)
 1492                           DOTSHEX_NFA:
 1493    00000000 83                    DC8     0x83
 1494    00000001 2E53                  DC8     '.S'
 1495    00000003 C8                    DC8     'H'+0x80
 1496                            ALIGNROM 2,0xFFFFFFFF
 1497    00000004 ........              DC32    WC_FISH_SYS_NFA
 1498                           DOTSHEX:
 1499    00000008 ........              DC32    DOCOL
 1500    0000000C ........10000         DC32    LIT, 16, DOTSBASE
                  000........  
 1501    00000018 ........              DC32    SEMIS
 1502                           
 1503                           
 1504                           //      .SD DOTSDEC:    ( -- )
 1505                           //      Nondestructively print items on stack in DECIMAL, preserving base.
 1506                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1507                           
 1508                            SECTION .text : CONST (2)
 1509                           DOTSDEC_NFA:
 1510    00000000 83                    DC8     0x83
 1511    00000001 2E53                  DC8     '.S'
 1512    00000003 C4                    DC8     'D'+0x80
 1513                            ALIGNROM 2,0xFFFFFFFF
 1514    00000004 ........              DC32    DOTSHEX_NFA
 1515                           DOTSDEC:
 1516    00000008 ........              DC32    DOCOL
 1517    0000000C ........0A000         DC32    LIT, 10, DOTSBASE
                  000........  
 1518    00000018 ........              DC32    SEMIS
 1519                           
 1520                           
 1521                           //      .SB DOTSBIN:    ( -- )
 1522                           //      Nondestructively print items on stack in BINARY, preserving base.
 1523                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1524                           
 1525                            SECTION .text : CONST (2)
 1526                           DOTSBIN_NFA:
 1527    00000000 83                    DC8     0x83
 1528    00000001 2E53                  DC8     '.S'
 1529    00000003 C2                    DC8     'B'+0x80
 1530                            ALIGNROM 2,0xFFFFFFFF
 1531    00000004 ........              DC32    DOTSDEC_NFA
 1532                           DOTSBIN:
 1533    00000008 ........              DC32    DOCOL
 1534    0000000C .............         DC32    TWO, DOTSBASE
                  ...          
 1535    00000014 ........              DC32    SEMIS
 1536                           
 1537                           
 1538                           //      .S DOTS:        ( -- )
 1539                           //      Nondestructively print items on stack in current base.
 1540                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1541                           
 1542                            SECTION .text : CONST (2)
 1543                           DOTS_NFA:
 1544    00000000 82                    DC8     0x82
 1545    00000001 2E                    DC8     '.'
 1546    00000002 D3                    DC8     'S'+0x80
 1547    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1548    00000004 ........              DC32    DOTSBIN_NFA
 1549                           DOTS:
 1550    00000008 ........              DC32    DOCOL
 1551    0000000C .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1552    0000001C .............         DC32    EQUAL, ZEQU, ZBRAN
                  ...........  
 1553    00000028 68000000              DC32    DOTSEND-.                       // IF NOTHING ON STACK
 1554                           
 1555    0000002C ........              DC32    PDOTQ
 1556    00000030 05                    DC8     5
 1557    00000031 544F533E20            DC8     'TOS> '
 1558    00000036 FFFF           ALIGNROM 2,0xFFFFFFFF
 1559                                 
 1560    00000038 .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1561    00000048 ........              DC32    XDO
 1562                           
 1563                           DOTSLOOP:
 1564    0000004C .............         DC32    I, AT
                  ...          
 1565    00000054 .............         DC32    BASE_SV, AT
                  ...          
 1566    0000005C ........0A000         DC32    LIT, 10, EQUAL                  // 
                  000........  
 1567    00000068 ........              DC32    ZBRAN                           // NOT = DECIMAL
 1568    0000006C 10000000              DC32    DBSUSEDUDOT-.
 1569    00000070 ........              DC32    DOT_BASE_SUFFIX
 1570    00000074 ........              DC32    BRAN
 1571    00000078 08000000              DC32    DBSUSEDOT-.
 1572                           
 1573                           DBSUSEDUDOT:
 1574    0000007C ........              DC32    UDOT_BASE_SUFFIX
 1575                           
 1576                           DBSUSEDOT:
 1577    00000080 ........              DC32    SPACE
 1578    00000084 .............         DC32    FOUR, XPLOOP
                  ...          
 1579    0000008C C0FFFFFF              DC32    DOTSLOOP-.
 1580                           
 1581                           DOTSEND:
 1582    00000090 ........              DC32    SEMIS
 1583                           
 1584                           
 1585                           //      2DUP TDUP:      ( n2 n1 -- n2 n1 n2 n1 )
 1586                           //      Duplicate top two stack items. The prefix 2 convention means
 1587                           //      an operation on the top two stack items.
 1588                           
 1589                            SECTION .text : CONST (2)
 1590                           TDUP_NFA:
 1591    00000000 84                    DC8     0x84
 1592    00000001 324455                DC8     '2DU'
 1593    00000004 D0                    DC8     'P'+0x80
 1594    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1595    00000008 ........              DC32    DOTS_NFA
 1596                           TDUP:
 1597    0000000C ........              DC32    .+5
 1598                            SECTION .text : CODE (2)
 1599                           // TDUP: OPT by picking pops
 1600    00000000 3868                  LDR     t, [p]          //
 1601    00000002 7A68                  LDR     w, [p, #4]      //
 1602                                   DPUSH                   // 
 1602                                   PUSHw   // push w to p, post decrement p
 1602.1  00000004 47F8042D              STR     w, [p, #-4]!
 1602.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1602.3                         //      STR     w, [p]
 1602.4                                 ENDM
 1602                                   TPUSH
 1602                                   PUSHt   // push t to p, pre decrement p
 1602.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1602.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1602.3                         //      STR     t, [p]
 1602.4                                 ENDM
 1602                                   NEXT
 1602.1                         // ARMv7-M Thumb = .+5
 1602.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1602.3                         // ARMv6-M Thumb = .+4
 1602.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1602                                   NEXT1
 1602.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1602.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1602.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1602.4                         // ARMv6-M Thumb = .+4
 1602.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1602.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1602.7                                 ENDM
 1602.8                                 ENDM
 1602.9                                 ENDM
 1602.10                                ENDM
 1603                           
 1604                           
 1605                           //      -DUP ZNDUP:     ( n1 -- n1 (if zero)
 1606                           //                      ( n1 -- n1 n1 (non-zero)
 1607                           //      Reproduce n1 only if it is non-zero. Used in type andSPACES.
 1608                           //      This is usually used to copy a value just before IF, to eliminate
 1609                           //      the need for an ELSE part to drop it. 
 1610                           
 1611                            SECTION .text : CONST (2)
 1612                           DDUP_NFA:
 1613    00000000 84                    DC8     0x84
 1614    00000001 2D4455                DC8     '-DU'
 1615    00000004 D0                    DC8     'P'+0x80
 1616    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1617    00000008 ........              DC32    TDUP_NFA
 1618                           ZNDUP:
 1619    0000000C ........              DC32    DOCOL
 1620    00000010 ........              DC32    DUP
 1621    00000014 ........              DC32    ZBRAN   // IF
 1622    00000018 08000000              DC32    DDUP1-.
 1623                           
 1624    0000001C ........              DC32    DUP     //endif
 1625                           DDUP1:
 1626    00000020 ........              DC32    SEMIS
 1627                           
 1628                           
 1629                           //      ROT ROT: ( nl n2 n3 --- n2 n3 nl )
 1630                           //      Rotate the top three values on the stack, bringing the third to the top.
 1631                           
 1632                            SECTION .text : CONST (2)
 1633                           ROT_NFA:
 1634    00000000 83                    DC8     0x83
 1635    00000001 524F                  DC8     'RO'
 1636    00000003 D4                    DC8     'T'+0x80
 1637                            ALIGNROM 2,0xFFFFFFFF
 1638    00000004 ........              DC32    DDUP_NFA
 1639                           ROT:
 1640    00000008 ........              DC32    .+5
 1641                            SECTION .text : CODE (2)
 1642                                   POP2w
 1642.1  00000000 57F8042B              LDR     w, [p],#4
 1642.2                         //      LDR     w, [p]
 1642.3                         //      ADDS    p, p, #4
 1642.4                                 ENDM
 1643                                   POP2n
 1643.1  00000004 57F8041B              LDR     n, [p],#4
 1643.2                         //      LDR     n, [p]
 1643.3                         //      ADDS    p, p, #4
 1643.4                                 ENDM
 1644                           #ifdef TOSCT
 1646                           #endif
 1647                                   POP2t
 1647.1  00000008 57F8040B              LDR     t, [p],#4       // Post-increment
 1647.2                         //#ifndef TOSCT
 1647.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1647.4                         //#endif
 1647.5                         //      ADDS    p, p, #4
 1647.6                                 ENDM
 1648                                   PUSHn
 1648.1  0000000C 47F8041D              STR     n, [p, #-4]!
 1648.2                         //      SUBS    p, p, #4        // push n to p, pre decrement p
 1648.3                         //      STR     n, [p]
 1648.4                                 ENDM
 1649                                   DPUSH                   //  --  LSW MSW )
 1649                                   PUSHw   // push w to p, post decrement p
 1649.1  00000010 47F8042D              STR     w, [p, #-4]!
 1649.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1649.3                         //      STR     w, [p]
 1649.4                                 ENDM
 1649                                   TPUSH
 1649                                   PUSHt   // push t to p, pre decrement p
 1649.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1649.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1649.3                         //      STR     t, [p]
 1649.4                                 ENDM
 1649                                   NEXT
 1649.1                         // ARMv7-M Thumb = .+5
 1649.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1649.3                         // ARMv6-M Thumb = .+4
 1649.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1649                                   NEXT1
 1649.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1649.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1649.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1649.4                         // ARMv6-M Thumb = .+4
 1649.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1649.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1649.7                                 ENDM
 1649.8                                 ENDM
 1649.9                                 ENDM
 1649.10                                ENDM
 1650                           
 1651                           
 1652                           //      I I:    ( -- n )
 1653                           //      Used within a DO-LOOP to copy the loop index to the stack. Other use
 1654                           //      is implementation dependent.
 1655                           //      See R.
 1656                           
 1657                            SECTION .text : CONST (2)
 1658                           I_NFA:
 1659    00000000 81                    DC8     0x81
 1660    00000001 C9                    DC8     'I'+0x80
 1661    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1662    00000004 ........              DC32    ROT_NFA
 1663                           I:
 1664    00000008 ........              DC32    .+5
 1665                            SECTION .text : CODE (2)
 1666    00000000 3068                  LDR     t, [r]  // GET INDEX VALUE
 1667                                   TPUSH
 1667                                   PUSHt   // push t to p, pre decrement p
 1667.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1667.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1667.3                         //      STR     t, [p]
 1667.4                                 ENDM
 1667                                   NEXT
 1667.1                         // ARMv7-M Thumb = .+5
 1667.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1667.3                         // ARMv6-M Thumb = .+4
 1667.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1667                                   NEXT1
 1667.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1667.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1667.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1667.4                         // ARMv6-M Thumb = .+4
 1667.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1667.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1667.7                                 ENDM
 1667.8                                 ENDM
 1667.9                                 ENDM
 1668                           
 1669                           
 1670                           //      SP@ SPAT:       ( -- addr )
 1671                           //      \ -- addr = Current TOP of the parameter stack (p) )
 1672                           //      Place the address of the TOP of the parameter stack (p)
 1673                           //      on the parameter stack (p) as it was before RP@ was executed.
 1674                           //      e.g.  1  2  SP@  @  .   .   .     would type 2  2  1
 1675                           
 1676                            SECTION .text : CONST (2)
 1677                           SPAT_NFA:
 1678    00000000 83                    DC8     0x83
 1679    00000001 5350                  DC8     'SP'
 1680    00000003 C0                    DC8     '@'+0x80
 1681                            ALIGNROM 2,0xFFFFFFFF
 1682    00000004 ........              DC32    I_NFA
 1683                           SPAT:
 1684    00000008 ........              DC32    .+5
 1685                            SECTION .text : CODE (2)
 1686    00000000 3846                  MOV     t, p
 1687                                   TPUSH
 1687                                   PUSHt   // push t to p, pre decrement p
 1687.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1687.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1687.3                         //      STR     t, [p]
 1687.4                                 ENDM
 1687                                   NEXT
 1687.1                         // ARMv7-M Thumb = .+5
 1687.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1687.3                         // ARMv6-M Thumb = .+4
 1687.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1687                                   NEXT1
 1687.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1687.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1687.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1687.4                         // ARMv6-M Thumb = .+4
 1687.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1687.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1687.7                                 ENDM
 1687.8                                 ENDM
 1687.9                                 ENDM
 1688                           
 1689                           
 1690                           //      RP@ RPAT:       ( -- addr )
 1691                           //      \ -- addr = Current TOP of the Return Stack (r) )
 1692                           //      Place the address of the TOP of the return stack (r)
 1693                           //      on the parameter stack (p) as it was before RP@ was executed.
 1694                           //      e.g.  1 >R  2 >R  RP@  @  .   .   . would type 2  2  1
 1695                           
 1696                            SECTION .text : CONST (2)
 1697                           RPAT_NFA:
 1698    00000000 83                    DC8     0x83
 1699    00000001 5250                  DC8     'RP'
 1700    00000003 C0                    DC8     '@'+0x80
 1701                            ALIGNROM 2,0xFFFFFFFF
 1702    00000004 ........              DC32    SPAT_NFA
 1703                           RPAT:
 1704    00000008 ........              DC32    .+5
 1705                            SECTION .text : CODE (2)
 1706    00000000 3046                  MOV     t, r
 1707                                   TPUSH
 1707                                   PUSHt   // push t to p, pre decrement p
 1707.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1707.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1707.3                         //      STR     t, [p]
 1707.4                                 ENDM
 1707                                   NEXT
 1707.1                         // ARMv7-M Thumb = .+5
 1707.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1707.3                         // ARMv6-M Thumb = .+4
 1707.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1707                                   NEXT1
 1707.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1707.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1707.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1707.4                         // ARMv6-M Thumb = .+4
 1707.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1707.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1707.7                                 ENDM
 1707.8                                 ENDM
 1707.9                                 ENDM
 1708                           
 1709                           
 1710                           //      LEAVE LEAVE:    ( -- )
 1711                           //      Force termination of a DO-LOOP at the next opportunity by setting
 1712                           //      the loop limit equal to the current value of the index. The index
 1713                           //      itself remains unchanged, and execution proceeds until LOOP
 1714                           //      or +LOOP is encountered.
 1715                           
 1716                            SECTION .text : CONST (2)
 1717                           LEAVE_NFA:
 1718    00000000 85                    DC8     0x85
 1719    00000001 4C454156              DC8     'LEAV'
 1720    00000005 C5                    DC8     'E'+0x80
 1721    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1722                           //      DC32    RPSTO_NFA
 1723    00000008 ........              DC32    RPAT_NFA
 1724                           LEAVE:
 1725    0000000C ........              DC32    .+5
 1726                            SECTION .text : CODE (2)
 1727    00000000 3268                  LDR     w, [r]          // GET Index
 1728    00000002 7260                  STR     w, [r, #4]  // Store it at Limit
 1729                                   NEXT
 1729.1                         // ARMv7-M Thumb = .+5
 1729.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1729.3                         // ARMv6-M Thumb = .+4
 1729.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1729                                   NEXT1
 1729.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1729.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1729.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1729.4                         // ARMv6-M Thumb = .+4
 1729.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1729.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1729.7                                 ENDM
 1729.8                                 ENDM
 1730                           
 1731                           
 1732                           //      R> RFROM:       ( -- n )
 1733                           //      Remove the top value from the return stack and leave it on the
 1734                           //      computation stack. See >R and R.
 1735                           
 1736                            SECTION .text : CONST (2)
 1737                           RFROM_NFA:
 1738    00000000 82                    DC8     0x82
 1739    00000001 52                    DC8     'R'
 1740    00000002 BE                    DC8     '>'+0x80
 1741    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1742    00000004 ........              DC32    LEAVE_NFA
 1743                           RFROM:
 1744    00000008 ........              DC32    .+5
 1745                            SECTION .text : CODE (2)
 1746                                   POPr2t
 1746.1  00000000 56F8040B              LDR     t, [r],#4
 1746.2                         //      LDR     t, [r]
 1746.3                         //      ADDS    r, r, #4
 1746.4                                 ENDM
 1747                                   TPUSH
 1747                                   PUSHt   // push t to p, pre decrement p
 1747.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1747.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1747.3                         //      STR     t, [p]
 1747.4                                 ENDM
 1747                                   NEXT
 1747.1                         // ARMv7-M Thumb = .+5
 1747.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1747.3                         // ARMv6-M Thumb = .+4
 1747.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1747                                   NEXT1
 1747.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1747.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1747.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1747.4                         // ARMv6-M Thumb = .+4
 1747.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1747.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1747.7                                 ENDM
 1747.8                                 ENDM
 1747.9                                 ENDM
 1748                           
 1749                           
 1750                           //      R R:    ( -- n )
 1751                           //      Copy the top of the return stack to the computation stack.
 1752                           
 1753                            SECTION .text : CONST (2)
 1754                           R_NFA:
 1755    00000000 81                    DC8     0x81
 1756    00000001 D2                    DC8     'R'+0x80
 1757    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1758    00000004 ........              DC32    RFROM_NFA
 1759                           R:
 1760    00000008 ........              DC32    .+5
 1761                            SECTION .text : CODE (2)
 1762    00000000 3068                  LDR     t, [r]  // Get Index
 1763                                   TPUSH
 1763                                   PUSHt   // push t to p, pre decrement p
 1763.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1763.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1763.3                         //      STR     t, [p]
 1763.4                                 ENDM
 1763                                   NEXT
 1763.1                         // ARMv7-M Thumb = .+5
 1763.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1763.3                         // ARMv6-M Thumb = .+4
 1763.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1763                                   NEXT1
 1763.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1763.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1763.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1763.4                         // ARMv6-M Thumb = .+4
 1763.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1763.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1763.7                                 ENDM
 1763.8                                 ENDM
 1763.9                                 ENDM
 1764                           
 1765                           //      >R TOR: ( n -- )
 1766                           //      Remove a number from the computation stack and place as the most
 1767                           //      accessable on the return stack. Use should be balanced with R> in
 1768                           //      the same definition.
 1769                           
 1770                            SECTION .text : CONST (2)
 1771                           TOR_NFA:
 1772    00000000 82                    DC8     0x82
 1773    00000001 3E                    DC8     '>'
 1774    00000002 D2                    DC8     'R'+0x80
 1775    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1776    00000004 ........              DC32    R_NFA
 1777                           TOR:
 1778    00000008 ........              DC32    .+5
 1779                            SECTION .text : CODE (2)
 1780                                   POP2n   // preserve TOS
 1780.1  00000000 57F8041B              LDR     n, [p],#4
 1780.2                         //      LDR     n, [p]
 1780.3                         //      ADDS    p, p, #4
 1780.4                                 ENDM
 1781                                   PUSHn2r
 1781.1  00000004 46F8041D              STR     n, [r, #-4]!
 1781.2                         //      SUBS    r, r, #4        //  push t to r, pre decrement r
 1781.3                         //      STR     n, [r]
 1781.4                                 ENDM
 1782                           #ifdef TOSCT
 1784                           #endif
 1785                                   NEXT
 1785.1                         // ARMv7-M Thumb = .+5
 1785.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1785.3                         // ARMv6-M Thumb = .+4
 1785.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1785                                   NEXT1
 1785.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1785.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1785.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1785.4                         // ARMv6-M Thumb = .+4
 1785.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1785.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1785.7                                 ENDM
 1785.8                                 ENDM
 1786                           
 1787                           
 1788                           //      OVER OVER:      ( nl n2 -- nl n2 n1 )
 1789                           //      Copy the second stack value, placing it as the new top.
 1790                           
 1791                            SECTION .text : CONST (2)
 1792                           OVER_NFA:
 1793    00000000 84                    DC8     0x84
 1794    00000001 4F5645                DC8     'OVE'
 1795    00000004 D2                    DC8     'R'+0x80
 1796    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1797    00000008 ........              DC32    TOR_NFA
 1798                           OVER:
 1799    0000000C ........              DC32    .+5
 1800                            SECTION .text : CODE (2)
 1801                                   POP2w           // n2
 1801.1  00000000 57F8042B              LDR     w, [p],#4
 1801.2                         //      LDR     w, [p]
 1801.3                         //      ADDS    p, p, #4
 1801.4                                 ENDM
 1802                           #ifdef TOSCT
 1806                           #else
 1807                                   POP2t           // n1
 1807.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1807.2                         //#ifndef TOSCT
 1807.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1807.4                         //#endif
 1807.5                         //      ADDS    p, p, #4
 1807.6                                 ENDM
 1808                           #endif
 1809                                   PUSHt           // -- n1 )
 1809.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1809.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1809.3                         //      STR     t, [p]
 1809.4                                 ENDM
 1810                                   DPUSH           //  --  LSW MSW )
 1810                                   PUSHw   // push w to p, post decrement p
 1810.1  0000000C 47F8042D              STR     w, [p, #-4]!
 1810.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1810.3                         //      STR     w, [p]
 1810.4                                 ENDM
 1810                                   TPUSH
 1810                                   PUSHt   // push t to p, pre decrement p
 1810.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1810.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1810.3                         //      STR     t, [p]
 1810.4                                 ENDM
 1810                                   NEXT
 1810.1                         // ARMv7-M Thumb = .+5
 1810.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1810.3                         // ARMv6-M Thumb = .+4
 1810.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1810                                   NEXT1
 1810.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1810.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1810.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1810.4                         // ARMv6-M Thumb = .+4
 1810.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1810.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1810.7                                 ENDM
 1810.8                                 ENDM
 1810.9                                 ENDM
 1810.10                                ENDM
 1811                           
 1812                           
 1813                           //      DROP DROP:      ( n1 -- )
 1814                           //      Drop n1 from the stack.
 1815                           
 1816                            SECTION .text : CONST (2)
 1817                           DROP_NFA:
 1818    00000000 84                    DC8     0x84
 1819    00000001 44524F                DC8     'DRO'
 1820    00000004 D0                    DC8     'P'+0x80
 1821    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1822    00000008 ........              DC32    OVER_NFA
 1823                           DROP:
 1824    0000000C ........              DC32    .+5
 1825                            SECTION .text : CODE (2)
 1826                           #ifdef TOSCT
 1830                           #else // DROP:
 1831                           //        POP2t         // Opt to just do p
 1832    00000000 3F1D                  ADDS    p, p, #4
 1833                           
 1834                           #endif
 1835                                   NEXT
 1835.1                         // ARMv7-M Thumb = .+5
 1835.2  00000002 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1835.3                         // ARMv6-M Thumb = .+4
 1835.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1835                                   NEXT1
 1835.1  00000006 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1835.2  0000000A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1835.3  0000000E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1835.4                         // ARMv6-M Thumb = .+4
 1835.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1835.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1835.7                                 ENDM
 1835.8                                 ENDM
 1836                           
 1837                           
 1838                           //      SWAP SWAP:      ( nl n2 -- n2 n1 )
 1839                           //      Exchange the top two values On the stack.
 1840                           
 1841                            SECTION .text : CONST (2)
 1842                           SWAP_NFA:
 1843    00000000 84                    DC8     0x84
 1844    00000001 535741                DC8     'SWA'
 1845    00000004 D0                    DC8     'P'+0x80
 1846    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1847    00000008 ........              DC32    DROP_NFA
 1848                           SWAP:
 1849    0000000C ........              DC32    .+5
 1850                            SECTION .text : CODE (2)
 1851                           #ifdef TOSCT
 1855                           #else // SWAP:
 1856                                   POP2w           // n2
 1856.1  00000000 57F8042B              LDR     w, [p],#4
 1856.2                         //      LDR     w, [p]
 1856.3                         //      ADDS    p, p, #4
 1856.4                                 ENDM
 1857                                   POP2t           // n1
 1857.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1857.2                         //#ifndef TOSCT
 1857.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1857.4                         //#endif
 1857.5                         //      ADDS    p, p, #4
 1857.6                                 ENDM
 1858                           #endif
 1859                                   DPUSH           //  --  LSW MSW )
 1859                                   PUSHw   // push w to p, post decrement p
 1859.1  00000008 47F8042D              STR     w, [p, #-4]!
 1859.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1859.3                         //      STR     w, [p]
 1859.4                                 ENDM
 1859                                   TPUSH
 1859                                   PUSHt   // push t to p, pre decrement p
 1859.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1859.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1859.3                         //      STR     t, [p]
 1859.4                                 ENDM
 1859                                   NEXT
 1859.1                         // ARMv7-M Thumb = .+5
 1859.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1859.3                         // ARMv6-M Thumb = .+4
 1859.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1859                                   NEXT1
 1859.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1859.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1859.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1859.4                         // ARMv6-M Thumb = .+4
 1859.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1859.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1859.7                                 ENDM
 1859.8                                 ENDM
 1859.9                                 ENDM
 1859.10                                ENDM
 1860                           
 1861                           
 1862                           //      DUP DUP:        ( n1 -- n1 n1 )
 1863                           //      Duplicate the value n1 on the stack.
 1864                           
 1865                            SECTION .text : CONST (2)
 1866                           DUP_NFA:
 1867    00000000 83                    DC8     0x83
 1868    00000001 4455                  DC8     'DU'
 1869    00000003 D0                    DC8     'P'+0x80
 1870                            ALIGNROM 2,0xFFFFFFFF
 1871    00000004 ........              DC32    SWAP_NFA
 1872                           DUP:
 1873    00000008 ........              DC32    .+5
 1874                            SECTION .text : CODE (2)
 1875                           //#ifdef TOSCT
 1876                           // NO NEED TO REFRESH t ?
 1877                           //#else DUP:
 1878                           // OPT by picking pops
 1879    00000000 3868                  LDR     t, [p]  //t_r0 p_r7
 1880                           //#endif
 1881                                   TPUSH   //// push t to p, pre decrement p
 1881                                   PUSHt   // push t to p, pre decrement p
 1881.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1881.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1881.3                         //      STR     t, [p]
 1881.4                                 ENDM
 1881                                   NEXT
 1881.1                         // ARMv7-M Thumb = .+5
 1881.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1881.3                         // ARMv6-M Thumb = .+4
 1881.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1881                                   NEXT1
 1881.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1881.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1881.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1881.4                         // ARMv6-M Thumb = .+4
 1881.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1881.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1881.7                                 ENDM
 1881.8                                 ENDM
 1881.9                                 ENDM
 1882                           
 1883                           //=============================== WORDCAT ====================================//
 1884                           //NOEXEC HEADERFORWORDCATEGORIES
 1885                           //      WC_STACK_NFA = Stack Stuff: CATEGORY
 1886                           
 1887                            SECTION .text : CONST (2)
 1888                           WC_STACK_NFA:
 1889    00000000 90                    DC8     0x80+4+12
 1890    00000001 0D0A                  DC8     0x0D, 0x0A
 1891    00000003 537461636B205         DC8     'Stack Stuff:'
                  3747566663A  
 1892    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1893    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1894    00000014 ........              DC32    DUP_NFA
 1895                           
 1896                           
 1897                           //      ANDBITS ANDBITS:        ( addr val -- )
 1898                           
 1899                            SECTION .text : CONST (2)
 1900                           ANDBITS_NFA:
 1901    00000000 87                    DC8     0x87
 1902    00000001 414E44424954          DC8     'ANDBIT'
 1903    00000007 D3                    DC8     'S'+0x80
 1904                            ALIGNROM 2,0xFFFFFFFF
 1905    00000008 ........              DC32    WC_STACK_NFA
 1906                           ANDBITS:
 1907    0000000C ........              DC32    .+5
 1908                            SECTION .text : CODE (2)
 1909                                   POPp2w          // val
 1909.1                                 // as in xeq token on ToS setup for exec
 1909.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1909.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1909.4                                 ENDM
 1910                                   POP2n           // addr
 1910.1  00000004 57F8041B              LDR     n, [p],#4
 1910.2                         //      LDR     n, [p]
 1910.3                         //      ADDS    p, p, #4
 1910.4                                 ENDM
 1911    00000008 0868                  LDR     t, [n]  // read [val]
 1912    0000000A 1040                  ANDS    t, t, w // modify val
 1913    0000000C 0860                  STR     t, [n]  // Write val
 1914                                   NEXT
 1914.1                         // ARMv7-M Thumb = .+5
 1914.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1914.3                         // ARMv6-M Thumb = .+4
 1914.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1914                                   NEXT1
 1914.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1914.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1914.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1914.4                         // ARMv6-M Thumb = .+4
 1914.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1914.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1914.7                                 ENDM
 1914.8                                 ENDM
 1915                           
 1916                           
 1917                           //      SETBITS SETBITS:        ( addr val -- ) OR val bits into addr.
 1918                           //      See also CLRBITS.
 1919                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1920                           
 1921                            SECTION .text : CONST (2)
 1922                           SETBITS_NFA:
 1923    00000000 87                    DC8     0x87
 1924    00000001 534554424954          DC8     'SETBIT'
 1925    00000007 D3                    DC8     'S'+0x80
 1926                            ALIGNROM 2,0xFFFFFFFF
 1927    00000008 ........              DC32    ANDBITS_NFA
 1928                           SETBITS:
 1929    0000000C ........              DC32    .+5
 1930                            SECTION .text : CODE (2)
 1931                                   POPp2w          // val
 1931.1                                 // as in xeq token on ToS setup for exec
 1931.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1931.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1931.4                                 ENDM
 1932                                   POP2n           // addr
 1932.1  00000004 57F8041B              LDR     n, [p],#4
 1932.2                         //      LDR     n, [p]
 1932.3                         //      ADDS    p, p, #4
 1932.4                                 ENDM
 1933    00000008 0868                  LDR     t, [n]  // read[val]
 1934    0000000A 1043                  ORRS    t, t, w // modify val
 1935    0000000C 0860                  STR     t, [n]  // Write val
 1936                                   NEXT
 1936.1                         // ARMv7-M Thumb = .+5
 1936.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1936.3                         // ARMv6-M Thumb = .+4
 1936.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1936                                   NEXT1
 1936.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1936.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1936.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1936.4                         // ARMv6-M Thumb = .+4
 1936.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1936.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1936.7                                 ENDM
 1936.8                                 ENDM
 1937                           
 1938                           
 1939                           //      CLRBITS CLRBITS:        ( addr val -- )
 1940                           //      XOR val bits into addr. See also SETBITS.
 1941                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1942                           
 1943                            SECTION .text : CONST (2)
 1944                           CLRBITS_NFA:
 1945    00000000 87                    DC8     0x87
 1946    00000001 434C52424954          DC8     'CLRBIT'
 1947    00000007 D3                    DC8     'S'+0x80
 1948                            ALIGNROM 2,0xFFFFFFFF
 1949    00000008 ........              DC32    SETBITS_NFA
 1950                           CLRBITS:
 1951    0000000C ........              DC32    .+5
 1952                            SECTION .text : CODE (2)
 1953                                   POPp2w                  // val
 1953.1                                 // as in xeq token on ToS setup for exec
 1953.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1953.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1953.4                                 ENDM
 1954                                   POP2n                   // addr
 1954.1  00000004 57F8041B              LDR     n, [p],#4
 1954.2                         //      LDR     n, [p]
 1954.3                         //      ADDS    p, p, #4
 1954.4                                 ENDM
 1955    00000008 0868                  LDR     t, [n]          // read [val]
 1956    0000000A 9043                  BICS    t, t, w         // modify val  - AND-NOT
 1957    0000000C 0860                  STR     t, [n]          // write val
 1958                                   NEXT
 1958.1                         // ARMv7-M Thumb = .+5
 1958.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1958.3                         // ARMv6-M Thumb = .+4
 1958.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1958                                   NEXT1
 1958.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1958.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1958.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1958.4                         // ARMv6-M Thumb = .+4
 1958.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1958.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1958.7                                 ENDM
 1958.8                                 ENDM
 1959                           
 1960                           
 1961                           //      CMOVE CMOVE:    ( from to count -- )
 1962                           //      Move the specified quantity of bytes beginning at address from to
 1963                           //      address to. The contents of address from is moved first proceeding
 1964                           //      toward high memory. Further specification is necessary on word
 1965                           //      addressing computers.
 1966                           
 1967                            SECTION .text : CONST (2)
 1968                           CMOVE_NFA:
 1969    00000000 85                    DC8     0x85
 1970    00000001 434D4F56              DC8     'CMOV'
 1971    00000005 C5                    DC8     'E'+0x80
 1972    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1973    00000008 ........              DC32    CLRBITS_NFA
 1974                           CMOVE:
 1975    0000000C ........              DC32    .+5
 1976                            SECTION .text : CODE (2)
 1977                                   POP2n //    ldr n, [p],#4      //COUNT
 1977.1  00000000 57F8041B              LDR     n, [p],#4
 1977.2                         //      LDR     n, [p]
 1977.3                         //      ADDS    p, p, #4
 1977.4                                 ENDM
 1978                                   POP2w //    ldr w, [p],#4      //DEST
 1978.1  00000004 57F8042B              LDR     w, [p],#4
 1978.2                         //      LDR     w, [p]
 1978.3                         //      ADDS    p, p, #4
 1978.4                                 ENDM
 1979                                   POP2x //    ldr x, [p],#4      //SOURCE
 1979.1  00000008 57F8043B              LDR     x, [p],#4
 1979.2                         //      LDR     x, [p]
 1979.3                         //      ADDS    p, p, #4
 1979.4                                 ENDM
 1980    0000000C 0029                  CMP     n, #0
 1981    0000000E 07D0                  BEQ     CM2
 1982                           CM1:
 1983                           //not for THUMB
 1984                           //strcpy  LDRB R2, [R1], #1
 1985                           //        STRB R2, [R0], #1
 1986                           //        TST R2, R2      // repeat if R2 is nonzero
 1987                           //        BNE strcpy
 1988    00000010 1878                  LDRB    t, [x]
 1989    00000012 1070                  STRB    t, [w]
 1990    00000014 491E                  SUBS    n, n, #1
 1991    00000016 0029                  CMP     n, #0
 1992    00000018 02D0                  BEQ     CM2
 1993                           
 1994    0000001A 521C                  ADDS    w, w, #1
 1995    0000001C 5B1C                  ADDS    x, x, #1
 1996    0000001E F7D1                  BNE     CM1
 1997                           CM2:
 1998                           #ifdef TOSCT
 2000                           #endif
 2001                                   NEXT
 2001.1                         // ARMv7-M Thumb = .+5
 2001.2  00000020 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2001.3                         // ARMv6-M Thumb = .+4
 2001.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2001                                   NEXT1
 2001.1  00000024 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2001.2  00000028 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2001.3  0000002C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2001.4                         // ARMv6-M Thumb = .+4
 2001.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2001.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2001.7                                 ENDM
 2001.8                                 ENDM
 2002                           
 2003                           
 2004                           //      FILL FILL:      ( addr quan b -- )
 2005                           //      Fill memory at the address with the specified quantity of bytes b.
 2006                           
 2007                            SECTION .text : CONST (2)
 2008                           FILL_NFA:
 2009    00000000 84                    DC8     0x84
 2010    00000001 46494C                DC8     'FIL'
 2011    00000004 CC                    DC8     'L'+0x80
 2012    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2013    00000008 ........              DC32    CMOVE_NFA
 2014                           FILL:
 2015    0000000C ........              DC32    .+5
 2016                            SECTION .text : CODE (2)
 2017                                   POP2t                   // Fill CHAR
 2017.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2017.2                         //#ifndef TOSCT
 2017.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2017.4                         //#endif
 2017.5                         //      ADDS    p, p, #4
 2017.6                                 ENDM
 2018                                   POP2n                   // Fill COUNT
 2018.1  00000004 57F8041B              LDR     n, [p],#4
 2018.2                         //      LDR     n, [p]
 2018.3                         //      ADDS    p, p, #4
 2018.4                                 ENDM
 2019                                   POP2w                   // Beginning ADDR
 2019.1  00000008 57F8042B              LDR     w, [p],#4
 2019.2                         //      LDR     w, [p]
 2019.3                         //      ADDS    p, p, #4
 2019.4                                 ENDM
 2020    0000000C 0029                  CMP     n, #0
 2021    0000000E 04D0                  BEQ     FEND            // Count is zero
 2022    00000010 8B18                  ADDS    x, n, w
 2023                           FLOOP:
 2024    00000012 1070                  STRB    t, [w]
 2025    00000014 521C                  ADDS    w, w, #1
 2026    00000016 9A42                  CMP     w, x
 2027    00000018 FBD1                  BNE     FLOOP
 2028                           FEND:
 2029                           #ifdef TOSCT
 2031                           #endif
 2032                                   NEXT
 2032.1                         // ARMv7-M Thumb = .+5
 2032.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2032.3                         // ARMv6-M Thumb = .+4
 2032.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2032                                   NEXT1
 2032.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2032.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2032.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2032.4                         // ARMv6-M Thumb = .+4
 2032.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2032.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2032.7                                 ENDM
 2032.8                                 ENDM
 2033                           
 2034                           
 2035                           //      ERASE ERASE:    ( addr n -- )
 2036                           //      Clear a region of memory to zero from addr over n addresses.
 2037                           
 2038                            SECTION .text : CONST (2)
 2039                           ERASE_NFA:
 2040    00000000 85                    DC8     0x85
 2041    00000001 45524153              DC8     'ERAS'
 2042    00000005 C5                    DC8     'E'+0x80
 2043    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2044    00000008 ........              DC32    FILL_NFA
 2045                           ERASE:
 2046    0000000C ........              DC32    DOCOL
 2047    00000010 ........              DC32    ZERO
 2048    00000014 ........              DC32    FILL
 2049    00000018 ........              DC32    SEMIS
 2050                           
 2051                           
 2052                           //      BLANKS BLANKS:  ( addr count -- )
 2053                           //      Fill an area of memory beginning at addr with blanks (0x20).
 2054                           
 2055                            SECTION .text : CONST (2)
 2056                           BLANKS_NFA:
 2057    00000000 86                    DC8     0x86
 2058    00000001 424C414E4B            DC8     'BLANK'
 2059    00000006 D3                    DC8     'S'+0x80
 2060    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2061    00000008 ........              DC32    ERASE_NFA
 2062                           BLANKS:
 2063    0000000C ........              DC32    DOCOL
 2064    00000010 ........              DC32    BLANK
 2065    00000014 ........              DC32    FILL
 2066    00000018 ........              DC32    SEMIS
 2067                           
 2068                           
 2069                           //      +! PSTORE:      ( n addr -- )
 2070                           //      Add n to the value at the address.
 2071                           //      Pronounced Plus Store
 2072                           
 2073                            SECTION .text : CONST (2)
 2074                           PSTORE_NFA:
 2075    00000000 82                    DC8     0x82
 2076    00000001 2B                    DC8     '+'
 2077    00000002 A1                    DC8     '!'+0x80
 2078    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2079    00000004 ........              DC32    BLANKS_NFA
 2080                           PSTORE:
 2081    00000008 ........              DC32    .+5
 2082                            SECTION .text : CODE (2)
 2083                                   POP2n                   // ADDRESS
 2083.1  00000000 57F8041B              LDR     n, [p],#4
 2083.2                         //      LDR     n, [p]
 2083.3                         //      ADDS    p, p, #4
 2083.4                                 ENDM
 2084                           #ifdef TOSCT
 2086                           #endif
 2087                                   POP2t                   // INCREMENT
 2087.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 2087.2                         //#ifndef TOSCT
 2087.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2087.4                         //#endif
 2087.5                         //      ADDS    p, p, #4
 2087.6                                 ENDM
 2088    00000008 0A68                  LDR     w, [n]
 2089    0000000A 8018                  ADDS    t, t, w
 2090    0000000C 0860                  STR     t, [n]
 2091                                   NEXT
 2091.1                         // ARMv7-M Thumb = .+5
 2091.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2091.3                         // ARMv6-M Thumb = .+4
 2091.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2091                                   NEXT1
 2091.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2091.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2091.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2091.4                         // ARMv6-M Thumb = .+4
 2091.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2091.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2091.7                                 ENDM
 2091.8                                 ENDM
 2092                           
 2093                           
 2094                           //      @ AT:   ( addr -- n )
 2095                           //      Read 32 bit contents of address to TOS.
 2096                           //      Pronounced Fetch, as in Fetch word at addr.
 2097                           
 2098                            SECTION .text : CONST (2)
 2099                           AT_NFA:
 2100    00000000 81                    DC8     0x81
 2101    00000001 C0                    DC8     '@'+0x80 //C0H
 2102    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2103                           //      DC32    TOGGLE_NFA
 2104    00000004 ........              DC32    PSTORE_NFA
 2105                           AT:
 2106    00000008 ........              DC32    .+5
 2107                            SECTION .text : CODE (2)
 2108                           //#ifdef TOSCT
 2109                           //        LDR     t, [t]
 2110                           //        STR     t, [p]
 2111                           //        NEXT
 2112                           //#else AT:
 2113                                   POP2n
 2113.1  00000000 57F8041B              LDR     n, [p],#4
 2113.2                         //      LDR     n, [p]
 2113.3                         //      ADDS    p, p, #4
 2113.4                                 ENDM
 2114    00000004 0868                  LDR     t, [n]
 2115                                   TPUSH
 2115                                   PUSHt   // push t to p, pre decrement p
 2115.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 2115.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 2115.3                         //      STR     t, [p]
 2115.4                                 ENDM
 2115                                   NEXT
 2115.1                         // ARMv7-M Thumb = .+5
 2115.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2115.3                         // ARMv6-M Thumb = .+4
 2115.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2115                                   NEXT1
 2115.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2115.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2115.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2115.4                         // ARMv6-M Thumb = .+4
 2115.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2115.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2115.7                                 ENDM
 2115.8                                 ENDM
 2115.9                                 ENDM
 2116                           //#endif
 2117                                   
 2118                           //      C@ CAT: ( addr -- b )
 2119                           //      Leave the 8 bit contents of addr on the stack.
 2120                           //      Pronounced "Char Fetch", as in Fetch byte at addr.
 2121                           
 2122                            SECTION .text : CONST (2)
 2123                           CAT_NFA:
 2124    00000000 82                    DC8     0x82
 2125    00000001 43                    DC8     'C'
 2126    00000002 C0                    DC8     '@'+0x80 //C0H
 2127    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2128    00000004 ........              DC32    AT_NFA
 2129                           CAT:
 2130    00000008 ........              DC32    .+5
 2131                            SECTION .text : CODE (2)
 2132                                   POP2n
 2132.1  00000000 57F8041B              LDR     n, [p],#4
 2132.2                         //      LDR     n, [p]
 2132.3                         //      ADDS    p, p, #4
 2132.4                                 ENDM
 2133    00000004 0878                  LDRB    t, [n]
 2134                                   TPUSH
 2134                                   PUSHt   // push t to p, pre decrement p
 2134.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 2134.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 2134.3                         //      STR     t, [p]
 2134.4                                 ENDM
 2134                                   NEXT
 2134.1                         // ARMv7-M Thumb = .+5
 2134.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2134.3                         // ARMv6-M Thumb = .+4
 2134.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2134                                   NEXT1
 2134.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2134.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2134.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2134.4                         // ARMv6-M Thumb = .+4
 2134.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2134.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2134.7                                 ENDM
 2134.8                                 ENDM
 2134.9                                 ENDM
 2135                           
 2136                           
 2137                           //      ! STORE:        ( n addr -- )
 2138                           //      Store n at address. Pronounced "Store".
 2139                           
 2140                            SECTION .text : CONST (2)
 2141                           STORE_NFA:
 2142    00000000 81                    DC8     0x81
 2143    00000001 A1                    DC8     '!'+0x80
 2144    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2145    00000004 ........              DC32    CAT_NFA
 2146                           STORE:
 2147    00000008 ........              DC32    .+5
 2148                            SECTION .text : CODE (2)
 2149                                   POP2t           // ADDR
 2149.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2149.2                         //#ifndef TOSCT
 2149.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2149.4                         //#endif
 2149.5                         //      ADDS    p, p, #4
 2149.6                                 ENDM
 2150                                   POP2n           // DATA
 2150.1  00000004 57F8041B              LDR     n, [p],#4
 2150.2                         //      LDR     n, [p]
 2150.3                         //      ADDS    p, p, #4
 2150.4                                 ENDM
 2151    00000008 0160                  STR     n, [t]
 2152                                   NEXT
 2152.1                         // ARMv7-M Thumb = .+5
 2152.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2152.3                         // ARMv6-M Thumb = .+4
 2152.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2152                                   NEXT1
 2152.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2152.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2152.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2152.4                         // ARMv6-M Thumb = .+4
 2152.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2152.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2152.7                                 ENDM
 2152.8                                 ENDM
 2153                           
 2154                           
 2155                           //      C! CSTORE:      ( n addr -- )
 2156                           //      Store LS 8 bits of n at address. Pronounced "Char Store".
 2157                           
 2158                            SECTION .text : CONST (2)
 2159                           CSTORE_NFA:
 2160    00000000 82                    DC8     0x82
 2161    00000001 43                    DC8     'C'
 2162    00000002 A1                    DC8     '!'+0x80
 2163    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2164    00000004 ........              DC32    STORE_NFA
 2165                           CSTORE:
 2166    00000008 ........              DC32    .+5
 2167                            SECTION .text : CODE (2)
 2168                                   POP2t
 2168.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2168.2                         //#ifndef TOSCT
 2168.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2168.4                         //#endif
 2168.5                         //      ADDS    p, p, #4
 2168.6                                 ENDM
 2169                                   POP2n
 2169.1  00000004 57F8041B              LDR     n, [p],#4
 2169.2                         //      LDR     n, [p]
 2169.3                         //      ADDS    p, p, #4
 2169.4                                 ENDM
 2170    00000008 0170                  STRB    n, [t]
 2171                                   NEXT
 2171.1                         // ARMv7-M Thumb = .+5
 2171.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2171.3                         // ARMv6-M Thumb = .+4
 2171.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2171                                   NEXT1
 2171.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2171.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2171.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2171.4                         // ARMv6-M Thumb = .+4
 2171.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2171.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2171.7                                 ENDM
 2171.8                                 ENDM
 2172                           
 2173                           
 2174                           //=============================== WORDCAT ====================================//
 2175                           //NOEXEC HEADERFORWORDCATEGORIES
 2176                           //      WC_RWMEMORY_NFA = Read and Write Memory With: CATEGORY
 2177                           
 2178                            SECTION .text : CONST (2)
 2179                           WC_RWMEMORY_NFA:
 2180    00000000 9F                    DC8     0x80+31
 2181    00000001 0D0A                  DC8     0x0D, 0x0A
 2182    00000003 5265616420616         DC8     'Read and Write Memory With:'
                  E642057726974
                  65204D656D6F7
                  2792057697468
                  3A           
 2183    0000001E 0D8A                  DC8     0x0D, 0x0A+0x80
 2184                            ALIGNROM 2,0xFFFFFFFF
 2185    00000020 ........              DC32    CSTORE_NFA
 2186                           
 2187                           
 2188                           //      ] RBRAC:        ( -- )
 2189                           //      Resume compilation, by STATE back to 0xC0 (zero is interpreting)
 2190                           //      0xC0 STATE  used in INTERPRET to execute Immediate words while compiling
 2191                           //      See [.
 2192                           
 2193                            SECTION .text : CONST (2)
 2194                           RBRAC_NFA:
 2195    00000000 81                    DC8     0x81
 2196    00000001 DD                    DC8     ']'+0x80
 2197    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2198                           //      DC32    SMUDGE_NFA
 2199    00000004 ........              DC32    WC_RWMEMORY_NFA
 2200                           RBRAC:
 2201    00000008 ........              DC32    DOCOL
 2202    0000000C ........C0000         DC32    strva, 0xC0, CSTATE
                  000........  
 2203    00000018 ........              DC32    SEMIS
 2204                           
 2205                           
 2206                           //      [ LBRAC:        ( -- ) IMMEDIATE
 2207                           //      Used in a colon-definition in form
 2208                           //              xxx    [  words   ]    more
 2209                           //      Suspend compilation by setting STATE to zero (0xC0 is compiling).
 2210                           //      The words after [ are executed, not compiled. This allows calculation
 2211                           //      or compilation exceptions before resuming compilation with ] .
 2212                           //      See LITERAL and ]
 2213                           
 2214                            SECTION .text : CONST (2)
 2215                           LBRAC_NFA:
 2216    00000000 C1                    DC8     0x0C1
 2217    00000001 DB                    DC8     '['+0x80
 2218    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2219    00000004 ........              DC32    RBRAC_NFA
 2220                           LBRAC:
 2221    00000008 ........              DC32    DOCOL
 2222    0000000C ........00000         DC32    strva, 0, CSTATE
                  000........  
 2223    00000018 ........              DC32    SEMIS
 2224                           
 2225                           
 2226                           //      [COMPILE] BCOMP:        ( -- ) IMMEDIATE
 2227                           //      Used in a colon-definition in form:
 2228                           //              :  xxx    [COMPILE]   immediate_word   ;
 2229                           //      [COMPILE] will force the compilation of an IMMEDIATE WORD
 2230                           //      that would otherwise execute during compilation. The above example
 2231                           //      will select the FORTH vocabulary then xxx executes, rather than at
 2232                           //      compile time.
 2233                           
 2234                            SECTION .text : CONST (2)
 2235                           BCOMP_NFA:
 2236    00000000 C9                    DC8     0x0C9
 2237    00000001 5B434F4D50494         DC8     '[COMPILE'
                  C45          
 2238    00000009 DD                    DC8     ']'+0x80
 2239    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2240    0000000C ........              DC32    LBRAC_NFA
 2241                           BCOMP:
 2242    00000010 ........              DC32    DOCOL
 2243    00000014 ........              DC32    DFIND   // noop there for TIB entry
 2244                           //      -FIND \ --- pfa len tf (found) \ --- ff (not found)
 2245    00000018 ........              DC32    ZEQU
 2246    0000001C .............         DC32    LIT, msg_qstack
                  ...          
 2247    00000024 ........              DC32    QERROR    // \ f nullstr-addr --
 2248    00000028 ........              DC32    DROP
 2249    0000002C ........              DC32    CFA
 2250    00000030 ........              DC32    COMMA   // alighned, INCREMENTS DP REFLECTED by HERE
 2251    00000034 ........              DC32    SEMIS
 2252                           
 2253                           
 2254                           //      DLITERAL DLITERAL:      ( d -- d ) IMMEDIATE
 2255                           //                              ( d -- )   (compiling)
 2256                           //      If compiling, compile a stack double number into a literal. Later
 2257                           //      execution of the definition containing the literal will push it to
 2258                           //      the stack. If executing, the number will remain on the stack.
 2259                           //      : xxx    [ calculate ]  DLITERAL  ; //
 2260                           
 2261                            SECTION .text : CONST (2)
 2262                           DLITERAL_NFA:
 2263    00000000 C8                    DC8     0x0C8
 2264    00000001 444C495445524         DC8     'DLITERA'
                  1            
 2265    00000008 CC                    DC8     'L'+0x80
 2266    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2267    0000000C ........              DC32    BCOMP_NFA
 2268                           DLITERAL:
 2269    00000010 ........              DC32    DOCOL
 2270    00000014 ........              DC32    STATE_SV
 2271    00000018 ........              DC32    AT
 2272    0000001C ........              DC32    ZBRAN   // IF
 2273    00000020 10000000              DC32     DLIT1-.
 2274                           
 2275    00000024 ........              DC32    SWAP
 2276    00000028 ........              DC32    LITERAL
 2277    0000002C ........              DC32    LITERAL // endif
 2278                           DLIT1:
 2279    00000030 ........              DC32    SEMIS
 2280                           
 2281                           
 2282                           //      LITERAL LITERAL:        ( n -- ) IMMEDIATE
 2283                           //      If compiling, then compile the stack value n as a 32 bit literal.
 2284                           //      This definition is immediate so that it will execute during a colon
 2285                           //      definition. The intended use is:
 2286                           //      : xxx    [ calculate ]  LITERAL  ; //
 2287                           //      Compilation is suspended for the compile time calculation of value.
 2288                           //      Compilation is resumed and LITERAL compiles this value.
 2289                           
 2290                            SECTION .text : CONST (2)
 2291                           LITERAL_NFA:
 2292    00000000 C7                    DC8     0x0C7
 2293    00000001 4C4954455241          DC8     'LITERA'
 2294    00000007 CC                    DC8     'L'+0x80
 2295                            ALIGNROM 2,0xFFFFFFFF
 2296    00000008 ........              DC32    DLITERAL_NFA
 2297                           LITERAL:
 2298    0000000C ........              DC32    DOCOL
 2299    00000010 ........              DC32    STATE_SV
 2300    00000014 ........              DC32    AT
 2301    00000018 ........              DC32    ZBRAN           // If not compiling
 2302    0000001C 10000000              DC32     LITE1-.        // go here
 2303                           
 2304    00000020 ........              DC32    COMP            // Compile
 2305    00000024 ........              DC32    LIT             // Literal
 2306    00000028 ........              DC32    COMMA           // Then COMPILE THE LITERAL VALUE
 2307                           LITE1:
 2308    0000002C ........              DC32    SEMIS
 2309                           
 2310                           
 2311                           //      #> EDIGS:       ( d=(LSW MSW) -- addr count )
 2312                           //      Terminates numeric output conversion by dropping dnum,
 2313                           //      leaving the text address and character count suitable for type.
 2314                           
 2315                            SECTION .text : CONST (2)
 2316                           EDIGS_NFA:
 2317    00000000 82                    DC8     0x82
 2318    00000001 23                    DC8     '#'
 2319    00000002 BE                    DC8     '>'+0x80
 2320    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2321    00000004 ........              DC32    LITERAL_NFA
 2322                           EDIGS:
 2323    00000008 ........              DC32    DOCOL
 2324    0000000C ........              DC32    DROP
 2325    00000010 ........              DC32    DROP
 2326    00000014 ........              DC32    HLD_SV
 2327    00000018 ........              DC32    AT
 2328    0000001C ........              DC32    PAD_SV
 2329    00000020 ........              DC32    OVER
 2330    00000024 ........              DC32    SUBB
 2331    00000028 ........              DC32    SEMIS
 2332                           
 2333                           
 2334                           //      HOLD HOLD:      ( c -- )
 2335                           //      Used between <# and #> to insert an ascii character into a pictured
 2336                           //      numeric output string.
 2337                           //      e.g. 0x2E HOLD will place a decimal point.
 2338                           
 2339                            SECTION .text : CONST (2)
 2340                           HOLD_NFA:
 2341    00000000 84                    DC8     0x84
 2342    00000001 484F4C                DC8     'HOL'
 2343    00000004 C4                    DC8     'D'+0x80
 2344    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2345    00000008 ........              DC32    EDIGS_NFA
 2346                           HOLD:
 2347    0000000C ........              DC32    DOCOL
 2348    00000010 ........FFFFF         DC32    LIT,-1
                  FFF          
 2349    00000018 ........              DC32    HLD_SV
 2350    0000001C ........              DC32    PSTORE
 2351    00000020 ........              DC32    HLD_SV
 2352    00000024 ........              DC32    AT
 2353    00000028 ........              DC32    CSTORE
 2354    0000002C ........              DC32    SEMIS
 2355                           
 2356                           
 2357                           //      SIGN SIGN:      ( n d=<LSW MSW> -- d=<LSW MSW> )
 2358                           //      Place an ascii "-" sign just before a converted numeric output
 2359                           //      string in the text output buffer when n is negative. n is discarded
 2360                           //      but double number dnum is maintained. Must be used between <# and #>.
 2361                           
 2362                            SECTION .text : CONST (2)
 2363                           SIGN_NFA:
 2364    00000000 84                    DC8     0x84
 2365    00000001 534947                DC8     'SIG'
 2366    00000004 CE                    DC8     'N'+0x80
 2367    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2368    00000008 ........              DC32    HOLD_NFA
 2369                           SIGN:
 2370    0000000C ........              DC32    DOCOL
 2371    00000010 ........              DC32    ROT
 2372    00000014 ........              DC32    ZLESS
 2373    00000018 ........              DC32    ZBRAN           // If
 2374    0000001C 10000000              DC32     SIGN1-.
 2375                           
 2376    00000020 ........2D000         DC32    LIT, '-'        // 0x2D
                  000          
 2377    00000028 ........              DC32    HOLD            // Endif
 2378                           SIGN1:
 2379    0000002C ........              DC32    SEMIS
 2380                           
 2381                           
 2382                           //      #S DIGS:        ( d1=<LSW MSW> -- d2=<LSW MSW> )
 2383                           //      Generates ascii text in the text output buffer, by the use of #,
 2384                           //      until a zero double number d2 results.
 2385                           //      Used between <# and #>.
 2386                           //      EACH NUMBER = BASE*number+(character-'0')
 2387                           
 2388                            SECTION .text : CONST (2)
 2389                           DIGS_NFA:
 2390    00000000 82                    DC8     0x82
 2391    00000001 23                    DC8     '#'
 2392    00000002 D3                    DC8     'S'+0x80
 2393    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2394    00000004 ........              DC32    SIGN_NFA
 2395                           DIGS:
 2396    00000008 ........              DC32    DOCOL
 2397                           DIGS1:                          // Begin generating ascii chars by DIG
 2398    0000000C ........              DC32    DIG             //\ d1=<LSW MSW> -- d2=QUO=<LSW MSW>
 2399    00000010 ........              DC32    OVER
 2400    00000014 ........              DC32    OVER
 2401    00000018 ........              DC32    OR
 2402    0000001C ........              DC32    ZEQU
 2403    00000020 ........              DC32    ZBRAN           //UNTIL
 2404    00000024 E8FFFFFF              DC32     DIGS1-.
 2405    00000028 ........              DC32    SEMIS
 2406                           
 2407                           
 2408                           //      # DIG:  ( d1=<LSW MSW> -- d2=QUO=<LSW MSW> ) BASE MUST BE SET!
 2409                           //      Generate from a double number d1, the next ascii character which is
 2410                           //      placed in an output string. Result d2 is the quotient after division
 2411                           //      by base, and is maintained for further processing.
 2412                           //      Used between <# and #>.
 2413                           //      See #S.
 2414                           //      EACH NUMBER = BASE*number+(character-'0')
 2415                           
 2416                            SECTION .text : CONST (2)
 2417                           DIG_NFA:
 2418    00000000 81                    DC8     0x81
 2419    00000001 A3                    DC8     '#'+0x80
 2420    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2421    00000004 ........              DC32    DIGS_NFA
 2422                           DIG:
 2423    00000008 ........              DC32    DOCOL
 2424    0000000C ........              DC32    BASE_SV         // EX 0 1 0
 2425    00000010 ........              DC32    AT              // -- 0 1 0 A
 2426    00000014 ........              DC32    MSMOD           // -- 0 1 0 0
 2427    00000018 ........              DC32    ROT             // -- 0 0 0 1
 2428    0000001C ........09000         DC32    LIT,9
                  000          
 2429    00000024 ........              DC32    OVER
 2430    00000028 ........              DC32    LESSTHAN
 2431    0000002C ........              DC32    ZBRAN           // If
 2432    00000030 10000000              DC32     DIG1-.
 2433                           
 2434    00000034 ........07000         DC32    LIT,7
                  000          
 2435    0000003C ........              DC32    PLUS            // Endif
 2436                           DIG1:
 2437    00000040 ........30000         DC32    LIT, 0x30
                  000          
 2438    00000048 ........              DC32    PLUS
 2439    0000004C ........              DC32    HOLD
 2440    00000050 ........              DC32    SEMIS
 2441                           
 2442                           
 2443                           //      <# BDIGS:       ( -- )
 2444                           //      Setup for pictured numeric output formatting using the words:
 2445                           //              <# # #S SIGN HOLD #>
 2446                           //      The conversion is done on a double number producing text at Pad
 2447                           
 2448                            SECTION .text : CONST (2)
 2449                           BDIGS_NFA:
 2450    00000000 82                    DC8     0x82
 2451    00000001 3C                    DC8     '<'
 2452    00000002 A3                    DC8     '#'+0x80
 2453    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2454    00000004 ........              DC32    DIG_NFA
 2455                           BDIGS:
 2456    00000008 ........              DC32    DOCOL
 2457    0000000C .............         DC32    strva, PAD, NHLD
                  ...........  
 2458    00000018 ........              DC32    SEMIS
 2459                           
 2460                           
 2461                           //      DOES> DOES:     ( pfa -- ) MODIFIED:
 2462                           //      A word which defines the run-time action within a high-level
 2463                           //      defining word. DOES> alters the code field and first parameter of
 2464                           //      the new word to execute the sequence of compiled word addresses
 2465                           //      following DOES>. Used in combination with <BUILDS. When the DOES>
 2466                           //      part executes it begins with the address of the first parameter of
 2467                           //      the new word on the stack. This allows interpretation using this
 2468                           //      area or its contents. Typical uses include the Forth assembler,
 2469                           //      multidimensional arrays, and compiler generation.
 2470                           
 2471                            SECTION .text : CONST (2)
 2472                           DOES_NFA:
 2473    00000000 85                    DC8     0x85
 2474    00000001 444F4553              DC8     'DOES'
 2475    00000005 BE                    DC8     '>'+0x80
 2476    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2477    00000008 ........              DC32    BDIGS_NFA
 2478                           DOES:
 2479    0000000C ........              DC32    DOCOL
 2480    00000010 ........              DC32    RFROM   // Get the addr of the first word after DOES>
 2481    00000014 ........              DC32    LATEST  // ( -- addr ) nfa OF the current <creator> word
 2482    00000018 ........              DC32    PFA     // Use the pfa to store a run-time cfa
 2483    0000001C .............         DC32    DUP, CFA
                  ...          
 2484    00000024 .............         DC32    LIT, CREATE_DOES_GOTO
                  ...          
 2485    0000002C .............         DC32    SWAP, STORE     // STORE GOTO
                  ...          
 2486    00000034 ........              DC32    STORE   // Store the run-time cfa as 1rst pfa Parameter.
 2487    00000038 ........              DC32    SEMIS
 2488                           
 2489                           
 2490                           //      <BUILDS BUILDS: ( -- )  MODIFIED: See CREATE and DOES>
 2491                           //      Used within a colon-definition
 2492                           //              CCcc  <BUILDS  ...  DOES>     ...
 2493                           //      Each time CCcc is executed, <BUILDS defines a new word with a
 2494                           //      high-level execution proceedure. Executing CCcc in the form
 2495                           //              CCcc nnnn
 2496                           //      uses <BUILDS to create a dictionary entry for nnnn with a call to
 2497                           //      the DOES> part for nnnn. When nnnn is later executed, it has the
 2498                           //      address of its parameter area on the stack and executes the words
 2499                           //      after DOES> in CCcc. <BUILDS and DOES> allow runtime proceedures to
 2500                           //      written in high-level code.
 2501                           
 2502                            SECTION .text : CONST (2)
 2503                           BUILDS_NFA:
 2504    00000000 87                    DC8     0x87
 2505    00000001 3C4255494C44          DC8     '<BUILD'
 2506    00000007 D3                    DC8     'S'+0x80
 2507                            ALIGNROM 2,0xFFFFFFFF
 2508    00000008 ........              DC32    DOES_NFA
 2509                           BUILDS:
 2510    0000000C ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 2511    00000010 ........              DC32    CREATE                  // CREATE's A CON POINTING TO IT'S PFA
 2512    00000014 ........              DC32    SEMIS
 2513                           
 2514                           
 2515                           //      +LOOP PLOOP:    ( n1 -- ) IMMEDIATE
 2516                           //                      ( addr n2 -- ) COMPILE
 2517                           //      At run time, DO begins a sequence with repetitive execution
 2518                           //      controlled by a loop limit n1 and an index with initial value n2. DO
 2519                           //      removes these from the stack. Upon reaching LOOP the index is
 2520                           //      incremented by one.
 2521                           //      Until the new index equals or exceeds the limit, execution loops
 2522                           //      back to just after DO// otherwise the loop parameters are discarded
 2523                           //      and execution continues ahead. Both n1 and n2 are determined at
 2524                           //      run-time and may be the result of other operations.
 2525                           //      Within a loop 'I' will copy the current value of the index to the
 2526                           //      stack. See I, LOOP, +LOOP, LEAVE.
 2527                           //
 2528                           //      When compiling within the colon definition, DO compiles (DO), leaves
 2529                           //      the following address addr and n for later error checking.
 2530                           
 2531                            SECTION .text : CONST (2)
 2532                           PLOOP_NFA:
 2533    00000000 C5                    DC8     0x0C5
 2534    00000001 2B4C4F4F              DC8     '+LOO'
 2535    00000005 D0                    DC8     'P'+0x80
 2536    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2537    00000008 ........              DC32    BUILDS_NFA
 2538                           PLOOP:
 2539    0000000C ........              DC32    DOCOL
 2540    00000010 ........              DC32    THREE
 2541    00000014 ........              DC32    QPAIR
 2542    00000018 ........              DC32    COMP
 2543    0000001C ........              DC32    XPLOOP
 2544    00000020 ........              DC32    BACK
 2545    00000024 ........              DC32    SEMIS
 2546                           
 2547                           
 2548                           //      LOOP LOOP:      ( addr n -- ) IMMEDIATE
 2549                           //      Occurs in a colon-definition in form:
 2550                           //              DO ... LOOP
 2551                           //      At run-time, LOOP selectively controls branching back to the
 2552                           //      corresponding DO based on the loop index and limit. The loop index
 2553                           //      is incremented by one and compared to the limit. The branch back to
 2554                           //      DO occurs until the index equals or exceeds the limit, then
 2555                           //      the parameters are discarded and execution continues ahead.
 2556                           //
 2557                           //      At compile-time. LOOP compiles (LOOP) and uses addr to calculate an
 2558                           //      offset to DO. n is used for error testing.
 2559                           
 2560                            SECTION .text : CONST (2)
 2561                           LOOP_NFA:
 2562    00000000 C4                    DC8     0x0C4
 2563    00000001 4C4F4F                DC8     'LOO'
 2564    00000004 D0                    DC8     'P'+0x80
 2565    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2566    00000008 ........              DC32    PLOOP_NFA
 2567                           LOOP:
 2568    0000000C ........              DC32    DOCOL
 2569    00000010 ........              DC32    THREE
 2570    00000014 ........              DC32    QPAIR
 2571    00000018 ........              DC32    COMP
 2572    0000001C ........              DC32    XLOOP
 2573    00000020 ........              DC32    BACK
 2574    00000024 ........              DC32    SEMIS
 2575                           
 2576                           
 2577                           //      DO DO:  ( n1 n2 -- ) IMMEDIATE
 2578                           //              (addr n -- ) COMPILE
 2579                           //      Occurs in a colon-definition in form:
 2580                           //      DO ... LOOP
 2581                           
 2582                            SECTION .text : CONST (2)
 2583                           DO_NFA:
 2584    00000000 C2                    DC8     0x0C2
 2585    00000001 44                    DC8     'D'
 2586    00000002 CF                    DC8     'O'+0x80
 2587    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2588    00000004 ........              DC32    LOOP_NFA
 2589                           DO:
 2590    00000008 ........              DC32    DOCOL
 2591    0000000C ........              DC32    COMP
 2592    00000010 ........              DC32    XDO
 2593    00000014 ........              DC32    HERE
 2594    00000018 ........              DC32    THREE
 2595    0000001C ........              DC32    SEMIS
 2596                           
 2597                           
 2598                           //      ENDIF ENDIF:    ( addr n -- ) IMMEDIATE
 2599                           //      Occurs in a colon-definition in form:
 2600                           //              IF ... ENDIF
 2601                           //              IF ... ELSE ... ENDIF
 2602                           //      At run-time, ENDIF serves only as the destination of a forward
 2603                           //      branch from IF or ELSE. It marks the conclusion of the conditional
 2604                           //      structure. THEN is another name for ENDIF. Both names are supported
 2605                           //      in fig-FORTH. See also IF and ELSE.
 2606                           //
 2607                           //      At compile-time, ENDIF computes the forward branch offset from addr
 2608                           //      to HERE and stores it at addr. n is used for error tests.
 2609                           
 2610                            SECTION .text : CONST (2)
 2611                           ENDIF_NFA:
 2612    00000000 C5                    DC8     0x0C5
 2613    00000001 454E4449              DC8     'ENDI'
 2614    00000005 C6                    DC8     'F'+0x80
 2615    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2616    00000008 ........              DC32    DO_NFA
 2617                           ENDIF:
 2618    0000000C ........              DC32    DOCOL
 2619    00000010 ........              DC32    QCOMP
 2620    00000014 ........              DC32    TWO     // 2 is the Error checking number for if.
 2621    00000018 ........              DC32    QPAIR
 2622    0000001C ........              DC32    HERE
 2623    00000020 ........              DC32    OVER
 2624    00000024 ........              DC32    SUBB
 2625    00000028 ........              DC32    SWAP
 2626    0000002C ........              DC32    STORE
 2627    00000030 ........              DC32    SEMIS
 2628                           
 2629                           
 2630                           //      THEN THEN:      ( -- ) IMMEDIATE
 2631                           //      An alias for ENDIF.
 2632                           
 2633                            SECTION .text : CONST (2)
 2634                           THEN_NFA:
 2635    00000000 C4                    DC8     0x0C4
 2636    00000001 544845                DC8     'THE'
 2637    00000004 CE                    DC8     'N'+0x80
 2638    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2639    00000008 ........              DC32    ENDIF_NFA
 2640                           THEN:
 2641    0000000C ........              DC32    DOCOL
 2642    00000010 ........              DC32    ENDIF
 2643    00000014 ........              DC32    SEMIS
 2644                           
 2645                           
 2646                           //      ELSE ELSE:      ( addr1 n1 -- ) IMMEDIATE
 2647                           //                      ( addr2 n2 -- ) COMPILING
 2648                           //      Occurs within a colon-definition in the form:
 2649                           //              IF ... ELSE ... ENDIF
 2650                           //      At run-time, ELSE executes after the true part following IF. ELSE
 2651                           //      forces execution to skip over the following false part and resumes
 2652                           //      execution after the ENDIF. It has no stack effect.
 2653                           //
 2654                           //      At compile-time ELSE emplaces BRANCH reserving a branch offset,
 2655                           //      leaves the address addr2 and n2 for error testing. ELSE also
 2656                           //      resolves the pending forward branch from IF by calculating the
 2657                           //      offset from addr1 to HERE and storing at addr1.
 2658                           
 2659                            SECTION .text : CONST (2)
 2660                           ELSE_NFA:
 2661    00000000 C4                    DC8     0x0C4
 2662    00000001 454C53                DC8     'ELS'
 2663    00000004 C5                    DC8     'E'+0x80
 2664    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2665    00000008 ........              DC32    THEN_NFA
 2666                           ELSE:
 2667    0000000C ........              DC32    DOCOL
 2668    00000010 ........              DC32    TWO
 2669    00000014 ........              DC32    QPAIR
 2670    00000018 ........              DC32    COMP
 2671    0000001C ........              DC32    BRAN
 2672    00000020 ........              DC32    HERE
 2673    00000024 ........              DC32    ZERO
 2674    00000028 ........              DC32    COMMA   // aligned, INCREMENTS DP REFLECTED by HERE
 2675    0000002C ........              DC32    SWAP
 2676    00000030 ........              DC32    TWO
 2677    00000034 ........              DC32    ENDIF
 2678    00000038 ........              DC32    TWO
 2679    0000003C ........              DC32    SEMIS
 2680                           
 2681                           
 2682                           //      IF IF:  ( f -- ) IMMEDIATE
 2683                           //              ( -- addr n ) COMPILE
 2684                           //      Occurs is a colon-definition in form:
 2685                           //              IF (tp) ...  ENDIF      .
 2686                           //              IF (tp) ... ELSE (fp) ... ENDIF
 2687                           //      At run-time, IF selects execution based on a boolean flag. If f is
 2688                           //      true (non-zero), execution continues ahead thru the true part. If f
 2689                           //      is false (zero), execution skips till just after ELSE to execute
 2690                           //      the false part. After either part, execution resumes after ENDIF.
 2691                           //      ELSE and its false part are optional.; if missing, false execution
 2692                           //      skips to just after ENDIF..
 2693                           //
 2694                           //      At compile-time IF compiles 0BRANCH and reserves space for an offset
 2695                           //      at addr. addr and n are used later for resolution of the offset and
 2696                           //      error testing.
 2697                           
 2698                            SECTION .text : CONST (2)
 2699                           IF_NFA:
 2700    00000000 C2                    DC8     0x0C2
 2701    00000001 49                    DC8     'I'
 2702    00000002 C6                    DC8     'F'+0x80
 2703    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2704    00000004 ........              DC32    ELSE_NFA
 2705                           IF:
 2706    00000008 ........              DC32    DOCOL
 2707    0000000C ........              DC32    COMP
 2708    00000010 ........              DC32    ZBRAN
 2709    00000014 ........              DC32    HERE
 2710    00000018 ........              DC32    ZERO
 2711    0000001C ........              DC32    COMMA
 2712    00000020 ........              DC32    TWO     // 2 is the Error checking number for if.
 2713    00000024 ........              DC32    SEMIS
 2714                           
 2715                           
 2716                           //      UNTIL UNTIL:    ( f -- ) IMMEDIATE
 2717                           //                      ( addr n -- ) COMPILE:
 2718                           //      Occurs within a colon-definition in the form:
 2719                           //              BEGIN ... UNTIL
 2720                           //      At run-time, UNTIL controls the conditional branch back to the
 2721                           //      corresponding BEGIN. If f is false, execution returns to just after.
 2722                           //      BEGIN:  if true, execution continues ahead.
 2723                           //      At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to
 2724                           //      addr. n is used for error tests.
 2725                           
 2726                            SECTION .text : CONST (2)
 2727                           UNTIL_NFA:
 2728    00000000 C5                    DC8     0x0C5
 2729    00000001 554E5449              DC8     'UNTI'
 2730    00000005 CC                    DC8     'L'+0x80
 2731    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2732    00000008 ........              DC32    IF_NFA
 2733                           UNTIL:
 2734    0000000C ........              DC32    DOCOL
 2735    00000010 ........              DC32    ONE
 2736    00000014 ........              DC32    QPAIR
 2737    00000018 ........              DC32    COMP
 2738    0000001C ........              DC32    ZBRAN
 2739    00000020 ........              DC32    BACK
 2740    00000024 ........              DC32    SEMIS
 2741                           
 2742                           
 2743                           //      AGAIN AGAIN:    ( addr n -- ) IMMEDIATE
 2744                           //      Used in a colon-definition in the form:
 2745                           //                      BEGIN ... AGAIN
 2746                           //      At run-time, AGAIN forces execution to return to corresponding BEGIN.
 2747                           //      There is no effect on the stack. Execution cannot leave this loop
 2748                           //      (unless R> DROP is executed one level below).
 2749                           //
 2750                           //      At compile time, AGAIN compiles BRANCH with an offset from HERE to
 2751                           //      addr. n is used for compile-time error checking.
 2752                           
 2753                            SECTION .text : CONST (2)
 2754                           AGAIN_NFA:
 2755    00000000 C5                    DC8     0x0C5
 2756    00000001 41474149              DC8     'AGAI'
 2757    00000005 CE                    DC8     'N'+0x80
 2758    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2759    00000008 ........              DC32    UNTIL_NFA
 2760                           AGAIN:
 2761    0000000C ........              DC32    DOCOL
 2762    00000010 ........              DC32    ONE
 2763    00000014 ........              DC32    QPAIR
 2764    00000018 ........              DC32    COMP
 2765    0000001C ........              DC32    BRAN
 2766    00000020 ........              DC32    BACK
 2767    00000024 ........              DC32    SEMIS
 2768                           
 2769                           
 2770                           //      REPEAT REPEAT:  ( addr n -- ) IMMEDIATE
 2771                           //      Used within a colon-definition in the form:
 2772                           //              BEGIN ... WHILE ... REPEAT
 2773                           //      At run-time, REPEAT forces an unconditional branch back to just
 2774                           //      after the corresponding BEGIN.
 2775                           //
 2776                           //      At compile-time, REPEAT compiles BRANCH and the offset from HERE to
 2777                           //      addr. n is used for error testing.
 2778                           
 2779                            SECTION .text : CONST (2)
 2780                           REPEAT_NFA:
 2781    00000000 C6                    DC8     0x0C6
 2782    00000001 5245504541            DC8     'REPEA'
 2783    00000006 D4                    DC8     'T'+0x80
 2784    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2785    00000008 ........              DC32    AGAIN_NFA
 2786                           REPEAT:
 2787    0000000C ........              DC32    DOCOL
 2788    00000010 ........              DC32    TOR
 2789    00000014 ........              DC32    TOR
 2790    00000018 ........              DC32    AGAIN
 2791    0000001C ........              DC32    RFROM
 2792    00000020 ........              DC32    RFROM
 2793    00000024 ........              DC32    TWO
 2794    00000028 ........              DC32    SUBB
 2795    0000002C ........              DC32    ENDIF
 2796    00000030 ........              DC32    SEMIS
 2797                           
 2798                           
 2799                           //      WHILE WHILE:    ( f -- ) IMMEDIATE
 2800                           //                      (ad1 nl -- ad1 n1 ad2 n2 ) COMPILE
 2801                           //      Occurs in a colon-definition in the form:
 2802                           //              BEGIN ... WHILE (tp) ... REPEAT
 2803                           //      At run-time, WHILE selects conditional execution based on boolean
 2804                           //      flag f. If f is true (non-zero), WHILE continues execution of the
 2805                           //      true part thru to REPEAT, which then branches back to BEGIN. If f is
 2806                           //      false (zero), execution skips to just after REPEAT, exiting the
 2807                           //      structure.
 2808                           //
 2809                           //      At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the
 2810                           //      reserved offset. The stack values will be resolved by REPEAT.
 2811                           
 2812                            SECTION .text : CONST (2)
 2813                           WHILE_NFA:
 2814    00000000 C5                    DC8     0x0C5
 2815    00000001 5748494C              DC8     'WHIL'
 2816    00000005 C5                    DC8     'E'+0x80
 2817    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2818    00000008 ........              DC32    REPEAT_NFA
 2819                           WHILE:
 2820    0000000C ........              DC32    DOCOL
 2821    00000010 ........              DC32    IF
 2822    00000014 ........              DC32    TWOP
 2823    00000018 ........              DC32    SEMIS
 2824                           
 2825                           
 2826                           //      BEGIN BEGIN:    ( -- addr n ) IMMEDIATE
 2827                           //      Occurs in a colon-definition in form:
 2828                           //      BEGIN ... UNTIL
 2829                           //      BEGIN ... AGAIN
 2830                           //      BEGIN ... WHILE ... REPEAT
 2831                           //      At run-time, BEGIN marks the start of a sequence that may be
 2832                           //      repetitively executed. It serves as a return point from the
 2833                           //      corresponding UNTIL, AGAIN or REPEAT. When executing UNTIL, a return
 2834                           //      to BEGIN will occur if the top of the stack is false//
 2835                           //      for AGAIN and REPEAT a return to BEGIN always occurs.
 2836                           //
 2837                           //      At compile time BEGIN leaves its return address and n for compiler
 2838                           //      error checking.
 2839                           
 2840                            SECTION .text : CONST (2)
 2841                           BEGIN_NFA:
 2842    00000000 C5                    DC8     0x0C5
 2843    00000001 42454749              DC8     'BEGI'
 2844    00000005 CE                    DC8     'N'+0x80
 2845    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2846    00000008 ........              DC32    WHILE_NFA
 2847                           BEGIN:
 2848    0000000C ........              DC32    DOCOL
 2849    00000010 ........              DC32    QCOMP
 2850    00000014 ........              DC32    HERE
 2851    00000018 ........              DC32    ONE
 2852    0000001C ........              DC32    SEMIS
 2853                           
 2854                           
 2855                           //=============================== WORDCAT ====================================//
 2856                           //NOEXEC HEADERFORWORDCATEGORIES
 2857                           //      WC_COMPILE_NFA = Inside Colon WORDS: CATEGORY
 2858                           
 2859                            SECTION .text : CONST (2)
 2860                           WC_COMPILE_NFA:
 2861    00000000 97                    DC8     0x80+4+19
 2862    00000001 0D0A                  DC8     0x0D, 0x0A
 2863    00000003 496E736964652         DC8     'Inside Colon WORDS:'
                  0436F6C6F6E20
                  574F5244533A 
 2864    00000016 0D8A                  DC8     0x0D, 0x0A+0x80
 2865                            ALIGNROM 2,0xFFFFFFFF
 2866    00000018 ........              DC32    BEGIN_NFA
 2867                           
 2868                           
 2869                           //      IMMEDIATE IMMED:        ( -- )
 2870                           //      Mark the most recently made definition so that when encountered at
 2871                           //      compile time, it will be executed rather than being compiled. i.e.
 2872                           //      the precedence bit in its header is set.
 2873                           //      This method allows definitions to handle unusual compiling
 2874                           //      situations, rather. than build them into the fundamental compiler.
 2875                           //      The system may force compilation of an immediate definition by
 2876                           //      preceeding it with [COMPILE].
 2877                           
 2878                            SECTION .text : CONST (2)
 2879                           IMMED_NFA:
 2880    00000000 89                    DC8     0x89
 2881    00000001 494D4D4544494         DC8     'IMMEDIAT'
                  154          
 2882    00000009 C5                    DC8     'E'+0x80
 2883    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2884    0000000C ........              DC32    WC_COMPILE_NFA
 2885                           IMMED:
 2886    00000010 ........              DC32    DOCOL
 2887    00000014 ........              DC32    LATEST
 2888    00000018 ........40000         DC32    LIT, 0x40
                  000          
 2889    00000020 ........              DC32    TOGGLE
 2890    00000024 ........              DC32    SEMIS
 2891                           
 2892                           
 2893                           //      CREATE CREATE:  ( -- )
 2894                           //      Create a word in The Dictionary.
 2895                           //      Make searchable and forgetable NFA/LFA, DOCON, ADDR->PFA
 2896                           //      USE <BUILDS with DOES> instead of CREATE.
 2897                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2898                           //
 2899                           //      Saves HERE in CSDP in case there's an error creating a word.
 2900                           //      CSDP is reset when a word is completed, by ; <BUILDS (?) CON and VAR.
 2901                           //
 2902                           //      A defining word used in the form:
 2903                           //              CREATE CCcc
 2904                           //      by such words as VAR, CON AND <BUILDS to create a dictionary header for
 2905                           //      a new word. The code field contains the address of the words
 2906                           //      parameter field.
 2907                           
 2908                            SECTION .text : CONST (2)
 2909                           CREATE_NFA:
 2910    00000000 86                    DC8     0x86
 2911    00000001 4352454154            DC8     'CREAT'
 2912    00000006 C5                    DC8     'E'+0x80
 2913    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2914    00000008 ........              DC32    IMMED_NFA
 2915                           CREATE:
 2916    0000000C ........              DC32    DOCOL
 2917    00000010 ........              DC32    DICTSPACE       //      \ -- n
 2918    00000014 ........0F000         DC32    LIT, 15, SUBB   // One less than smallest definition
                  000........  
 2919    00000020 ........              DC32    ZLESS
 2920    00000024 ........              DC32    ZBRAN
 2921    00000028 08000000              DC32    CREATEOK-.
 2922                           
 2923    0000002C ........              DC32    DICTFULL_ABORT
 2924                           
 2925                           CREATEOK:
 2926    00000030 ........              DC32    DFIND                   // Parse nfa
 2927                           //      -FIND DFIND \ --- pfa len tf (found) \ --- ff (not found)
 2928    00000034 ........              DC32    ZBRAN
 2929    00000038 24000000              DC32     CREA1-.
 2930                           
 2931                           #ifdef IO2TP
 2935                           #endif
 2936    0000003C ........              DC32    DROP
 2937    00000040 ........              DC32    NFA
 2938    00000044 ........              DC32    IDDOT
 2939    00000048 .............         DC32    LIT, msg_wordexists
                  ...          
 2940                           // Nothing created yet so ABORT is correct.
 2941                           //        DC32    ERROR
 2942    00000050 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 2943    00000058 ........              DC32    ABORT
 2944                           
 2945                           CREA1:
 2946                           // Save HERE in CSDP so ERROR can reset DP if this definition fails.
 2947                           // CSDP is reset by SEMIC_CREATE when this definition is completed.
 2948                           // SEMIC_CREATE used in ; CON and VAR to reset CSDP.
 2949                           
 2950                           // This new definitions cstring name has been moved to HERE 
 2951    0000005C .............         DC32    HERE, DUP       // This will become the new CURRENT (this NFA).
                  ...          
 2952    00000064 .............         DC32    CSDP_SV, STORE  // HERE to CSDP to restore in case of error.
                  ...          
 2953                           // Dup HERE-NFA to allot NFAx
 2954    0000006C ........              DC32    DUP
 2955                           // Limit NFA allot to maxwordlen. DOES NOT CHANGE actual count!
 2956                           // If count is larger than MAXWORDLEN behaviour of this def is unpredictable!
 2957    00000070 ........              DC32    CAT
 2958    00000074 ........1F000         DC32    LIT, MAXWORDLEN // ELIMINATED WIDTH AND WIDTH_SV 
                  000          
 2959    0000007C ........              DC32    MIN
 2960    00000080 ........              DC32    ALLOT_PRIM      // HERE (DP) at end of NFA with padding.
 2961                           // Dup HERE-NFA to set count byte, and to be consumed later
 2962                           // for setting CURRENT after previous CURRENT compiled into LFA.
 2963    00000084 ........              DC32    DUP
 2964                           // Make regular (not immediate) NFA count byte
 2965    00000088 ........80000         DC32    LIT, 0x80
                  000          
 2966    00000090 ........              DC32    TOGGLE          // Count Byte = 80+count
 2967                           // HERE is new now. Mark end of NFA for PFIND search
 2968    00000094 ........              DC32    HERE            // DP after allot of NFA
 2969    00000098 ........80000         DC32    LIT,0x80        // Set last character in NFA
                  000          
 2970    000000A0 ........              DC32    TOGGLE          // smudge bit
 2971                           // Bump DP to LFA
 2972    000000A4 .............         DC32    ONE, DP_SV      // MOVE HERE (DP)
                  ...          
 2973    000000AC ........              DC32    PSTORE          // TO LFA
 2974                           // Set LFA
 2975    000000B0 ........              DC32    LATEST          // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
 2976    000000B4 ........              DC32    COMMA           // Compile last words NFA into this link field.
 2977                                                           // DUP'd HERE should be on stack
 2978                           // Have to set CURRENT with last dup's HERE-NFA after LATEST is compiled
 2979    000000B8 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
 2980    000000BC ........              DC32    STORE           // so storing NEWWORD_NFA into CURRENT.
 2981    000000C0 .............         DC32    COMP, DOCON     // Compile DOCON as CFA
                  ...          
 2982    000000C8 .............         DC32    HERE, FOURP     // Compute and
                  ...          
 2983    000000D0 ........              DC32    COMMA           // COMPILE Addr of PFA
 2984                           //      DC32    SMUDGE          // ELIMINATED
 2985                           //      DC32    SEMIC_CREATE    // USED IN CALLERS OF CREATE, NOT HERE!
 2986    000000D4 ........              DC32    SEMIS
 2987                           
 2988                           
 2989                           //      CON CON:        ( n -- )  MODIFIED: and CONSTANT renamed CON
 2990                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2991                           //      A defining word used in the form:
 2992                           //              n CONSTANT CCcc
 2993                           //      to create word CCcc, with its parameter field containing n. When
 2994                           //      CCcc is later executed, it will push the value of n to the stack.
 2995                           
 2996                            SECTION .text : CONST (2)
 2997                           CONSTANT_NFA:
 2998    00000000 88                    DC8     0x88
 2999    00000001 434F4E5354414         DC8     'CONSTAN'
                  E            
 3000    00000008 D4                    DC8     'T'+0x80
 3001    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3002    0000000C ........              DC32    CREATE_NFA
 3003                           CONSTANT:
 3004    00000010 .............         DC32    DOCOL, CON, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3005                           
 3006                           
 3007                            SECTION .text : CONST (2)
 3008                           CON_NFA:
 3009    00000000 83                    DC8     0x83
 3010    00000001 434F                  DC8     'CO'
 3011    00000003 CE                    DC8     'N'+0x80
 3012                            ALIGNROM 2,0xFFFFFFFF
 3013                           //      DC32    CREATE_NFA
 3014    00000004 ........              DC32    CONSTANT_NFA
 3015                           CON:
 3016    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3017    0000000C ........              DC32    CREATE  // Make Header NFA/LFA, DOCON, ADDR->PFA
 3018    00000010 ........FCFFF         DC32    LIT, -4, DP_SV, PSTORE  // back up to ADDR->PFA
                  FFF..........
                  ......       
 3019    00000020 ........              DC32    COMMA                   // Replace with Con value
 3020    00000024 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3021                           //        DC32    DOTDICTSPACE
 3022    00000028 ........              DC32    SEMIS
 3023                           
 3024                           
 3025                           //      VAR VAR:        ( -- ) RENAMED: VARIABLE to VAR
 3026                           //      IF RAMVARSPACE FULL PRINT Error MESSAGE AND Abort.
 3027                           //      A defining word used in the form:
 3028                           //              VARIABLE CCcc
 3029                           //      When VARIABLE is executed, it creates the definition CCcc with its
 3030                           //      with its cell space uninitialized. When CCcc is executed,
 3031                           //      its cell space address is put on the stack. Use with @ or !
 3032                           //      NOTE: VAR's cell space is allocated in ram. See UP and VARALLOT.
 3033                           
 3034                            SECTION .text : CONST (2)
 3035                           VARIABLE_NFA:
 3036    00000000 88                    DC8     0x88
 3037    00000001 5641524941424         DC8     'VARIABL'
                  C            
 3038    00000008 C5                    DC8     'E'+0x80
 3039    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3040    0000000C ........              DC32    CON_NFA
 3041                           VARIABLE:
 3042    00000010 .............         DC32    DOCOL, VAR_, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3043                           
 3044                            SECTION .text : CONST (2)
 3045                           VAR_NFA:
 3046    00000000 83                    DC8     0x83
 3047    00000001 5641                  DC8     'VA'
 3048    00000003 D2                    DC8     'R'+0x80
 3049                            ALIGNROM 2,0xFFFFFFFF
 3050                           //      DC32    CON_NFA
 3051    00000004 ........              DC32    VARIABLE_NFA
 3052                           VAR_:
 3053    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3054    0000000C ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3055    00000010 ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3056    00000020 .............         DC32    COMP, DOVAR     // CFA of VAR's
                  ...          
 3057                           //        DC32    COMP, DOCON     // CFA of VAR's
 3058                           // aligned, INCREMENTS DP REFLECTED by HERE
 3059                           // compile the value \ v --
 3060    00000028 ........              DC32    ONE
 3061    0000002C ........              DC32    VARALLOT        // Do .VS check and return VAR addr.
 3062    00000030 ........              DC32    COMMA           // Compile address of the ram allotment.
 3063    00000034 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3064                           //        DC32    DOTDICTSPACE
 3065                           //        DC32    DOTVARSPACE
 3066    00000038 ........              DC32    SEMIS
 3067                           
 3068                           
 3069                           //      ; SEMI: ( -- ) IMMEDIATE
 3070                           //      Terminate a colon-definition and stop further compilation.
 3071                           //      Compiles the run-time ;S.
 3072                           
 3073                            SECTION .text : CONST (2)
 3074                           SEMI_NFA:
 3075    00000000 C1                    DC8     0x0C1
 3076    00000001 BB                    DC8     ';'+0x80
 3077    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3078    00000004 ........              DC32    VAR_NFA
 3079                           SEMI:
 3080    00000008 ........              DC32    DOCOL
 3081    0000000C ........              DC32    QCSP
 3082    00000010 ........              DC32    COMP
 3083    00000014 ........              DC32    SEMIS
 3084    00000018 ........              DC32    LBRAC
 3085    0000001C ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3086                           //        DC32    DOTDICTSPACE
 3087    00000020 ........              DC32    SEMIS
 3088                           
 3089                           
 3090                           //      : COLON:        ( -- ) IMMEDIATE
 3091                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 3092                           //      Used in the form called a colon-definition:
 3093                           //              : CCcc     ...     //
 3094                           //      Creates a dictionary entry defining CCcc as equivalent to the
 3095                           //      following sequence of Forth word definitions '...' until the next
 3096                           //      ';' or ';CODE'.
 3097                           //      The compiling process is done by the text interpreter as long as
 3098                           //      STATE is non-zero. Other details are that the CONTEXT vocabulary is
 3099                           //      set to the CURRENT vocabulary and that words with the precedence bit
 3100                           //      set (P) are executed rather than being compiled.
 3101                           
 3102                            SECTION .text : CONST (2)
 3103                           COLON_NFA:
 3104    00000000 C1                    DC8     0x0C1
 3105    00000001 BA                    DC8     ':'+0x80
 3106    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3107    00000004 ........              DC32    SEMI_NFA
 3108                           COLON:
 3109    00000008 ........              DC32    DOCOL
 3110                           //      DICTSPACE TEST DONE IN CREATE
 3111    0000000C ........              DC32    QEXEC
 3112    00000010 ........              DC32    SCSP    // Save the stack position in CSP. Compiler security.
 3113    00000014 ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3114    00000018 ........              DC32    RBRAC   // Resume compiliting by setting STATE_SV to 0xC0
 3115    0000001C ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3116    0000002C .............         DC32    COMP, DOCOL     // aligned, INCREMENTS DP REFLECTED by HERE
                  ...          
 3117    00000034 ........              DC32    SEMIS
 3118                           
 3119                           
 3120                           //=============================== WORDCAT ====================================//
 3121                           //NOEXEC HEADERFORWORDCATEGORIES
 3122                           //      WC_CREATE_NFA = CREATE WORDS With: CATEGORY
 3123                           
 3124                            SECTION .text : CONST (2)
 3125                           WC_CREATE_NFA:
 3126    00000000 96                    DC8     0x80+22
 3127    00000001 0D0A                  DC8     0x0D, 0x0A
 3128    00000003 4352454154452         DC8     'CREATE WORDS With:'
                  0574F52445320
                  576974683A   
 3129    00000015 0D8A                  DC8     0x0D, 0x0A+0x80
 3130    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 3131    00000018 ........              DC32    COLON_NFA
 3132                           
 3133                           //      DABS DABS: ( sd=(LSW MSW) -- ud=(LSW MSW) )
 3134                           //      Leave the absolute value ud of a signed double number.
 3135                           
 3136                            SECTION .text : CONST (2)
 3137                           DABS_NFA:
 3138    00000000 84                    DC8     0x84
 3139    00000001 444142                DC8     'DAB'
 3140    00000004 D3                    DC8     'S'+0x80
 3141    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3142    00000008 ........              DC32    WC_CREATE_NFA
 3143                           DABSF:
 3144                           DABS:
 3145    0000000C ........              DC32    DOCOL
 3146    00000010 ........              DC32    DUP
 3147    00000014 ........              DC32    DPM
 3148    00000018 ........              DC32    SEMIS
 3149                           
 3150                           
 3151                           //      DNEGATE DNEGATE: ( d1 -- d<2>=(LSW MSW) ) RENAMED: DMINUS to DNEGATE
 3152                           //      Convert d1 to its double number two's complement d2.
 3153                           
 3154                            SECTION .text : CONST (2)
 3155                           DNEGATE_NFA:
 3156    00000000 87                    DC8     0x87
 3157    00000001 444E45474154          DC8     'DNEGAT'
 3158    00000007 C5                    DC8     'E'+0x80
 3159                            ALIGNROM 2,0xFFFFFFFF
 3160    00000008 ........              DC32    DABS_NFA
 3161                           DNEGATE:
 3162    0000000C ........              DC32    .+5
 3163                            SECTION .text : CODE (2)
 3164                                   POP2t                   // MSW   //POP  BX
 3164.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3164.2                         //#ifndef TOSCT
 3164.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3164.4                         //#endif
 3164.5                         //      ADDS    p, p, #4
 3164.6                                 ENDM
 3165                                   POP2w                   // LSW   //POP  CX
 3165.1  00000004 57F8042B              LDR     w, [p],#4
 3165.2                         //      LDR     w, [p]
 3165.3                         //      ADDS    p, p, #4
 3165.4                                 ENDM
 3166    00000008 C043                  MVNS    t, t            // negate MSW
 3167    0000000A D243                  MVNS    w, w            // negate LSW
 3168    0000000C 521C                  ADDS    w, w, #1        // add 1 to LSW
 3169                                   DPUSH                   //  --  LSW MSW )
 3169                                   PUSHw   // push w to p, post decrement p
 3169.1  0000000E 47F8042D              STR     w, [p, #-4]!
 3169.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3169.3                         //      STR     w, [p]
 3169.4                                 ENDM
 3169                                   TPUSH
 3169                                   PUSHt   // push t to p, pre decrement p
 3169.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3169.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3169.3                         //      STR     t, [p]
 3169.4                                 ENDM
 3169                                   NEXT
 3169.1                         // ARMv7-M Thumb = .+5
 3169.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3169.3                         // ARMv6-M Thumb = .+4
 3169.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3169                                   NEXT1
 3169.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3169.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3169.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3169.4                         // ARMv6-M Thumb = .+4
 3169.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3169.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3169.7                                 ENDM
 3169.8                                 ENDM
 3169.9                                 ENDM
 3169.10                                ENDM
 3170                           
 3171                           
 3172                           //      DPL_SV: ( -- addr of NDPL ) Contains # of digits after . in double number
 3173                           //      A system variable containing the number of digits to the right of the
 3174                           //      decimal on double integer input. It may also be used to hold output
 3175                           //      column location of a decimal point, in system generated formating. The
 3176                           //      default value on single number input is -1.
 3177                            SECTION .text : CONST (2)
 3178                           DPL_NFA:
 3179    00000000 83                    DC8     0x83
 3180    00000001 4450                  DC8     'DP'
 3181    00000003 CC                    DC8     'L'+0x80
 3182                            ALIGNROM 2,0xFFFFFFFF
 3183    00000004 ........              DC32    DNEGATE_NFA
 3184                           DPL_SV:
 3185    00000008 .............         DC32    DOCON, NDPL
                  ...          
 3186                           
 3187                           
 3188                           //      D.R DDOTR:      ( sd=<LSW MSW> n -- ) SIGNED:
 3189                           //      Print a signed double number sd right aligned
 3190                           //      in a field n characters wide.
 3191                           
 3192                            SECTION .text : CONST (2)
 3193                           DDOTR_NFA:
 3194    00000000 83                    DC8     0x83
 3195    00000001 442E                  DC8     'D.'
 3196    00000003 D2                    DC8     'R'+0x80
 3197                            ALIGNROM 2,0xFFFFFFFF
 3198    00000004 ........              DC32    DPL_NFA
 3199                           DDOTR:
 3200    00000008 ........              DC32    DOCOL
 3201    0000000C ........              DC32    TOR     // N CHAR FIELD LEN to r
 3202    00000010 ........              DC32    SWAP    // ( LSW MSW -- MSW LSW )
 3203    00000014 ........              DC32    OVER    // ( MSW LSW -- MSW LSW MSW )
 3204    00000018 ........              DC32    DABS    // ( MSW LSW MSW -- MSW uLSW uMSW )
 3205    0000001C ........              DC32    BDIGS   // <# SET HLD to Pad
 3206    00000020 ........              DC32    DIGS    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3207    00000024 ........              DC32    SIGN    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3208    00000028 ........              DC32    EDIGS   //      #>  ( d=<LSW MSW>  ---  addr  count )
 3209    0000002C ........              DC32    RFROM   // GET THE N CHAR FIELD LEN
 3210    00000030 ........              DC32    OVER    // ( addr count n -- addr count n count )
 3211    00000034 ........              DC32    SUBB    // ( n addr count addr -- n addr count-n )
 3212    00000038 ........              DC32    SPACES  // SPACES  ( n -- )
 3213    0000003C ........              DC32    TYPE    // ( n addr -- )
 3214    00000040 ........              DC32    SEMIS
 3215                           
 3216                           
 3217                           //      D. DDOT:        ( S32-2'S COMPLEMET = (d=<LSW MSW> -- )
 3218                           //      Print a signed double number from a 32 bit two's complement value.
 3219                           //      The high-order 32 bits are most accessable on the stack. Conversion
 3220                           //      is performed according to the current base. A blank follows.
 3221                           
 3222                            SECTION .text : CONST (2)
 3223                           DDOT_NFA:
 3224    00000000 82                    DC8     0x82
 3225    00000001 44                    DC8     'D'
 3226    00000002 AE                    DC8     '.'+0x80
 3227    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3228    00000004 ........              DC32    DDOTR_NFA
 3229                           DDOT:
 3230    00000008 ........              DC32    DOCOL
 3231    0000000C ........              DC32    ZERO
 3232    00000010 ........              DC32    DDOTR
 3233    00000014 ........              DC32    SPACE
 3234    00000018 ........              DC32    SEMIS
 3235                           
 3236                           
 3237                           //      D+ DPLUS:       ( LSW1 MSW1 LSW2 MSW2 --- LSW MSW )  SIGNED:
 3238                           //      Leave the signed double number sum of two signed double numbers.
 3239                           
 3240                            SECTION .text : CONST (2)
 3241                           DPLUS_NFA:
 3242    00000000 82                    DC8     0x82
 3243    00000001 44                    DC8     'D'
 3244    00000002 AB                    DC8     '+'+0x80
 3245    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3246    00000004 ........              DC32    DDOT_NFA
 3247                           DPLUS:
 3248    00000008 ........              DC32    .+5
 3249                            SECTION .text : CODE (2)
 3250                                   POP2t   //    ldr     t, [p],#4       // MS
 3250.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3250.2                         //#ifndef TOSCT
 3250.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3250.4                         //#endif
 3250.5                         //      ADDS    p, p, #4
 3250.6                                 ENDM
 3251                                   POP2n   //    ldr     n, [p],#4       // LS
 3251.1  00000004 57F8041B              LDR     n, [p],#4
 3251.2                         //      LDR     n, [p]
 3251.3                         //      ADDS    p, p, #4
 3251.4                                 ENDM
 3252                                   POP2x   //    ldr     x, [p],#4       // MS
 3252.1  00000008 57F8043B              LDR     x, [p],#4
 3252.2                         //      LDR     x, [p]
 3252.3                         //      ADDS    p, p, #4
 3252.4                                 ENDM
 3253                                   POP2w   //    ldr     w, [p],#4       // LS
 3253.1  0000000C 57F8042B              LDR     w, [p],#4
 3253.2                         //      LDR     w, [p]
 3253.3                         //      ADDS    p, p, #4
 3253.4                                 ENDM
 3254    00000010 5218                  ADDS    w, w, n         // LS sum, set status flags
 3255    00000012 5841                  ADCS    t, t, x         // MS sum + carry
 3256                                   DPUSH                   //  --  LSW MSW )
 3256                                   PUSHw   // push w to p, post decrement p
 3256.1  00000014 47F8042D              STR     w, [p, #-4]!
 3256.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3256.3                         //      STR     w, [p]
 3256.4                                 ENDM
 3256                                   TPUSH
 3256                                   PUSHt   // push t to p, pre decrement p
 3256.1  00000018 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3256.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3256.3                         //      STR     t, [p]
 3256.4                                 ENDM
 3256                                   NEXT
 3256.1                         // ARMv7-M Thumb = .+5
 3256.2  0000001C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3256.3                         // ARMv6-M Thumb = .+4
 3256.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3256                                   NEXT1
 3256.1  00000020 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3256.2  00000024 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3256.3  00000028 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3256.4                         // ARMv6-M Thumb = .+4
 3256.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3256.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3256.7                                 ENDM
 3256.8                                 ENDM
 3256.9                                 ENDM
 3256.10                                ENDM
 3257                           
 3258                           
 3259                           //      S->D STOD:      ( n -- d=<LSW MSW> ) SIGNED:
 3260                           //      Sign extend a single number to form a double number.
 3261                           //      : S->D DUP 0< NEGATE // hi level equivalent
 3262                           
 3263                            SECTION .text : CONST (2)
 3264                           STOD_NFA:
 3265    00000000 84                    DC8     0x84
 3266    00000001 532D3E                DC8     'S->'
 3267    00000004 C4                    DC8     'D'+0x80
 3268    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3269    00000008 ........              DC32    DPLUS_NFA
 3270                           STOD:
 3271    0000000C ........              DC32    .+5
 3272                            SECTION .text : CODE (2)
 3273                                   POP2w                   // POP LSW
 3273.1  00000000 57F8042B              LDR     w, [p],#4
 3273.2                         //      LDR     w, [p]
 3273.3                         //      ADDS    p, p, #4
 3273.4                                 ENDM
 3274    00000004 4040                  EORS    t, t            // Zero MSW
 3275    00000006 1243                  ORRS    w, w, w         // OR LSW
 3276    00000008 00D5                  BPL     STOD1           // LSW is POS
 3277                           
 3278    0000000A 401E                  SUBS     t, t, #1       // LSW is NEG
 3279                           STOD1:
 3280                                   DPUSH                   //  --  LSW MSW )
 3280                                   PUSHw   // push w to p, post decrement p
 3280.1  0000000C 47F8042D              STR     w, [p, #-4]!
 3280.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3280.3                         //      STR     w, [p]
 3280.4                                 ENDM
 3280                                   TPUSH
 3280                                   PUSHt   // push t to p, pre decrement p
 3280.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3280.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3280.3                         //      STR     t, [p]
 3280.4                                 ENDM
 3280                                   NEXT
 3280.1                         // ARMv7-M Thumb = .+5
 3280.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3280.3                         // ARMv6-M Thumb = .+4
 3280.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3280                                   NEXT1
 3280.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3280.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3280.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3280.4                         // ARMv6-M Thumb = .+4
 3280.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3280.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3280.7                                 ENDM
 3280.8                                 ENDM
 3280.9                                 ENDM
 3280.10                                ENDM
 3281                           
 3282                           
 3283                           //      2* TWOSTAR:     ( n -- n*2 ) LSL 1
 3284                           
 3285                            SECTION .text : CONST (2)
 3286                           TWOSTAR_NFA:
 3287    00000000 82                    DC8     0x82
 3288    00000001 32                    DC8     '2'
 3289    00000002 AA                    DC8     '*'+0x80
 3290    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3291    00000004 ........              DC32    STOD_NFA
 3292                           TWOSTAR:
 3293    00000008 ........              DC32    .+5
 3294                            SECTION .text : CODE (2)
 3295                                   POP2t
 3295.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3295.2                         //#ifndef TOSCT
 3295.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3295.4                         //#endif
 3295.5                         //      ADDS    p, p, #4
 3295.6                                 ENDM
 3296    00000004 4000                  LSLS    t, t, #1        //
 3297                                   TPUSH
 3297                                   PUSHt   // push t to p, pre decrement p
 3297.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3297.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3297.3                         //      STR     t, [p]
 3297.4                                 ENDM
 3297                                   NEXT
 3297.1                         // ARMv7-M Thumb = .+5
 3297.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3297.3                         // ARMv6-M Thumb = .+4
 3297.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3297                                   NEXT1
 3297.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3297.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3297.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3297.4                         // ARMv6-M Thumb = .+4
 3297.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3297.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3297.7                                 ENDM
 3297.8                                 ENDM
 3297.9                                 ENDM
 3298                           
 3299                           
 3300                           //      2/ TWOSLASH:    ( n -- n/1 ) ASR 1 (FLOORED)
 3301                           
 3302                            SECTION .text : CONST (2)
 3303                           TWOSLASH_NFA:
 3304    00000000 82                    DC8     0x82
 3305    00000001 32                    DC8     '2'
 3306    00000002 AF                    DC8     '/'+0x80
 3307    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3308    00000004 ........              DC32    TWOSTAR_NFA
 3309                           TWOSLASH:
 3310    00000008 ........              DC32    .+5
 3311                            SECTION .text : CODE (2)
 3312                                   POP2t
 3312.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3312.2                         //#ifndef TOSCT
 3312.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3312.4                         //#endif
 3312.5                         //      ADDS    p, p, #4
 3312.6                                 ENDM
 3313    00000004 4010                  ASRS    t, t, #1        //
 3314                                   TPUSH
 3314                                   PUSHt   // push t to p, pre decrement p
 3314.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3314.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3314.3                         //      STR     t, [p]
 3314.4                                 ENDM
 3314                                   NEXT
 3314.1                         // ARMv7-M Thumb = .+5
 3314.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3314.3                         // ARMv6-M Thumb = .+4
 3314.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3314                                   NEXT1
 3314.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3314.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3314.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3314.4                         // ARMv6-M Thumb = .+4
 3314.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3314.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3314.7                                 ENDM
 3314.8                                 ENDM
 3314.9                                 ENDM
 3315                                   
 3316                           
 3317                           //      1- ONEM:        ( n -- n-1 )
 3318                           
 3319                            SECTION .text : CONST (2)
 3320                           ONEM_NFA:
 3321    00000000 82                    DC8     0x82
 3322    00000001 31                    DC8     '1'
 3323    00000002 AD                    DC8     '-'+0x80
 3324    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3325    00000004 ........              DC32    TWOSLASH_NFA
 3326                           ONEM:
 3327    00000008 ........              DC32    .+5
 3328                            SECTION .text : CODE (2)
 3329                                   POP2t
 3329.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3329.2                         //#ifndef TOSCT
 3329.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3329.4                         //#endif
 3329.5                         //      ADDS    p, p, #4
 3329.6                                 ENDM
 3330    00000004 401E                  SUBS    t, t, #1        //
 3331                                   TPUSH
 3331                                   PUSHt   // push t to p, pre decrement p
 3331.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3331.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3331.3                         //      STR     t, [p]
 3331.4                                 ENDM
 3331                                   NEXT
 3331.1                         // ARMv7-M Thumb = .+5
 3331.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3331.3                         // ARMv6-M Thumb = .+4
 3331.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3331                                   NEXT1
 3331.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3331.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3331.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3331.4                         // ARMv6-M Thumb = .+4
 3331.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3331.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3331.7                                 ENDM
 3331.8                                 ENDM
 3331.9                                 ENDM
 3332                           
 3333                           
 3334                           //      1+ ONEP:        ( n -- n+1 )
 3335                           
 3336                            SECTION .text : CONST (2)
 3337                           ONEP_NFA:
 3338    00000000 82                    DC8     0x82
 3339    00000001 31                    DC8     '1'
 3340    00000002 AB                    DC8     '+'+0x80
 3341    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3342    00000004 ........              DC32    ONEM_NFA
 3343                           ONEP:
 3344    00000008 ........              DC32    .+5
 3345                            SECTION .text : CODE (2)
 3346                                   POP2t
 3346.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3346.2                         //#ifndef TOSCT
 3346.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3346.4                         //#endif
 3346.5                         //      ADDS    p, p, #4
 3346.6                                 ENDM
 3347    00000004 401C                  ADDS    t, t, #1        //
 3348                                   TPUSH
 3348                                   PUSHt   // push t to p, pre decrement p
 3348.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3348.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3348.3                         //      STR     t, [p]
 3348.4                                 ENDM
 3348                                   NEXT
 3348.1                         // ARMv7-M Thumb = .+5
 3348.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3348.3                         // ARMv6-M Thumb = .+4
 3348.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3348                                   NEXT1
 3348.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3348.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3348.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3348.4                         // ARMv6-M Thumb = .+4
 3348.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3348.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3348.7                                 ENDM
 3348.8                                 ENDM
 3348.9                                 ENDM
 3349                           
 3350                           
 3351                           //      2+ TWOP:        ( n -- n+2 )
 3352                           
 3353                            SECTION .text : CONST (2)
 3354                           TWOP_NFA:
 3355    00000000 82                    DC8     0x82
 3356    00000001 32                    DC8     '2'
 3357    00000002 AB                    DC8     '+'+0x80
 3358    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3359    00000004 ........              DC32    ONEP_NFA
 3360                           TWOP:
 3361    00000008 ........              DC32    .+5
 3362                            SECTION .text : CODE (2)
 3363                                   POP2t
 3363.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3363.2                         //#ifndef TOSCT
 3363.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3363.4                         //#endif
 3363.5                         //      ADDS    p, p, #4
 3363.6                                 ENDM
 3364    00000004 801C                  ADDS    t, t, #2
 3365                                   TPUSH
 3365                                   PUSHt   // push t to p, pre decrement p
 3365.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3365.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3365.3                         //      STR     t, [p]
 3365.4                                 ENDM
 3365                                   NEXT
 3365.1                         // ARMv7-M Thumb = .+5
 3365.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3365.3                         // ARMv6-M Thumb = .+4
 3365.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3365                                   NEXT1
 3365.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3365.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3365.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3365.4                         // ARMv6-M Thumb = .+4
 3365.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3365.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3365.7                                 ENDM
 3365.8                                 ENDM
 3365.9                                 ENDM
 3366                           
 3367                           
 3368                           //      4+ FOURP:       ( n -- n+4 )
 3369                           
 3370                            SECTION .text : CONST (2)
 3371                           FOURP_NFA:
 3372    00000000 82                    DC8     0x82
 3373    00000001 34                    DC8     '4'
 3374    00000002 AB                    DC8     '+'+0x80
 3375    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3376    00000004 ........              DC32    TWOP_NFA
 3377                           FOURP:
 3378    00000008 ........              DC32    .+5
 3379                            SECTION .text : CODE (2)
 3380                                   POP2t
 3380.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3380.2                         //#ifndef TOSCT
 3380.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3380.4                         //#endif
 3380.5                         //      ADDS    p, p, #4
 3380.6                                 ENDM
 3381    00000004 001D                  ADDS    t, t, #4
 3382                                   TPUSH
 3382                                   PUSHt   // push t to p, pre decrement p
 3382.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3382.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3382.3                         //      STR     t, [p]
 3382.4                                 ENDM
 3382                                   NEXT
 3382.1                         // ARMv7-M Thumb = .+5
 3382.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3382.3                         // ARMv6-M Thumb = .+4
 3382.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3382                                   NEXT1
 3382.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3382.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3382.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3382.4                         // ARMv6-M Thumb = .+4
 3382.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3382.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3382.7                                 ENDM
 3382.8                                 ENDM
 3382.9                                 ENDM
 3383                           
 3384                           
 3385                           //      4- FOURM:       ( n -- n-4 )
 3386                           
 3387                            SECTION .text : CONST (2)
 3388                           FOURM_NFA:
 3389    00000000 82                    DC8     0x82
 3390    00000001 34                    DC8     '4'
 3391    00000002 AD                    DC8     '-'+0x80
 3392    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3393    00000004 ........              DC32    FOURP_NFA
 3394                           FOURM:
 3395    00000008 ........              DC32    .+5
 3396                            SECTION .text : CODE (2)
 3397                                   POP2t
 3397.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3397.2                         //#ifndef TOSCT
 3397.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3397.4                         //#endif
 3397.5                         //      ADDS    p, p, #4
 3397.6                                 ENDM
 3398    00000004 001F                  SUBS    t, t, #4
 3399                                   TPUSH
 3399                                   PUSHt   // push t to p, pre decrement p
 3399.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3399.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3399.3                         //      STR     t, [p]
 3399.4                                 ENDM
 3399                                   NEXT
 3399.1                         // ARMv7-M Thumb = .+5
 3399.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3399.3                         // ARMv6-M Thumb = .+4
 3399.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3399                                   NEXT1
 3399.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3399.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3399.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3399.4                         // ARMv6-M Thumb = .+4
 3399.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3399.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3399.7                                 ENDM
 3399.8                                 ENDM
 3399.9                                 ENDM
 3400                           
 3401                           
 3402                           //      0 ZERO: ( -- 0 )
 3403                           
 3404                            SECTION .text : CONST (2)
 3405                           ZERO_NFA:
 3406    00000000 81                    DC8     0x81
 3407    00000001 B0                    DC8     '0'+0x80
 3408    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3409    00000004 ........              DC32    FOURM_NFA
 3410                           ZERO:
 3411    00000008 ........00000         DC32    DOCON, 0
                  000          
 3412                           
 3413                           
 3414                           //      1 ONE: ( -- 1 )
 3415                           
 3416                            SECTION .text : CONST (2)
 3417                           ONE_NFA:
 3418    00000000 81                    DC8     0x81
 3419    00000001 B1                    DC8     '1'+0x80
 3420    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3421    00000004 ........              DC32    ZERO_NFA
 3422                           ONE:
 3423    00000008 ........01000         DC32    DOCON, 1
                  000          
 3424                           
 3425                           
 3426                           //      2 TWO: ( -- 2 )
 3427                           
 3428                            SECTION .text : CONST (2)
 3429                           TWO_NFA:
 3430    00000000 81                    DC8     0x81
 3431    00000001 B2                    DC8     '2'+0x80
 3432    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3433    00000004 ........              DC32    ONE_NFA
 3434                           TWO:
 3435    00000008 ........02000         DC32    DOCON, 2
                  000          
 3436                           
 3437                           
 3438                           //      3 THREE: ( -- 3 )
 3439                           
 3440                            SECTION .text : CONST (2)
 3441                           THREE_NFA:
 3442    00000000 81                    DC8     0x81
 3443    00000001 B3                    DC8     '3'+0x80
 3444    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3445    00000004 ........              DC32    TWO_NFA
 3446                           THREE:
 3447    00000008 ........03000         DC32    DOCON, 3
                  000          
 3448                           
 3449                           
 3450                           //      4 FOUR: ( -- 4 )
 3451                           
 3452                            SECTION .text : CONST (2)
 3453                           FOUR_NFA:
 3454    00000000 81                    DC8     0x81
 3455    00000001 B4                    DC8     '4'+0x80
 3456    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3457    00000004 ........              DC32    THREE_NFA
 3458                           FOUR:
 3459    00000008 ........04000         DC32    DOCON, 4
                  000          
 3460                           
 3461                           
 3462                           //      M* MSTAR:       ( n1 n2 -- d=<S32LSW S32MSW> )  SIGNED:
 3463                           //      A mixed magnitude math operation which leaves the double number
 3464                           //      signed product of two signed number.
 3465                           
 3466                            SECTION .text : CONST (2)
 3467                           MSTAR_NFA:
 3468    00000000 82                    DC8     0x82
 3469    00000001 4D                    DC8     'M'
 3470    00000002 AA                    DC8     '*'+0x80
 3471    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3472    00000004 ........              DC32    FOUR_NFA
 3473                           MSTAR:
 3474    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3475    00000010 ........              DC32    XORR
 3476    00000014 ........              DC32    TOR
 3477    00000018 ........              DC32    ABS
 3478    0000001C ........              DC32    SWAP
 3479    00000020 ........              DC32    ABS
 3480    00000024 ........              DC32    USTAR
 3481    00000028 ........              DC32    RFROM
 3482    0000002C ........              DC32    DPM
 3483    00000030 ........              DC32    SEMIS
 3484                           
 3485                           
 3486                           //      M/ MSLASH:      ( sd  n1  ---  d=<s32REM  S32QUO> )
 3487                           //      A mixed magnitude math operator which leaves the signed remainder
 3488                           //      and signed quotient from sd, a double number dividend and divisor n1.
 3489                           //      The remainder takes its sign from the dividend.
 3490                           
 3491                            SECTION .text : CONST (2)
 3492                           MSLASH_NFA:
 3493    00000000 82                    DC8     0x82
 3494    00000001 4D                    DC8     'M'
 3495    00000002 AF                    DC8     '/'+0x80
 3496    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3497    00000004 ........              DC32    MSTAR_NFA
 3498                           MSLASH:
 3499    00000008 ........              DC32    DOCOL
 3500    0000000C ........              DC32    OVER
 3501    00000010 ........              DC32    TOR
 3502    00000014 ........              DC32    TOR
 3503    00000018 ........              DC32    DABS    // ( LSW MSW -- uLSW uMSW )
 3504    0000001C ........              DC32    R
 3505    00000020 ........              DC32    ABS
 3506    00000024 ........              DC32    USLASH
 3507    00000028 ........              DC32    RFROM
 3508    0000002C ........              DC32    R
 3509    00000030 ........              DC32    XORR
 3510    00000034 ........              DC32    PM
 3511    00000038 ........              DC32    SWAP
 3512    0000003C ........              DC32    RFROM
 3513    00000040 ........              DC32    PM
 3514    00000044 ........              DC32    SWAP
 3515    00000048 ........              DC32    SEMIS
 3516                           
 3517                           
 3518                           //      * STAR: ( n1 n2 -- prod=n3 )
 3519                           //      Leave the signed product n3 of two (32bit) signed numbers n1 and n2.
 3520                           
 3521                            SECTION .text : CONST (2)
 3522                           STAR_NFA:
 3523    00000000 81                    DC8     0x81
 3524    00000001 AA                    DC8     '*'+0x80
 3525    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3526    00000004 ........              DC32    MSLASH_NFA
 3527                           STAR:
 3528    00000008 ........              DC32    DOCOL
 3529    0000000C ........              DC32    MSTAR
 3530    00000010 ........              DC32    DROP
 3531    00000014 ........              DC32    SEMIS
 3532                           
 3533                           
 3534                           //      /MOD SLMOD:     ( n1 n2 -- rem quot )   SIGNED:
 3535                           //      Leave the remainder and signed quotient of n1/n2. The remainder has
 3536                           //      the sign of the dividend.
 3537                           
 3538                            SECTION .text : CONST (2)
 3539                           SLMOD_NFA:
 3540    00000000 84                    DC8     0x84
 3541    00000001 2F4D4F                DC8     '/MO'
 3542    00000004 C4                    DC8     'D'+0x80
 3543    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3544    00000008 ........              DC32    STAR_NFA
 3545                           SLMOD:
 3546    0000000C ........              DC32    DOCOL
 3547    00000010 ........              DC32    TOR
 3548    00000014 ........              DC32    STOD
 3549    00000018 ........              DC32    RFROM
 3550    0000001C ........              DC32    MSLASH
 3551    00000020 ........              DC32    SEMIS
 3552                           
 3553                           
 3554                           //      / SLASH:        ( sn1 sn2 -- sn ) SIGNED:
 3555                           //      Leave the signed quotient sn of sn1/sn2.
 3556                           
 3557                            SECTION .text : CONST (2)
 3558                           SLASH_NFA:
 3559    00000000 81                    DC8     0x81
 3560    00000001 AF                    DC8     '/'+0x80
 3561    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3562    00000004 ........              DC32    SLMOD_NFA
 3563                           SLASH:
 3564    00000008 ........              DC32    DOCOL
 3565    0000000C ........              DC32    SLMOD
 3566    00000010 ........              DC32    SWAP
 3567    00000014 ........              DC32    DROP
 3568    00000018 ........              DC32    SEMIS
 3569                           
 3570                           
 3571                           //      MOD MOD:        ( sn1 n2 -- modulo )
 3572                           //      Leave the remainder of sn1/n2, with the same sign as sn1.
 3573                           
 3574                            SECTION .text : CONST (2)
 3575                           MODD_NFA:
 3576    00000000 83                    DC8     0x83
 3577    00000001 4D4F                  DC8     'MO'
 3578    00000003 C4                    DC8     'D'+0x80
 3579                            ALIGNROM 2,0xFFFFFFFF
 3580    00000004 ........              DC32    SLASH_NFA
 3581                           MOD:
 3582    00000008 ........              DC32    DOCOL
 3583    0000000C ........              DC32    SLMOD
 3584    00000010 ........              DC32    DROP
 3585    00000014 ........              DC32    SEMIS
 3586                           
 3587                           
 3588                           //      */MOD SSMOD:    ( n1 n2 n3 -- n4 n5 )
 3589                           //      Leave the quotient n5 and remainder n4 of the operation n1*n2/n3 A
 3590                           //      31 bit intermediate product is used as for */.
 3591                           
 3592                            SECTION .text : CONST (2)
 3593                           SSMOD_NFA:
 3594    00000000 85                    DC8     0x85
 3595    00000001 2A2F4D4F              DC8     '*/MO'
 3596    00000005 C4                    DC8     'D'+0x80
 3597    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 3598    00000008 ........              DC32    MODD_NFA
 3599                           SSMOD:
 3600    0000000C ........              DC32    DOCOL
 3601    00000010 ........              DC32    TOR
 3602    00000014 ........              DC32    MSTAR
 3603    00000018 ........              DC32    RFROM
 3604    0000001C ........              DC32    MSLASH
 3605    00000020 ........              DC32    SEMIS
 3606                           
 3607                           
 3608                           //      */ SSLASH:      ( n1 n2 n3 -- n4 )
 3609                           //      Leave the ratio n4 = n1*n2/n3 where all are signed numbers.
 3610                           //      Retention of an intermediate 31 bit product permits greater accuracy
 3611                           //      than would. be available with the sequence:
 3612                           //              n1  n2  *  n3  /
 3613                           
 3614                            SECTION .text : CONST (2)
 3615                           SSLASH_NFA:
 3616    00000000 82                    DC8     0x82
 3617    00000001 2A                    DC8     '*'
 3618    00000002 AF                    DC8     '/'+0x80
 3619    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3620    00000004 ........              DC32    SSMOD_NFA
 3621                           SSLASH:
 3622    00000008 ........              DC32    DOCOL
 3623    0000000C ........              DC32    SSMOD
 3624    00000010 ........              DC32    SWAP
 3625    00000014 ........              DC32    DROP
 3626    00000018 ........              DC32    SEMIS
 3627                           
 3628                           
 3629                           //      + PLUS: ( n1 n2 -- n3 )
 3630                           //      Add n1 and n2, leaving sum n3
 3631                           
 3632                            SECTION .text : CONST (2)
 3633                           PLUS_NFA:
 3634    00000000 81                    DC8     0x81
 3635    00000001 AB                    DC8     0xAB    // '+' + 0x80
 3636    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3637    00000004 ........              DC32    SSLASH_NFA
 3638                           PLUS:
 3639    00000008 ........              DC32    .+5
 3640                            SECTION .text : CODE (2)
 3641                                   POP2t
 3641.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3641.2                         //#ifndef TOSCT
 3641.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3641.4                         //#endif
 3641.5                         //      ADDS    p, p, #4
 3641.6                                 ENDM
 3642                                   POP2n
 3642.1  00000004 57F8041B              LDR     n, [p],#4
 3642.2                         //      LDR     n, [p]
 3642.3                         //      ADDS    p, p, #4
 3642.4                                 ENDM
 3643    00000008 4018                  ADDS    t, t, n
 3644                                   TPUSH
 3644                                   PUSHt   // push t to p, pre decrement p
 3644.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3644.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3644.3                         //      STR     t, [p]
 3644.4                                 ENDM
 3644                                   NEXT
 3644.1                         // ARMv7-M Thumb = .+5
 3644.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3644.3                         // ARMv6-M Thumb = .+4
 3644.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3644                                   NEXT1
 3644.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3644.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3644.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3644.4                         // ARMv6-M Thumb = .+4
 3644.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3644.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3644.7                                 ENDM
 3644.8                                 ENDM
 3644.9                                 ENDM
 3645                           
 3646                           
 3647                           //      - SUBB: ( n1 n2 -- n3 )
 3648                           //      Leave the difference of n1-n2 as n3.
 3649                           //      1 2 - . -1
 3650                           //      2 1 - .  1
 3651                           
 3652                            SECTION .text : CONST (2)
 3653                           SUB_NFA:
 3654    00000000 81                    DC8     0x81
 3655    00000001 AD                    DC8     '-'+0x80
 3656    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3657    00000004 ........              DC32    PLUS_NFA
 3658                           SUBB:
 3659    00000008 ........              DC32    .+5
 3660                            SECTION .text : CODE (2)
 3661                                   POP2t
 3661.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3661.2                         //#ifndef TOSCT
 3661.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3661.4                         //#endif
 3661.5                         //      ADDS    p, p, #4
 3661.6                                 ENDM
 3662                                   POP2n
 3662.1  00000004 57F8041B              LDR     n, [p],#4
 3662.2                         //      LDR     n, [p]
 3662.3                         //      ADDS    p, p, #4
 3662.4                                 ENDM
 3663    00000008 081A                  SUBS    t, n, t
 3664                                   TPUSH
 3664                                   PUSHt   // push t to p, pre decrement p
 3664.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3664.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3664.3                         //      STR     t, [p]
 3664.4                                 ENDM
 3664                                   NEXT
 3664.1                         // ARMv7-M Thumb = .+5
 3664.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3664.3                         // ARMv6-M Thumb = .+4
 3664.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3664                                   NEXT1
 3664.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3664.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3664.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3664.4                         // ARMv6-M Thumb = .+4
 3664.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3664.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3664.7                                 ENDM
 3664.8                                 ENDM
 3664.9                                 ENDM
 3665                           
 3666                           
 3667                           //      = EQUAL:        (n1 n2 -- f )
 3668                           //      Leave a true flag if n1=n2// otherwise leave a false flag.
 3669                           
 3670                            SECTION .text : CONST (2)
 3671                           EQUAL_NFA:
 3672    00000000 81                    DC8     0x81
 3673    00000001 BD                    DC8     '='+0x80
 3674    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3675    00000004 ........              DC32    SUB_NFA
 3676                           EQUAL:
 3677    00000008 ........              DC32    .+5
 3678                            SECTION .text : CODE (2)
 3679                           #ifdef TRUE_EQU_NEG_ONE
 3680    00000000 4040                  EORS    t, t
 3681                           #endif
 3682                                   POP2t
 3682.1  00000002 57F8040B              LDR     t, [p],#4       // Post-increment
 3682.2                         //#ifndef TOSCT
 3682.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3682.4                         //#endif
 3682.5                         //      ADDS    p, p, #4
 3682.6                                 ENDM
 3683                                   POP2n
 3683.1  00000006 57F8041B              LDR     n, [p],#4
 3683.2                         //      LDR     n, [p]
 3683.3                         //      ADDS    p, p, #4
 3683.4                                 ENDM
 3684    0000000A 401A                  SUBS    t, t, n
 3685    0000000C 09D0                  BEQ     EQUAL_TRUE
 3686    0000000E 4040                  EORS    t, t
 3687                                   TPUSH
 3687                                   PUSHt   // push t to p, pre decrement p
 3687.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3687.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3687.3                         //      STR     t, [p]
 3687.4                                 ENDM
 3687                                   NEXT
 3687.1                         // ARMv7-M Thumb = .+5
 3687.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3687.3                         // ARMv6-M Thumb = .+4
 3687.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3687                                   NEXT1
 3687.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3687.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3687.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3687.4                         // ARMv6-M Thumb = .+4
 3687.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3687.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3687.7                                 ENDM
 3687.8                                 ENDM
 3687.9                                 ENDM
 3688                           
 3689                           EQUAL_TRUE:
 3690                           #ifdef TRUE_EQU_NEG_ONE
 3691    00000022 0138                  SUBS    t, #1 // -1
 3692                           #else
 3694                           #endif
 3695                                   TPUSH
 3695                                   PUSHt   // push t to p, pre decrement p
 3695.1  00000024 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3695.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3695.3                         //      STR     t, [p]
 3695.4                                 ENDM
 3695                                   NEXT
 3695.1                         // ARMv7-M Thumb = .+5
 3695.2  00000028 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3695.3                         // ARMv6-M Thumb = .+4
 3695.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3695                                   NEXT1
 3695.1  0000002C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3695.2  00000030 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3695.3  00000034 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3695.4                         // ARMv6-M Thumb = .+4
 3695.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3695.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3695.7                                 ENDM
 3695.8                                 ENDM
 3695.9                                 ENDM
 3696                           /*
 3697                                   DC32    DOCOL
 3698                                   DC32    SUBB
 3699                                   DC32    ZEQU
 3700                                   DC32    SEMIS
 3701                           */
 3702                           
 3703                           
 3704                           //      < LESSTHAN:     ( n1 n2 -- f ) SIGNED:
 3705                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3706                           //      C0 1 < . 0  -1 C0 < . 1
 3707                           
 3708                            SECTION .text : CONST (2)
 3709                           LESSTHAN_NFA:
 3710    00000000 81                    DC8     0x81
 3711    00000001 BC                    DC8     '<'+0x80
 3712    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3713    00000004 ........              DC32    EQUAL_NFA
 3714                           LESSTHAN:
 3715    00000008 ........              DC32    .+5
 3716                            SECTION .text : CODE (2)
 3717                           #ifdef TRUE_EQU_NEG_ONE
 3718    00000000 4040                  EORS    t, t    // zero t
 3719    00000002 0138                  SUBS    t, #1   // -1
 3720                           #else
 3722                           #endif
 3723                                   POP2n                           // n2
 3723.1  00000004 57F8041B              LDR     n, [p],#4
 3723.2                         //      LDR     n, [p]
 3723.3                         //      ADDS    p, p, #4
 3723.4                                 ENDM
 3724                                   POP2w                           // n1
 3724.1  00000008 57F8042B              LDR     w, [p],#4
 3724.2                         //      LDR     w, [p]
 3724.3                         //      ADDS    p, p, #4
 3724.4                                 ENDM
 3725    0000000C 9142                  CMP     n, w        // n1 < n2
 3726    0000000E 00DC                  BGT     LESS1
 3727                           
 3728    00000010 4040                  EORS    t, t    // zero t =< n
 3729                           LESS1:
 3730                                   TPUSH
 3730                                   PUSHt   // push t to p, pre decrement p
 3730.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3730.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3730.3                         //      STR     t, [p]
 3730.4                                 ENDM
 3730                                   NEXT
 3730.1                         // ARMv7-M Thumb = .+5
 3730.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3730.3                         // ARMv6-M Thumb = .+4
 3730.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3730                                   NEXT1
 3730.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3730.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3730.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3730.4                         // ARMv6-M Thumb = .+4
 3730.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3730.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3730.7                                 ENDM
 3730.8                                 ENDM
 3730.9                                 ENDM
 3731                           
 3732                           
 3733                           //      U< ULESSTHAN:   ( n1 n2 -- f )  UNSIGNED:
 3734                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3735                           //      -1 -2 U< . 0  -1 2 U< . 0  1 2 U< . 1
 3736                           
 3737                            SECTION .text : CONST (2)
 3738                           ULESSTHAN_NFA:
 3739    00000000 82                    DC8     0x82
 3740    00000001 55                    DC8     'U'
 3741    00000002 BC                    DC8     '<'+0x80
 3742    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3743    00000004 ........              DC32    LESSTHAN_NFA
 3744                           ULESSTHAN:
 3745    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3746    00000010 .............         DC32    XORR, ZLESS
                  ...          
 3747    00000018 ........              DC32    ZBRAN
 3748    0000001C 18000000              DC32    ULES1-. //IF
 3749                           
 3750    00000020 .............         DC32    DROP, ZLESS
                  ...          
 3751    00000028 ........              DC32    ZEQU
 3752    0000002C ........              DC32    BRAN
 3753    00000030 0C000000              DC32    ULES2-.
 3754                           
 3755                           ULES1:
 3756    00000034 .............         DC32    SUBB,ZLESS      //ELSE
                  ...          
 3757                           
 3758                           ULES2:
 3759    0000003C ........              DC32    SEMIS           //endif
 3760                           
 3761                           
 3762                           //      > GREATERTHAN:  ( n1 n2 --  f ) SIGNED: L0
 3763                           //      Leave a true flag if n1 is greater than n2 otherwise a false flag.
 3764                           //      -1 1 > . 0  1 -1 > . 1
 3765                           
 3766                            SECTION .text : CONST (2)
 3767                           GREATERTHAN_NFA:
 3768    00000000 81                    DC8     0x81
 3769    00000001 BE                    DC8     '>'+0x80
 3770    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3771    00000004 ........              DC32    ULESSTHAN_NFA
 3772                           GREATERTHAN:
 3773    00000008 ........              DC32    DOCOL
 3774    0000000C ........              DC32    SWAP
 3775    00000010 ........              DC32    LESSTHAN
 3776    00000014 ........              DC32    SEMIS
 3777                           
 3778                           
 3779                           //      0= ZEQU:        ( n -- f )
 3780                           //      Leave a true flag is the number is equal to zero, otherwise leave a
 3781                           //      false flag. CHANGED Code dependent on true flag being 1 FOR -1 TRUE
 3782                           
 3783                            SECTION .text : CONST (2)
 3784                           ZEQU_NFA:
 3785    00000000 82                    DC8     0x82
 3786    00000001 30                    DC8     '0'
 3787    00000002 BD                    DC8     '='+0x80
 3788    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3789    00000004 ........              DC32    GREATERTHAN_NFA
 3790                           ZEQU:
 3791    00000008 ........              DC32    .+5
 3792                            SECTION .text : CODE (2)
 3793    00000000 4040                  EORS    t, t
 3794                                   POP2n
 3794.1  00000002 57F8041B              LDR     n, [p],#4
 3794.2                         //      LDR     n, [p]
 3794.3                         //      ADDS    p, p, #4
 3794.4                                 ENDM
 3795    00000006 0029                  CMP     n, #0
 3796    00000008 00D1                  BNE     ZEQU_ZERO
 3797                           
 3798                           #ifdef TRUE_EQU_NEG_ONE
 3799    0000000A 401E                  SUBS    t, t, #1
 3800                           #else
 3802                           #endif
 3803                           
 3804                           ZEQU_ZERO:
 3805                                   TPUSH
 3805                                   PUSHt   // push t to p, pre decrement p
 3805.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3805.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3805.3                         //      STR     t, [p]
 3805.4                                 ENDM
 3805                                   NEXT
 3805.1                         // ARMv7-M Thumb = .+5
 3805.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3805.3                         // ARMv6-M Thumb = .+4
 3805.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3805                                   NEXT1
 3805.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3805.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3805.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3805.4                         // ARMv6-M Thumb = .+4
 3805.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3805.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3805.7                                 ENDM
 3805.8                                 ENDM
 3805.9                                 ENDM
 3806                           
 3807                           
 3808                           //      0< ZLESS:       ( n -- f )
 3809                           //      Leave a true flag if the number is less than zero (negative),
 3810                           //      otherwise leave a false flag.
 3811                           
 3812                            SECTION .text : CONST (2)
 3813                           ZLESS_NFA:
 3814    00000000 82                    DC8     0x82
 3815    00000001 30                    DC8     '0'
 3816    00000002 BC                    DC8     '<'+0x80
 3817    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3818    00000004 ........              DC32    ZEQU_NFA
 3819                           ZLESS:
 3820    00000008 ........              DC32    .+5
 3821                            SECTION .text : CODE (2)
 3822                           #ifdef TOSCT    // REPLACING t SO THIS IS FASTER THAN POP2n
 3825                           #else
 3826                                   POP2n
 3826.1  00000000 57F8041B              LDR     n, [p],#4
 3826.2                         //      LDR     n, [p]
 3826.3                         //      ADDS    p, p, #4
 3826.4                                 ENDM
 3827                           #endif
 3828                           #ifdef TRUE_EQU_NEG_ONE
 3829    00000004 4040                  EORS    t, t
 3830    00000006 0138                  SUBS    t, #1   // TRUE -1
 3831                           #else
 3833                           #endif
 3834    00000008 0943                  ORRS    n, n, n // SET FLAGS
 3835    0000000A 00D4                  BMI     ZLESS1  // JS   ZLESS1
 3836                           
 3837    0000000C 4040                  EORS    t, t    // FALSE
 3838                           ZLESS1:
 3839                                   TPUSH
 3839                                   PUSHt   // push t to p, pre decrement p
 3839.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3839.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3839.3                         //      STR     t, [p]
 3839.4                                 ENDM
 3839                                   NEXT
 3839.1                         // ARMv7-M Thumb = .+5
 3839.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3839.3                         // ARMv6-M Thumb = .+4
 3839.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3839                                   NEXT1
 3839.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3839.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3839.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3839.4                         // ARMv6-M Thumb = .+4
 3839.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3839.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3839.7                                 ENDM
 3839.8                                 ENDM
 3839.9                                 ENDM
 3840                           
 3841                           
 3842                           //      BIN BIN:        ( -- )
 3843                           //      Set the numeric conversion base to TWO (bianry).
 3844                           
 3845                            SECTION .text : CONST (2)
 3846                           BIN_NFA:
 3847    00000000 83                    DC8     0x83
 3848    00000001 4249                  DC8     'BI'
 3849    00000003 CE                    DC8     'N'+0x80
 3850                            ALIGNROM 2,0xFFFFFFFF
 3851    00000004 ........              DC32    ZLESS_NFA
 3852                           BIN:
 3853    00000008 ........              DC32    DOCOL
 3854    0000000C ........02000         DC32    STRVA, 2, NBASE
                  000........  
 3855    00000018 ........              DC32    SEMIS
 3856                           
 3857                           
 3858                           //      HEX HEX:        ( -- )
 3859                           //      Set the numeric conversion base to sixteen (hexadecimal).
 3860                           
 3861                            SECTION .text : CONST (2)
 3862                           HEX_NFA:
 3863    00000000 83                    DC8     0x83
 3864    00000001 4845                  DC8     'HE'
 3865    00000003 D8                    DC8     'X'+0x80
 3866                            ALIGNROM 2,0xFFFFFFFF
 3867    00000004 ........              DC32    BIN_NFA
 3868                           HEX:
 3869    00000008 ........              DC32    DOCOL
 3870    0000000C ........10000         DC32    STRVA, 16, NBASE
                  000........  
 3871    00000018 ........              DC32    SEMIS
 3872                           
 3873                           
 3874                           //      DECIMAL DECIMAL:        ( -- )
 3875                           //      Set the numeric conversion base to TEN (decimal).
 3876                           //      DEC IS A NUMBER!
 3877                           
 3878                            SECTION .text : CONST (2)
 3879                           DECIMAL_NFA:
 3880    00000000 87                    DC8     0x87
 3881    00000001 444543494D41          DC8     'DECIMA'
 3882    00000007 CC                    DC8     'L'+0x80
 3883                            ALIGNROM 2,0xFFFFFFFF
 3884    00000008 ........              DC32    HEX_NFA
 3885                           DECIMAL:
 3886    0000000C ........              DC32    DOCOL
 3887    00000010 ........0A000         DC32    STRVA, 10, NBASE
                  000........  
 3888    0000001C ........              DC32    SEMIS
 3889                           
 3890                           
 3891                           //      NEGATE NEGATE: ( n1 -- n2 ) RENAMED: MINUS to NEGATE
 3892                           //      Leave the two's complement of a number.
 3893                           
 3894                            SECTION .text : CONST (2)
 3895                           NEGATE_NFA:
 3896    00000000 86                    DC8     0x86
 3897    00000001 4E45474154            DC8     'NEGAT'
 3898    00000006 C5                    DC8     'E'+0x80
 3899    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 3900    00000008 ........              DC32    DECIMAL_NFA
 3901                           NEGATE:
 3902    0000000C ........              DC32    .+5
 3903                            SECTION .text : CODE (2)
 3904                                   POP2t                   // MVN YES
 3904.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3904.2                         //#ifndef TOSCT
 3904.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3904.4                         //#endif
 3904.5                         //      ADDS    p, p, #4
 3904.6                                 ENDM
 3905    00000004 C043                  MVNS     t, t           // 1's compliment
 3906    00000006 401C                  ADDS     t, t, #1       // 2's compliment
 3907                                   TPUSH
 3907                                   PUSHt   // push t to p, pre decrement p
 3907.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3907.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3907.3                         //      STR     t, [p]
 3907.4                                 ENDM
 3907                                   NEXT
 3907.1                         // ARMv7-M Thumb = .+5
 3907.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3907.3                         // ARMv6-M Thumb = .+4
 3907.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3907                                   NEXT1
 3907.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3907.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3907.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3907.4                         // ARMv6-M Thumb = .+4
 3907.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3907.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3907.7                                 ENDM
 3907.8                                 ENDM
 3907.9                                 ENDM
 3908                           
 3909                           
 3910                           //      ABS ABS:        ( n -- ub )
 3911                           //      Leave the absolute value of n as un.
 3912                           
 3913                            SECTION .text : CONST (2)
 3914                           ABS1_NFA:
 3915    00000000 83                    DC8     0x83
 3916    00000001 4142                  DC8     'AB'
 3917    00000003 D3                    DC8     'S'+0x80
 3918                            ALIGNROM 2,0xFFFFFFFF
 3919    00000004 ........              DC32    NEGATE_NFA
 3920                           ABS:
 3921    00000008 ........              DC32    DOCOL
 3922    0000000C ........              DC32    DUP
 3923    00000010 ........              DC32    PM
 3924    00000014 ........              DC32    SEMIS
 3925                           
 3926                           
 3927                           //      MIN MIN:        ( n1 n2 -- min )
 3928                           //      Leave the smaller of two numbers.
 3929                           
 3930                            SECTION .text : CONST (2)
 3931                           MIN_NFA:
 3932    00000000 83                    DC8     0x83
 3933    00000001 4D49                  DC8     'MI'
 3934    00000003 CE                    DC8     'N'+0x80
 3935                            ALIGNROM 2,0xFFFFFFFF
 3936    00000004 ........              DC32    ABS1_NFA
 3937                           MIN:
 3938    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3939    00000010 ........              DC32    GREATERTHAN
 3940    00000014 ........              DC32    ZBRAN   //IF
 3941    00000018 08000000              DC32     MIN1-.
 3942                           
 3943    0000001C ........              DC32    SWAP    //endif
 3944                           MIN1:
 3945    00000020 ........              DC32    DROP
 3946    00000024 ........              DC32    SEMIS
 3947                           
 3948                           
 3949                           //      MAX MAX:        ( n1 n2 -- max )
 3950                           //      Leave the greater of two numbers.
 3951                           
 3952                            SECTION .text : CONST (2)
 3953                           MAX_NFA:
 3954    00000000 83                    DC8     0x83
 3955    00000001 4D41                  DC8     'MA'
 3956    00000003 D8                    DC8     'X'+0x80
 3957                            ALIGNROM 2,0xFFFFFFFF
 3958    00000004 ........              DC32    MIN_NFA
 3959                           MAX:
 3960    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3961    00000010 ........              DC32    LESSTHAN
 3962    00000014 ........              DC32    ZBRAN   //IF
 3963    00000018 08000000              DC32     MAX1-.
 3964                           
 3965    0000001C ........              DC32    SWAP    //endif
 3966                           MAX1:
 3967    00000020 ........              DC32    DROP
 3968    00000024 ........              DC32    SEMIS
 3969                           
 3970                           
 3971                           //      AND ANDD:       ( n1 n2 -- n2 )
 3972                           //      Leave the bitwise logical and of n1 and n2 as n3.
 3973                           
 3974                            SECTION .text : CONST (2)
 3975                           ANDD_NFA:
 3976    00000000 83                    DC8     0x83
 3977    00000001 414E                  DC8     'AN'
 3978    00000003 C4                    DC8     'D'+0x80
 3979                            ALIGNROM 2,0xFFFFFFFF
 3980    00000004 ........              DC32    MAX_NFA
 3981                           ANDD:
 3982    00000008 ........              DC32    .+5
 3983                            SECTION .text : CODE (2)
 3984                                   POP2t
 3984.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3984.2                         //#ifndef TOSCT
 3984.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3984.4                         //#endif
 3984.5                         //      ADDS    p, p, #4
 3984.6                                 ENDM
 3985                                   POP2n
 3985.1  00000004 57F8041B              LDR     n, [p],#4
 3985.2                         //      LDR     n, [p]
 3985.3                         //      ADDS    p, p, #4
 3985.4                                 ENDM
 3986    00000008 0840                  ANDS     t, t, n
 3987                                   TPUSH
 3987                                   PUSHt   // push t to p, pre decrement p
 3987.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3987.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3987.3                         //      STR     t, [p]
 3987.4                                 ENDM
 3987                                   NEXT
 3987.1                         // ARMv7-M Thumb = .+5
 3987.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3987.3                         // ARMv6-M Thumb = .+4
 3987.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3987                                   NEXT1
 3987.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3987.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3987.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3987.4                         // ARMv6-M Thumb = .+4
 3987.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3987.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3987.7                                 ENDM
 3987.8                                 ENDM
 3987.9                                 ENDM
 3988                           
 3989                           
 3990                           //      OR OR:  ( n1 n2 -- n3 )
 3991                           //      Leave the bit-wise logical or of n1 and n2 as n3.
 3992                           
 3993                            SECTION .text : CONST (2)
 3994                           OR_NFA:
 3995    00000000 82                    DC8     0x82
 3996    00000001 4F                    DC8     'O'
 3997    00000002 D2                    DC8     'R'+0x80
 3998    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3999    00000004 ........              DC32    ANDD_NFA
 4000                           OR:
 4001    00000008 ........              DC32    .+5
 4002                            SECTION .text : CODE (2)
 4003                                   POP2t
 4003.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4003.2                         //#ifndef TOSCT
 4003.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4003.4                         //#endif
 4003.5                         //      ADDS    p, p, #4
 4003.6                                 ENDM
 4004                                   POP2n
 4004.1  00000004 57F8041B              LDR     n, [p],#4
 4004.2                         //      LDR     n, [p]
 4004.3                         //      ADDS    p, p, #4
 4004.4                                 ENDM
 4005    00000008 0843                  ORRS     t, t, n
 4006                                   TPUSH
 4006                                   PUSHt   // push t to p, pre decrement p
 4006.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4006.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4006.3                         //      STR     t, [p]
 4006.4                                 ENDM
 4006                                   NEXT
 4006.1                         // ARMv7-M Thumb = .+5
 4006.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4006.3                         // ARMv6-M Thumb = .+4
 4006.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4006                                   NEXT1
 4006.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4006.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4006.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4006.4                         // ARMv6-M Thumb = .+4
 4006.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4006.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4006.7                                 ENDM
 4006.8                                 ENDM
 4006.9                                 ENDM
 4007                           
 4008                           
 4009                           //      NOT NOT: ( nl -- n2 )
 4010                           //      Leave the bitwise logical not of n1 as n2
 4011                           
 4012                            SECTION .text : CONST (2)
 4013                           NOT_NFA:
 4014    00000000 83                    DC8     0x83
 4015    00000001 4E4F                  DC8     'NO'
 4016    00000003 D4                    DC8     'T'+0x80
 4017                            ALIGNROM 2,0xFFFFFFFF
 4018    00000004 ........              DC32    OR_NFA
 4019                           NOT:
 4020    00000008 ........              DC32    .+5
 4021                            SECTION .text : CODE (2)
 4022                                   POP2t
 4022.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4022.2                         //#ifndef TOSCT
 4022.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4022.4                         //#endif
 4022.5                         //      ADDS    p, p, #4
 4022.6                                 ENDM
 4023    00000004 C043                  MVNS            t, t    // 1's compliment
 4024                                   TPUSH
 4024                                   PUSHt   // push t to p, pre decrement p
 4024.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4024.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4024.3                         //      STR     t, [p]
 4024.4                                 ENDM
 4024                                   NEXT
 4024.1                         // ARMv7-M Thumb = .+5
 4024.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4024.3                         // ARMv6-M Thumb = .+4
 4024.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4024                                   NEXT1
 4024.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4024.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4024.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4024.4                         // ARMv6-M Thumb = .+4
 4024.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4024.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4024.7                                 ENDM
 4024.8                                 ENDM
 4024.9                                 ENDM
 4025                           
 4026                           
 4027                           //      XORR XOR:       ( nl n2 -- n3 )
 4028                           //      Leave the bitwise logical exclusive or n1 and n2 as n3
 4029                           
 4030                            SECTION .text : CONST (2)
 4031                           XORR_NFA:
 4032    00000000 83                    DC8     0x83
 4033    00000001 584F                  DC8     'XO'
 4034    00000003 D2                    DC8     'R'+0x80
 4035                            ALIGNROM 2,0xFFFFFFFF
 4036    00000004 ........              DC32    NOT_NFA
 4037                           XORR:
 4038    00000008 ........              DC32    .+5
 4039                            SECTION .text : CODE (2)
 4040                                   POP2t
 4040.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4040.2                         //#ifndef TOSCT
 4040.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4040.4                         //#endif
 4040.5                         //      ADDS    p, p, #4
 4040.6                                 ENDM
 4041                                   POP2n
 4041.1  00000004 57F8041B              LDR     n, [p],#4
 4041.2                         //      LDR     n, [p]
 4041.3                         //      ADDS    p, p, #4
 4041.4                                 ENDM
 4042    00000008 4840                  EORS     t, t, n
 4043                                   TPUSH
 4043                                   PUSHt   // push t to p, pre decrement p
 4043.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4043.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4043.3                         //      STR     t, [p]
 4043.4                                 ENDM
 4043                                   NEXT
 4043.1                         // ARMv7-M Thumb = .+5
 4043.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4043.3                         // ARMv6-M Thumb = .+4
 4043.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4043                                   NEXT1
 4043.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4043.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4043.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4043.4                         // ARMv6-M Thumb = .+4
 4043.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4043.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4043.7                                 ENDM
 4043.8                                 ENDM
 4043.9                                 ENDM
 4044                           
 4045                           //      SXTH SXH:       ( nl -- n3 )
 4046                           //      Sign extend HALFWORD on the stack
 4047                           
 4048                            SECTION .text : CONST (2)
 4049                           SXTH_NFA:
 4050    00000000 84                    DC8     0x84
 4051    00000001 535854                DC8     'SXT'
 4052    00000004 C8                    DC8     'H'+0x80
 4053    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4054    00000008 ........              DC32    XORR_NFA
 4055                           SXH:
 4056    0000000C ........              DC32    .+5
 4057                            SECTION .text : CODE (2)
 4058                                   POP2t
 4058.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4058.2                         //#ifndef TOSCT
 4058.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4058.4                         //#endif
 4058.5                         //      ADDS    p, p, #4
 4058.6                                 ENDM
 4059    00000004 00B2                  SXTH     t, t
 4060                                   TPUSH
 4060                                   PUSHt   // push t to p, pre decrement p
 4060.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4060.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4060.3                         //      STR     t, [p]
 4060.4                                 ENDM
 4060                                   NEXT
 4060.1                         // ARMv7-M Thumb = .+5
 4060.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4060.3                         // ARMv6-M Thumb = .+4
 4060.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4060                                   NEXT1
 4060.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4060.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4060.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4060.4                         // ARMv6-M Thumb = .+4
 4060.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4060.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4060.7                                 ENDM
 4060.8                                 ENDM
 4060.9                                 ENDM
 4061                           
 4062                           
 4063                           //      SXTB SXB:       ( nl -- n3 )
 4064                           //      Signe extend byte in the word on the stack
 4065                           
 4066                            SECTION .text : CONST (2)
 4067                           SXTB_NFA:
 4068    00000000 84                    DC8     0x84
 4069    00000001 535854                DC8     'SXT'
 4070    00000004 C2                    DC8     'B'+0x80
 4071    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4072    00000008 ........              DC32    SXTH_NFA
 4073                           SXB:
 4074    0000000C ........              DC32    .+5
 4075                            SECTION .text : CODE (2)
 4076                                   POP2t
 4076.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4076.2                         //#ifndef TOSCT
 4076.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4076.4                         //#endif
 4076.5                         //      ADDS    p, p, #4
 4076.6                                 ENDM
 4077    00000004 40B2                  SXTB     t, t
 4078                                   TPUSH
 4078                                   PUSHt   // push t to p, pre decrement p
 4078.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4078.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4078.3                         //      STR     t, [p]
 4078.4                                 ENDM
 4078                                   NEXT
 4078.1                         // ARMv7-M Thumb = .+5
 4078.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4078.3                         // ARMv6-M Thumb = .+4
 4078.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4078                                   NEXT1
 4078.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4078.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4078.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4078.4                         // ARMv6-M Thumb = .+4
 4078.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4078.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4078.7                                 ENDM
 4078.8                                 ENDM
 4078.9                                 ENDM
 4079                           
 4080                           
 4081                           //      REVW REVW:      ( n -- n )
 4082                           //      Reverse bytes in n.
 4083                           
 4084                            SECTION .text : CONST (2)
 4085                           REVW_NFA:
 4086    00000000 84                    DC8     0x84
 4087    00000001 524556                DC8     'REV'
 4088    00000004 D7                    DC8     'W'+0x80
 4089    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4090    00000008 ........              DC32    SXTB_NFA
 4091                           REVW:
 4092    0000000C ........              DC32    .+5
 4093                            SECTION .text : CODE (2)
 4094                                   POP2t
 4094.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4094.2                         //#ifndef TOSCT
 4094.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4094.4                         //#endif
 4094.5                         //      ADDS    p, p, #4
 4094.6                                 ENDM
 4095    00000004 00BA                  REV     t, t
 4096                                   TPUSH
 4096                                   PUSHt   // push t to p, pre decrement p
 4096.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4096.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4096.3                         //      STR     t, [p]
 4096.4                                 ENDM
 4096                                   NEXT
 4096.1                         // ARMv7-M Thumb = .+5
 4096.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4096.3                         // ARMv6-M Thumb = .+4
 4096.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4096                                   NEXT1
 4096.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4096.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4096.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4096.4                         // ARMv6-M Thumb = .+4
 4096.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4096.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4096.7                                 ENDM
 4096.8                                 ENDM
 4096.9                                 ENDM
 4097                           
 4098                           
 4099                           //      ASR ASR:   ( sn count -- sn' )  
 4100                           //      Shift sn (sign-extended) right by count.
 4101                           //      Valid count values are 0 to 31.
 4102                           
 4103                            SECTION .text : CONST (2)
 4104                           ASR_NFA:
 4105    00000000 83                    DC8     0x83
 4106    00000001 4153                  DC8     'AS'
 4107    00000003 D2                    DC8     'R'+0x80
 4108                            ALIGNROM 2,0xFFFFFFFF
 4109    00000004 ........              DC32    REVW_NFA
 4110                           ASR:
 4111    00000008 ........              DC32    .+5
 4112                            SECTION .text : CODE (2)
 4113                                   POP2w           ; shift count
 4113.1  00000000 57F8042B              LDR     w, [p],#4
 4113.2                         //      LDR     w, [p]
 4113.3                         //      ADDS    p, p, #4
 4113.4                                 ENDM
 4114                                   POP2t           ; original data
 4114.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4114.2                         //#ifndef TOSCT
 4114.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4114.4                         //#endif
 4114.5                         //      ADDS    p, p, #4
 4114.6                                 ENDM
 4115    00000008 1041                  ASRS    t, t, w
 4116                                   TPUSH           ; shifted data
 4116                                   PUSHt   // push t to p, pre decrement p
 4116.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4116.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4116.3                         //      STR     t, [p]
 4116.4                                 ENDM
 4116                                   NEXT
 4116.1                         // ARMv7-M Thumb = .+5
 4116.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4116.3                         // ARMv6-M Thumb = .+4
 4116.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4116                                   NEXT1
 4116.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4116.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4116.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4116.4                         // ARMv6-M Thumb = .+4
 4116.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4116.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4116.7                                 ENDM
 4116.8                                 ENDM
 4116.9                                 ENDM
 4117                           
 4118                           
 4119                           //      LSR LSR:   ( n count -- n' )
 4120                           //      Logical (zero-extended) shift right by count.
 4121                           //      Valid count values are 0 to 31.
 4122                           
 4123                            SECTION .text : CONST (2)
 4124                           LSR_NFA:
 4125    00000000 83                    DC8     0x83
 4126    00000001 4C53                  DC8     'LS'
 4127    00000003 D2                    DC8     'R'+0x80
 4128                            ALIGNROM 2,0xFFFFFFFF
 4129    00000004 ........              DC32    ASR_NFA
 4130                           LSR:
 4131    00000008 ........              DC32    .+5
 4132                            SECTION .text : CODE (2)
 4133                                   POP2w           ; shift count
 4133.1  00000000 57F8042B              LDR     w, [p],#4
 4133.2                         //      LDR     w, [p]
 4133.3                         //      ADDS    p, p, #4
 4133.4                                 ENDM
 4134                                   POP2t           ; original data
 4134.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4134.2                         //#ifndef TOSCT
 4134.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4134.4                         //#endif
 4134.5                         //      ADDS    p, p, #4
 4134.6                                 ENDM
 4135    00000008 D040                  LSRS    t, t, w
 4136                                   TPUSH           ; shifted data
 4136                                   PUSHt   // push t to p, pre decrement p
 4136.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4136.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4136.3                         //      STR     t, [p]
 4136.4                                 ENDM
 4136                                   NEXT
 4136.1                         // ARMv7-M Thumb = .+5
 4136.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4136.3                         // ARMv6-M Thumb = .+4
 4136.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4136                                   NEXT1
 4136.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4136.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4136.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4136.4                         // ARMv6-M Thumb = .+4
 4136.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4136.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4136.7                                 ENDM
 4136.8                                 ENDM
 4136.9                                 ENDM
 4137                           
 4138                           
 4139                           //      LSL LSL:   ( n count -- n' )
 4140                           //      Logical (zero-extended) shift left by count.
 4141                           //      Valid count values are 0 to 31.
 4142                           
 4143                            SECTION .text : CONST (2)
 4144                           LSL_NFA:
 4145    00000000 83                    DC8     0x83
 4146    00000001 4C53                  DC8     'LS'
 4147    00000003 CC                    DC8     'L'+0x80
 4148                            ALIGNROM 2,0xFFFFFFFF
 4149    00000004 ........              DC32    LSR_NFA
 4150                           LSL:
 4151    00000008 ........              DC32    .+5
 4152                            SECTION .text : CODE (2)
 4153                                   POP2w           ; shift count
 4153.1  00000000 57F8042B              LDR     w, [p],#4
 4153.2                         //      LDR     w, [p]
 4153.3                         //      ADDS    p, p, #4
 4153.4                                 ENDM
 4154                                   POP2t           ; original data
 4154.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4154.2                         //#ifndef TOSCT
 4154.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4154.4                         //#endif
 4154.5                         //      ADDS    p, p, #4
 4154.6                                 ENDM
 4155    00000008 9040                  LSLS    t, t, w
 4156                                   TPUSH           ; shifted data---
 4156                                   PUSHt   // push t to p, pre decrement p
 4156.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4156.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4156.3                         //      STR     t, [p]
 4156.4                                 ENDM
 4156                                   NEXT
 4156.1                         // ARMv7-M Thumb = .+5
 4156.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4156.3                         // ARMv6-M Thumb = .+4
 4156.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4156                                   NEXT1
 4156.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4156.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4156.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4156.4                         // ARMv6-M Thumb = .+4
 4156.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4156.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4156.7                                 ENDM
 4156.8                                 ENDM
 4156.9                                 ENDM
 4157                           
 4158                           
 4159                           //      .R DOTR:        ( sn1 n2 -- ) SIGNED:
 4160                           //      Print the signed number sn1 right aligned in a field whose width is n2.
 4161                           //      No following blank is printed.
 4162                           
 4163                            SECTION .text : CONST (2)
 4164                           DOTR_NFA:
 4165    00000000 82                    DC8     0x82
 4166    00000001 2E                    DC8     '.'
 4167    00000002 D2                    DC8     'R'+0x80
 4168    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4169    00000004 ........              DC32    LSL_NFA
 4170                           DOTR:
 4171    00000008 ........              DC32    DOCOL
 4172    0000000C ........              DC32    TOR
 4173    00000010 ........              DC32    STOD
 4174    00000014 ........              DC32    RFROM
 4175    00000018 ........              DC32    DDOTR
 4176    0000001C ........              DC32    SEMIS
 4177                           
 4178                           
 4179                           //      .RU DOTRU:      ( n1 n2 -- ) UNSIGNED:
 4180                           //      Print the unsigned number n1 right aligned in a field whose width is n2.
 4181                           //      No following blank is printed.
 4182                           
 4183                            SECTION .text : CONST (2)
 4184                           DOTRU_NFA:
 4185    00000000 83                    DC8     0x83
 4186    00000001 2E52                  DC8     '.R'
 4187    00000003 D5                    DC8     'U'+0x80
 4188                            ALIGNROM 2,0xFFFFFFFF
 4189    00000004 ........              DC32    DOTR_NFA
 4190                           DOTRU:
 4191    00000008 ........              DC32    DOCOL
 4192    0000000C ........              DC32    TOR
 4193    00000010 ........              DC32    ZERO
 4194    00000014 .............         DC32    BDIGS, DIGS, EDIGS
                  ...........  
 4195    00000020 .............         DC32    DUP, RFROM
                  ...          
 4196    00000028 .............         DC32    SWAP, SUBB, SPACES, TYPE
                  .............
                  ......       
 4197                           #ifdef IO2TP
 4200                           #endif
 4201    00000038 ........              DC32    SEMIS
 4202                           
 4203                           
 4204                           //      U. UDOT:        ( n -- ) USIGNED DOT
 4205                           
 4206                            SECTION .text : CONST (2)
 4207                           UDOT_NFA:
 4208    00000000 82                    DC8     0x82
 4209    00000001 55                    DC8     'U'
 4210    00000002 AE                    DC8     '.'+0x80
 4211    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4212    00000004 ........              DC32    DOTRU_NFA
 4213                           UDOT:
 4214    00000008 ........              DC32    DOCOL
 4215    0000000C ........              DC32    ZERO
 4216    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4217    00000014 ........              DC32    SEMIS
 4218                           
 4219                           
 4220                           //      ? QUES: ( addr -- )
 4221                           //      Print the value contained at the address in free format according to
 4222                           //      the current base using DOT.
 4223                           
 4224                            SECTION .text : CONST (2)
 4225                           QUES_NFA:
 4226    00000000 81                    DC8     0x81
 4227    00000001 BF                    DC8     '?'+0x80
 4228    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4229    00000004 ........              DC32    UDOT_NFA
 4230                           QUES:
 4231    00000008 ........              DC32    DOCOL
 4232    0000000C ........              DC32    AT
 4233    00000010 ........              DC32    DOT
 4234    00000014 ........              DC32    SEMIS
 4235                           
 4236                           
 4237                           //      . DOT:  ( n -- ) SIGNED 2'S COMPLEMENT:
 4238                           //      Print a number from a signed 32 bit two's complement value,
 4239                           //      converted according to the numeric base.
 4240                           //      A trailing blanks follows.
 4241                           
 4242                            SECTION .text : CONST (2)
 4243                           DOT_NFA:
 4244    00000000 81                    DC8     0x81
 4245    00000001 AE                    DC8     '.'+0x80
 4246    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4247    00000004 ........              DC32    QUES_NFA
 4248                           DOT:
 4249    00000008 ........              DC32    DOCOL
 4250    0000000C ........              DC32    STOD
 4251    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4252    00000014 ........              DC32    SEMIS
 4253                           
 4254                           
 4255                           //------------------------------ DOTBASE SECTION -------------------------------
 4256                           //      .H DOTHEX:      ( n -- )
 4257                           //      Prints TOS in Hex using DOT, not affecting Base in the system
 4258                           
 4259                           #ifndef SRM
 4260                           //      .B DOTBIN:      ( n -- )
 4261                           //      Prints TOS in BINARY using DOT, not affecting Base in the system
 4262                           
 4263                            SECTION .text : CONST (2)
 4264                           DOTBIN_NFA:
 4265    00000000 82                    DC8     0x82
 4266    00000001 2E                    DC8     '.'
 4267    00000002 C2                    DC8     'B'+0x80
 4268    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4269    00000004 ........              DC32    DOT_NFA
 4270                           DOTBIN:
 4271    00000008 ........              DC32    DOCOL
 4272    0000000C .............         DC32    TWO, DOTBASE
                  ...          
 4273    00000014 ........              DC32    SEMIS
 4274                           #endif  // not SRM
 4275                           
 4276                           
 4277                            SECTION .text : CONST (2)
 4278                           DOTHEX_NFA:
 4279    00000000 82                    DC8     0x82
 4280    00000001 2E                    DC8     '.'
 4281    00000002 C8                    DC8     'H'+0x80
 4282    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4283    00000004 ........              DC32    DOTBIN_NFA
 4284                           DOTHEX:
 4285    00000008 ........              DC32    DOCOL
 4286                           #ifdef SRM
 4288                           #else
 4289    0000000C ........10000         DC32    LIT, 16, DOTBASE        // this version appends BASE Suffix
                  000........  
 4290                           #endif
 4291    00000018 ........              DC32    SEMIS
 4292                           
 4293                           
 4294                           #ifndef SRM
 4295                           //      .D DOTDEC:      ( n -- )
 4296                           //      Prints TOS in DECIMAL using DOT, not affecting Base in the system
 4297                           
 4298                            SECTION .text : CONST (2)
 4299                           DOTDEC_NFA:
 4300    00000000 82                    DC8     0x82
 4301    00000001 2E                    DC8     '.'
 4302    00000002 C4                    DC8     'D'+0x80
 4303    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4304    00000004 ........              DC32    DOTHEX_NFA
 4305                           DOTDEC:
 4306    00000008 ........              DC32    DOCOL
 4307    0000000C ........0A000         DC32    LIT, 10, DOTBASE
                  000........  
 4308    00000018 ........              DC32    SEMIS
 4309                           #endif  // not SRM
 4310                           
 4311                           
 4312                           //=============================== WORDCAT ====================================//
 4313                           //NOEXEC HEADERFORWORDCATEGORIES
 4314                           //      WC_NUMBERS_NFA = NUMBER Stuff: CATEGORY
 4315                           
 4316                            SECTION .text : CONST (2)
 4317                           WC_NUMBERS_NFA:
 4318    00000000 91                    DC8     0x80+4+13
 4319    00000001 0D0A                  DC8     0x0D, 0x0A
 4320    00000003 4E554D4245522         DC8     'NUMBER Stuff:'
                  053747566663A
 4321    00000010 0D8A                  DC8     0x0D, 0x0A+0x80
 4322    00000012 FFFF           ALIGNROM 2,0xFFFFFFFF
 4323    00000014 ........              DC32    DOTDEC_NFA
 4324                           
 4325                           
 4326                           //=============================== UART0_INIT =================================//
 4327                           
 4328                           // LFA ABOVE NEEDS TO BE WC_NUMBERS_NFA
 4329                           $FISH_STM32F4_UART3_INIT.s
 4330                           // LFA BELOW NEEDS TO BE UART3_INIT_NFA
 4331                           
 4332                           //=============================== UART0_INIT =================================//
 4333                           
 4334                           //      MYBAUD MYBAUD: ( n -- ) BAUD MUST BE IN DECIMAL or EQUIVALENT!!!
 4335                           //      MUST BE USED BEFORE USING UART0_INIT!!!
 4336                           //      Because FISH does a reset if you invoke a HARD FAULT RESET
 4337                           //      THIS MECHANISM IS ESSENTIAL TO STAYING AT USER SET BAUDRATE THRU A RESET!
 4338                           //      SET NON-INIT RAM VARIABLES DBAUD TO ZERO AND UBAUD n.
 4339                           //      See UART0_INIT
 4340                           
 4341                            SECTION .text : CONST (2)
 4342                           MYBAUD_NFA:
 4343    00000000 86                    DC8     0x86
 4344    00000001 4D59424155            DC8     'MYBAU'
 4345    00000006 C4                    DC8     'D'+0x80
 4346    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4347    00000008 ........              DC32    UART3_INIT_NFA
 4348                           MYBAUD:
 4349    0000000C ........              DC32    DOCOL
 4350    00000010 ........00000         DC32    strva, 0, DBAUD
                  000........  
 4351    0000001C .............         DC32    LIT, UBAUD, STORE       // SET UBAUD TO NEW BAUD FOR UART0_INIT
                  ...........  
 4352    00000028 ........              DC32    SEMIS
 4353                           
 4354                           
 4355                           //      STM32F4 UART3_LSR UART3_LSR: ( -- value )
 4356                           
 4357                            SECTION .text : CONST (2)
 4358                           UART3_LSR_NFA:
 4359    00000000 89                    DC8     0x89
 4360    00000001 55415254335F4         DC8     'UART3_LS'
                  C53          
 4361    00000009 D2                    DC8     'R'+0x80
 4362    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 4363    0000000C ........              DC32    MYBAUD_NFA
 4364                           UART3_LSR:
 4365    00000010 ........              DC32    .+5
 4366                            SECTION .text : CODE (2)
 4367    00000000 0549                  LDR     n, = USART3_SR
 4368    00000002 0878                  LDRB    t, [n]
 4369                                   TPUSH
 4369                                   PUSHt   // push t to p, pre decrement p
 4369.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4369.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4369.3                         //      STR     t, [p]
 4369.4                                 ENDM
 4369                                   NEXT
 4369.1                         // ARMv7-M Thumb = .+5
 4369.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4369.3                         // ARMv6-M Thumb = .+4
 4369.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4369                                   NEXT1
 4369.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4369.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4369.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4369.4                         // ARMv6-M Thumb = .+4
 4369.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4369.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4369.7                                 ENDM
 4369.8                                 ENDM
 4369.9                                 ENDM
 4370    00000016 0000           LTORG
 4370.1                                  TABLE
 4370.2  00000018 00480040              Reference on line 4367
 4371                           
 4372                           
 4373                           //      STM32F4 UART3_RX UART3_RX: ( -- addr )
 4374                           //      This is the serial terminal.
 4375                           
 4376                            SECTION .text : CONST (2)
 4377                           UART3_RX_NFA:
 4378    00000000 88                    DC8     0x88
 4379    00000001 55415254335F5         DC8     'UART3_R'
                  2            
 4380    00000008 D8                    DC8     'X'+0x80
 4381    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4382    0000000C ........              DC32    UART3_LSR_NFA
 4383                           UART0_RX:
 4384    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4385                           
 4386                           //      STM32F4 UART3_TX UART3_TX: ( -- addr )
 4387                           //      This is the serial terminal.
 4388                           
 4389                            SECTION .text : CONST (2)
 4390                           UART3_TX_NFA:
 4391    00000000 88                    DC8     0x88
 4392    00000001 55415254335F5         DC8     'UART3_T'
                  4            
 4393    00000008 D8                    DC8     'X'+0x80
 4394    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4395    0000000C ........              DC32    UART3_RX_NFA
 4396                           UART3_TX:
 4397    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4398                           
 4399                           
 4400                           #ifdef XON_XOFF
 4401                           //      XOFF XOFF: ( -- ) Send XOFF
 4402                           
 4403                            SECTION .text : CONST (2)
 4404                           XOFF_NFA:
 4405    00000000 84                    DC8     0x84
 4406    00000001 584F46                DC8     'XOF'
 4407    00000004 C6                    DC8     'F'+0x80
 4408    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4409    00000008 ........              DC32    UART3_TX_NFA
 4410                           XOFF:
 4411    0000000C ........              DC32    .+5
 4412                            SECTION .text : CODE (2)       // Does not incr OUT and wait for line status
 4413                           #ifdef IO2TP
 4415                           #else
 4416    00000000 ........              BL      TXRDY_SUBR
 4417    00000004 ........              BL      XOFF_SUBR
 4418                                   NEXT
 4418.1                         // ARMv7-M Thumb = .+5
 4418.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4418.3                         // ARMv6-M Thumb = .+4
 4418.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4418                                   NEXT1
 4418.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4418.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4418.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4418.4                         // ARMv6-M Thumb = .+4
 4418.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4418.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4418.7                                 ENDM
 4418.8                                 ENDM
 4419                           #endif // #else IO2TP
 4420                           //#endif // XON_XOFF after XON:
 4421                           
 4422                           
 4423                           //      XON XON: ( -- ) Send XON
 4424                           
 4425                            SECTION .text : CONST (2)
 4426                           XON_NFA:
 4427    00000000 83                    DC8     0x83
 4428    00000001 584F                  DC8     'XO'
 4429    00000003 CE                    DC8     'N'+0x80
 4430                            ALIGNROM 2,0xFFFFFFFF
 4431    00000004 ........              DC32    XOFF_NFA
 4432                           XON:
 4433    00000008 ........              DC32    .+5
 4434                            SECTION .text : CODE (2)       // Does not incr OUT or wait for line status.
 4435                           #ifdef IO2TP
 4437                           #else
 4438                           // Required, no 'quick send'
 4439    00000000 ........              BL      TXRDY_SUBR
 4440    00000004 ........              BL      XON_SUBR
 4441                                   NEXT
 4441.1                         // ARMv7-M Thumb = .+5
 4441.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4441.3                         // ARMv6-M Thumb = .+4
 4441.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4441                                   NEXT1
 4441.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4441.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4441.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4441.4                         // ARMv6-M Thumb = .+4
 4441.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4441.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4441.7                                 ENDM
 4441.8                                 ENDM
 4442                           #endif // #else IO2TP
 4443                           #endif // XON_XOFF
 4444                           
 4445                           //---------------- EMIT KEY ?KEY CR SECTION ------------------------------
 4446                           
 4447                           //      SPACES SPACES:  ( n -- )
 4448                           //      Transmit n ascii blanks (0x20) to the output device.
 4449                           
 4450                            SECTION .text : CONST (2)
 4451                           SPACES_NFA:
 4452    00000000 86                    DC8     0x86
 4453    00000001 5350414345            DC8     'SPACE'
 4454    00000006 D3                    DC8     'S'+0x80
 4455    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4456                           #ifdef XON_XOFF
 4457    00000008 ........              DC32    XON_NFA
 4458                           #else
 4460                           #endif
 4461                           SPACES:
 4462    0000000C ........              DC32    DOCOL
 4463    00000010 ........              DC32    ZERO
 4464    00000014 ........              DC32    MAX
 4465    00000018 ........              DC32    ZNDUP
 4466    0000001C ........              DC32    ZBRAN
 4467    00000020 18000000              DC32     SPACES_DONE-.
 4468                           
 4469    00000024 ........              DC32    ZERO
 4470    00000028 ........              DC32    XDO     //DO
 4471                           
 4472                           SPACES_DO:
 4473    0000002C ........              DC32    SPACE
 4474    00000030 ........              DC32    XLOOP   //LOOP
 4475    00000034 F8FFFFFF              DC32     SPACES_DO-.
 4476                           
 4477                           SPACES_DONE:
 4478    00000038 ........              DC32    SEMIS
 4479                           
 4480                           
 4481                           //      SPACE SPACE: ( -- )
 4482                           //      Emit a space character, 0x20.
 4483                           
 4484                            SECTION .text : CONST (2)
 4485                           SPACE_NFA:
 4486    00000000 85                    DC8     0x85
 4487    00000001 53504143              DC8     'SPAC'
 4488    00000005 C5                    DC8     'E'+0x80
 4489    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4490    00000008 ........              DC32    SPACES_NFA
 4491                           SPACE:
 4492    0000000C ........              DC32    DOCOL
 4493    00000010 ........              DC32    BLANK
 4494    00000014 ........              DC32    EMIT
 4495    00000018 ........              DC32    SEMIS
 4496                           
 4497                           
 4498                           //      ID. IDDOT:      ( NFA-addr -- ) ?RENAME .NFA
 4499                           //      Print a definition's name from its name field address.
 4500                           
 4501                            SECTION .text : CONST (2)
 4502                           IDDOT_NFA:
 4503    00000000 83                    DC8     0x83
 4504    00000001 4944                  DC8     'ID'
 4505    00000003 AE                    DC8     '.'+0x80
 4506                            ALIGNROM 2,0xFFFFFFFF
 4507    00000004 ........              DC32    SPACE_NFA
 4508                           IDDOT:
 4509    00000008 ........              DC32    DOCOL
 4510                           //      NOW COUNT is on NFA, fig code copied it out to pad
 4511    0000000C ........              DC32    COUNT   // Count could be SMUDGE'd.
 4512    00000010 ........1F000         DC32    LIT, MAXWORDLEN // Strip SMUDGEing from count
                  000          
 4513    00000018 ........              DC32    ANDD            // only time 
 4514    0000001C ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4515    00000020 ........              DC32    SPACE
 4516    00000024 ........              DC32    SEMIS
 4517                           
 4518                           
 4519                           //      ." DOTQ:        ( -- ) IMMEDIATE
 4520                           //      Type quoted string out or compile inline string to be typed at runtime
 4521                           //      CHANGED COMPILE TIME ACTION TO WORK WITH 4 byte alighment REQUIREMENT.
 4522                           //      Used in the form:
 4523                           //              .' CCcc"
 4524                           //      Compiles an in-line string CCcc (delimited by the trailing ") with
 4525                           //      an execution proceedure to transmit the text to the output device.
 4526                           //      If executed outside a definition, ." will immediately print the text
 4527                           //      until the final ',. The maximum number of characters may be an
 4528                           //      installation dependent value. See (.").
 4529                           
 4530                            SECTION .text : CONST (2)
 4531                           DOTQ_NFA:
 4532    00000000 C2                    DC8     0x0C2
 4533    00000001 2E                    DC8     '.'
 4534    00000002 A2                    DC8     '"'+0x80
 4535    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4536    00000004 ........              DC32    IDDOT_NFA
 4537                           DOTQ:
 4538    00000008 ........              DC32    DOCOL
 4539    0000000C ........22000         DC32    LIT, '"'        // 0x22 ending qoute delimiter for WORD
                  000          
 4540    00000014 ........              DC32    STATE_SV
 4541    00000018 ........              DC32    AT
 4542    0000001C ........              DC32    ZBRAN   // IF Not COMPILING
 4543    00000020 2C000000              DC32     DOTQ1-.
 4544                           
 4545    00000024 ........              DC32    COMP    // COMPILING
 4546    00000028 ........              DC32    PDOTQ   // compile LIT, cnt-str-addr, count, type
 4547    0000002C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4548    00000030 ........              DC32    HERE
 4549    00000034 ........              DC32    CAT
 4550    00000038 ........              DC32    ONEP
 4551    0000003C ........              DC32    ALIGNED
 4552    00000040 ........              DC32    ALLOT_PRIM
 4553    00000044 ........              DC32    BRAN    // ELSE
 4554    00000048 14000000              DC32     DOTQ2-.
 4555                           DOTQ1:
 4556    0000004C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4557    00000050 ........              DC32    HERE
 4558    00000054 ........              DC32    COUNT
 4559    00000058 ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4560                                                   // endif
 4561                           #ifdef IO2TP
 4565                           #endif
 4566                           DOTQ2:
 4567    0000005C ........              DC32    SEMIS
 4568                           
 4569                           
 4570                           //      TYPE TYPE:      ( addr count -- )
 4571                           //      ADDR must be ALIGNED!
 4572                           //      OUT MUST BE INITIALIZED!!
 4573                           //      EMIT COUNT OF 8-bits in a string, preferably ascii characters,
 4574                           //      (last nfa char (+80h)ok!) from addr thru count,
 4575                           
 4576                            SECTION .text : CONST (2)
 4577                           TYPE_NFA:
 4578    00000000 84                    DC8     0x84
 4579    00000001 545950                DC8     'TYP'
 4580    00000004 C5                    DC8     'E'+0x80
 4581    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4582    00000008 ........              DC32    DOTQ_NFA
 4583                           TYPE:
 4584    0000000C ........              DC32    DOCOL
 4585    00000010 ........              DC32    ZNDUP
 4586    00000014 ........              DC32    ZBRAN   // IF NOTHING TO TYPE
 4587    00000018 34000000              DC32     TYPE1-.
 4588                           
 4589                           #ifdef XON_XOFF
 4590    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 4591                           #endif
 4592    00000020 ........              DC32    OVER
 4593    00000024 ........              DC32    PLUS
 4594    00000028 ........              DC32    SWAP
 4595    0000002C ........              DC32    XDO     // DO
 4596                           TYPE2:
 4597    00000030 ........              DC32    I
 4598    00000034 ........              DC32    CATLT7F // Limit output to ASCII characters under 80h
 4599    00000038 ........              DC32    EMIT
 4600                           tt1:
 4601    0000003C ........              DC32    XLOOP   // LOOP
 4602                           tt2:
 4603    00000040 F0FFFFFF              DC32     TYPE2-.
 4604                           
 4605    00000044 ........              DC32    BRAN    // ELSE
 4606    00000048 08000000              DC32     TYPE3-.
 4607                           TYPE1:
 4608    0000004C ........              DC32    DROP    // endif
 4609                           TYPE3:
 4610    00000050 ........              DC32    SEMIS
 4611                           
 4612                           
 4613                           //      EMIT EMIT:      ( c -- )
 4614                           //      Transmit ascii character c to the selected output device. OUT is
 4615                           //      incremented for each character output.
 4616                           
 4617                            SECTION .text : CONST (2)
 4618                           EMIT_NFA:
 4619    00000000 84                    DC8     0x84
 4620    00000001 454D49                DC8     'EMI'
 4621    00000004 D4                    DC8     'T'+0x80
 4622    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4623    00000008 ........              DC32    TYPE_NFA
 4624                           EMIT:
 4625                           #ifndef IO2TP
 4626                           // NOT IO2TP SECTION:
 4627    0000000C ........              DC32    .+5
 4628                            SECTION .text : CODE (2)
 4629                                   POP2t                   // GET CHAR
 4629.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4629.2                         //#ifndef TOSCT
 4629.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4629.4                         //#endif
 4629.5                         //      ADDS    p, p, #4
 4629.6                                 ENDM
 4630    00000004 ........              BL      TXRDY_SUBR
 4631    00000008 0649                  LDR     n, = USART3_DR // 
 4632                           // BSOUT handles negative out issue
 4633    0000000A 0870                  STRB    t, [n]          // EMIT (Send) Char
 4634    0000000C 0649                  LDR     n, = OUT        // Increment Out
 4635    0000000E 0868                  LDR     t, [n]
 4636    00000010 401C                  ADDS    t, t, #1
 4637    00000012 0860                  STR     t, [n]
 4638                                   NEXT
 4638.1                         // ARMv7-M Thumb = .+5
 4638.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4638.3                         // ARMv6-M Thumb = .+4
 4638.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4638                                   NEXT1
 4638.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4638.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4638.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4638.4                         // ARMv6-M Thumb = .+4
 4638.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4638.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4638.7                                 ENDM
 4638.8                                 ENDM
 4639                           #else // if IO2TP Transmit char to PAD, increment OUT
 4654                           #endif  // IO2TP
 4655    00000022 0000           LTORG
 4655.1                                  TABLE
 4655.2  00000024 04480040              Reference on line 4631
 4655.3  00000028 ........              Reference on line 4634
 4656                           
 4657                           
 4658                           //      KEY KEY:        (  -- ch )
 4659                           
 4660                            SECTION .text : CONST (2)
 4661                           KEY_NFA:
 4662    00000000 83                    DC8     0x83
 4663    00000001 4B45                  DC8     'KE'
 4664    00000003 D9                    DC8     'Y'+0x80
 4665                            ALIGNROM 2,0xFFFFFFFF
 4666    00000004 ........              DC32    EMIT_NFA
 4667                           KEY_INTERPRETED_ENTRY:
 4668                           #ifndef IO2TP
 4669    00000008 ........              DC32    DOCOL
 4670    0000000C ........              DC32    XON     // EXEC SETS XOFF SO UNDO IT
 4671    00000010 ........              DC32    KEY     // TE GET KEY!
 4672    00000014 ........              DC32    SEMIS
 4673                           
 4674                           
 4675                           //:NONAME KEY KEY:      ( -- CH ) 0-7Fh
 4676                           KEY:
 4677    00000018 ........              DC32    .+5
 4678                            SECTION .text : CODE (2)
 4679    00000000 074A                  LDR     w, = USART3_DR // Data Register w_r2
 4680    00000002 084B                  LDR     x, = USART3_SR // Status Register x_r3
 4681                           rxRDY?:
 4682    00000004 1968                  LDR     n, [x]          // Get Line Status from [x_r3] to n_r2 
 4683                           //      LSRS    n, n, #5        // Bit 5 RXNE: Read data register not empty
 4684                           // THIS IS ___ AND FAILS TEXT DOWNLOAD
 4685    00000006 8909                  LSRS    n, n, #6        // Bit 6 ORIG - REQ'D FOR TEXT FILE DOWNLOAD
 4686    00000008 FCD3                  BCC     rxRDY?          // sets carry flag to fall thru
 4687                           
 4688    0000000A 1068                  LDR     t, [w]          // t_r0 w_r2 should be uart data register
 4689                                   TPUSH
 4689                                   PUSHt   // push t to p, pre decrement p
 4689.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4689.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4689.3                         //      STR     t, [p]
 4689.4                                 ENDM
 4689                                   NEXT
 4689.1                         // ARMv7-M Thumb = .+5
 4689.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4689.3                         // ARMv6-M Thumb = .+4
 4689.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4689                                   NEXT1
 4689.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4689.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4689.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4689.4                         // ARMv6-M Thumb = .+4
 4689.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4689.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4689.7                                 ENDM
 4689.8                                 ENDM
 4689.9                                 ENDM
 4690                           #else
 4692                           #endif  // IO2TP
 4693    0000001E 0000           LTORG
 4693.1                                  TABLE
 4693.2  00000020 04480040              Reference on line 4679
 4693.3  00000024 00480040              Reference on line 4680
 4694                           
 4695                           
 4696                           //      ?KEY QKEY: ( -- f )
 4697                           //      Return zero unless key in fifo - key is not consumed.
 4698                           //      : TB BEGIN ?KEY UNTIL ; Will execute until any key is entered.
 4699                           
 4700                            SECTION .text : CONST (2)
 4701                           QKEY_NFA:
 4702    00000000 84                    DC8     0x84
 4703    00000001 3F4B45                DC8     '?KE'
 4704    00000004 D9                    DC8     'Y'+0x80
 4705    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4706    00000008 ........              DC32    KEY_NFA // -1
 4707                           QKEY:
 4708    0000000C ........              DC32    .+5
 4709                            SECTION .text : CODE (2)
 4710                           #ifdef IO2TP
 4712                           #else
 4713                           #ifdef XON_XOFF // XON IN QKEY
 4714    00000000 ........              BL      TXRDY_SUBR
 4715    00000004 ........              BL      XON_SUBR
 4716                           #endif
 4717    00000008 4040                  EORS    t, t    // zero t
 4718    0000000A 074B                  LDR     x, = USART3_SR
 4719    0000000C 1968                  LDR     n, [x]          // Get Line Status
 4720    0000000E 8909                  LSRS    n, n, #6        // Char available
 4721    00000010 00D3                  BCC     NO_KEY          // No char, not Ready
 4722                           
 4723                           // HAVE A KEY - DON'T CONSUME IT
 4724                           #ifdef TRUE_EQU_NEG_ONE
 4725    00000012 0138                  SUBS    t, #1   // -1
 4726                           #else
 4728                           #endif
 4729                           #endif  // DEFAULT TO NO KEY IF IO2TP
 4730                           NO_KEY:
 4731                                   TPUSH
 4731                                   PUSHt   // push t to p, pre decrement p
 4731.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4731.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4731.3                         //      STR     t, [p]
 4731.4                                 ENDM
 4731                                   NEXT
 4731.1                         // ARMv7-M Thumb = .+5
 4731.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4731.3                         // ARMv6-M Thumb = .+4
 4731.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4731                                   NEXT1
 4731.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4731.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4731.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4731.4                         // ARMv6-M Thumb = .+4
 4731.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4731.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4731.7                                 ENDM
 4731.8                                 ENDM
 4731.9                                 ENDM
 4732    00000026 0000           LTORG
 4732.1                                  TABLE
 4732.2  00000028 00480040              Reference on line 4718
 4733                           
 4734                           
 4735                           //      CRS CRS:        ( n -- )
 4736                           //      Emit n cr'S (0x0d) and lf (0x0A)
 4737                           
 4738                            SECTION .text : CONST (2)
 4739                           CRS_NFA:
 4740    00000000 83                    DC8     0x83
 4741    00000001 4352                  DC8     'CR'
 4742    00000003 D3                    DC8     'S'+0x80
 4743                            ALIGNROM 2,0xFFFFFFFF
 4744    00000004 ........              DC32    QKEY_NFA
 4745                           CRS:
 4746    00000008 ........              DC32    DOCOL
 4747    0000000C ........              DC32    ZERO
 4748    00000010 ........              DC32    XDO
 4749                           CRS_BEGIN:
 4750    00000014 ........              DC32    CR
 4751    00000018 ........              DC32    XLOOP
 4752    0000001C F8FFFFFF              DC32     CRS_BEGIN-.
 4753    00000020 ........              DC32    SEMIS
 4754                           
 4755                           
 4756                           //      CR CR:  ( -- )
 4757                           //      Emit cr (0x0d) and lf (0x0A)
 4758                           
 4759                            SECTION .text : CONST (2)
 4760                           CR_NFA:
 4761    00000000 82                    DC8     0x82
 4762    00000001 43                    DC8     'C'
 4763    00000002 D2                    DC8     'R'+0x80
 4764    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4765    00000004 ........              DC32    CRS_NFA
 4766                           CR:
 4767                           #ifdef IO2TP
 4770                           #else
 4771    00000008 ........              DC32    DOCOL
 4772    0000000C ........              DC32    zero_OUT
 4773    00000010 ........              DC32    PDOTQ
 4774    00000014 02                    DC8     2
 4775    00000015 0D0A                  DC8     0x0D, 0x0A
 4776    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 4777    00000018 ........              DC32    SEMIS
 4778                           #endif
 4779                           
 4780                           
 4781                           //=============================== WORDCAT ====================================//
 4782                           //NOEXEC HEADERFORWORDCATEGORIES
 4783                           //      WC_UART0_NFA = FISH IO: CATEGORY
 4784                           
 4785                            SECTION .text : CONST (2)
 4786                           WC_UARTx_NFA:
 4787    00000000 8C                    DC8     0x80+4+8
 4788    00000001 0D0A                  DC8     0x0D, 0x0A
 4789    00000003 4649534820494         DC8     'FISH IO:'
                  F3A          
 4790    0000000B 0D8A                  DC8     0x0D, 0x0A+0x80
 4791    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4792    00000010 ........              DC32    CR_NFA
 4793                           
 4794                           //      CMSIS_ENABLE_IRQS IRQS_RESUME:  ( -- )
 4795                            SECTION .text : CONST (2)
 4796                           IRQS_RESUME_NFA:
 4797    00000000 8B                    DC8     0x8B
 4798    00000001 495251535F524         DC8     'IRQS_RESUM'
                  553554D      
 4799    0000000B C5                    DC8     'E'+0x80
 4800                            ALIGNROM 2,0xFFFFFFFF
 4801    0000000C ........              DC32    WC_UARTx_NFA
 4802                           CMSIS_ENABLE_IRQS:
 4803    00000010 ........              DC32 .+5
 4804                            SECTION .text : CODE (2)
 4805                            ALIGNROM 2,0xFFFFFFFF
 4806                            IMPORT C_CMSIS_ENABLE_IRQS
 4807    00000000 ........              BL      C_CMSIS_ENABLE_IRQS
 4808                                   NEXT
 4808.1                         // ARMv7-M Thumb = .+5
 4808.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4808.3                         // ARMv6-M Thumb = .+4
 4808.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4808                                   NEXT1
 4808.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4808.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4808.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4808.4                         // ARMv6-M Thumb = .+4
 4808.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4808.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4808.7                                 ENDM
 4808.8                                 ENDM
 4809                           
 4810                           //      CMSIS_DISABLE_IRQS IRQS_SUSPEND:        ( -- )
 4811                            SECTION .text : CONST (2)
 4812                           IRQS_SUSPEND_NFA:
 4813    00000000 8C                    DC8     0x8C
 4814    00000001 495251535F535         DC8     'IRQS_SUSPEN'
                  55350454E    
 4815    0000000C C4                    DC8     'D'+0x80
 4816    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4817    00000010 ........              DC32    IRQS_RESUME_NFA
 4818                           CMSIS_DISABLE_IRQS:
 4819    00000014 ........              DC32 .+5
 4820                            SECTION .text : CODE (2)
 4821                            ALIGNROM 2,0xFFFFFFFF
 4822                            IMPORT C_CMSIS_DISABLE_IRQS
 4823    00000000 ........              BL      C_CMSIS_DISABLE_IRQS
 4824                                   NEXT
 4824.1                         // ARMv7-M Thumb = .+5
 4824.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4824.3                         // ARMv6-M Thumb = .+4
 4824.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4824                                   NEXT1
 4824.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4824.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4824.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4824.4                         // ARMv6-M Thumb = .+4
 4824.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4824.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4824.7                                 ENDM
 4824.8                                 ENDM
 4825                           
 4826                           
 4827                           //      SYSTICK_IRQ_OFF SYSTICK_IRQ_OFF:        ( -- )
 4828                           //      Turn SYSTICK interrupt off.
 4829                           //      STCTR only incremented when SYSTICK interrupt is on.
 4830                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4831                            SECTION .text : CONST (2)
 4832                           SYSTICK_IRQ_OFF_NFA:
 4833    00000000 8F                    DC8     0x8F
 4834    00000001 5359535449434         DC8     'SYSTICK_IRQ_OF'
                  B5F4952515F4F
                  46           
 4835    0000000F C6                    DC8     'F'+0x80
 4836                            ALIGNROM 2,0xFFFFFFFF
 4837    00000010 ........              DC32    IRQS_SUSPEND_NFA
 4838                           SYSTICK_IRQ_OFF:
 4839    00000014 ........              DC32    .+5
 4840                            SECTION .text : CODE (2)
 4841    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4842    00000002 0520                  MOVS    t, #5
 4843    00000004 0860                  STR     t, [n]
 4844                                   NEXT
 4844.1                         // ARMv7-M Thumb = .+5
 4844.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4844.3                         // ARMv6-M Thumb = .+4
 4844.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4844                                   NEXT1
 4844.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4844.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4844.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4844.4                         // ARMv6-M Thumb = .+4
 4844.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4844.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4844.7                                 ENDM
 4844.8                                 ENDM
 4845                           // LTORG         //Always outside of code, else data in words
 4846                           
 4847                           
 4848                           //      SYSTICK_IRQ_ON SYSTICK_IRQ_ON:  ( -- )
 4849                           //      Turn SYSTICK interrupt on.
 4850                           //      STCTR only incremented when SYSTICK interrupt is on.
 4851                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4851.1                                  TABLE
 4851.2  00000014 10E000E0              Reference on line 4841
 4852                            SECTION .text : CONST (2)
 4853                           SYSTICK_IRQ_ON_NFA:
 4854    00000000 8E                    DC8     0x8E
 4855    00000001 5359535449434         DC8     'SYSTICK_IRQ_O'
                  B5F4952515F4F
 4856    0000000E CE                    DC8     'N'+0x80
 4857    0000000F FF             ALIGNROM 2,0xFFFFFFFF
 4858    00000010 ........              DC32    SYSTICK_IRQ_OFF_NFA
 4859                           SYSTICK_IRQ_ON:
 4860    00000014 ........              DC32    .+5
 4861                            SECTION .text : CODE (2)
 4862    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4863    00000002 0720                  MOVS    t, #7
 4864    00000004 0860                  STR     t, [n]
 4865                                   NEXT
 4865.1                         // ARMv7-M Thumb = .+5
 4865.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4865.3                         // ARMv6-M Thumb = .+4
 4865.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4865                                   NEXT1
 4865.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4865.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4865.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4865.4                         // ARMv6-M Thumb = .+4
 4865.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4865.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4865.7                                 ENDM
 4865.8                                 ENDM
 4866                            LTORG   //Always outside of code, else data in words
 4866.1                                  TABLE
 4866.2  00000014 10E000E0              Reference on line 4862
 4867                           
 4868                           //=============================== WORDCAT ====================================//
 4869                           //NOEXEC HEADERFORWORDCATEGORIES
 4870                           //      WC_IRQ_NFA = INTERRUPTS: CATEGORY
 4871                           
 4872                            SECTION .text : CONST (2)
 4873                           WC_IRQ_NFA:
 4874    00000000 8F                    DC8     0x80+4+11
 4875    00000001 0D0A                  DC8     0x0D, 0x0A
 4876    00000003 494E544552525         DC8     'INTERRUPTS:'
                  55054533A    
 4877    0000000E 0D8A                  DC8     0x0D, 0x0A+0x80
 4878                            ALIGNROM 2,0xFFFFFFFF
 4879    00000010 ........              DC32    SYSTICK_IRQ_ON_NFA
 4880                           
 4881                           
 4882                           //------------------------------------------------------------------------------
 4883                           $FISH_STM32F4_FLASH.s       // FLASH_SAVE and FLASH_FORGET Words
 4884                           // LFA BELOW NEEDS TO BE FLASH_FORGET_NFA
 4885                           //------------------------------------------------------------------------------
 4886                           
 4887                           //-------------------------- PROMPT VECTOR SECTION -----------------------------
 4888                           
 4889                           //      POFF ( -- )   Set NULL$ address in PROMPT to zero so quit does CR only.
 4890                           
 4891                            SECTION .text : CONST (2)
 4892                           POFF_NFA:
 4893    00000000 84                    DC8     0x84
 4894    00000001 504F46                DC8     'POF'
 4895    00000004 C6                    DC8     'F'+0x80
 4896    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4897    00000008 ........              DC32    FLASH_FORGET_NFA
 4898                           POFF:
 4899    0000000C ........              DC32    DOCOL
 4900    00000010 ........00000         DC32    STRVA, 0, PROMPT
                  000........  
 4901    0000001C ........              DC32    SEMIS
 4902                           
 4903                           //      PON ( -- )   Set NULL$ address in PROMPT to msg_MY_OK
 4904                           
 4905                            SECTION .text : CONST (2)
 4906                           PON_NFA:
 4907    00000000 83                    DC8     0x83
 4908    00000001 504F                  DC8     'PO'
 4909    00000003 CE                    DC8     'N'+0x80
 4910                            ALIGNROM 2,0xFFFFFFFF
 4911    00000004 ........              DC32    POFF_NFA
 4912                           PON:
 4913    00000008 ........              DC32    DOCOL
 4914    0000000C .............         DC32    STRVA, msg_MY_OK, PROMPT
                  ...........  
 4915    00000018 ........              DC32    SEMIS
 4916                           
 4917                           //      P ( -- addr )   Address of PROMPT, contains 0 or NULL$ address.
 4918                           
 4919                            SECTION .text : CONST (2)
 4920                           P_NFA:
 4921    00000000 81                    DC8     0x81
 4922    00000001 D0                    DC8     'P'+0x80
 4923    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4924    00000004 ........              DC32    PON_NFA
 4925                           P:
 4926    00000008 .............         DC32    DOCON, PROMPT
                  ...          
 4927                           
 4928                           //-------------------------- ERROR_HALT SECTION -----------------------------
 4929                           
 4930                           //      EHOFF ( -- )   Set ERROR_HALT to 0
 4931                           
 4932                            SECTION .text : CONST (2)
 4933                           EHOFF_NFA:
 4934    00000000 85                    DC8     0x85
 4935    00000001 45484F46              DC8     'EHOF'
 4936    00000005 C6                    DC8     'F'+0x80
 4937    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4938    00000008 ........              DC32    P_NFA
 4939                           EHOFF:
 4940    0000000C .............         DC32    DOCOL, ZERO, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 4941                           
 4942                           //      EHON ( -- )   Set ERROR_HALT to 1
 4943                           
 4944                            SECTION .text : CONST (2)
 4945                           EHON_NFA:
 4946    00000000 84                    DC8     0x84
 4947    00000001 45484F                DC8     'EHO'
 4948    00000004 CE                    DC8     'N'+0x80
 4949    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4950    00000008 ........              DC32    EHOFF_NFA
 4951                           EHON:
 4952    0000000C .............         DC32    DOCOL, ONE, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 4953                           
 4954                           //-------------------------- DOTDICTSPACE SECTION ------------------------------
 4955                           
 4956                           //      .DS DOTDICTSPACE:       ( n -- )
 4957                           //      Prints number of bytes availble in dictionary in DECIMAL using DOT,
 4958                           //      not affecting Base in the system
 4959                           
 4960                            SECTION .text : CONST (2)
 4961                           DOTDICTSPACE_NFA:
 4962    00000000 83                    DC8     0x83
 4963    00000001 2E44                  DC8     '.D'
 4964    00000003 D3                    DC8     'S'+0x80
 4965                            ALIGNROM 2,0xFFFFFFFF
 4966                           //      DC32    FLASH_FORGET_NFA
 4967                           //      DC32    P_NFA
 4968    00000004 ........              DC32    EHON_NFA
 4969                           DOTDICTSPACE:
 4970    00000008 ........              DC32    DOCOL
 4971    0000000C ........              DC32    DICTSPACE
 4972    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 4973    00000014 ........              DC32    DOTDEC
 4974    00000018 ........              DC32    BASE_FROM_R12   // Restore BASE
 4975    0000001C .............         DC32    LIT, msg_dictspace
                  ...          
 4976    00000024 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 4977                           #ifdef IO2TP
 4981                           #endif
 4982    0000002C ........              DC32    SEMIS
 4983                           
 4984                           
 4985                           //-------------------------- DOTVARSPACE SECTION -------------------------------
 4986                           
 4987                           //      .VS DOTVARSPACE:        ( n -- )
 4988                           //      Prints number of bytes availble in RAM VAR SPACE in DECIMAL using DOT,
 4989                           //      not affecting Base in the system.
 4990                           
 4991                            SECTION .text : CONST (2)
 4992                           DOTVARSPACE_NFA:
 4993    00000000 83                    DC8     0x83
 4994    00000001 2E56                  DC8     '.V'
 4995    00000003 D3                    DC8     'S'+0x80
 4996                            ALIGNROM 2,0xFFFFFFFF
 4997    00000004 ........              DC32    DOTDICTSPACE_NFA
 4998                           DOTVARSPACE:
 4999    00000008 ........              DC32    DOCOL
 5000    0000000C ........              DC32    VARSPACE
 5001    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 5002    00000014 .............         DC32    FOUR, SLASH
                  ...          
 5003    0000001C ........              DC32    DOTDEC
 5004    00000020 ........              DC32    BASE_FROM_R12   // Restore BASE
 5005    00000024 .............         DC32    LIT, msg_uvspace
                  ...          
 5006    0000002C .............         DC32    NULLSTRLEN, TYPE
                  ...          
 5007                           #ifdef IO2TP
 5011                           #endif
 5012    00000034 ........              DC32    SEMIS
 5013                           
 5014                           
 5015                           //      DUMP DUMP:      ( addr n -- )
 5016                           //      Print adrr and n lines of 4 columns of memory values in hexadecimal.
 5017                           //      Address must be even and a multiple of 4 else error message issued.
 5018                           //      Any key presssed will stop DUMP.
 5019                           
 5020                            SECTION .text : CONST (2)
 5021                           DUMP_NFA:
 5022    00000000 84                    DC8     0x84
 5023    00000001 44554D                DC8     'DUM'
 5024    00000004 D0                    DC8     'P'+0x80
 5025    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5026    00000008 ........              DC32    DOTVARSPACE_NFA
 5027                           DUMP:
 5028    0000000C ........              DC32    DOCOL
 5029                           
 5030    00000010 .............         DC32    OVER, QALIGNED  // \ -- addr n
                  ...          
 5031                           // DON'T SAVE BASE UNTIL AFTER ALIGNED TEST
 5032    00000018 ........              DC32    BASE_TO_R12     // Save current BASE
 5033    0000001C ........              DC32    HEX
 5034    00000020 .............         DC32    ZERO, XDO
                  ...          
 5035                           DUMP_ADDR_LINE:
 5036    00000028 ........              DC32    CR
 5037    0000002C .............         DC32    DUP, LIT, 10, DOTRU     // Print addr in Field
                  ...0A000000..
                  ......       
 5038    0000003C .............         DC32    FOUR, ZERO, XDO         // Four colum loop
                  ...........  
 5039                           DUMP_EACH_LOC:
 5040    00000048 .............         DC32    DUP, AT
                  ...          
 5041                           // Little Endian means addresses will print correctly
 5042                           // but to see character strings REVW is needed
 5043                           // but the addresses are scrambled!
 5044                           //        DC32    REVW                    // Reverse bytes in word
 5045    00000050 ........0E000         DC32    LIT, 14, DOTRU          // Diplay in Field
                  000........  
 5046    0000005C ........              DC32    FOURP
 5047    00000060 ........              DC32    XLOOP
 5048    00000064 E4FFFFFF              DC32     DUMP_EACH_LOC-.
 5049                           
 5050                           #ifdef IO2TP
 5054                           #endif
 5055    00000068 ........              DC32    QKEY
 5056    0000006C ........              DC32    ZBRAN
 5057    00000070 08000000              DC32     DUMP_CONT-.
 5058    00000074 ........              DC32    LEAVE
 5059                           DUMP_CONT:
 5060    00000078 ........              DC32    XLOOP
 5061    0000007C ACFFFFFF              DC32    DUMP_ADDR_LINE-.
 5062                           
 5063    00000080 .............         DC32    DROP, CR
                  ...          
 5064    00000088 ........              DC32    BASE_FROM_R12   // Restore BASE
 5065    0000008C ........              DC32    SEMIS
 5066                           
 5067                           
 5068                           //      VBASE VBASE:    ( -- addr )
 5069                           //      Return base addr of VAR's .
 5070                           
 5071                            SECTION .text : CONST (2)
 5072                           VBASE_NFA:
 5073    00000000 85                    DC8     0x85
 5074    00000001 56424153              DC8     'VBAS'
 5075    00000005 C5                    DC8     'E'+0x80
 5076    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5077    00000008 ........              DC32    DUMP_NFA
 5078                           VBASE:
 5079    0000000C .............         DC32    DOCON,  RAMVARSPACE_START
                  ...          
 5080                           
 5081                           
 5082                           //      DBASE DBASE:    ( -- addr )
 5083                           //      Return base addr of the dictionary.
 5084                           
 5085                            SECTION .text : CONST (2)
 5086                           DBASE_NFA:
 5087    00000000 85                    DC8     0x85
 5088    00000001 44424153              DC8     'DBAS'
 5089    00000005 C5                    DC8     'E'+0x80
 5090    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5091    00000008 ........              DC32    VBASE_NFA
 5092                           DBASE:
 5093    0000000C .............         DC32    DOCON,  ORIG
                  ...          
 5094                           
 5095                           
 5096                           //      RBASE RBASE:    ( -- addr )
 5097                           //      Return base addr of RAM THE DICTIONARY IS IN!.
 5098                           
 5099                            SECTION .text : CONST (2)
 5100                           RBASE_NFA:
 5101    00000000 85                    DC8     0x85
 5102    00000001 52424153              DC8     'RBAS'
 5103    00000005 C5                    DC8     'E'+0x80
 5104    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5105    00000008 ........              DC32    DBASE_NFA
 5106                           RBASE:
 5107    0000000C .............         DC32    DOCON,  RAM_START    // RAM WHERE DICT ALLOACTED IN MEMMAP
                  ...          
 5108                           
 5109                           
 5110                           //      CLS CLS:        ( -- )
 5111                           //      Clear serial terminal screen using a formfeed character
 5112                           
 5113                            SECTION .text : CONST (2)
 5114                           CLS_NFA:
 5115    00000000 83                    DC8     0x83
 5116    00000001 434C                  DC8     'CL'
 5117    00000003 D3                    DC8     'S'+0x80
 5118                            ALIGNROM 2,0xFFFFFFFF
 5119    00000004 ........              DC32    RBASE_NFA
 5120                           CLS:
 5121    00000008 ........              DC32    DOCOL
 5122    0000000C ........              DC32    PDOTQ
 5123    00000010 04                    DC8     4
 5124    00000011 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT100 ESC SETUP
 5125    00000013 324A                  DC8     '2J'            // Clearscreen
 5126    00000015 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5127    00000018 ........              DC32    PDOTQ
 5128    0000001C 04                    DC8     4
 5129    0000001D 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT00 ESC SETUP
 5130    0000001F 3B48                  DC8     ';H'            // CURSORHOME \ upper left corner
 5131    00000021 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5132    00000024 ........              DC32    CR              // Reset OUT
 5133    00000028 ........              DC32    SEMIS
 5134                           
 5135                           
 5136                           //      ( PAREN:        ( -- ) IMMEDIATE
 5137                           //      Used in the form:
 5138                           //              ( CCcc )
 5139                           //      Ignore comments within parenthesis. A right parenthesis ends comment.
 5140                           //      The comments may be multi-line but a space or tab is required
 5141                           //      for any line that is otherwise empty for formatting purposes,
 5142                           //      else a comment error will be printed. May occur during execution or in a
 5143                           //      colon-definition. A blank after the leading parenthesis is required.
 5144                           
 5145                            SECTION .text : CONST (2)
 5146                           PAREN_NFA:
 5147    00000000 C1                    DC8     0x0C1
 5148    00000001 A8                    DC8     '('+0x80
 5149    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5150    00000004 ........              DC32    CLS_NFA
 5151                           PAREN:
 5152                           // Slow Single line comment
 5153                           //      DC32    DOCOL, LIT, ')', WORD, SEMIS
 5154    00000008 ........              DC32    DOCOL
 5155                           PML_LOOP:
 5156    0000000C ........29000         DC32    LIT, ')'
                  000          
 5157    00000014 ........              DC32    TIB_CHAR_SCAN   // ( c -- f )
 5158                           //
 5159    00000018 ........              DC32    ZEQU            // If null
 5160    0000001C ........              DC32    ZBRAN           // found fall thru
 5161    00000020 34000000              DC32      PE_DONE-.     // else were done
 5162                           
 5163                           // Acting like the outer interpreter here, signal DLE
 5164    00000024 .............         DC32    CR, LIT, 0x10, EMIT
                  ...10000000..
                  ......       
 5165    00000034 ........              DC32    QUERY
 5166                           //  AND IF ONLY CR (null) ERR
 5167                           //        DC32    TIB_SV, CAT
 5168    00000038 .............         DC32    LIT, TIB+1, CAT // PAST COUNT BYTE
                  ...........  
 5169    00000044 ........              DC32    ZBRAN
 5170    00000048 10000000              DC32      PAREN_ERR-.
 5171                           
 5172                           //  If closing paren not in this line LOOP
 5173    0000004C ........              DC32    BRAN
 5174    00000050 BCFFFFFF              DC32      PML_LOOP-.
 5175                           
 5176                           PE_DONE:
 5177    00000054 ........              DC32    SEMIS
 5178                           
 5179                           PAREN_ERR:
 5180    00000058 .............         DC32    LIT, msg_paren_err
                  ...          
 5181    00000060 .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 5182    00000068 ........              DC32    SEMIS
 5183                           
 5184                           
 5185                           //      BACKSLASH BACKSLASH:    ( --  )
 5186                           //      After a trailing space treat the rest of the line as a comment.
 5187                           //      By setting a null terminator in TIB
 5188                           
 5189                            SECTION .text : CONST (2)
 5190                           BACKSLASH_NFA:
 5191    00000000 C1                    DC8     0x0C1
 5192    00000001 DC                    DC8     '\\'+0x80
 5193    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5194    00000004 ........              DC32    PAREN_NFA
 5195                           BACKSLASH:
 5196    00000008 ........              DC32    DOCOL
 5197    0000000C .............         DC32    ZERO, TIB_SV, IN_SV, AT, PLUS, CSTORE
                  .............
                  .............
                  .........    
 5198    00000024 ........              DC32    SEMIS
 5199                           
 5200                           
 5201                           //      SYSCLK SYSCLK:  ( -- value )
 5202                           //      Returns system clock value in Hz, i.e. 48000000 = 48Mhz.
 5203                           
 5204                            SECTION .text : CONST (2)
 5205                           SYSCLK_NFA:
 5206    00000000 86                    DC8     0x86
 5207    00000001 535953434C            DC8     'SYSCL'
 5208    00000006 CB                    DC8     'K'+0x80
 5209    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 5210    00000008 ........              DC32    BACKSLASH_NFA
 5211                           SYSCLK:
 5212    0000000C ........              DC32    .+5
 5213                            SECTION .text : CODE (2)
 5214    00000000 0549                  LDR     n, = SYSCLOCK   // SystemCoreClock
 5215    00000002 0868                  LDR     t, [n]
 5216                                   TPUSH   // Push -- t
 5216                                   PUSHt   // push t to p, pre decrement p
 5216.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 5216.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 5216.3                         //      STR     t, [p]
 5216.4                                 ENDM
 5216                                   NEXT
 5216.1                         // ARMv7-M Thumb = .+5
 5216.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5216.3                         // ARMv6-M Thumb = .+4
 5216.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5216                                   NEXT1
 5216.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5216.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5216.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5216.4                         // ARMv6-M Thumb = .+4
 5216.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5216.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5216.7                                 ENDM
 5216.8                                 ENDM
 5216.9                                 ENDM
 5217    00000016 0000           LTORG   //Always outside of code, else data in words
 5217.1                                  TABLE
 5217.2  00000018 ........              Reference on line 5214
 5218                           
 5219                           
 5220                           //      STCTR   ( -- addr ) SYSTICK Interrupt increments this with 32but wrap.
 5221                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5222                            SECTION .text : CONST (2)
 5223                           STCTR_NFA:
 5224    00000000 85                    DC8     0x85
 5225    00000001 53544354              DC8     'STCT'
 5226    00000005 D2                    DC8     'R'+0x80
 5227    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5228                           //      DC32    STI_ON_NFA
 5229    00000008 ........              DC32    SYSCLK_NFA
 5230                           STCTR:
 5231    0000000C .............         DC32    DOCON, STICKER
                  ...          
 5232                           
 5233                           
 5234                           //      DELAY ( n value -- ) 7 E000E010h !   5 E000E010h !
 5235                            SECTION .text : CONST (2)
 5236                           DELAY_NFA:
 5237    00000000 85                    DC8     0x85
 5238    00000001 44454C41              DC8     'DELA'
 5239    00000005 D9                    DC8     'Y'+0x80
 5240    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5241    00000008 ........              DC32    STCTR_NFA
 5242                           DELAY:
 5243    0000000C ........              DC32    .+5
 5244                            SECTION .text : CODE (2)
 5245                                   POP2n   // Reload value in n
 5245.1  00000000 57F8041B              LDR     n, [p],#4
 5245.2                         //      LDR     n, [p]
 5245.3                         //      ADDS    p, p, #4
 5245.4                                 ENDM
 5246                                   POP2t   // loop count in t
 5246.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 5246.2                         //#ifndef TOSCT
 5246.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 5246.4                         //#endif
 5246.5                         //      ADDS    p, p, #4
 5246.6                                 ENDM
 5247                           // SET STCTR TO NEGATIVE LOOP COUNT TO END AT ZERO
 5248    00000008 0C4C                  LDR     y, = STICKER
 5249    0000000A C043                  MVNS    t, t            // 1's compliment
 5250    0000000C 401C                  ADDS    t, t, #1        // 2's compliment
 5251    0000000E 2060                  STR     t, [y]
 5252                           // Load SYST_RVR with countdown value
 5253    00000010 0B4A                  LDR     w, = SYST_RVR
 5254    00000012 1160                  STR     n, [w]
 5255                           // and reset SYST_CVR to start countdown.
 5256    00000014 0B4A                 LDR     w, = SYST_CVR
 5257                           // Writing it clears the System Tick counter and the COUNTFLAG bit in STCTRL.
 5258    00000016 1160                  STR     n, [w]
 5259                           // If n=0 in t user is just setting reload value
 5260    00000018 0028                  CMP     t, #0           // LOOP OF ZERO
 5261    0000001A 06D0                  BEQ     DELAY_DONE
 5262                           // INTERRUPT VERSION: negate n to STCTR and leave when STCTR = 0
 5263                           // STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5264                           // Save and restore user interrupt setting
 5265                           // y = STICKER
 5266    0000001C 0A4A                  LDR     w, = SYST_CSR
 5267    0000001E 1068                  LDR     t, [w]          // Save user SYSTICK interrupt setting
 5268    00000020 0721                  MOVS    n, #7
 5269    00000022 1160                  STR     n, [w]          // Turn SYSTICK interrupt on in case it's off
 5270                           DELAY_LOOP:
 5271    00000024 2168                  LDR     n, [y]
 5272    00000026 0029                  CMP     n, #0
 5273    00000028 FCD1                  BNE     DELAY_LOOP
 5274                           DELAY_DONE:
 5275    0000002A 1060                  STR     t, [w]  // Restore user SYSTICK interrupt setting
 5276                                   NEXT
 5276.1                         // ARMv7-M Thumb = .+5
 5276.2  0000002C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5276.3                         // ARMv6-M Thumb = .+4
 5276.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5276                                   NEXT1
 5276.1  00000030 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5276.2  00000034 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5276.3  00000038 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5276.4                         // ARMv6-M Thumb = .+4
 5276.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5276.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5276.7                                 ENDM
 5276.8                                 ENDM
 5277    0000003A 0000           LTORG
 5277.1                                  TABLE
 5277.2  0000003C ........              Reference on line 5248
 5277.3  00000040 14E000E0              Reference on line 5253
 5277.4  00000044 18E000E0              Reference on line 5256
 5277.5  00000048 10E000E0              Reference on line 5266
 5278                           
 5279                           
 5280                           //      MS MS: ( n -- ) n * 1 millisecond execution time
 5281                           //      SYSTICK_IRQ_ON/OFF  STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! 
 5282                           
 5283                            SECTION .text : CONST (2)
 5284                           MS_NFA:
 5285    00000000 82                    DC8     0x82
 5286    00000001 4D                    DC8     'M'
 5287    00000002 D3                    DC8     'S'+0x80
 5288    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 5289    00000004 ........              DC32    DELAY_NFA
 5290                           MS:
 5291    00000008 ........              DC32    DOCOL
 5292                           #ifdef STM32F4_IRC16_48MHZ
 5294                           #endif
 5295                           #ifdef STM32F205RC_XRC10_118MHZ
 5297                           #endif
 5298                           #ifdef STM32F4_XRC08_168MHZ
 5299    0000000C ........3F900         DC32    LIT, 167999d    // 2903Fh 1ms @ 168mhz RELOAD COUNTER VALUE
                  200          
 5300                           #endif
 5301    00000014 ........              DC32    DELAY
 5302    00000018 ........              DC32    SEMIS
 5303                           
 5304                           
 5305                           //      WORDCAT WORDCAT: ( -- )
 5306                           //      Creates a Word Category NFA and LFA that cannot be searched for,
 5307                           //      but is displayed by WORDS and MYWORDS to label a group of Words.
 5308                           //      Define a group of Words and then add a category name with WORDCAT.
 5309                           //      EX: WORDCAT MY APP WORDS:
 5310                           //      It must be on a line of it's own.
 5311                           //      The colon at the end is FISH convention.
 5312                            SECTION .text : CONST (2)
 5313                           WORDCAT_NFA:
 5314    00000000 87                    DC8     0x87
 5315    00000001 574F52444341          DC8     'WORDCA'
 5316    00000007 D4                    DC8     'T'+0x80
 5317                            ALIGNROM 2,0xFFFFFFFF
 5318    00000008 ........              DC32    MS_NFA
 5319                           WORDCAT:
 5320    0000000C ........              DC32    DOCOL
 5321    00000010 .............         DC32    HERE, TOR
                  ...          
 5322    00000018 .............         DC32    ZERO, CCOMMA    // Count byte place holder
                  ...          
 5323    00000020 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5324    0000002C ........              DC32    HERE
 5325    00000030 ........0D000         DC32    LIT, 0Dh, WORD
                  000........  
 5326    0000003C .............         DC32    DUP, CAT
                  ...          
 5327    00000044 ........0A000         DC32    LIT, 0Ah, ROT, CSTORE
                  000..........
                  ......       
 5328    00000054 .............         DC32    DUP, ONEP, ALLOT
                  ...........  
 5329    00000060 ........84000         DC32    LIT, 084h        // Count before system text
                  000          
 5330    00000068 .............         DC32    PLUS, R, CSTORE
                  ...........  
 5331    00000074 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5332    00000080 ........8A000         DC32    LIT, 08Ah, CCOMMA
                  000........  
 5333    0000008C ........              DC32    ALIGN32_DP_FF_PAD
 5334    00000090 .............         DC32    LATEST, COMMA
                  ...          
 5335    00000098 ........              DC32    RFROM
 5336    0000009C .............         DC32    LIT, CURRENT
                  ...          
 5337    000000A4 ........              DC32    STORE
 5338    000000A8 ........              DC32    SEMIS
 5339                           
 5340                           
 5341                           //      WORDS WORDS:    ( -- ) RENAMED: VLIST to WORDS
 5342                           //      Output list of Words in the dictionary in search order.
 5343                           //      Uses WC_ nfa's to format Word Categories.
 5344                           //      Uses FENCE for where to stop.
 5345                           //      See MYWORDS.
 5346                           
 5347                            SECTION .text : CONST (2)
 5348                           WORDS_NFA:
 5349    00000000 85                    DC8     0x85
 5350    00000001 574F5244              DC8     'WORD'
 5351    00000005 D3                    DC8     'S'+0x80
 5352    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5353    00000008 ........              DC32    WORDCAT_NFA
 5354                           WORDS:
 5355    0000000C ........              DC32    DOCOL
 5356    00000010 .............         DC32    THREE, SPACES
                  ...          
 5357    00000018 ........              DC32    LATEST
 5358                           #ifdef XON_XOFF
 5359    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 5360                           #endif
 5361                           WORDS1:  // ADD nfa length to current out_uv & verify it doesn't violate csll.
 5362                           
 5363    00000020 .............         DC32    ZERO, OVER      // -- nfa zero nfa
                  ...          
 5364    00000028 .............         DC32    ONEP, CAT       // If wc_ header skip
                  ...          
 5365    00000030 ........0D000         DC32    LIT, 0x0D       // -- nfa zero (c@) 0x0D
                  000          
 5366    00000038 .............         DC32    EQUAL, ZEQU     // -- nfa zerro flag
                  ...          
 5367    00000040 ........              DC32    ZBRAN           // -- nfa zero
 5368    00000044 1C000000              DC32     WORDS2-.       // wc_ goto
 5369                                   
 5370    00000048 ........              DC32    DROP            // -- nfa
 5371    0000004C .............         DC32    DUP, PFA, LFA   // -- nfa lfa
                  ...........  
 5372    00000058 .............         DC32    OVER, SUBB      // -- nfa (lfa - nfa)
                  ...          
 5373                           
 5374                           WORDS2: // -- nfa n
 5375                           
 5376    00000060 .............         DC32    OUT_SV, AT      // Use OUT to regulate line length.
                  ...          
 5377    00000068 ........              DC32    PLUS
 5378    0000006C ........4A000         DC32    LIT, 74         // was :NONAME CSLL - WORDS line length constant.
                  000          
 5379    00000074 ........              DC32    GREATERTHAN
 5380    00000078 ........              DC32    ZBRAN           // If not at end of line
 5381    0000007C 10000000              DC32     WORD21-.        // skip cr and out reset
 5382                           
 5383    00000080 ........              DC32    CR              // Start another line
 5384    00000084 .............         DC32    THREE, SPACES
                  ...          
 5385                           
 5386                           WORD21:
 5387                           #ifdef  IO2TP
 5390                           #endif
 5391                           // For MYWORDS test FENCE and stop if less
 5392    0000008C ........              DC32    DUP             // nfa
 5393    00000090 .............         DC32    FENCE_SV, AT
                  ...          
 5394    00000098 ........              DC32    LESSTHAN
 5395    0000009C ........              DC32    ZBRAN
 5396    000000A0 0C000000              DC32     WORDSCONT-.
 5397                           
 5398    000000A4 ........              DC32    BRAN
 5399    000000A8 54000000              DC32     WORDSDONE-.
 5400                           
 5401                           WORDSCONT:
 5402    000000AC ........              DC32    DUP             // nfa
 5403    000000B0 ........              DC32    IDDOT
 5404    000000B4 .............         DC32    TWO, SPACES
                  ...          
 5405                           
 5406    000000BC .............         DC32    DUP, ONEP, CAT  // Take nfa and look for WORDCAT signature
                  ...........  
 5407    000000C8 ........0D000         DC32    LIT, 0x0D       // which is cr
                  000          
 5408    000000D0 ........              DC32    EQUAL
 5409    000000D4 ........              DC32    ZBRAN           // If not wordcat
 5410    000000D8 08000000              DC32     NOT_WC-.       // skip
 5411                           
 5412    000000DC ........              DC32    zero_OUT
 5413                           
 5414                           NOT_WC:
 5415    000000E0 ........              DC32    PFA             // \ nfa -- pfa
 5416    000000E4 ........              DC32    LFA             // \ pfa -- lfa
 5417    000000E8 ........              DC32    AT              // Is next lfa
 5418    000000EC ........              DC32    DUP
 5419    000000F0 ........              DC32    ZEQU            // Zero = end of dictionary
 5420                           
 5421                           // REMOVED SO WORDS AND MYWORDS CAN BE USED IN DOWNLOAD FILES
 5422                           //      DC32    QKEY           // Zero or break key \ ^C = 0x03
 5423                           //      DC32    OR
 5424                           
 5425    000000F4 ........              DC32    ZBRAN           // Until break key or end of dictionary
 5426    000000F8 28FFFFFF              DC32     WORDS1-.
 5427                           
 5428                           #ifdef  IO2TP
 5431                           #endif
 5432                           WORDSDONE:
 5433    000000FC .............         DC32    DROP, CR
                  ...          
 5434    00000104 ........              DC32    SEMIS
 5435                           
 5436                           
 5437                           //      MYWORDS MYWORDS: ( -- )
 5438                           //      Print only system defined words by manipulating FENCE.
 5439                           
 5440                            SECTION .text : CONST (2)
 5441                           MYWORDS_NFA:
 5442    00000000 87                    DC8     0x87
 5443    00000001 4D59574F5244          DC8     'MYWORD'
 5444    00000007 D3                    DC8     'S'+0x80
 5445                            ALIGNROM 2,0xFFFFFFFF
 5446    00000008 ........              DC32    WORDS_NFA
 5447                           MYWORDS:
 5448    0000000C ........              DC32    DOCOL
 5449    00000010 ........00000         DC32    strva , FLASH_SPAGE, FENCE
                  208........  
 5450    0000001C ........              DC32    WORDS                   // now print words in ram
 5451    00000020 ........00000         DC32    strva, 0 , FENCE
                  000........  
 5452    0000002C ........              DC32    SEMIS
 5453                           
 5454                           
 5455                           //      FISH_ONLY FISH_ONLY     ( -- ) MODIFIED:
 5456                           //      RESET DP, UP AND CURRENT TO ORIGINAL FLASH IMAGE
 5457                           
 5458                            SECTION .text : CONST (2)
 5459                           FISH_ONLY_NFA:
 5460    00000000 89                    DC8     0x80+9
 5461    00000001 464953485F4F4         DC8     'FISH_ONL'
                  E4C          
 5462    00000009 D9                    DC8     'Y'+0x80
 5463    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 5464    0000000C ........              DC32    MYWORDS_NFA
 5465                           FISH_ONLY:
 5466    00000010 ........              DC32    .+5
 5467                            SECTION .text : CODE (2)
 5468                           //      LDR     n, = TASK_NFA           // preserve TOS
 5469                           #ifdef FISH_PubRel_WORDSET
 5470    00000000 0949                  LDR     n, = WC_FISH_PubRel_NFA
 5471                           #endif
 5472                           #ifdef FISH_STM32M407vg_PRO_WORDCAT
 5474                           #endif
 5475    00000002 0A4C                  LDR     y, = CURRENT            // CURRENT SETTING
 5476    00000004 2160                  STR     n, [y]
 5477    00000006 0A4C                  LDR     y, = FPC                // FLASH CURRENT
 5478    00000008 2160                  STR     n, [y]
 5479    0000000A 0A49                  LDR     n, = RAMVARSPACE_START
 5480    0000000C 0A4C                  LDR     y, = UP                 // UP SETTING
 5481    0000000E 2160                  STR     n, [y]
 5482    00000010 0A4C                  LDR     y, = FPSV                // FLASH USER VARS
 5483    00000012 2160                  STR     n, [y]
 5484    00000014 0A49                  LDR     n, = ORIG
 5485    00000016 0B4C                  LDR     y, = DP                 // DP SETTING
 5486    00000018 2160                  STR     n, [y]
 5487                                   NEXT
 5487.1                         // ARMv7-M Thumb = .+5
 5487.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5487.3                         // ARMv6-M Thumb = .+4
 5487.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5487                                   NEXT1
 5487.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5487.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5487.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5487.4                         // ARMv6-M Thumb = .+4
 5487.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5487.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5487.7                                 ENDM
 5487.8                                 ENDM
 5488                            LTORG
 5488.1                                  TABLE
 5488.2  00000028 ........              Reference on line 5470
 5488.3  0000002C ........              Reference on line 5475
 5488.4  00000030 ........              Reference on line 5477
 5488.5  00000034 ........              Reference on line 5479
 5488.6  00000038 ........              Reference on line 5480
 5488.7  0000003C ........              Reference on line 5482
 5488.8  00000040 ........              Reference on line 5484
 5488.9  00000044 ........              Reference on line 5485
 5489                           
 5490                           
 5491                           //      FISH FISH:      ( -- )
 5492                           //      Print Flash Status and FISH Signon Message.
 5493                           
 5494                           
 5495                            SECTION .text : CONST (2)
 5496                           FISH_NFA:
 5497    00000000 84                    DC8     0x84
 5498    00000001 464953                DC8     'FIS'
 5499    00000004 C8                    DC8     'H'+0x80
 5500    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5501    00000008 ........              DC32    FISH_ONLY_NFA
 5502                           FISH:
 5503    0000000C ........              DC32    DOCOL
 5504    00000010 ........              DC32    FLASH_SCAN
 5505    00000014 ........              DC32    SIGNON
 5506    00000018 ........              DC32    SEMIS
 5507                           
 5508                           //=============================== WORDCAT ====================================//
 5509                           //NOEXEC HEADERFORWORDCATEGORIES
 5510                           //      WC_FISH_PubRel: = FISH Reference Model: CATEGORY
 5511                            SECTION .text : CONST (2)
 5512                           WC_FISH_PubRel_NFA:
 5513    00000000 99                    DC8     0x80+4+21
 5514    00000001 0D0A                  DC8     0x0D, 0x0A
 5515    00000003 4649534820526         DC8     'FISH Reference Model:'
                  5666572656E63
                  65204D6F64656
                  C3A          
 5516    00000018 0D8A                  DC8     0x0D, 0x0A+0x80
 5517    0000001A FFFF           ALIGNROM 2,0xFFFFFFFF
 5518    0000001C ........              DC32    FISH_NFA
 5519                           
 5520                           ;**** FIRST WORD LISTED****
 5521                           
 5522                           //=============================== WORDCAT ====================================//
 5523                           
 5524                           #ifdef FISH_STM_M3_PRO_WORDCAT
 5526                           #endif
 5527                           // FIRST WORDCAT
 5528                           
 5529                           //------------------------------------------------------------------------------
 5530                           // FOR MULTI TASKING MUST BE PLACED IN RAM AND OFFSET USED IN SYSTEM VARS!!!!!!
 5531                           //            T A S K 
 5532                           //
 5533                           ;.data          // Place TASK at beginning of RAM, or not.
 5534                           /*
 5535                            SECTION .text : CONST (2)
 5536                           TASK_NFA:
 5537                                   DC8     0x84
 5538                                   DC8     'TAS'
 5539                                   DC8     'K'+0x80
 5540                            ALIGNROM 2,0xFFFFFFFF
 5541                           //      TASK Is top of dictionary until new definitionsa added
 5542                           //      PATCH CONTEXT or LATEST else LFA in TASK FROM SYM TABLE
 5543                           //      To debug dictionary searches - see - PFIND & DFIND
 5544                           //      DC32    ZEQU_NFA        // 4 (no match) bombing at +
 5545                           //      DC32    NOOP_NFA        // Patch here to shorten test of PFIND
 5546                           //      DC32    CAT_NFA         // C@ before @
 5547                           //      DC32    LESS_NFA        // < before =
 5548                           //       DC32   SoCinit_NFA     //XON_NFA               // FULL DICT SEARCH
 5549                                   DC32    MS_NFA
 5550                           TASK:
 5551                                   DC32    DOCOL
 5552                                   DC32    SEMIS
 5553                           */
 5554                           
 5555                           //------------------------------------------------------------------------------
 5556                           //:NONAME SECTION:
 5557                           // THESE STAY HERE (INSTEAD OF SLLIB) BECAUSE THEY ARE CONDITIONALLY INCLUDED
 5558                           // HI-LEVEL THEM ASM SECTIONS
 5559                           #ifdef IO2TP
 5568                           #endif
 5569                           
 5570                           #ifdef IO2TP
 5579                           #endif
 5580                           
 5581                           #ifdef USE_CMAIN
 5591                           #endif
 5592                           
 5593                           #ifdef TESTRAM
 5699                           #endif  // TESTRAM
 5700                           //------------------------------------------------------------------------------
 5701                           // Placing blocks that can change at end of link map
 5702                           // Place :NONAME for static Library first in FISH_STM_M3_SLIB.s
 5703                           
 5704                           // $PROJ_DIR$\..\FISH_RM_COMMON
 5705                           // $PROJ_DIR$\..\FISH_RM_CORTEX_M_COMMON_CODE
 5706                           // In Assembler preprocessor set additional include directories 
 5707                           $FISH_RM_MSGS.h
 5708                           // equals below
 5709                           //#include ".\..\FISH_COMMON_CODE\FISH_RM_MSGS.h"
 5710                           
 5711                           // SYSTEMCLOCK #define set in FISH_M0_EQUATES.s for SYSCLOCK value.
 5712                           // THIS IS A :NONAME WORDSET
 5713                           
 5714                           $FISH_STM32F4_SOC_INIT.s
 5715                           
 5716                            END
##############################
#           CRC:0            #
#        Errors:   0         #
#        Warnings: 0         #
#        Bytes: 83983        #
##############################




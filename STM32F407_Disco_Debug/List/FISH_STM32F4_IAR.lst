###################################################################################################
#                                                                                                 #
#     IAR Assembler V8.22.1.15669/W32 for ARM 22/Apr/2018  12:13:24                               #
#     Copyright 1999-2018 IAR Systems AB.                                                         #
#                                                                                                 #
#           Source file   =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\FISH_STM32F4_IAR.s   #
#           List file     =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\List\FISH_STM32F4_IAR.lst#
#           Object file   =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\Obj\FISH_STM32F4_IAR.o#
#           Command line  =  -f C:\Users\CLYDEW~1\AppData\Local\Temp\EW8841.tmp                   #
#                            (C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\FISH_STM32F4_IAR.s  #
#                            -OC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\Obj #
#                            -s+ -M<> -w+ -r -DFISH_PubRel_WORDSET -DFISH_Debug_WORDSET           #
#                            -DSTM32F4_XRC08_168MHZ                                               #
#                            -LC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\List #
#                            -t8 --cpu Cortex-M4 --fpu VFPv4_sp                                   #
#                            -IC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\..\FISH_Libs\FISH_RM_COMMON\ #
#                            -IC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\..\FISH_Libs\FISH_RM_COMMON_CODE_CORTEX_M\) #
#                                                                                                 #
###################################################################################################

    1                           // FISH_STM32F4_IAR.s - FULL WORD v1.7.2
    2                           // FISH FOR THE STM IS CURRENTLY SUPPORTING F2 TO F4
    3                           // Code is common, seperate linker files used for memory map differences.
    4                           $FISH_STM32F4_MAIN_INCLUDES.h
    5                           //------------------------------------------------------------------------------
    6                           
    7                           // 2DO: Add VIO_UARTX, VIO_KEY, VIO_?KEY and VIO_EMIT
    8                           // (EMIT), (KEY?), and (KEY).
    9                           
   10                           // v1.8 4th tos/nos caching
   11                           
   12                           // v1.7.2 Fixed backspace issue
   13                           
   14                           // v1.7.1:
   15                           
   16                           // Fix NUMBER by merge with NXP which works correctly!
   17                           // 2DO: Restore SYSTICK ISR to ASM version
   18                           // 2DO: Signon updated. (FOR TEST - FIX B4 SHIP)
   19                           // 2DO: Updated .hex .out and sym.bat
   20                           
   21                           // #define EOL_DLE // DLE 0x10/16d in QUIT>CR after last word interpreted.
   22                           // #define EOL_NAK // NAK 0x15/21d in error messages for STDLED editor highlight
   23                           // The EOL_NAK makes SPACE NAK end of string in FISH_RM_MSGS.h
   24                           
   25                           // Split out files to FISH_RM_COMMON and FISH_RM_COMMON_CODE_CORTEX_M
   26                           
   27                           // ADDED EHON and EHOFF to FISH RM
   28                           // Changes iar.s COLD, ERROR and ABORT
   29                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM:
   30                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - ERROR_HALT: SV 
   31                           
   32                           // ADDED P(PROMPT), PON(PROMPTON) and POFF(PROMPTOFF) to FISH RM
   33                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM: & QUIT:
   34                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - PROMPT: SV 
   35                           
   36                           // Added #define TRUE_EQU_NEG_ONE
   37                           // Changed all user visible true flags to -1
   38                           
   39                           // Added SXTB Rd, Rm  and SXTH Rd, Rm
   40                           
   41                           // Number Stuff Wordcat reorganized (search NOEXEC or WC_NUMBERS_NFA)
   42                           // EXPECT does counted null strings:
   43                           // NUMBER to look for null terminatiion instead of BLANK.
   44                           // WORD changed to expect null string and elimated BLANKS fill of HERE.
   45                           //      SPEEDS UP TOKENIZATION OF TIB INPUT!
   46                           // ALL IN AND IN_SV INIT SET TO 1 in QUERY SV_INIT_VALUES CLRTIB
   47                           // NUMBERSUFFIX changed to replace suffix with null
   48                           // PAREN ( changed to use TIB+1
   49                           // DPL restored to dictionairy.
   50                           
   51                           //------------------------------------------------------------------------------
   52                            SECTION .text : CONST (2)
   53                           msg_FISH:
   54                           // DC8 "?" IS A NULL TERMINATED STRING
   55                           // DC8 '?' IS NOT
   56                           //#if FISH_PubRel_WORDSET | FISH_DebugSrc_WORDSET
   57    00000000 4649534820415         DC8     'FISH ARM '
                  24D20        
   58                           //#endif
   59                           #if FISH_PubRel_WORDSET & FISH_Debug_WORDSET
   60    00000009 20313031302C3         DC8     ' 1010,1100 - EHON/EHOFF '
                  1313030202D20
                  45484F4E2F454
                  84F464620    
   61                           //        DC8     '-1 True Flag '
   62                           #endif
   63                           #if VTOR_PATCH & STM32F205RC
   65                           #endif
   66                           #ifdef FISH_Debug_WORDSET
   67    00000021 4465627567537         DC8     'DebugSrc '
                  26320        
   68                           #endif
   69                           #ifdef  STM32F4_XRC08_168MHZ
   70    0000002A 53544D3332463         DC8     'STM32F407VG DISCO @168Mhz '
                  4303756472044
                  4953434F20403
                  136384D687A20
   71                           #endif
   72                           #ifdef STM32F205RC_XRC10_118MHZ
   74                           #endif
   75                           #ifdef FISH_PRO_WORDCAT
   77                           #endif
   78    00000044 524D2056312E3         DC8     'RM V1.7.2 (C)2014-2018 A-TEAM FORTH : '
                  72E3220284329
                  323031342D323
                  0313820412D54
                  45414D20464F5
                  25448203A20  
   79    0000006A 4170722032322         DC8     __DATE__        // Null string
                  03230313800  
   80                           msg_FISH_TIMESTAMP:
   81    00000076 20617420              DC8     ' at '
   82    0000007A 31323A31333A3         DC8     __TIME__        // Null string
                  23400        
   83                           #ifdef EOL_NAK
   84                           msg_SIGNON_DLE:
   85    00000083 1500                  DC8     0x15, 0
   86                           #endif
   87                           msg_MY_OK:
   88    00000085 206F6B2C20676         DC8     " ok, go fish in BASE "
                  F206669736820
                  696E204241534
                  52000        
   89                           //-----------------START OF DICTIONARY = Last word in search--------------------
   90                           // Conditionally include FISH_STM32F4_Peripheral_Register_ADDRS.h include here
   91                           #ifdef FISH_STM32F4_Peripheral_Register_ADDRS
   92                           $FISH_STM32F4_Peripheral_Register_ADDRS.h
   93                           // If included link below will point to the GPIO WORDCAT
   94                           #endif
   95                           // 
   96                           //      NOOP NOOP:      ( -- )
   97                            SECTION .text : CONST (2)
   98                           NOOP_NFA:
   99    00000000 84                    DC8     0x84
  100    00000001 4E4F4F                DC8     'NOO'
  101    00000004 D0                    DC8     'P'+0x80
  102    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  103                           #ifdef FISH_STM32F4_Peripheral_Register_ADDRS
  104    00000008 ........              DC32    WC_FISH_Peripheral_REG_ADDR_GPIO
  105                           #else
  107                           #endif
  108                           NOOP:
  109    0000000C ........              DC32    .+5
  110                            SECTION .text : CODE (2)
  111                                   NEXT
  111.1                         // ARMv7-M Thumb = .+5
  111.2  00000000 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  111.3                         // ARMv6-M Thumb = .+4
  111.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  111                                   NEXT1
  111.1  00000004 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  111.2  00000008 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  111.3  0000000C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  111.4                         // ARMv6-M Thumb = .+4
  111.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  111.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  111.7                                 ENDM
  111.8                                 ENDM
  112                           
  113                           
  114                           //      EXECUTE EXEC:   ( cfa -- ) RENAMED: EXECUTE to EXEC
  115                           //      Execute a single word whose cfa is on the stack
  116                           
  117                            SECTION .text : CONST (2)
  118                           EXEC_NFA:
  119    00000000 87                    DC8     0x87
  120    00000001 455845435554          DC8     'EXECUT'
  121    00000007 C5                    DC8     'E'+0x80
  122                            ALIGNROM 2,0xFFFFFFFF
  123    00000008 ........              DC32    NOOP_NFA
  124                           EXEC:
  125    0000000C ........              DC32    .+5
  126                            SECTION .text : CODE (2)
  127                           #ifndef IO2TP
  128                           #ifdef XON_XOFF
  129    00000000 ........              BL      TXRDY_SUBR
  130    00000004 ........              BL      XOFF_SUBR
  131                           #endif
  132                           #endif
  133                           EXEC_ACTION:
  134                                   POPp2w // as in xeq token at ToS setup for exec LDM     p!, {w}
  134.1                                 // as in xeq token on ToS setup for exec
  134.2  00000008 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
  134.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
  134.4                                 ENDM
  135                                   NEXT1
  135.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  135.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  135.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  135.4                         // ARMv6-M Thumb = .+4
  135.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  135.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  135.7                                 ENDM
  136                           
  137                           #ifndef IO2TP
  138                           // TXRDY_SUBR:
  139                            SECTION .text : CODE (2)
  140                           TXRDY_SUBR:
  141    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  142    00000002 024C                  LDR     y, = USART3_SR  // Line Status Register
  143                           txRDY?:
  144    00000004 2168                  LDR     n, [y]          // Get Line Status
  145                           // THIS IS TXE TEST AND FAILS IN TEXT DOWNLOAD
  146                           //        LSRS    n, n, #7      // 80h Bit 7 TXE: Transmit data register empty
  147                           // THIS IS ___ AND WORKS IN TEXT DOWNLOAD
  148    00000006 090A                  LSRS    n, n, #8        // 100h Bit 8 ORIG
  149    00000008 FCD3                  BCC     txRDY?          // Ready
  150    0000000A 1047                  BX      w               // lr  - SUBR RETURN
  151                           
  152                           // XOFF_SUBR:
  153                           #ifdef XON_XOFF
  153.1                                  TABLE
  153.2  0000000C 00480040              Reference on line 142
  154                            SECTION .text : CODE (2)
  155                           XOFF_SUBR:
  156    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  157    00000002 0249                  LDR     n,= USART3_DR
  158    00000004 1324                  LDR     y,  = XOFF_CHAR
  159    00000006 0C70                  STRB    y, [n]
  160    00000008 1047                  BX      w               // lr  - SUBR RETURN
  161                           #endif // XON_XOFF
  162                           
  163                           // XON_SUBR:
  164                           #ifdef XON_XOFF
  164.1                                  TABLE
  164.2  0000000C 04480040              Reference on line 157
  165                            SECTION .text : CODE (2)
  166                           XON_SUBR:
  167    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  168    00000002 0249                  LDR     n,= USART3_DR
  169    00000004 1124                  LDR     y, = XON_CHAR   // preserve TOS 11 24 01 49
  170    00000006 0C70                  STRB    y, [n]
  171    00000008 1047                  BX      w       //lr              // SUBR RETURN
  172                           #endif // XON_XOFF
  173                           #endif // IO2TP
  174    0000000A 0000           LTORG
  174.1                                  TABLE
  174.2  0000000C 04480040              Reference on line 168
  175                           
  176                           //      BL BLANK:       ( -- n )
  177                           //      Push ascii space character as n to TOS.
  178                           
  179                            SECTION .text : CONST (2)
  180                           BLANK_NFA:
  181    00000000 82                    DC8     0x82
  182    00000001 42                    DC8     'B'
  183    00000002 CC                    DC8     'L'+0x80
  184    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  185    00000004 ........              DC32    EXEC_NFA
  186                           BLANK:
  187    00000008 ........20000         DC32    DOCON, 0x20
                  000          
  188                           
  189                           
  190                           //========================= START SYSTEM VARIABLES ===========================//
  191                           // _SV IS cfa label of WORD's that return their address.
  192                           // MODIFIED ALL to be label based vs. offset based.
  193                           
  194                           
  195                           //      UP UP_SV:       ( -- addr of UP ) Value stored here is ALIGNED
  196                           //      A system variable, the RAM VAR pointer, which contains
  197                           //      the address of the next free memory above in the USERRAMSPACE.
  198                           //      The value may be read by .UV and altered by VAR.
  199                           
  200                            SECTION .text : CONST (2)
  201                           UP_NFA:
  202    00000000 82                    DC8     0x82
  203    00000001 55                    DC8     'U'
  204    00000002 D0                    DC8     'P'+0x80
  205    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  206    00000004 ........              DC32    BLANK_NFA
  207                           UP_SV:
  208    00000008 .............         DC32    DOCON, UP
                  ...          
  209                           
  210                           
  211                           //      FENCE FENCE_SV: ( -- addr of FENCE )
  212                           //      A system variable containing an address below which FORGET ting is
  213                           //      trapped. To forget below this point the system must alter the contents
  214                           //      of FENCE.
  215                           
  216                            SECTION .text : CONST (2)
  217                           FENCE_NFA:
  218    00000000 85                    DC8     0x85
  219    00000001 46454E43              DC8     'FENC'
  220    00000005 C5                    DC8     'E'+0x80
  221    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  222    00000008 ........              DC32    UP_NFA
  223                           FENCE_SV:
  224    0000000C .............         DC32    DOCON, FENCE
                  ...          
  225                           
  226                           
  227                           //      DP DP_SV:       ( -- addr of DP ) Value stored here is ALIGNED
  228                           //      A system variable, the dictionary pointer, which contains the address
  229                           //      of the next free memory above the dictionary. The value may be read
  230                           //      by HERE and altered by COMMA (ALIGNED) , ALLOT and CALLOT (UNALIGNED) .
  231                           
  232                            SECTION .text : CONST (2)
  233                           DP_NFA:
  234    00000000 82                    DC8     0x82
  235    00000001 44                    DC8     'D'
  236    00000002 D0                    DC8     'P'+0x80
  237    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  238    00000004 ........              DC32    FENCE_NFA
  239                           DP_SV:
  240    00000008 .............         DC32    DOCON, DP
                  ...          
  241                           
  242                           
  243                           //      BASE BASE_SV:   ( -- addr of NBASE )
  244                           //      A system variable containing the current number base used for input
  245                           //      and output conversion.
  246                           
  247                            SECTION .text : CONST (2)
  248                           BASE_NFA:
  249    00000000 84                    DC8     0x84
  250    00000001 424153                DC8     'BAS'
  251    00000004 C5                    DC8     'E'+0x80
  252    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  253    00000008 ........              DC32    DP_NFA
  254                           BASE_SV:
  255    0000000C .............         DC32    DOCON, NBASE
                  ...          
  256                           
  257                           
  258                           //      CURRENT CURRENT_SV:     ( -- addr of CURRENT )
  259                           //      CURRENT searched everytime. CONTEXT is not used
  260                           //      Used by Create, Definitions, etc and by Latest
  261                           //      to leave the nfa of the topmost word in the CURRENT
  262                           //      vocabulary.  See LATEST NOTE:(FIG) CURR @ @ this CURR @
  263                           
  264                            SECTION .text : CONST (2)
  265                           CURRENT_NFA:
  266    00000000 87                    DC8     0x87
  267    00000001 43555252454E          DC8     'CURREN'
  268    00000007 D4                    DC8     'T'+0x80
  269                            ALIGNROM 2,0xFFFFFFFF
  270    00000008 ........              DC32    BASE_NFA
  271                           CURRENT_SV:
  272    0000000C .............         DC32    DOCON, CURRENT  // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
                  ...          
  273                           
  274                           
  275                           //      STATE STATE_SV: ( -- addr of CSTATE )
  276                           //      A system variable containing the compilation state. A non-zero value
  277                           //      indicates compilation. The value itself may be implementation
  278                           //      dependent. 0xC0 must be used for INTERPRET to execute IMMEDIATE words.
  279                           
  280                            SECTION .text : CONST (2)
  281                           STATE_NFA:
  282    00000000 85                    DC8     0x85
  283    00000001 53544154              DC8     'STAT'
  284    00000005 C5                    DC8     'E'+0x80
  285    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  286    00000008 ........              DC32    CURRENT_NFA
  287                           STATE_SV:
  288    0000000C .............         DC32    DOCON, CSTATE       //Compile STATE
                  ...          
  289                           
  290                           
  291                           //      OUT OUT_SV:     ( -- addr of OUT )
  292                           //      A system variable that contains a value incremented by EMIT. The system
  293                           //      may alter and examine OUT to control display formating.
  294                           
  295                            SECTION .text : CONST (2)
  296                           OUT_NFA:
  297    00000000 83                    DC8     0x83
  298    00000001 4F55                  DC8     'OU'
  299    00000003 D4                    DC8     'T'+0x80
  300                            ALIGNROM 2,0xFFFFFFFF
  301    00000004 ........              DC32    STATE_NFA
  302                           OUT_SV:
  303    00000008 .............         DC32    DOCON, OUT
                  ...          
  304                           
  305                           
  306                           //      IN IN_SV:       ( -- addr of IN )
  307                           //      A system variable containing the byte offset within (TIB),
  308                           //      from which the tokens are parsed by WORD and moved to HERE,
  309                           //      as a counted null terminated string (created by EXPECT).
  310                           //      Initialized to 1 to skip count byte produced by EXPECT.
  311                           
  312                            SECTION .text : CONST (2)
  313                           IN_NFA:
  314    00000000 82                    DC8     0x82
  315    00000001 49                    DC8     'I'
  316    00000002 CE                    DC8     'N'+0x80
  317    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  318    00000004 ........              DC32    OUT_NFA
  319                           IN_SV:
  320    00000008 .............          DC32   DOCON, IN
                  ...          
  321                           
  322                           
  323                           //      PAD PAD_SV:     ( -- addr of PAD )
  324                           //      Leave the address of the text output buffer PAD on the stack.
  325                           //      Typically at least 82 bytes long.
  326                           
  327                            SECTION .text : CONST (2)
  328                           PAD_NFA:
  329    00000000 83                    DC8     0x83
  330    00000001 5041                  DC8     'PA'
  331    00000003 C4                    DC8     'D'+0x80
  332                            ALIGNROM 2,0xFFFFFFFF
  333    00000004 ........              DC32    IN_NFA
  334                           PAD_SV:
  335    00000008 .............         DC32    DOCON, PAD
                  ...          
  336                           
  337                           
  338                           //      TIB TIB_SV:     ( -- addr of INITTIB )
  339                           //      Leave the address of the text input buffer TIB on the stack.
  340                           //      Typically at least 82 bytes long.
  341                           
  342                            SECTION .text : CONST (2)
  343                           TIB_NFA:
  344    00000000 83                    DC8     0x83
  345    00000001 5449                  DC8     'TI'
  346    00000003 C2                    DC8     'B'+0x80
  347                            ALIGNROM 2,0xFFFFFFFF
  348    00000004 ........              DC32    PAD_NFA
  349                           TIB_SV:
  350    00000008 .............         DC32    DOCON, TIB
                  ...          
  351                           
  352                           
  353                           //======================== END SYSTEM VARIABLES ==============================//
  354                           
  355                           
  356                           //      HERE HERE:      ( -- addr ) Value stored here is ALIGNED
  357                           //      Leave the address of the next available dictionary location.
  358                           
  359                            SECTION .text : CONST (2)
  360                           HERE_NFA:
  361    00000000 84                    DC8     0x84
  362    00000001 484552                DC8     'HER'
  363    00000004 C5                    DC8     'E'+0x80
  364    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  365    00000008 ........              DC32    TIB_NFA
  366                           HERE:
  367    0000000C ........              DC32    DOCOL
  368    00000010 ........              DC32    DP_SV
  369    00000014 ........              DC32    AT
  370    00000018 ........              DC32    SEMIS
  371                           
  372                           
  373                           //      ALLOT ALLOT:    ( sn -- ) Warning: UNALIGNED:
  374                           //      IF DICTIONAIRY FULL PRINT error MESSAGE AND abort.
  375                           //      Add the signed number to the dictionary pointer DP. May be used to
  376                           //      reserve dictionary space or re-origin memory.
  377                           //      CAUTION!
  378                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  379                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  380                           
  381                            SECTION .text : CONST (2)
  382                           ALLOT_NFA:
  383    00000000 85                    DC8     0x85
  384    00000001 414C4C4F              DC8     'ALLO'
  385    00000005 D4                    DC8     'T'+0x80
  386    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  387    00000008 ........              DC32    HERE_NFA
  388                           ALLOT:
  389    0000000C ........              DC32    DOCOL
  390    00000010 ........              DC32    DICTSPACE       // \ -- n
  391    00000014 .............         DC32    OVER, SUBB
                  ...          
  392    0000001C ........              DC32    ZLESS
  393    00000020 ........              DC32    ZBRAN
  394    00000024 08000000              DC32    ALLOTOK-.
  395                           
  396    00000028 ........              DC32    DICTFULL_ABORT
  397                           
  398                           ALLOTOK:
  399    0000002C ........              DC32    DP_SV
  400    00000030 ........              DC32    PSTORE
  401    00000034 ........              DC32    SEMIS
  402                           
  403                           
  404                           //      ALIGNED ALIGNED:        ( addr -- a-addr ) DPANS94
  405                           
  406                            SECTION .text : CONST (2)
  407                           ALIGNED_NFA:
  408    00000000 87                    DC8     0x87
  409    00000001 414C49474E45          DC8     'ALIGNE'
  410    00000007 C4                    DC8     'D'+0x80
  411                            ALIGNROM 2,0xFFFFFFFF
  412    00000008 ........              DC32    ALLOT_NFA
  413                           ALIGNED:
  414    0000000C ........              DC32    .+5
  415                            SECTION .text : CODE (2)
  416                                   POP2t
  416.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  416.2                         //#ifndef TOSCT
  416.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  416.4                         //#endif
  416.5                         //      ADDS    p, p, #4
  416.6                                 ENDM
  417    00000004 C01C                  ADDS    t, t, #3
  418    00000006 0549                  LDR     n, =-4
  419    00000008 0840                  ANDS    t, t, n
  420                                   TPUSH
  420                                   PUSHt   // push t to p, pre decrement p
  420.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  420.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  420.3                         //      STR     t, [p]
  420.4                                 ENDM
  420                                   NEXT
  420.1                         // ARMv7-M Thumb = .+5
  420.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  420.3                         // ARMv6-M Thumb = .+4
  420.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  420                                   NEXT1
  420.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  420.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  420.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  420.4                         // ARMv6-M Thumb = .+4
  420.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  420.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  420.7                                 ENDM
  420.8                                 ENDM
  420.9                                 ENDM
  421                            LTORG
  421.1                                  TABLE
  421.2  0000001C FCFFFFFF              Reference on line 418
  422                           
  423                           
  424                           //      ALIGN32_DP_FF_PAD ALIGN:        ( -- ) DPANS94
  425                           //      Align DP_SV primitive. Pads current DP with 0xFF until aligned.
  426                           //      USED IN , (COMMA:) .  Reflected by HERE .
  427                           //      CAUTION! USE AFTER ALLOT or C, (CCOMMA:) .
  428                           //      See , (COMMA:) which is ALIGNED.
  429                           
  430                            SECTION .text : CONST (2)
  431                           ALIGN_NFA:
  432    00000000 85                    DC8     0x85
  433    00000001 414C4947              DC8     'ALIG'
  434    00000005 CE                    DC8     'N'+0x80
  435    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  436    00000008 ........              DC32    ALIGNED_NFA
  437                           ALIGN:
  438                           ALIGN32_DP_FF_PAD:
  439    0000000C ........              DC32    DOCOL
  440    00000010 ........              DC32    HERE
  441                                   // COULD ADD CODE TO SEE IF ALIGNED ALREADY
  442    00000014 .............         DC32    THREE, PLUS             // 3PLUS
                  ...          
  443    0000001C .............         DC32    DUP, TOR
                  ...          
  444    00000024 ........              DC32    HERE
  445    00000028 ........              DC32    XDO
  446                           ALIGN_PAD_DO:
  447    0000002C ........FF000         DC32    LIT, 0xFF, I, CSTORE
                  000..........
                  ......       
  448    0000003C ........              DC32    XLOOP
  449    00000040 ECFFFFFF              DC32    ALIGN_PAD_DO-.
  450                           
  451    00000044 ........              DC32    RFROM
  452    00000048 ........FCFFF         DC32    LIT, 0xFFFFFFFC // -4
                  FFF          
  453    00000050 ........              DC32    ANDD
  454    00000054 .............         DC32    DP_SV, STORE
                  ...          
  455    0000005C ........              DC32    SEMIS
  456                           
  457                           
  458                           //      , COMMA:        ( n -- ) ALIGNED
  459                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  460                           //      Write n into next ALIGNED dictionary memory cell, DP reflected by HERE
  461                           
  462                            SECTION .text : CONST (2)
  463                           COMMA_NFA:
  464    00000000 81                    DC8     0x81
  465    00000001 AC                    DC8     ','+0x80
  466    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  467    00000004 ........              DC32    ALIGN_NFA
  468                           COMMA:
  469    00000008 ........              DC32    DOCOL
  470    0000000C ........              DC32    DICTSPACE       // \ -- n
  471    00000010 ........              DC32    ZLESS
  472    00000014 ........              DC32    ZBRAN
  473    00000018 08000000              DC32    COMMA_OK-.
  474                           
  475    0000001C ........              DC32    DICTFULL_ABORT
  476                           
  477                           COMMA_OK:
  478    00000020 ........              DC32    COMMA_PRIM
  479    00000024 ........              DC32    SEMIS
  480                           
  481                           
  482                           //      C, CCOMMA:      ( n -- ) Warning: UNALIGNED:
  483                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  484                           //      Store LS 8 bits of n into the next available dictionary byte, advancing
  485                           //      the dictionary pointer.
  486                           //      CAUTION!
  487                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  488                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  489                           //      See , (COMMA:) which is ALIGNED.
  490                           
  491                            SECTION .text : CONST (2)
  492                           CCOMMA_NFA:
  493    00000000 82                    DC8     0x82
  494    00000001 43                    DC8     'C'
  495    00000002 AC                    DC8     ','+0x80
  496    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  497    00000004 ........              DC32    COMMA_NFA
  498                           CCOMMA:
  499    00000008 ........              DC32    DOCOL
  500    0000000C ........              DC32    DICTSPACE       // \ -- n
  501    00000010 ........              DC32    ZLESS
  502    00000014 ........              DC32    ZBRAN
  503    00000018 08000000              DC32    CCOMMA_OK-.
  504                           
  505    0000001C ........              DC32    DICTFULL_ABORT
  506                           
  507                           CCOMMA_OK:
  508    00000020 ........              DC32    HERE
  509    00000024 ........              DC32    CSTORE
  510    00000028 ........              DC32    ONE
  511    0000002C ........              DC32    ALLOT_PRIM
  512    00000030 ........              DC32    SEMIS
  513                           
  514                           
  515                           //      VARALLOT VARALLOT:      ( n -- addr ) Value stored here is ALIGNED
  516                           //      IF USERVAR SPACE FULL PRINT Error MESSAGE AND Abort.
  517                           //      Add n * 32 bits to the RAMVARSPACE pointer UP.
  518                           //      Used to allocate space in Ram for VAR's and other system data structures
  519                           
  520                            SECTION .text : CONST (2)
  521                           VARALLOT_NFA:
  522    00000000 88                    DC8     0x88
  523    00000001 564152414C4C4         DC8     'VARALLO'
                  F            
  524    00000008 D4                    DC8     'T'+0x80
  525    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  526    0000000C ........              DC32    CCOMMA_NFA
  527                           VARALLOT:
  528    00000010 ........              DC32    DOCOL
  529    00000014 ........              DC32    VARSPACE                // \ -- n
  530    00000018 .............         DC32    FOUR, SLASH, OVER, SUBB
                  .............
                  ......       
  531    00000028 ........              DC32    ZLESS
  532    0000002C ........              DC32    ZBRAN
  533    00000030 18000000              DC32    VALLOT_OK-.
  534                           
  535    00000034 .............         DC32    LIT, msg_uvfull
                  ...          
  536    0000003C .............         DC32    NULLSTRLEN, TYPE
                  ...          
  537                           #ifdef IO2TP
  541                           #endif
  542    00000044 ........              DC32    ABORT
  543                           
  544                           VALLOT_OK:
  545    00000048 .............         DC32    UP_SV, AT       // Address of this allotment
                  ...          
  546    00000050 ........              DC32    SWAP            // n
  547    00000054 .............         DC32    FOUR, STAR      // n = 4 bytes
                  ...          
  548    0000005C ........              DC32    UP_SV
  549    00000060 ........              DC32    PSTORE          // Address of next var available
  550    00000064 ........              DC32    SEMIS
  551                           
  552                           
  553                           //      LATEST LATEST: ( -- nfa )
  554                           //      Initially ADDR OF LAST WORD IN THE DICTIONARY
  555                           //      Leave the nfa of the topmost word in the dictionary.
  556                           
  557                            SECTION .text : CONST (2)
  558                           LATEST_NFA:
  559    00000000 86                    DC8     0x86
  560    00000001 4C41544553            DC8     'LATES'
  561    00000006 D4                    DC8     'T'+0x80
  562    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  563    00000008 ........              DC32    VARALLOT_NFA
  564                           LATEST:
  565    0000000C ........              DC32    DOCOL
  566    00000010 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
  567    00000014 ........              DC32    AT
  568    00000018 ........              DC32    SEMIS
  569                           
  570                           
  571                           //      LFA LFA:        ( pfa -- lfa )
  572                           //      Convert the parameter field address of a dictionary definition to
  573                           //      its link field address.
  574                           
  575                            SECTION .text : CONST (2)
  576                           LFA_NFA:
  577    00000000 83                    DC8     0x83
  578    00000001 4C46                  DC8     'LF'
  579    00000003 C1                    DC8     'A'+0x80
  580                            ALIGNROM 2,0xFFFFFFFF
  581    00000004 ........              DC32    LATEST_NFA
  582                           LFA:
  583    00000008 ........              DC32    .+5
  584                            SECTION .text : CODE (2)
  585                                   POP2t
  585.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  585.2                         //#ifndef TOSCT
  585.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  585.4                         //#endif
  585.5                         //      ADDS    p, p, #4
  585.6                                 ENDM
  586    00000004 0838                  SUBS     t, t, #8
  587                                   TPUSH
  587                                   PUSHt   // push t to p, pre decrement p
  587.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  587.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  587.3                         //      STR     t, [p]
  587.4                                 ENDM
  587                                   NEXT
  587.1                         // ARMv7-M Thumb = .+5
  587.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  587.3                         // ARMv6-M Thumb = .+4
  587.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  587                                   NEXT1
  587.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  587.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  587.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  587.4                         // ARMv6-M Thumb = .+4
  587.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  587.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  587.7                                 ENDM
  587.8                                 ENDM
  587.9                                 ENDM
  588                           
  589                           
  590                           //      CFA CFA:        ( pfa -- cfa )
  591                           //      Convert the parameter field address of a dictionary definition to
  592                           //      its code field address. <if thumb2 execution addr smudged>
  593                           
  594                            SECTION .text : CONST (2)
  595                           CFA_NFA:
  596    00000000 83                    DC8     0x83
  597    00000001 4346                  DC8     'CF'
  598    00000003 C1                    DC8     'A'+0x80
  599                            ALIGNROM 2,0xFFFFFFFF
  600    00000004 ........              DC32    LFA_NFA
  601                           CFA:
  602    00000008 ........              DC32    .+5
  603                            SECTION .text : CODE (2)
  604                                   POP2t
  604.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  604.2                         //#ifndef TOSCT
  604.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  604.4                         //#endif
  604.5                         //      ADDS    p, p, #4
  604.6                                 ENDM
  605    00000004 001F                  SUBS     t, t, #4
  606                                   TPUSH
  606                                   PUSHt   // push t to p, pre decrement p
  606.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  606.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  606.3                         //      STR     t, [p]
  606.4                                 ENDM
  606                                   NEXT
  606.1                         // ARMv7-M Thumb = .+5
  606.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  606.3                         // ARMv6-M Thumb = .+4
  606.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  606                                   NEXT1
  606.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  606.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  606.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  606.4                         // ARMv6-M Thumb = .+4
  606.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  606.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  606.7                                 ENDM
  606.8                                 ENDM
  606.9                                 ENDM
  607                           
  608                           
  609                           //      NFA NFA:        ( pfa -- nfa )
  610                           //      Convert the parameter field address of a definition to its name
  611                           //      field. Modified for nfa alighnment padding
  612                           
  613                            SECTION .text : CONST (2)
  614                           NFA_NFA:
  615    00000000 83                    DC8     0x83
  616    00000001 4E46                  DC8     'NF'
  617    00000003 C1                    DC8     'A'+0x80
  618                            ALIGNROM 2,0xFFFFFFFF
  619    00000004 ........              DC32    CFA_NFA
  620                           NFA:
  621    00000008 ........              DC32    DOCOL
  622    0000000C .............         DC32    EIGHT, SUBB     // Addr OF lfa, DUPED TO TRAVERSE Padding
                  ...          
  623                           
  624                           NFA_ALIGN_BEGIN:
  625    00000014 .............         DC32    ONE, SUBB       // ADDR 1 BEFORE lfa, eliminate padding
                  ...          
  626    0000001C .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  627    00000024 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  628    00000030 ........              DC32    ZBRAN           // UNTIL
  629    00000034 E0FFFFFF              DC32    NFA_ALIGN_BEGIN-.
  630                                       
  631    00000038 ........FFFFF         DC32    LIT,-1          // DIRECTION FOR TRAVERSE = Toward nfa
                  FFF          
  632    00000040 ........              DC32    TRAVERSE                // \ -- addr2
  633    00000044 ........              DC32    SEMIS
  634                           
  635                           
  636                           //      PFA PFA:        ( nfa -- pfa )
  637                           //      Convert the name field address of a compiled definition to its
  638                           //      parameter field address.
  639                           
  640                            SECTION .text : CONST (2)
  641                           PFA_NFA:
  642    00000000 83                    DC8     0x83
  643    00000001 5046                  DC8     'PF'
  644    00000003 C1                    DC8     'A'+0x80
  645                            ALIGNROM 2,0xFFFFFFFF
  646    00000004 ........              DC32    NFA_NFA
  647                           PFA:
  648    00000008 ........              DC32    DOCOL           // \ NFA --
  649    0000000C ........              DC32    ONE             // DIRECTION FOR TRAVERSE = Toward CFA
  650    00000010 ........              DC32    TRAVERSE        // \ NFA 1 -- addr2
  651                           
  652                           PFA_ALIGN_BEGIN:
  653    00000014 ........              DC32    ONEP            // ADDR 1 BEFORE lfa, eliminate padding
  654    00000018 .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  655    00000020 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  656    0000002C ........              DC32    ZBRAN           // UNTIL
  657    00000030 E4FFFFFF              DC32    PFA_ALIGN_BEGIN-.
  658                           
  659    00000034 ........              DC32    EIGHT
  660    00000038 ........              DC32    PLUS
  661    0000003C ........              DC32    SEMIS
  662                           
  663                           
  664                           //      ?ALIGNED QALIGNED: ( value -- )
  665                           //      If value not aligned by 4 issue message and ABORT.
  666                           
  667                            SECTION .text : CONST (2)
  668                           QALIGNED_NFA:
  669    00000000 88                    DC8     0x88
  670    00000001 3F414C49474E4         DC8     '?ALIGNE'
                  5            
  671    00000008 C4                    DC8     'D'+0x80
  672    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  673    0000000C ........              DC32    PFA_NFA
  674                           QALIGNED:
  675    00000010 ........              DC32    DOCOL
  676    00000014 ........03000         DC32    LIT, 3, ANDD
                  000........  
  677    00000020 ........              DC32    ZBRAN           //IF no err leave
  678    00000024 3C000000              DC32     QALIGN_OK-.
  679                           
  680    00000028 ........              DC32    PDOTQ
  681    0000002C 2E                    DC8     46
  682    0000002D 56414C5545204         DC8     'VALUE MUST BE EVEN NOT ODD AND MULTIPLE OF 4! '
                  D555354204245
                  204556454E204
                  E4F54204F4444
                  20414E44204D5
                  54C5449504C45
                  204F462034212
                  0            
  683    0000005B FF             ALIGNROM 2,0xFFFFFFFF
  684    0000005C ........              DC32    ABORT
  685                           
  686                           QALIGN_OK:
  687    00000060 ........              DC32    SEMIS
  688                           
  689                           
  690                           //      ?ERROR QERROR: ( f nullstr -- )
  691                           //      If f NON ZERO type error message (nullstr) and ABORT.
  692                           
  693                            SECTION .text : CONST (2)
  694                           QERROR_NFA:
  695    00000000 86                    DC8     0x86
  696    00000001 3F4552524F            DC8     '?ERRO'
  697    00000006 D2                    DC8     'R'+0x80
  698    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  699    00000008 ........              DC32    QALIGNED_NFA
  700                           QERROR:
  701    0000000C ........              DC32    DOCOL
  702    00000010 ........              DC32    SWAP
  703    00000014 ........              DC32    ZBRAN   //IF no err leave
  704    00000018 10000000              DC32     QERROR_FINISH-.
  705                           
  706    0000001C ........              DC32    ERROR   // nullstr-addr ---  ABORT's
  707    00000020 ........              DC32    BRAN    // ELSE
  708    00000024 08000000              DC32     QERROR_DONE-.
  709                           
  710                           QERROR_FINISH:
  711    00000028 ........              DC32    DROP    //endif
  712                           
  713                           QERROR_DONE:
  714    0000002C ........              DC32    SEMIS
  715                           
  716                           
  717                           //      DIGIT DIGIT:    ( c base -- digit 1 ) (ok)
  718                           //                      ( c base -- 0 (bad)
  719                           //      Converts the ascii character c using base to its binary
  720                           //      equivalent digit, accompanied by a true flag. If the conversion is
  721                           //      invalid, leaves only a false flag.
  722                           
  723                           //      If digit gets 0, space, dot, comma or any non number it returns 0 
  724                           
  725                            SECTION .text : CONST (2)
  726                           DIGIT_NFA:
  727    00000000 85                    DC8     0x85
  728    00000001 44494749              DC8     'DIGI'
  729    00000005 D4                    DC8     'T'+0x80
  730    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  731    00000008 ........              DC32    QERROR_NFA
  732                           DIGIT:
  733    0000000C ........              DC32    .+5
  734                            SECTION .text : CODE (2)
  735                                   POP2w                   // Number base
  735.1  00000000 57F8042B              LDR     w, [p],#4
  735.2                         //      LDR     w, [p]
  735.3                         //      ADDS    p, p, #4
  735.4                                 ENDM
  736                                   POP2t                   // ASCII DIGIT
  736.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
  736.2                         //#ifndef TOSCT
  736.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  736.4                         //#endif
  736.5                         //      ADDS    p, p, #4
  736.6                                 ENDM
  737    00000008 3038                  SUBS   t, t, #'0'
  738    0000000A 13D4                  BMI   DIGI2             // Number error
  739                           
  740    0000000C 0928                  CMP   t, #9
  741    0000000E 02DD                  BLE   DIGI1             // Number = 0 THRU 9
  742                           
  743                                   // Combine?
  744    00000010 C01F                  SUBS   t, t, #7
  745    00000012 0A28                  CMP   t, #10            // Number 'A' THRU 'Z'?
  746    00000014 0EDB                  BLT   DIGI2             // NO
  747                           
  748                           DIGI1:
  749    00000016 9042                  CMP     t, w            // COMPARE Number TO base
  750    00000018 0CDA                  BGE     DIGI2
  751                           
  752    0000001A 0246                  MOV     w, t            // NEW BINARY Number
  753    0000001C 0120                  MOVS    t, #1           // TRUE FLAG
  754                                   DPUSH
  754                                   PUSHw   // push w to p, post decrement p
  754.1  0000001E 47F8042D              STR     w, [p, #-4]!
  754.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  754.3                         //      STR     w, [p]
  754.4                                 ENDM
  754                                   TPUSH
  754                                   PUSHt   // push t to p, pre decrement p
  754.1  00000022 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  754.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  754.3                         //      STR     t, [p]
  754.4                                 ENDM
  754                                   NEXT
  754.1                         // ARMv7-M Thumb = .+5
  754.2  00000026 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  754.3                         // ARMv6-M Thumb = .+4
  754.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  754                                   NEXT1
  754.1  0000002A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  754.2  0000002E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  754.3  00000032 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  754.4                         // ARMv6-M Thumb = .+4
  754.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  754.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  754.7                                 ENDM
  754.8                                 ENDM
  754.9                                 ENDM
  754.10                                ENDM
  755                           
  756                                   // Number error
  757                           DIGI2:
  758    00000034 0020                  MOVS   t, #0            // FALSE FLAG
  759                                   TPUSH
  759                                   PUSHt   // push t to p, pre decrement p
  759.1  00000036 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  759.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  759.3                         //      STR     t, [p]
  759.4                                 ENDM
  759                                   NEXT
  759.1                         // ARMv7-M Thumb = .+5
  759.2  0000003A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  759.3                         // ARMv6-M Thumb = .+4
  759.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  759                                   NEXT1
  759.1  0000003E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  759.2  00000042 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  759.3  00000046 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  759.4                         // ARMv6-M Thumb = .+4
  759.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  759.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  759.7                                 ENDM
  759.8                                 ENDM
  759.9                                 ENDM
  760                           
  761                           
  762                           //      ENCLOSE ENCL:   ( addr1 c -- addr1 n1 n2 n3 )
  763                           //      A text scanning iterative primitive used only in WORD.
  764                           //      IN is used before and after callS for the iteration
  765                           //      Typically TIB + IN = addr1
  766                           //      noop EX: \ TIB   32 -- TIB   0 4 5
  767                           //      NULL EX: \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  768                           //      NULL EX: \ WORD/ENCL -> TIB 1, 0, 20'S
  769                           //      From the text address addr1 and an ascii delimiting character c,
  770                           //      is determined the byte offset to the first non-delimiter character n1,
  771                           //      the offset to the first delimiter after the text n2,
  772                           //      and the offset to the first character not included.
  773                           //      This procedure will not process past an ASCII 'null', treating it
  774                           //      as an unconditional delimiter. NULL termination by EXPECT in QUERY.
  775                           
  776                            SECTION .text : CONST (2)
  777                           ENCL_NFA:
  778    00000000 87                    DC8     0x87
  779    00000001 454E434C4F53          DC8     'ENCLOS'
  780    00000007 C5                    DC8     'E'+0x80
  781                            ALIGNROM 2,0xFFFFFFFF
  782    00000008 ........              DC32    DIGIT_NFA
  783                           ENCL:
  784    0000000C ........              DC32    .+5
  785                            SECTION .text : CODE (2)
  786                                   POP2t                   // TERMINATOR CHAR
  786.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  786.2                         //#ifndef TOSCT
  786.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  786.4                         //#endif
  786.5                         //      ADDS    p, p, #4
  786.6                                 ENDM
  787    00000004 3968                  LDR     n, [p]          // get text address but leave on stack
  788    00000006 0022                  MOVS    w, #0
  789    00000008 521E                  SUBS    w, w, #1        // CHAR  COUNTER
  790    0000000A 491E                  SUBS    n, n, #1        // ADDR -1
  791                           
  792                           //  SCAN TO FIRST NON-TERMINATOR CHARACTER
  793                           //      and PUSH count to stack leaving last 2 params to compute
  794                           ENCL1:
  795    0000000C 491C                  ADDS    n, n, #1        // ADDR+1
  796    0000000E 521C                  ADDS    w, w, #1        // COUNT+1
  797    00000010 0B78                  LDRB    x, [n]
  798    00000012 9842                  CMP     t, x            //CMP   AL,[BX]
  799    00000014 FAD0                  BEQ     ENCL1           //JZ    ENCL1   // WAIT FOR NON-TERMINATOR
  800                                   PUSHw                   //offset to the first non-delimiter character
  800.1  00000016 47F8042D              STR     w, [p, #-4]!
  800.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  800.3                         //      STR     w, [p]
  800.4                                 ENDM
  801                                                           //EXiT is now only DPUSH
  802    0000001A 002B                  CMP     x, #0           //CMP   AH,[BX] // null CHAR?
  803    0000001C 0CD1                  BNE     ENCL2           //JNZ   ENCL2   // NO
  804                           
  805                           // FOUND null BEFORE 1ST NON-TERM CHAR
  806                           // RETURN ok args = NULL EX//
  807                           // \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  808                           //
  809    0000001E 1846                  MOV     t, x
  810    00000020 521C                  ADDS    w, w, #1        // w = offset to the delimiter after the text
  811                                   DPUSH
  811                                   PUSHw   // push w to p, post decrement p
  811.1  00000022 47F8042D              STR     w, [p, #-4]!
  811.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  811.3                         //      STR     w, [p]
  811.4                                 ENDM
  811                                   TPUSH
  811                                   PUSHt   // push t to p, pre decrement p
  811.1  00000026 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  811.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  811.3                         //      STR     t, [p]
  811.4                                 ENDM
  811                                   NEXT
  811.1                         // ARMv7-M Thumb = .+5
  811.2  0000002A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  811.3                         // ARMv6-M Thumb = .+4
  811.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  811                                   NEXT1
  811.1  0000002E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  811.2  00000032 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  811.3  00000036 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  811.4                         // ARMv6-M Thumb = .+4
  811.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  811.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  811.7                                 ENDM
  811.8                                 ENDM
  811.9                                 ENDM
  811.10                                ENDM
  812                           
  813                           //   FOUND FIRST TEXT CHAR - COUNT THE CHARS
  814                           ENCL2:
  815    00000038 491C                  ADDS    n, n, #1        // ADDR+1
  816    0000003A 521C                  ADDS    w, w, #1        //COUNT+1
  817    0000003C 0B78                  LDRB    x, [n]
  818    0000003E 9842                  CMP     t, x            //TERMINATOR CHAR?
  819    00000040 01D0                  BEQ     ENCL4           //YES
  820                           
  821    00000042 002B                  CMP     x, #0           //null CHAR?
  822    00000044 F8D1                  BNE     ENCL2           //NO, LOOP AGAIN
  823                           
  824                           ENCL3:  //   FOUND null AT END OF TEXT
  825                           ENCL4:  //   FOUND TERMINATOR CHARACTER
  826    00000046 1046                  MOV     t, w            // COUNT+1 =
  827    00000048 401C                  ADDS    t, t, #1        // offset to the first character not included
  828                                   DPUSH
  828                                   PUSHw   // push w to p, post decrement p
  828.1  0000004A 47F8042D              STR     w, [p, #-4]!
  828.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  828.3                         //      STR     w, [p]
  828.4                                 ENDM
  828                                   TPUSH
  828                                   PUSHt   // push t to p, pre decrement p
  828.1  0000004E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  828.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  828.3                         //      STR     t, [p]
  828.4                                 ENDM
  828                                   NEXT
  828.1                         // ARMv7-M Thumb = .+5
  828.2  00000052 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  828.3                         // ARMv6-M Thumb = .+4
  828.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  828                                   NEXT1
  828.1  00000056 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  828.2  0000005A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  828.3  0000005E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  828.4                         // ARMv6-M Thumb = .+4
  828.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  828.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  828.7                                 ENDM
  828.8                                 ENDM
  828.9                                 ENDM
  828.10                                ENDM
  829                           
  830                           
  831                           //      0 NULL: ( -- ) IMMEDIATE
  832                           //      Don't return to Interpret, return to Quit at end of a line of input.
  833                           //      Executed at end of TIB when QUERY lenght or CR entered.
  834                           
  835                            SECTION .text : CONST (2)
  836                           NULL_NFA:
  837    00000000 C1                    DC8     0x0C1                   // A BINARY ZER
  838    00000001 80                    DC8     0x80
  839    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  840    00000004 ........              DC32    ENCL_NFA
  841                           NULL:
  842                           //      DC32    SEMIS                   // Actual Semis code below
  843    00000008 ........              DC32    .+5
  844                            SECTION .text : CODE (2)
  845                                   POPr2i  // pop docol saved IP from Rstack
  845.1  00000000 56F8045B              LDR     i, [r],#4       ; pop DOCOL'd IP from Rstack
  845.2                         //      LDR i, [r]              //  pop r to i, post increment r
  845.3                         //      ADDS    r, r, #4
  845.4                                 ENDM
  846                                   NEXT
  846.1                         // ARMv7-M Thumb = .+5
  846.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  846.3                         // ARMv6-M Thumb = .+4
  846.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  846                                   NEXT1
  846.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  846.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  846.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  846.4                         // ARMv6-M Thumb = .+4
  846.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  846.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  846.7                                 ENDM
  846.8                                 ENDM
  847                           
  848                           
  849                           //      WORD WORD:      ( c -- )
  850                           //      Parse the text in TIB , until a delimiter c is found, tokenizing input.
  851                           //      Move the token to HERE, with a count byte and 2 nulls at the end.
  852                           //      Leading occurrences of c are ignored. IN is incremented.
  853                           //      See IN. Usually used inside a definition.
  854                           
  855                            SECTION .text : CONST (2)
  856                           WORD_NFA:
  857    00000000 84                    DC8     0x84
  858    00000001 574F52                DC8     'WOR'
  859    00000004 C4                    DC8     'D'+0x80
  860    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  861    00000008 ........              DC32    NULL_NFA
  862                           WORD:
  863    0000000C ........              DC32    DOCOL
  864                           WORD1:
  865                           //      This is required for number suffix's at least ???
  866                           // NOT WITH NEW COUNTED NULL STRING EXPECT
  867                           //      DC32    HERE, LIT, MAXWORDLEN+2, BLANKS
  868    00000010 ........              DC32    TIB_SV
  869                           WORD2:
  870    00000014 ........              DC32    IN_SV
  871    00000018 ........              DC32    AT
  872    0000001C ........              DC32    PLUS
  873    00000020 ........              DC32    SWAP    // ( TIB+IN CH-DELIM -- )
  874    00000024 ........              DC32    ENCL    // ( TIB+IN 32 -- TIB+IN   0 4 5 )
  875                           WENCL:
  876    00000028 ........              DC32    IN_SV   // encl TOS = end of word offset to be added to IN
  877    0000002C ........              DC32    PSTORE  // TIB+IN   0 4
  878    00000030 ........              DC32    OVER    // 
  879    00000034 ........              DC32    SUBB    // Char cnt going to R and HERE
  880    00000038 ........              DC32    TOR
  881    0000003C ........              DC32    R
  882    00000040 ........              DC32    HERE
  883    00000044 ........              DC32    CSTORE   // CHAR CNT OF word
  884    00000048 ........              DC32    PLUS
  885    0000004C ........              DC32    HERE
  886    00000050 ........              DC32    ONEP
  887                           //      DC32    RFROM
  888                           // MOVE word TO DICT FOR finding ENDING WITH NULLS
  889    00000054 ........              DC32    R
  890    00000058 ........              DC32    CMOVE   // ( from to count -- )
  891                           // add null to end of token - NUMBER adjusted        
  892    0000005C .............         DC32    ZERO, HERE, ONEP, RFROM, PLUS, CSTORE
                  .............
                  .............
                  .........    
  893                           #ifdef  IOBUFS_DEBUG
  895                           #endif        
  896    00000074 ........              DC32    SEMIS
  897                           
  898                           
  899                           //      NUMBER NUMBER:  ( addr -- sd )
  900                           //      If error print message and ABORT.
  901                           //      Convert a character string left at addr with a preceeding count,
  902                           //      and a terminating null, to a signed number, in the current numeric base.
  903                           //      If a decimal point is encountered in the text, its position will be
  904                           //      given in DPL, but no other effect occurs. If numeric conversion is
  905                           //      not possible, an error message will be given.
  906                           
  907                           //      Added support for , as a single number formatter.
  908                           
  909                           #define comma_test
  910                           
  911                            SECTION .text : CONST (2)
  912                           NUMBER_NFA:
  913    00000000 86                    DC8     0x86
  914    00000001 4E554D4245            DC8     'NUMBE'
  915    00000006 D2                    DC8     'R'+0x80
  916    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  917    00000008 ........              DC32    WORD_NFA
  918                           NUMBER:
  919    0000000C ........              DC32    DOCOL
  920    00000010 ........              DC32    BASE_TO_R12     // Save current BASE.
  921    00000014 ........              DC32    NUMBERSUFFIX    // (addr -- sddr) Change BASE if suffix used.
  922                           
  923                           // SETUP: stack arguments for PNUMBER.
  924    00000018 .............         DC32    ZERO, ZERO
                  ...          
  925    00000020 ........              DC32    ROT             // ( 0 0 addr -- )
  926                           
  927                           // SETUP: reeturn stack with sign flag
  928                           // NONAME CANDIDATE!
  929                           // START: Handle minus sign by saving status on Return Stack.
  930                           // and incrementing to addr after it.
  931    00000024 .............         DC32    DUP, ONEP       // ( 0 0 addr addr+1 -- )
                  ...          
  932    0000002C ........              DC32    CAT             // ( 0 0 addr 1rstchar -- )
  933    00000030 ........2D000         DC32    LIT, '-'        // ( 0 0 addr 1rstchar 0x2D --- )
                  000          
  934    00000038 ........              DC32    EQUAL           // ( 0 0 addr f -- )
  935                           #ifdef TRUE_EQU_NEG_ONE         // EQUAL returns -1 NEED 0 or 1 here!
  936    0000003C .............         DC32    ONE, ANDD       // ( 0 0 addr f -- ) MAKE FLAG ONE OR ZERO!
                  ...          
  937                           #endif
  938    00000044 .............         DC32    DUP, TOR        // ( 0 0 addr f -- ) copy of f >R
                  ...          
  939                           // END: Handle - by saving status on Return Stack.
  940                           
  941                           // SETUP: addr pointing to 1rst digit.
  942                           // If minus sign, flag from above will increment to next char.
  943    0000004C ........              DC32    PLUS            // Increment (OR NOT) addr to next char
  944                           
  945                           // So could be at 1rst OR 2nd character in string here!
  946                           
  947                           // ENTER LOOP WITH -1 DPL = single number and sign flag on return stack.
  948    00000050 ........FFFFF         DC32    LIT, -1
                  FFF          
  949                           // PNUMBER is used in loop to convert string segment until non-mumeric chracter.
  950                           // A period in the string manipulates DPL to create a double number.
  951                           // A comma in the string resets DPL to create a single number.
  952                           // A null indicates the end of the string.
  953                           NUMB1:                          // Begin
  954    00000058 .............         DC32    DPL_SV, STORE   // PNUMBER creates whole, dot or comma number segment
                  ...          
  955                           
  956                           // PNUMBER converts one or more characters until first unconvertable digit.
  957                           // ud and addr in string is maintained while in loop.
  958    00000060 ........              DC32    PNUMBER         // ( 0 0 addr -- ud=(LSW MSW) ADDR=PAST#)
  959                           // Perform check for period, comma and null.
  960                           // Any other character here invalidates this number conversion.
  961                           
  962                           // Null Test: = end of string.
  963    00000064 .............         DC32    DUP, CAT
                  ...          
  964    0000006C ........              DC32    ZERO            // End of string used to be BLANK, is now Null.
  965    00000070 ........              DC32    SUBB
  966    00000074 ........              DC32    ZBRAN           // IF emd of number string conversion is
  967    00000078 6C000000              DC32      NUMB2-.       // DONE UNLESS IT NEEDS TO BE NEGATED.
  968                           
  969                           // Period Test: = increment DPL.
  970    0000007C .............         DC32    DUP, CAT
                  ...          
  971    00000084 ........2E000         DC32    LIT, '.'        // 2Eh = period.
                  000          
  972    0000008C ........              DC32    SUBB
  973    00000090 ........              DC32    ZBRAN
  974    00000094 44000000              DC32      DPL_ZERO_INCR-.
  975                           
  976                           #ifdef  comma_test
  977                           // Comma Test: = reset DPL.
  978    00000098 .............         DC32    DUP, CAT
                  ...          
  979    000000A0 ........2C000         DC32    LIT, ','        // 2CH comma
                  000          
  980    000000A8 ........              DC32    EQUAL
  981    000000AC ........              DC32    ZBRAN
  982    000000B0 14000000              DC32      BASE_RESET_THEN_ERROR-.
  983                           
  984                           // Fall thru if comma so reset DPL to create a single number.
  985                           DPL_RESET:        
  986    000000B4 ........FFFFF         DC32    LIT, -1
                  FFF          
  987    000000BC ........              DC32    BRAN
  988    000000C0 98FFFFFF              DC32      NUMB1-.
  989                           #endif
  990                           
  991                           BASE_RESET_THEN_ERROR:
  992                           // GOING TO ERROR SO RESTORE BASE!
  993    000000C4 ........              DC32    BASE_FROM_R12   // Restore BASE
  994                           //NO_BASE_RESTORE:
  995    000000C8 ........              DC32    ONE     // provide non zero flag for error
  996    000000CC .............         DC32    LIT, msg_number_error
                  ...          
  997    000000D4 ........              DC32    QERROR // ( f nullstr-addr -- ) IF f TRUE EXECUTE ERROR!
  998                           
  999                           DPL_ZERO_INCR:      // set DPL to zero
 1000    000000D8 ........              DC32    ZERO
 1001    000000DC ........              DC32    BRAN
 1002    000000E0 78FFFFFF              DC32      NUMB1-.
 1003                           
 1004                           NUMB2:
 1005    000000E4 ........              DC32    DROP
 1006    000000E8 ........              DC32    RFROM           // FLAG OF "-" TEST
 1007                                                           // IF
 1008    000000EC ........              DC32    ZBRAN
 1009    000000F0 08000000              DC32      NUMB3-.
 1010                           
 1011    000000F4 ........              DC32    DNEGATE
 1012                           
 1013                           NUMB3:                          // endif
 1014    000000F8 ........              DC32    BASE_FROM_R12   // Restore BASE
 1015    000000FC ........              DC32    SEMIS
 1016                           
 1017                           
 1018                           //      ERROR ERROR:    ( nullstr --- )
 1019                           //      Execute error notification and restart of system.
 1020                           //      IN_SV is saved to assist in determining the location of the error.
 1021                           
 1022                            SECTION .text : CONST (2)
 1023                           ERROR_NFA:
 1024    00000000 85                    DC8     0x85
 1025    00000001 4552524F              DC8     'ERRO'
 1026    00000005 D2                    DC8     'R'+0x80
 1027    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1028                           //      DC32    DFIND_NFA
 1029    00000008 ........              DC32    NUMBER_NFA
 1030                           ERROR:
 1031    0000000C ........              DC32    DOCOL
 1032    00000010 .............         DC32    HERE, COUNT, TYPE       // Offending item
                  ...........  
 1033    0000001C .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 1034                           #ifdef IO2TP
 1038                           #endif
 1039                           #ifdef XON_XOFF
 1040    00000024 ........              DC32    XOFF    // TEMP TEST THRE
 1041                           #endif
 1042                                   
 1043                           //      DO THIS WHERE STATE IS SET BACK TO ZERO
 1044    00000028 .............         DC32    STATE_SV, AT
                  ...          
 1045    00000030 ........              DC32    ZBRAN
 1046    00000034 40000000              DC32     CREATED_OK-.
 1047                           
 1048                           //      NON-ZERO CSDP = RESTORE DP TO forget DAMAGED WORDS
 1049    00000038 .............         DC32    CSDP_SV, AT   // Create saves dp here for if word exists err
                  ...          
 1050    00000040 ........              DC32    ZBRAN
 1051    00000044 30000000              DC32     CREATED_OK-.
 1052                           
 1053                           // assume ITS A CREATE'd WORD!!!!
 1054                           ERROR_FIXUP:     // CSDP_SV contains NFA of definition that has error.
 1055    00000048 .............         DC32    CSDP_SV, AT     // SHOULD BE AT NFA!!
                  ...          
 1056    00000050 ........              DC32    PFA     // \ nfa -- pfa
 1057    00000054 .............         DC32    LFA, AT // \ pfa --- lfa
                  ...          
 1058    0000005C .............         DC32    CURRENT_SV, STORE       // Has to be NFA of last good word
                  ...          
 1059                           // RESET DP!
 1060    00000064 .............         DC32    CSDP_SV, AT
                  ...          
 1061    0000006C .............         DC32    DP_SV, STORE
                  ...          
 1062                           
 1063                           CREATED_OK:
 1064    00000074 ........              DC32    SEMIC_CREATE            // RESET CSDP FOR AUTO FORGET
 1065                           #ifdef ABORT_STOP_TILL_CO
 1066    00000078 ........              DC32    ABORT
 1067                           #else
 1069                           #endif
 1070                           //      DC32    QUIT    // FROM Error
 1071                           
 1072                           
 1073                           //      ' TICK: ( -- pfa ) IMMEDIATE
 1074                           //      Used in the form: .
 1075                           //      ' CCcc
 1076                           //      Leaves the parameter field address of dictionary word CCcc.
 1077                           //      If the word is not found after a search of CURRENT,
 1078                           //      an appropriate error message is given.
 1079                           //      As a compiler directive, executed in a colon-definition to compile
 1080                           //      the address as a literal.
 1081                           //      Pronounced "TICK".
 1082                           
 1083                            SECTION .text : CONST (2)
 1084                           TICK_NFA:
 1085    00000000 C1                    DC8     0x0C1
 1086    00000001 A7                    DC8     ''''+0x80
 1087    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1088    00000004 ........              DC32    ERROR_NFA
 1089                           TICK:
 1090    00000008 ........              DC32    DOCOL
 1091    0000000C ........              DC32    DFIND   // noop there for TIB entry
 1092    00000010 ........              DC32    ZEQU
 1093    00000014 .............         DC32    LIT, msg_word_error
                  ...          
 1094    0000001C ........              DC32    QERROR    // \ f nullstr-addr --
 1095    00000020 ........              DC32    DROP
 1096    00000024 ........              DC32    LITERAL
 1097    00000028 ........              DC32    SEMIS
 1098                           
 1099                           
 1100                           //      EXPECT EXPECT:  ( addr count -- )
 1101                           //      Transfer characters from the terminal to the buffer starting at addr+1,
 1102                           //      until a "return" or the count of characters have been received.
 1103                           //      One or two nulls are added at the end creating a null-terminated string.
 1104                           //      A count byte is placed at addr, the count being derived by $LEN
 1105                           //      Use COUNT with TYPE for strings saved this way.
 1106                           //      Strings longer that 255 will have an invalid count byte. Use $LEN:
 1107                           //      $LEN and TYPE can be used when the argument to $LEN is addr+1.
 1108                           
 1109                           //      Comments below use TIB input (QUERY in INTERPRET) as an example.
 1110                           
 1111                            SECTION .text : CONST (2)
 1112                           EXPECT_NFA:
 1113    00000000 86                    DC8     0x86
 1114    00000001 4558504543            DC8     'EXPEC'
 1115    00000006 D4                    DC8     'T'+0x80
 1116    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1117    00000008 ........              DC32    TICK_NFA
 1118                           EXPECT:                 // ( NOS TOS -- NOS TOS )
 1119    0000000C ........              DC32    DOCOL   // ( TIB LEN -- )
 1120    00000010 ........              DC32    ONEP    // ( TIB LEN+1 -- ) (Index and Limit)+1 for count byte
 1121    00000014 ........              DC32    OVER    // ( TIB LEN+1 TIB -- )
 1122    00000018 ........              DC32    PLUS    // ( TIB TIB+LEN+1 -- )
 1123    0000001C ........              DC32    OVER    // ( TIB TIB+LEN+1 TIB -- )
 1124    00000020 ........              DC32    ONEP    // ( TIB TIB+LEN+1 TIB+1 -- ) SKIP COUNT BYTE
 1125                           #ifdef XON_XOFF
 1126    00000024 ........              DC32    XON
 1127                           #endif
 1128                           // ( ORGIGINAL-TIB TIB+LEN+1 TIB+1 -- ORGIGINAL-TIB ) 
 1129                           //                (Index & Limit)+1 for count byte
 1130    00000028 ........              DC32    XDO     // DO   Index = addr, Limit = addr+cnt
 1131                           EXPE1:
 1132    0000002C ........              DC32    KEY     // CAN BREAKPOINT OR CHANGE TO BE 0x0D ONLY
 1133                           #ifdef XON_XOFF
 1134    00000030 ........              DC32    IF_EOL_SEND_XOFF        // IF CR QUICK XOFF!
 1135                           #endif
 1136                           // goto main branch (EL1:)if not tab
 1137    00000034 .............         DC32    DUP, LIT, 9, EQUAL      // ? TAB
                  ...09000000..
                  ......       
 1138    00000044 ........              DC32    ZBRAN                   // Not tab
 1139    00000048 0C000000              DC32     EL1-.                  // Goto MAIN LOOP
 1140                                   
 1141                           // REPLACE TAB WITH SPACE               // -- ch f
 1142    0000004C .............         DC32    DROP, BLANK             // Convert tab to space
                  ...          
 1143                           EL1:
 1144                           // MAIN LOOP ENTERED WITH CHAR ON TOS
 1145    00000054 ........              DC32    DUP             // ( TIB key key -- )
 1146                           // FALL THRU IF BACKSPACE OR DELETE KEY
 1147    00000058 ........              DC32    BACKSPACE_CHAR
 1148    0000005C ........              DC32    EQUAL
 1149    00000060 ........              DC32    OVER
 1150    00000064 ........7F000         DC32    LIT, 07Fh       // DEL KEY
                  000          
 1151    0000006C ........              DC32    EQUAL
 1152    00000070 ........              DC32    OR
 1153                           // BRANCH IF NOT BACKSPACE OR DELETE KEY
 1154    00000074 ........              DC32    ZBRAN           // If not backspace
 1155    00000078 50000000              DC32     EXPE2-.        // go here
 1156                           
 1157                           // CASE OF BACKSPACE/DELETE KEY
 1158    0000007C ........              DC32    DROP            // ( TOS> 8 TIB -- TIB ) Drop Backspace on stack
 1159    00000080 ........              DC32    DUP             // ( TOS> TIB -- TOS> TIB TIB )  Current TIB addr
 1160    00000084 ........              DC32    I               // ( TOS> TIB TIB -- I=TIB+? TIB TIB )
 1161                           // COMPENSATE FOR COUNT BYTE - BUMP ADDR+1 (NEXT CHAR LOCATION) BACK TO CURRENT
 1162    00000088 ........              DC32    ONEM
 1163    0000008C ........              DC32    EQUAL           // ( TOS> I=TIB+? TIB TIB -- f TIB )
 1164    00000090 ........              DC32    DUP             // ( TOS> f TIB -- f f TIB )
 1165                           // I AND RFROM STARTS AT TIB+1 
 1166                           // REMOVE INDEX FROM LOOP TO REPLACE IT WITH BACKSPACE CORRECTED ADDRESS
 1167    00000094 ........              DC32    RFROM           // ( TOS> f f TIB -- TIB+1 f f TIB )
 1168                           // ADDING 2 BECAUSE TIB+1 IS FROM I AND FLAG MAKES IT = TO 1
 1169                           // WHEN AT THE BEGIINING (ADDR+1) OF THE ADDR BUFFER
 1170    00000098 ........              DC32    TWO
 1171    0000009C ........              DC32    SUBB
 1172                           // ADD FLAG 
 1173    000000A0 ........              DC32    PLUS
 1174    000000A4 ........              DC32    TOR
 1175    000000A8 ........              DC32    ZBRAN           // If not at beginning of line
 1176    000000AC 10000000              DC32     EXPE6-.        // Goto bsout
 1177                           
 1178    000000B0 ........              DC32    BELL            // At beginning of TIB issue bell
 1179    000000B4 ........              DC32    BRAN            // Goto end of loop
 1180    000000B8 60000000              DC32     EXPE33-.
 1181                           
 1182                           EXPE6:
 1183    000000BC ........              DC32    BSOUT           // endif
 1184                           EXPE7:  // LABEL NOT USED BECAUSE BELL AND BSOUT Emit THEMSELVES
 1185    000000C0 ........              DC32    BRAN            // Goto end of loop
 1186    000000C4 54000000              DC32     EXPE33-.
 1187                           
 1188                           EXPE2:
 1189    000000C8 ........              DC32    DUP
 1190    000000CC ........0D000         DC32    LIT, 0x0D       // cr
                  000          
 1191    000000D4 ........              DC32    EQUAL
 1192    000000D8 ........              DC32    ZBRAN           // If not cr
 1193    000000DC 1C000000              DC32     EXPE4-.        // Goto save this char and loop again
 1194                                   
 1195    000000E0 ........              DC32    LEAVE           // ( TOS> ODh TIB --  )
 1196                           #ifdef  IOBUFS_DEBUG        
 1198                           #endif
 1199                                   // CR DROPPED HERE I USED AT END FOR CASE OF EXPECT COUNT REACHED
 1200    000000E4 ........              DC32    DROP            // ( TOS> TIB -- )
 1201    000000E8 ........              DC32    BLANK           // ( TOS> 20h TIB -- ) space IS FOR EMIT!
 1202    000000EC ........              DC32    ZERO            // ( TOS> 0 20h TIB -- ) null
 1203    000000F0 ........              DC32    BRAN            // Goto store these at end of loop
 1204    000000F4 08000000              DC32     EXPE5-.
 1205                           
 1206                           EXPE4:
 1207    000000F8 ........              DC32    DUP             // Regular char 
 1208                           
 1209                           EXPE5:
 1210    000000FC ........              DC32    I               // I=TIB Store char
 1211    00000100 ........              DC32    CSTORE          // or 1rst null in CASE OF CR
 1212    00000104 ........              DC32    ZERO            // 1rst or second null if cr
 1213                                   // CASE OF CR ( TOS> 0 20h TIB -- )
 1214    00000108 ........              DC32    I
 1215    0000010C ........              DC32    ONEP
 1216    00000110 ........              DC32    CSTORE
 1217                           EXPE3:
 1218                                   // CASE OF CR ( TOS> 20H TIB -- )
 1219    00000114 ........              DC32    EMIT
 1220                           EXPE33:
 1221    00000118 ........              DC32    XLOOP
 1222    0000011C 10FFFFFF              DC32     EXPE1-.        // Loop is LEAVE'd
 1223                           
 1224                           #ifdef XON_XOFF
 1225    00000120 ........              DC32    XOFF            // FOR CASE OF count reached befor cr
 1226                           #endif
 1227                           // Creat count byte        
 1228                                   // ( ORIGINAL ADDR -- )
 1229                                   // ORIGINAL ADDR (TIB) ON STACK HERE SO CORRECT FOR $LEN
 1230    00000124 ........              DC32    ONEP            // PAST COUNT BYTE FOR CORRECT COUNT
 1231                                   // NULLSTRLEN:          // ( addr -- addr len )
 1232    00000128 ........              DC32    NULLSTRLEN      // ( TOS> LEN TIB+1 -- )
 1233    0000012C .............         DC32    SWAP, ONEM      // BACK UP TO COUNT BYTE
                  ...          
 1234    00000134 ........              DC32    CSTORE
 1235    00000138 ........              DC32    SEMIS
 1236                           
 1237                           
 1238                           //      COUNT COUNT:    ( addr1 --- addr2 n )
 1239                           //      Leave the byte address addr2 and byte count n of a count byte string,
 1240                           //      beginning at address addr1. It is presumed that the first byte at
 1241                           //      addr1 contains the text byte count and the actual text starts with
 1242                           //      the second byte. NFA's may report SMUDGE'd byte counts, handled only
 1243                           //      by ID. User Strings may be up to 255 characters.
 1244                           //      Typically COUNT is followed by TYPE.
 1245                           //      See TYPE $LEN and EXPECT
 1246                           
 1247                            SECTION .text : CONST (2)
 1248                           COUNT_NFA:
 1249    00000000 85                    DC8     0x85
 1250    00000001 434F554E              DC8     'COUN'
 1251    00000005 D4                    DC8     'T'+0x80
 1252    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1253    00000008 ........              DC32    EXPECT_NFA
 1254                           COUNT:
 1255    0000000C ........              DC32    DOCOL
 1256    00000010 ........              DC32    DUP
 1257    00000014 ........              DC32    ONEP
 1258    00000018 ........              DC32    SWAP
 1259                           //        DC32    CATLT7F
 1260    0000001C ........              DC32    CAT     // n could be SMUDGE'd count from NFA's
 1261    00000020 ........              DC32    SEMIS   // Only internal usage is ID.
 1262                           
 1263                           
 1264                           //      $LEN NULLSTRLEN:        ( addr - addr len )
 1265                           //      Count length of null terminated string.
 1266                           //      TYPE can be used after this word.
 1267                           
 1268                            SECTION .text : CONST (2)
 1269                           NULLSTRLEN_NFA:
 1270    00000000 84                    DC8     0x84
 1271    00000001 244C45                DC8     '$LE'
 1272    00000004 CE                    DC8     'N'+0x80
 1273    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1274    00000008 ........              DC32    COUNT_NFA
 1275                           NULLSTRLEN:
 1276    0000000C ........              DC32    .+5
 1277                            SECTION .text : CODE (2)
 1278                                   NDPOP2w                         // Get but leave addr on stack
 1278.1  00000000 3A68                  LDR     w, [p]
 1278.2                                 ENDM
 1279    00000002 4040                  EORS            t, t, t         // zero count
 1280                           
 1281                           NSLEN_LOOP:
 1282    00000004 115C                  LDRB            n, [w,t]
 1283    00000006 0943                  ORRS            n, n, n
 1284    00000008 01D0                  BEQ             NSLEN_DONE
 1285    0000000A 401C                  ADDS            t, t, #1
 1286    0000000C FAE7                  B               NSLEN_LOOP
 1287                           
 1288                           NSLEN_DONE:
 1289                                   TPUSH
 1289                                   PUSHt   // push t to p, pre decrement p
 1289.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1289.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1289.3                         //      STR     t, [p]
 1289.4                                 ENDM
 1289                                   NEXT
 1289.1                         // ARMv7-M Thumb = .+5
 1289.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1289.3                         // ARMv6-M Thumb = .+4
 1289.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1289                                   NEXT1
 1289.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1289.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1289.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1289.4                         // ARMv6-M Thumb = .+4
 1289.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1289.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1289.7                                 ENDM
 1289.8                                 ENDM
 1289.9                                 ENDM
 1290                           
 1291                           
 1292                           //      FORGET FORGET:  ( -- )
 1293                           //      PRINTS NEW HERE IF SUCCESSFUL. FIXED FIG VERSION MEMORY LEAK.
 1294                           //      Executed in the form:
 1295                           //      FORGET CCcc
 1296                           //      Deletes definition named CCcc from the dictionary with all entries
 1297                           //      physically following it. In fig-FORTH, an error message will occur
 1298                           //      if the CURRENT and CONTEXT vocabularies are not currently the same.
 1299                           //      MODIFIED: To update Current along with context and reset DP,
 1300                           //      and execute .DS and .VS
 1301                           
 1302                            SECTION .text : CONST (2)
 1303                           FORGET_NFA:
 1304    00000000 86                    DC8     0x86
 1305    00000001 464F524745            DC8     'FORGE'
 1306    00000006 D4                    DC8     'T'+0x80
 1307    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1308    00000008 ........              DC32    NULLSTRLEN_NFA
 1309                           FORGET:
 1310    0000000C ........              DC32    DOCOL
 1311    00000010 ........              DC32    TICK                    // \ -- pfa ELSE error message
 1312    00000014 ........              DC32    DUP
 1313    00000018 ........00000         DC32    LIT, FLASH_SPAGE        // DONT FORGET FISH WORDS SAVED IN FLASH
                  208          
 1314    00000020 ........              DC32    LESSTHAN
 1315    00000024 .............         DC32    LIT, msg_forget_fish
                  ...          
 1316    0000002C ........              DC32    QERROR                  // \ f nullstr-addr --
 1317    00000030 ........              DC32    DUP
 1318    00000034 ........00001         DC32    LIT, FLASH_PPAGE        // DONT FORGET USER WORDS IN FLASH
                  008          
 1319    0000003C ........              DC32    LESSTHAN
 1320    00000040 .............         DC32    LIT, msg_forget_saved
                  ...          
 1321    00000048 ........              DC32    QERROR                  // \ f nullstr-addr --
 1322                           //      MOVE NFA update of the DP to after Currrent and Context
 1323    0000004C ........              DC32    DUP                     // PFA PFA --
 1324    00000050 ........              DC32    LFA                     // PFA LFA --
 1325                           
 1326                           // VAR space reclamation starts here:
 1327                           // PFA LFA --
 1328    00000054 ........              DC32    TOR                     // LFA_BOT
 1329                           
 1330                           VS_RECVR_LOOP:
 1331    00000058 .............         DC32    LATEST, PFA, LFA        // LFA_TOP
                  ...........  
 1332    00000064 .............         DC32    DUP, AT                 // LFA NEXT_LFA
                  ...          
 1333    0000006C .............         DC32    CURRENT_SV, STORE       // SET NEXT WORD TO CHECK
                  ...          
 1334    00000074 .............         DC32    DUP, FOURP, AT          // GET CFA
                  ...........  
 1335    00000080 .............         DC32    LIT, DOVAR, EQUAL       // IS IT A DOVAR
                  ...........  
 1336    0000008C ........              DC32    ZBRAN
 1337    00000090 14000000              DC32     VS_RECVR_NEXT-.
 1338                                   
 1339    00000094 ........FCFFF         DC32    LIT, -4, UP_SV, PSTORE  // DECREMENT UP
                  FFF..........
                  ......       
 1340                           
 1341                           VS_RECVR_NEXT:
 1342    000000A4 .............         DC32    R, EQUAL
                  ...          
 1343    000000AC ........              DC32    ZBRAN
 1344    000000B0 A8FFFFFF              DC32     VS_RECVR_LOOP-.
 1345                           
 1346    000000B4 ........              DC32    RFROM
 1347                           // VAR SPACE RECLAMATION DONE
 1348                           
 1349                           // PFA LFA --
 1350    000000B8 ........              DC32    AT              // LFA
 1351    000000BC ........              DC32    CURRENT_SV
 1352    000000C0 ........              DC32    STORE
 1353    000000C4 ........              DC32    NFA             // FROM PFA
 1354    000000C8 ........              DC32    DP_SV
 1355    000000CC ........              DC32    STORE
 1356    000000D0 .............         DC32    DOTVARSPACE, DOTDICTSPACE
                  ...          
 1357    000000D8 ........              DC32    SEMIS
 1358                           
 1359                           
 1360                           //      BYE BYE: ( -- ) COLD RESTART WITH SERIAL INITIALIZATION
 1361                           
 1362                            SECTION .text : CONST (2)
 1363                           BYE_NFA:
 1364    00000000 83                    DC8     0x83
 1365    00000001 4259                  DC8     'BY'
 1366    00000003 C5                    DC8     'E'+0x80
 1367                            ALIGNROM 2,0xFFFFFFFF
 1368    00000004 ........              DC32    FORGET_NFA
 1369                           BYE:
 1370    00000008 ........              DC32    .+5
 1371                            SECTION .text : CODE (2)
 1372                           //        B       FM3_COLD      // __iar_program_start
 1373    00000000 ........              B       STM32Fx_COLD_FISH
 1374                            LTORG
 1375                           
 1376                           
 1377                           //      ABORT ABORT:    ( -- )
 1378                           //      Clear the stacks, zero out and execute RUN or QUIT
 1379                           //      DOES NOT RESET DICTIONAIRY. SEE COLD.
 1380                           
 1381                            SECTION .text : CONST (2)
 1382                           ABORT_NFA:
 1383    00000000 85                    DC8     0x85
 1384    00000001 41424F52              DC8     'ABOR'
 1385    00000005 D4                    DC8     'T'+0x80
 1386    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1387    00000008 ........              DC32    BYE_NFA
 1388                           ABORT:
 1389    0000000C ........              DC32    DOCOL
 1390    00000010 ........              DC32    SPSTO
 1391    00000014 ........              DC32    RPSTO
 1392                           #ifdef IO2TP
 1397                           #endif
 1398    00000018 ........              DC32    zero_OUT
 1399                           //      DC32    QSTACK  // IF STACK error abort using QERROR->ERROR
 1400                           
 1401                           // LOOK UP RUN AND EXEC IT
 1402    0000001C .............         DC32    LIT, msg_RUN
                  ...          
 1403    00000024 ........              DC32    LATEST
 1404                           //ABORT_BP1_B4_PFIND_RUN:
 1405                           // DC32 NOOP
 1406    00000028 ........              DC32    PFIND   // 0 OR pfa len 1
 1407    0000002C ........              DC32    ZBRAN
 1408    00000030 10000000              DC32      ABORT_QUIT-.
 1409                           
 1410    00000034 ........              DC32    DROP    // LEN
 1411    00000038 .............         DC32    CFA, EXEC
                  ...          
 1412                           ABORT_QUIT:
 1413                           //      DC32    SEMIC_CREATE // Use ERROR if need to recover from bad definition
 1414                           #ifdef ABORT_STOP_TILL_CO
 1415    00000040 .............         DC32    LIT, ERROR_HALT, AT
                  ...........  
 1416    0000004C ........              DC32    ZBRAN
 1417    00000050 6C000000              DC32      CO_END-.
 1418                           // halt on all errors until "CO" entered
 1419                           // BEGIN
 1420    00000054 .............         DC32    LIT, msg_CO, NULLSTRLEN, TYPE
                  .............
                  ......       
 1421                           NOT_CO:
 1422    00000064 ........              DC32    QKEY
 1423    00000068 ........              DC32    ZBRAN
 1424    0000006C F8FFFFFF              DC32      NOT_CO-.
 1425                           // IF KEY = "C'
 1426    00000070 .............         DC32    KEY, LIT, 43h, EQUAL
                  ...43000000..
                  ......       
 1427    00000080 ........              DC32    ZBRAN
 1428    00000084 E0FFFFFF              DC32      NOT_CO-.
 1429                           // NEXT KEY "0"
 1430    00000088 .............         DC32    KEY, LIT, 4Fh, EQUAL
                  ...4F000000..
                  ......       
 1431    00000098 ........              DC32    ZBRAN
 1432    0000009C C8FFFFFF              DC32      NOT_CO-.
 1433                           // NEXT KEY "Enter"
 1434    000000A0 .............         DC32    KEY, LIT, 0Dh, EQUAL
                  ...0D000000..
                  ......       
 1435    000000B0 ........              DC32    ZBRAN
 1436    000000B4 B0FFFFFF              DC32      NOT_CO-.
 1437                           // UNTIL
 1438    000000B8 ........              DC32    CR
 1439                           CO_END:
 1440                           #endif
 1441    000000BC ........              DC32    QUIT    // OI
 1442                           #ifdef ABORT_STOP_TILL_CO
 1443                           $FISH_CO_MSGS.h
 1444                           #endif
 1445                           
 1446                           //      COLD COLD:      ( -- )  MODIFIED:
 1447                           //      FIGISH SYSTEM COLD = WARM (INIT RAMVARSPACE) -> type signon MSG ->ABORT
 1448                           //      CLEARS DICTIONAIRY. SEE ABORT.
 1449                           
 1450                            SECTION .text : CONST (2)
 1451                           COLD_NFA:
 1452    00000000 84                    DC8     0x84
 1453    00000001 434F4C                DC8     'COL'
 1454    00000004 C4                    DC8     'D'+0x80
 1455    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1456    00000008 ........              DC32    ABORT_NFA
 1457                           COLD:
 1458    0000000C ........              DC32    DOCOL
 1459    00000010 ........              DC32    WARM            // FISH System VAR init.
 1460    00000014 ........              DC32    SIGNON
 1461                           #ifdef ABORT_STOP_TILL_CO
 1462    00000018 ........              DC32    QUIT
 1463                           #else
 1465                           #endif
 1466                           
 1467                           //=============================== WORDCAT ====================================//
 1468                           //NOEXEC HEADERFORWORDCATEGORIES
 1469                           //      WC_FISH_SYS: = FISH System: CATEGORY
 1470                           
 1471                            SECTION .text : CONST (2)
 1472                           WC_FISH_SYS_NFA:
 1473    00000000 90                    DC8     0x80+4+12
 1474    00000001 0D0A                  DC8     0x0D, 0x0A
 1475    00000003 4649534820537         DC8     'FISH System:'
                  97374656D3A  
 1476    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1477    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1478    00000014 ........              DC32    COLD_NFA
 1479                           
 1480                           
 1481                           //----------------------------- DOTSTACK SECTION -------------------------------
 1482                           
 1483                           //      .SH DOTSHEX:    ( -- )
 1484                           //      Nondestructively print items on stack in HEX, preserving base.
 1485                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1486                           
 1487                            SECTION .text : CONST (2)
 1488                           DOTSHEX_NFA:
 1489    00000000 83                    DC8     0x83
 1490    00000001 2E53                  DC8     '.S'
 1491    00000003 C8                    DC8     'H'+0x80
 1492                            ALIGNROM 2,0xFFFFFFFF
 1493    00000004 ........              DC32    WC_FISH_SYS_NFA
 1494                           DOTSHEX:
 1495    00000008 ........              DC32    DOCOL
 1496    0000000C ........10000         DC32    LIT, 16, DOTSBASE
                  000........  
 1497    00000018 ........              DC32    SEMIS
 1498                           
 1499                           
 1500                           //      .SD DOTSDEC:    ( -- )
 1501                           //      Nondestructively print items on stack in DECIMAL, preserving base.
 1502                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1503                           
 1504                            SECTION .text : CONST (2)
 1505                           DOTSDEC_NFA:
 1506    00000000 83                    DC8     0x83
 1507    00000001 2E53                  DC8     '.S'
 1508    00000003 C4                    DC8     'D'+0x80
 1509                            ALIGNROM 2,0xFFFFFFFF
 1510    00000004 ........              DC32    DOTSHEX_NFA
 1511                           DOTSDEC:
 1512    00000008 ........              DC32    DOCOL
 1513    0000000C ........0A000         DC32    LIT, 10, DOTSBASE
                  000........  
 1514    00000018 ........              DC32    SEMIS
 1515                           
 1516                           
 1517                           //      .SB DOTSBIN:    ( -- )
 1518                           //      Nondestructively print items on stack in BINARY, preserving base.
 1519                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1520                           
 1521                            SECTION .text : CONST (2)
 1522                           DOTSBIN_NFA:
 1523    00000000 83                    DC8     0x83
 1524    00000001 2E53                  DC8     '.S'
 1525    00000003 C2                    DC8     'B'+0x80
 1526                            ALIGNROM 2,0xFFFFFFFF
 1527    00000004 ........              DC32    DOTSDEC_NFA
 1528                           DOTSBIN:
 1529    00000008 ........              DC32    DOCOL
 1530    0000000C .............         DC32    TWO, DOTSBASE
                  ...          
 1531    00000014 ........              DC32    SEMIS
 1532                           
 1533                           
 1534                           //      .S DOTS:        ( -- )
 1535                           //      Nondestructively print items on stack in current base.
 1536                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1537                           
 1538                            SECTION .text : CONST (2)
 1539                           DOTS_NFA:
 1540    00000000 82                    DC8     0x82
 1541    00000001 2E                    DC8     '.'
 1542    00000002 D3                    DC8     'S'+0x80
 1543    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1544    00000004 ........              DC32    DOTSBIN_NFA
 1545                           DOTS:
 1546    00000008 ........              DC32    DOCOL
 1547    0000000C .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1548    0000001C .............         DC32    EQUAL, ZEQU, ZBRAN
                  ...........  
 1549    00000028 68000000              DC32    DOTSEND-.                       // IF NOTHING ON STACK
 1550                           
 1551    0000002C ........              DC32    PDOTQ
 1552    00000030 05                    DC8     5
 1553    00000031 544F533E20            DC8     'TOS> '
 1554    00000036 FFFF           ALIGNROM 2,0xFFFFFFFF
 1555                                 
 1556    00000038 .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1557    00000048 ........              DC32    XDO
 1558                           
 1559                           DOTSLOOP:
 1560    0000004C .............         DC32    I, AT
                  ...          
 1561    00000054 .............         DC32    BASE_SV, AT
                  ...          
 1562    0000005C ........0A000         DC32    LIT, 10, EQUAL                  // 
                  000........  
 1563    00000068 ........              DC32    ZBRAN                           // NOT = DECIMAL
 1564    0000006C 10000000              DC32    DBSUSEDUDOT-.
 1565    00000070 ........              DC32    DOT_BASE_SUFFIX
 1566    00000074 ........              DC32    BRAN
 1567    00000078 08000000              DC32    DBSUSEDOT-.
 1568                           
 1569                           DBSUSEDUDOT:
 1570    0000007C ........              DC32    UDOT_BASE_SUFFIX
 1571                           
 1572                           DBSUSEDOT:
 1573    00000080 ........              DC32    SPACE
 1574    00000084 .............         DC32    FOUR, XPLOOP
                  ...          
 1575    0000008C C0FFFFFF              DC32    DOTSLOOP-.
 1576                           
 1577                           DOTSEND:
 1578    00000090 ........              DC32    SEMIS
 1579                           
 1580                           
 1581                           //      2DUP TDUP:      ( n2 n1 -- n2 n1 n2 n1 )
 1582                           //      Duplicate top two stack items. The prefix 2 convention means
 1583                           //      an operation on the top two stack items.
 1584                           
 1585                            SECTION .text : CONST (2)
 1586                           TDUP_NFA:
 1587    00000000 84                    DC8     0x84
 1588    00000001 324455                DC8     '2DU'
 1589    00000004 D0                    DC8     'P'+0x80
 1590    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1591    00000008 ........              DC32    DOTS_NFA
 1592                           TDUP:
 1593    0000000C ........              DC32    .+5
 1594                            SECTION .text : CODE (2)
 1595                           // TDUP: OPT by picking pops
 1596    00000000 3868                  LDR     t, [p]          //
 1597    00000002 7A68                  LDR     w, [p, #4]      //
 1598                                   DPUSH                   // 
 1598                                   PUSHw   // push w to p, post decrement p
 1598.1  00000004 47F8042D              STR     w, [p, #-4]!
 1598.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1598.3                         //      STR     w, [p]
 1598.4                                 ENDM
 1598                                   TPUSH
 1598                                   PUSHt   // push t to p, pre decrement p
 1598.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1598.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1598.3                         //      STR     t, [p]
 1598.4                                 ENDM
 1598                                   NEXT
 1598.1                         // ARMv7-M Thumb = .+5
 1598.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1598.3                         // ARMv6-M Thumb = .+4
 1598.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1598                                   NEXT1
 1598.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1598.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1598.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1598.4                         // ARMv6-M Thumb = .+4
 1598.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1598.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1598.7                                 ENDM
 1598.8                                 ENDM
 1598.9                                 ENDM
 1598.10                                ENDM
 1599                           
 1600                           
 1601                           //      -DUP ZNDUP:     ( n1 -- n1 (if zero)
 1602                           //                      ( n1 -- n1 n1 (non-zero)
 1603                           //      Reproduce n1 only if it is non-zero. Used in type andSPACES.
 1604                           //      This is usually used to copy a value just before IF, to eliminate
 1605                           //      the need for an ELSE part to drop it. 
 1606                           
 1607                            SECTION .text : CONST (2)
 1608                           DDUP_NFA:
 1609    00000000 84                    DC8     0x84
 1610    00000001 2D4455                DC8     '-DU'
 1611    00000004 D0                    DC8     'P'+0x80
 1612    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1613    00000008 ........              DC32    TDUP_NFA
 1614                           ZNDUP:
 1615    0000000C ........              DC32    DOCOL
 1616    00000010 ........              DC32    DUP
 1617    00000014 ........              DC32    ZBRAN   // IF
 1618    00000018 08000000              DC32    DDUP1-.
 1619                           
 1620    0000001C ........              DC32    DUP     //endif
 1621                           DDUP1:
 1622    00000020 ........              DC32    SEMIS
 1623                           
 1624                           
 1625                           //      ROT ROT: ( nl n2 n3 --- n2 n3 nl )
 1626                           //      Rotate the top three values on the stack, bringing the third to the top.
 1627                           
 1628                            SECTION .text : CONST (2)
 1629                           ROT_NFA:
 1630    00000000 83                    DC8     0x83
 1631    00000001 524F                  DC8     'RO'
 1632    00000003 D4                    DC8     'T'+0x80
 1633                            ALIGNROM 2,0xFFFFFFFF
 1634    00000004 ........              DC32    DDUP_NFA
 1635                           ROT:
 1636    00000008 ........              DC32    .+5
 1637                            SECTION .text : CODE (2)
 1638                                   POP2w
 1638.1  00000000 57F8042B              LDR     w, [p],#4
 1638.2                         //      LDR     w, [p]
 1638.3                         //      ADDS    p, p, #4
 1638.4                                 ENDM
 1639                                   POP2n
 1639.1  00000004 57F8041B              LDR     n, [p],#4
 1639.2                         //      LDR     n, [p]
 1639.3                         //      ADDS    p, p, #4
 1639.4                                 ENDM
 1640                           #ifdef TOSCT
 1642                           #endif
 1643                                   POP2t
 1643.1  00000008 57F8040B              LDR     t, [p],#4       // Post-increment
 1643.2                         //#ifndef TOSCT
 1643.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1643.4                         //#endif
 1643.5                         //      ADDS    p, p, #4
 1643.6                                 ENDM
 1644                                   PUSHn
 1644.1  0000000C 47F8041D              STR     n, [p, #-4]!
 1644.2                         //      SUBS    p, p, #4        // push n to p, pre decrement p
 1644.3                         //      STR     n, [p]
 1644.4                                 ENDM
 1645                                   DPUSH                   //  --  LSW MSW )
 1645                                   PUSHw   // push w to p, post decrement p
 1645.1  00000010 47F8042D              STR     w, [p, #-4]!
 1645.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1645.3                         //      STR     w, [p]
 1645.4                                 ENDM
 1645                                   TPUSH
 1645                                   PUSHt   // push t to p, pre decrement p
 1645.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1645.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1645.3                         //      STR     t, [p]
 1645.4                                 ENDM
 1645                                   NEXT
 1645.1                         // ARMv7-M Thumb = .+5
 1645.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1645.3                         // ARMv6-M Thumb = .+4
 1645.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1645                                   NEXT1
 1645.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1645.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1645.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1645.4                         // ARMv6-M Thumb = .+4
 1645.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1645.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1645.7                                 ENDM
 1645.8                                 ENDM
 1645.9                                 ENDM
 1645.10                                ENDM
 1646                           
 1647                           
 1648                           //      I I:    ( -- n )
 1649                           //      Used within a DO-LOOP to copy the loop index to the stack. Other use
 1650                           //      is implementation dependent.
 1651                           //      See R.
 1652                           
 1653                            SECTION .text : CONST (2)
 1654                           I_NFA:
 1655    00000000 81                    DC8     0x81
 1656    00000001 C9                    DC8     'I'+0x80
 1657    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1658    00000004 ........              DC32    ROT_NFA
 1659                           I:
 1660    00000008 ........              DC32    .+5
 1661                            SECTION .text : CODE (2)
 1662    00000000 3068                  LDR     t, [r]  // GET INDEX VALUE
 1663                                   TPUSH
 1663                                   PUSHt   // push t to p, pre decrement p
 1663.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1663.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1663.3                         //      STR     t, [p]
 1663.4                                 ENDM
 1663                                   NEXT
 1663.1                         // ARMv7-M Thumb = .+5
 1663.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1663.3                         // ARMv6-M Thumb = .+4
 1663.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1663                                   NEXT1
 1663.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1663.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1663.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1663.4                         // ARMv6-M Thumb = .+4
 1663.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1663.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1663.7                                 ENDM
 1663.8                                 ENDM
 1663.9                                 ENDM
 1664                           
 1665                           
 1666                           //      SP@ SPAT:       ( -- addr )
 1667                           //      \ -- addr = Current TOP of the parameter stack (p) )
 1668                           //      Place the address of the TOP of the parameter stack (p)
 1669                           //      on the parameter stack (p) as it was before RP@ was executed.
 1670                           //      e.g.  1  2  SP@  @  .   .   .     would type 2  2  1
 1671                           
 1672                            SECTION .text : CONST (2)
 1673                           SPAT_NFA:
 1674    00000000 83                    DC8     0x83
 1675    00000001 5350                  DC8     'SP'
 1676    00000003 C0                    DC8     '@'+0x80
 1677                            ALIGNROM 2,0xFFFFFFFF
 1678    00000004 ........              DC32    I_NFA
 1679                           SPAT:
 1680    00000008 ........              DC32    .+5
 1681                            SECTION .text : CODE (2)
 1682    00000000 3846                  MOV     t, p
 1683                                   TPUSH
 1683                                   PUSHt   // push t to p, pre decrement p
 1683.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1683.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1683.3                         //      STR     t, [p]
 1683.4                                 ENDM
 1683                                   NEXT
 1683.1                         // ARMv7-M Thumb = .+5
 1683.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1683.3                         // ARMv6-M Thumb = .+4
 1683.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1683                                   NEXT1
 1683.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1683.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1683.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1683.4                         // ARMv6-M Thumb = .+4
 1683.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1683.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1683.7                                 ENDM
 1683.8                                 ENDM
 1683.9                                 ENDM
 1684                           
 1685                           
 1686                           //      RP@ RPAT:       ( -- addr )
 1687                           //      \ -- addr = Current TOP of the Return Stack (r) )
 1688                           //      Place the address of the TOP of the return stack (r)
 1689                           //      on the parameter stack (p) as it was before RP@ was executed.
 1690                           //      e.g.  1 >R  2 >R  RP@  @  .   .   . would type 2  2  1
 1691                           
 1692                            SECTION .text : CONST (2)
 1693                           RPAT_NFA:
 1694    00000000 83                    DC8     0x83
 1695    00000001 5250                  DC8     'RP'
 1696    00000003 C0                    DC8     '@'+0x80
 1697                            ALIGNROM 2,0xFFFFFFFF
 1698    00000004 ........              DC32    SPAT_NFA
 1699                           RPAT:
 1700    00000008 ........              DC32    .+5
 1701                            SECTION .text : CODE (2)
 1702    00000000 3046                  MOV     t, r
 1703                                   TPUSH
 1703                                   PUSHt   // push t to p, pre decrement p
 1703.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1703.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1703.3                         //      STR     t, [p]
 1703.4                                 ENDM
 1703                                   NEXT
 1703.1                         // ARMv7-M Thumb = .+5
 1703.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1703.3                         // ARMv6-M Thumb = .+4
 1703.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1703                                   NEXT1
 1703.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1703.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1703.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1703.4                         // ARMv6-M Thumb = .+4
 1703.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1703.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1703.7                                 ENDM
 1703.8                                 ENDM
 1703.9                                 ENDM
 1704                           
 1705                           
 1706                           //      LEAVE LEAVE:    ( -- )
 1707                           //      Force termination of a DO-LOOP at the next opportunity by setting
 1708                           //      the loop limit equal to the current value of the index. The index
 1709                           //      itself remains unchanged, and execution proceeds until LOOP
 1710                           //      or +LOOP is encountered.
 1711                           
 1712                            SECTION .text : CONST (2)
 1713                           LEAVE_NFA:
 1714    00000000 85                    DC8     0x85
 1715    00000001 4C454156              DC8     'LEAV'
 1716    00000005 C5                    DC8     'E'+0x80
 1717    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1718                           //      DC32    RPSTO_NFA
 1719    00000008 ........              DC32    RPAT_NFA
 1720                           LEAVE:
 1721    0000000C ........              DC32    .+5
 1722                            SECTION .text : CODE (2)
 1723    00000000 3268                  LDR     w, [r]          // GET Index
 1724    00000002 7260                  STR     w, [r, #4]  // Store it at Limit
 1725                                   NEXT
 1725.1                         // ARMv7-M Thumb = .+5
 1725.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1725.3                         // ARMv6-M Thumb = .+4
 1725.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1725                                   NEXT1
 1725.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1725.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1725.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1725.4                         // ARMv6-M Thumb = .+4
 1725.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1725.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1725.7                                 ENDM
 1725.8                                 ENDM
 1726                           
 1727                           
 1728                           //      R> RFROM:       ( -- n )
 1729                           //      Remove the top value from the return stack and leave it on the
 1730                           //      computation stack. See >R and R.
 1731                           
 1732                            SECTION .text : CONST (2)
 1733                           RFROM_NFA:
 1734    00000000 82                    DC8     0x82
 1735    00000001 52                    DC8     'R'
 1736    00000002 BE                    DC8     '>'+0x80
 1737    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1738    00000004 ........              DC32    LEAVE_NFA
 1739                           RFROM:
 1740    00000008 ........              DC32    .+5
 1741                            SECTION .text : CODE (2)
 1742                                   POPr2t
 1742.1  00000000 56F8040B              LDR     t, [r],#4
 1742.2                         //      LDR     t, [r]
 1742.3                         //      ADDS    r, r, #4
 1742.4                                 ENDM
 1743                                   TPUSH
 1743                                   PUSHt   // push t to p, pre decrement p
 1743.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1743.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1743.3                         //      STR     t, [p]
 1743.4                                 ENDM
 1743                                   NEXT
 1743.1                         // ARMv7-M Thumb = .+5
 1743.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1743.3                         // ARMv6-M Thumb = .+4
 1743.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1743                                   NEXT1
 1743.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1743.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1743.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1743.4                         // ARMv6-M Thumb = .+4
 1743.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1743.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1743.7                                 ENDM
 1743.8                                 ENDM
 1743.9                                 ENDM
 1744                           
 1745                           
 1746                           //      R R:    ( -- n )
 1747                           //      Copy the top of the return stack to the computation stack.
 1748                           
 1749                            SECTION .text : CONST (2)
 1750                           R_NFA:
 1751    00000000 81                    DC8     0x81
 1752    00000001 D2                    DC8     'R'+0x80
 1753    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1754    00000004 ........              DC32    RFROM_NFA
 1755                           R:
 1756    00000008 ........              DC32    .+5
 1757                            SECTION .text : CODE (2)
 1758    00000000 3068                  LDR     t, [r]  // Get Index
 1759                                   TPUSH
 1759                                   PUSHt   // push t to p, pre decrement p
 1759.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1759.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1759.3                         //      STR     t, [p]
 1759.4                                 ENDM
 1759                                   NEXT
 1759.1                         // ARMv7-M Thumb = .+5
 1759.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1759.3                         // ARMv6-M Thumb = .+4
 1759.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1759                                   NEXT1
 1759.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1759.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1759.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1759.4                         // ARMv6-M Thumb = .+4
 1759.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1759.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1759.7                                 ENDM
 1759.8                                 ENDM
 1759.9                                 ENDM
 1760                           
 1761                           //      >R TOR: ( n -- )
 1762                           //      Remove a number from the computation stack and place as the most
 1763                           //      accessable on the return stack. Use should be balanced with R> in
 1764                           //      the same definition.
 1765                           
 1766                            SECTION .text : CONST (2)
 1767                           TOR_NFA:
 1768    00000000 82                    DC8     0x82
 1769    00000001 3E                    DC8     '>'
 1770    00000002 D2                    DC8     'R'+0x80
 1771    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1772    00000004 ........              DC32    R_NFA
 1773                           TOR:
 1774    00000008 ........              DC32    .+5
 1775                            SECTION .text : CODE (2)
 1776                                   POP2n   // preserve TOS
 1776.1  00000000 57F8041B              LDR     n, [p],#4
 1776.2                         //      LDR     n, [p]
 1776.3                         //      ADDS    p, p, #4
 1776.4                                 ENDM
 1777                                   PUSHn2r
 1777.1  00000004 46F8041D              STR     n, [r, #-4]!
 1777.2                         //      SUBS    r, r, #4        //  push t to r, pre decrement r
 1777.3                         //      STR     n, [r]
 1777.4                                 ENDM
 1778                           #ifdef TOSCT
 1780                           #endif
 1781                                   NEXT
 1781.1                         // ARMv7-M Thumb = .+5
 1781.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1781.3                         // ARMv6-M Thumb = .+4
 1781.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1781                                   NEXT1
 1781.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1781.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1781.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1781.4                         // ARMv6-M Thumb = .+4
 1781.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1781.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1781.7                                 ENDM
 1781.8                                 ENDM
 1782                           
 1783                           
 1784                           //      OVER OVER:      ( nl n2 -- nl n2 n1 )
 1785                           //      Copy the second stack value, placing it as the new top.
 1786                           
 1787                            SECTION .text : CONST (2)
 1788                           OVER_NFA:
 1789    00000000 84                    DC8     0x84
 1790    00000001 4F5645                DC8     'OVE'
 1791    00000004 D2                    DC8     'R'+0x80
 1792    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1793    00000008 ........              DC32    TOR_NFA
 1794                           OVER:
 1795    0000000C ........              DC32    .+5
 1796                            SECTION .text : CODE (2)
 1797                                   POP2w           // n2
 1797.1  00000000 57F8042B              LDR     w, [p],#4
 1797.2                         //      LDR     w, [p]
 1797.3                         //      ADDS    p, p, #4
 1797.4                                 ENDM
 1798                           #ifdef TOSCT
 1802                           #else
 1803                                   POP2t           // n1
 1803.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1803.2                         //#ifndef TOSCT
 1803.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1803.4                         //#endif
 1803.5                         //      ADDS    p, p, #4
 1803.6                                 ENDM
 1804                           #endif
 1805                                   PUSHt           // -- n1 )
 1805.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1805.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1805.3                         //      STR     t, [p]
 1805.4                                 ENDM
 1806                                   DPUSH           //  --  LSW MSW )
 1806                                   PUSHw   // push w to p, post decrement p
 1806.1  0000000C 47F8042D              STR     w, [p, #-4]!
 1806.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1806.3                         //      STR     w, [p]
 1806.4                                 ENDM
 1806                                   TPUSH
 1806                                   PUSHt   // push t to p, pre decrement p
 1806.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1806.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1806.3                         //      STR     t, [p]
 1806.4                                 ENDM
 1806                                   NEXT
 1806.1                         // ARMv7-M Thumb = .+5
 1806.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1806.3                         // ARMv6-M Thumb = .+4
 1806.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1806                                   NEXT1
 1806.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1806.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1806.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1806.4                         // ARMv6-M Thumb = .+4
 1806.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1806.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1806.7                                 ENDM
 1806.8                                 ENDM
 1806.9                                 ENDM
 1806.10                                ENDM
 1807                           
 1808                           
 1809                           //      DROP DROP:      ( n1 -- )
 1810                           //      Drop n1 from the stack.
 1811                           
 1812                            SECTION .text : CONST (2)
 1813                           DROP_NFA:
 1814    00000000 84                    DC8     0x84
 1815    00000001 44524F                DC8     'DRO'
 1816    00000004 D0                    DC8     'P'+0x80
 1817    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1818    00000008 ........              DC32    OVER_NFA
 1819                           DROP:
 1820    0000000C ........              DC32    .+5
 1821                            SECTION .text : CODE (2)
 1822                           #ifdef TOSCT
 1826                           #else // DROP:
 1827                           //        POP2t         // Opt to just do p
 1828    00000000 3F1D                  ADDS    p, p, #4
 1829                           
 1830                           #endif
 1831                                   NEXT
 1831.1                         // ARMv7-M Thumb = .+5
 1831.2  00000002 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1831.3                         // ARMv6-M Thumb = .+4
 1831.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1831                                   NEXT1
 1831.1  00000006 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1831.2  0000000A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1831.3  0000000E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1831.4                         // ARMv6-M Thumb = .+4
 1831.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1831.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1831.7                                 ENDM
 1831.8                                 ENDM
 1832                           
 1833                           
 1834                           //      SWAP SWAP:      ( nl n2 -- n2 n1 )
 1835                           //      Exchange the top two values On the stack.
 1836                           
 1837                            SECTION .text : CONST (2)
 1838                           SWAP_NFA:
 1839    00000000 84                    DC8     0x84
 1840    00000001 535741                DC8     'SWA'
 1841    00000004 D0                    DC8     'P'+0x80
 1842    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1843    00000008 ........              DC32    DROP_NFA
 1844                           SWAP:
 1845    0000000C ........              DC32    .+5
 1846                            SECTION .text : CODE (2)
 1847                           #ifdef TOSCT
 1851                           #else // SWAP:
 1852                                   POP2w           // n2
 1852.1  00000000 57F8042B              LDR     w, [p],#4
 1852.2                         //      LDR     w, [p]
 1852.3                         //      ADDS    p, p, #4
 1852.4                                 ENDM
 1853                                   POP2t           // n1
 1853.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1853.2                         //#ifndef TOSCT
 1853.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1853.4                         //#endif
 1853.5                         //      ADDS    p, p, #4
 1853.6                                 ENDM
 1854                           #endif
 1855                                   DPUSH           //  --  LSW MSW )
 1855                                   PUSHw   // push w to p, post decrement p
 1855.1  00000008 47F8042D              STR     w, [p, #-4]!
 1855.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1855.3                         //      STR     w, [p]
 1855.4                                 ENDM
 1855                                   TPUSH
 1855                                   PUSHt   // push t to p, pre decrement p
 1855.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1855.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1855.3                         //      STR     t, [p]
 1855.4                                 ENDM
 1855                                   NEXT
 1855.1                         // ARMv7-M Thumb = .+5
 1855.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1855.3                         // ARMv6-M Thumb = .+4
 1855.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1855                                   NEXT1
 1855.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1855.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1855.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1855.4                         // ARMv6-M Thumb = .+4
 1855.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1855.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1855.7                                 ENDM
 1855.8                                 ENDM
 1855.9                                 ENDM
 1855.10                                ENDM
 1856                           
 1857                           
 1858                           //      DUP DUP:        ( n1 -- n1 n1 )
 1859                           //      Duplicate the value n1 on the stack.
 1860                           
 1861                            SECTION .text : CONST (2)
 1862                           DUP_NFA:
 1863    00000000 83                    DC8     0x83
 1864    00000001 4455                  DC8     'DU'
 1865    00000003 D0                    DC8     'P'+0x80
 1866                            ALIGNROM 2,0xFFFFFFFF
 1867    00000004 ........              DC32    SWAP_NFA
 1868                           DUP:
 1869    00000008 ........              DC32    .+5
 1870                            SECTION .text : CODE (2)
 1871                           //#ifdef TOSCT
 1872                           // NO NEED TO REFRESH t ?
 1873                           //#else DUP:
 1874                           // OPT by picking pops
 1875    00000000 3868                  LDR     t, [p]
 1876                           //#endif
 1877                                   TPUSH
 1877                                   PUSHt   // push t to p, pre decrement p
 1877.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1877.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1877.3                         //      STR     t, [p]
 1877.4                                 ENDM
 1877                                   NEXT
 1877.1                         // ARMv7-M Thumb = .+5
 1877.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1877.3                         // ARMv6-M Thumb = .+4
 1877.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1877                                   NEXT1
 1877.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1877.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1877.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1877.4                         // ARMv6-M Thumb = .+4
 1877.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1877.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1877.7                                 ENDM
 1877.8                                 ENDM
 1877.9                                 ENDM
 1878                           
 1879                           //=============================== WORDCAT ====================================//
 1880                           //NOEXEC HEADERFORWORDCATEGORIES
 1881                           //      WC_STACK_NFA = Stack Stuff: CATEGORY
 1882                           
 1883                            SECTION .text : CONST (2)
 1884                           WC_STACK_NFA:
 1885    00000000 90                    DC8     0x80+4+12
 1886    00000001 0D0A                  DC8     0x0D, 0x0A
 1887    00000003 537461636B205         DC8     'Stack Stuff:'
                  3747566663A  
 1888    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1889    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1890    00000014 ........              DC32    DUP_NFA
 1891                           
 1892                           
 1893                           //      ANDBITS ANDBITS:        ( addr val -- )
 1894                           
 1895                            SECTION .text : CONST (2)
 1896                           ANDBITS_NFA:
 1897    00000000 87                    DC8     0x87
 1898    00000001 414E44424954          DC8     'ANDBIT'
 1899    00000007 D3                    DC8     'S'+0x80
 1900                            ALIGNROM 2,0xFFFFFFFF
 1901    00000008 ........              DC32    WC_STACK_NFA
 1902                           ANDBITS:
 1903    0000000C ........              DC32    .+5
 1904                            SECTION .text : CODE (2)
 1905                                   POPp2w          // val
 1905.1                                 // as in xeq token on ToS setup for exec
 1905.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1905.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1905.4                                 ENDM
 1906                                   POP2n           // addr
 1906.1  00000004 57F8041B              LDR     n, [p],#4
 1906.2                         //      LDR     n, [p]
 1906.3                         //      ADDS    p, p, #4
 1906.4                                 ENDM
 1907    00000008 0868                  LDR     t, [n]  // read [val]
 1908    0000000A 1040                  ANDS    t, t, w // modify val
 1909    0000000C 0860                  STR     t, [n]  // Write val
 1910                                   NEXT
 1910.1                         // ARMv7-M Thumb = .+5
 1910.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1910.3                         // ARMv6-M Thumb = .+4
 1910.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1910                                   NEXT1
 1910.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1910.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1910.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1910.4                         // ARMv6-M Thumb = .+4
 1910.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1910.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1910.7                                 ENDM
 1910.8                                 ENDM
 1911                           
 1912                           
 1913                           //      SETBITS SETBITS:        ( addr val -- ) OR val bits into addr.
 1914                           //      See also CLRBITS.
 1915                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1916                           
 1917                            SECTION .text : CONST (2)
 1918                           SETBITS_NFA:
 1919    00000000 87                    DC8     0x87
 1920    00000001 534554424954          DC8     'SETBIT'
 1921    00000007 D3                    DC8     'S'+0x80
 1922                            ALIGNROM 2,0xFFFFFFFF
 1923    00000008 ........              DC32    ANDBITS_NFA
 1924                           SETBITS:
 1925    0000000C ........              DC32    .+5
 1926                            SECTION .text : CODE (2)
 1927                                   POPp2w          // val
 1927.1                                 // as in xeq token on ToS setup for exec
 1927.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1927.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1927.4                                 ENDM
 1928                                   POP2n           // addr
 1928.1  00000004 57F8041B              LDR     n, [p],#4
 1928.2                         //      LDR     n, [p]
 1928.3                         //      ADDS    p, p, #4
 1928.4                                 ENDM
 1929    00000008 0868                  LDR     t, [n]  // read[val]
 1930    0000000A 1043                  ORRS    t, t, w // modify val
 1931    0000000C 0860                  STR     t, [n]  // Write val
 1932                                   NEXT
 1932.1                         // ARMv7-M Thumb = .+5
 1932.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1932.3                         // ARMv6-M Thumb = .+4
 1932.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1932                                   NEXT1
 1932.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1932.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1932.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1932.4                         // ARMv6-M Thumb = .+4
 1932.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1932.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1932.7                                 ENDM
 1932.8                                 ENDM
 1933                           
 1934                           
 1935                           //      CLRBITS CLRBITS:        ( addr val -- )
 1936                           //      XOR val bits into addr. See also SETBITS.
 1937                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1938                           
 1939                            SECTION .text : CONST (2)
 1940                           CLRBITS_NFA:
 1941    00000000 87                    DC8     0x87
 1942    00000001 434C52424954          DC8     'CLRBIT'
 1943    00000007 D3                    DC8     'S'+0x80
 1944                            ALIGNROM 2,0xFFFFFFFF
 1945    00000008 ........              DC32    SETBITS_NFA
 1946                           CLRBITS:
 1947    0000000C ........              DC32    .+5
 1948                            SECTION .text : CODE (2)
 1949                                   POPp2w                  // val
 1949.1                                 // as in xeq token on ToS setup for exec
 1949.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1949.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1949.4                                 ENDM
 1950                                   POP2n                   // addr
 1950.1  00000004 57F8041B              LDR     n, [p],#4
 1950.2                         //      LDR     n, [p]
 1950.3                         //      ADDS    p, p, #4
 1950.4                                 ENDM
 1951    00000008 0868                  LDR     t, [n]          // read [val]
 1952    0000000A 9043                  BICS    t, t, w         // modify val  - AND-NOT
 1953    0000000C 0860                  STR     t, [n]          // write val
 1954                                   NEXT
 1954.1                         // ARMv7-M Thumb = .+5
 1954.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1954.3                         // ARMv6-M Thumb = .+4
 1954.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1954                                   NEXT1
 1954.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1954.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1954.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1954.4                         // ARMv6-M Thumb = .+4
 1954.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1954.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1954.7                                 ENDM
 1954.8                                 ENDM
 1955                           
 1956                           
 1957                           //      CMOVE CMOVE:    ( from to count -- )
 1958                           //      Move the specified quantity of bytes beginning at address from to
 1959                           //      address to. The contents of address from is moved first proceeding
 1960                           //      toward high memory. Further specification is necessary on word
 1961                           //      addressing computers.
 1962                           
 1963                            SECTION .text : CONST (2)
 1964                           CMOVE_NFA:
 1965    00000000 85                    DC8     0x85
 1966    00000001 434D4F56              DC8     'CMOV'
 1967    00000005 C5                    DC8     'E'+0x80
 1968    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1969    00000008 ........              DC32    CLRBITS_NFA
 1970                           CMOVE:
 1971    0000000C ........              DC32    .+5
 1972                            SECTION .text : CODE (2)
 1973                                   POP2n //    ldr n, [p],#4      //COUNT
 1973.1  00000000 57F8041B              LDR     n, [p],#4
 1973.2                         //      LDR     n, [p]
 1973.3                         //      ADDS    p, p, #4
 1973.4                                 ENDM
 1974                                   POP2w //    ldr w, [p],#4      //DEST
 1974.1  00000004 57F8042B              LDR     w, [p],#4
 1974.2                         //      LDR     w, [p]
 1974.3                         //      ADDS    p, p, #4
 1974.4                                 ENDM
 1975                                   POP2x //    ldr x, [p],#4      //SOURCE
 1975.1  00000008 57F8043B              LDR     x, [p],#4
 1975.2                         //      LDR     x, [p]
 1975.3                         //      ADDS    p, p, #4
 1975.4                                 ENDM
 1976    0000000C 0029                  CMP     n, #0
 1977    0000000E 07D0                  BEQ     CM2
 1978                           CM1:
 1979                           //not for THUMB
 1980                           //strcpy  LDRB R2, [R1], #1
 1981                           //        STRB R2, [R0], #1
 1982                           //        TST R2, R2      // repeat if R2 is nonzero
 1983                           //        BNE strcpy
 1984    00000010 1878                  LDRB    t, [x]
 1985    00000012 1070                  STRB    t, [w]
 1986    00000014 491E                  SUBS    n, n, #1
 1987    00000016 0029                  CMP     n, #0
 1988    00000018 02D0                  BEQ     CM2
 1989                           
 1990    0000001A 521C                  ADDS    w, w, #1
 1991    0000001C 5B1C                  ADDS    x, x, #1
 1992    0000001E F7D1                  BNE     CM1
 1993                           CM2:
 1994                           #ifdef TOSCT
 1996                           #endif
 1997                                   NEXT
 1997.1                         // ARMv7-M Thumb = .+5
 1997.2  00000020 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1997.3                         // ARMv6-M Thumb = .+4
 1997.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1997                                   NEXT1
 1997.1  00000024 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1997.2  00000028 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1997.3  0000002C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1997.4                         // ARMv6-M Thumb = .+4
 1997.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1997.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1997.7                                 ENDM
 1997.8                                 ENDM
 1998                           
 1999                           
 2000                           //      FILL FILL:      ( addr quan b -- )
 2001                           //      Fill memory at the address with the specified quantity of bytes b.
 2002                           
 2003                            SECTION .text : CONST (2)
 2004                           FILL_NFA:
 2005    00000000 84                    DC8     0x84
 2006    00000001 46494C                DC8     'FIL'
 2007    00000004 CC                    DC8     'L'+0x80
 2008    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2009    00000008 ........              DC32    CMOVE_NFA
 2010                           FILL:
 2011    0000000C ........              DC32    .+5
 2012                            SECTION .text : CODE (2)
 2013                                   POP2t                   // Fill CHAR
 2013.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2013.2                         //#ifndef TOSCT
 2013.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2013.4                         //#endif
 2013.5                         //      ADDS    p, p, #4
 2013.6                                 ENDM
 2014                                   POP2n                   // Fill COUNT
 2014.1  00000004 57F8041B              LDR     n, [p],#4
 2014.2                         //      LDR     n, [p]
 2014.3                         //      ADDS    p, p, #4
 2014.4                                 ENDM
 2015                                   POP2w                   // Beginning ADDR
 2015.1  00000008 57F8042B              LDR     w, [p],#4
 2015.2                         //      LDR     w, [p]
 2015.3                         //      ADDS    p, p, #4
 2015.4                                 ENDM
 2016    0000000C 0029                  CMP     n, #0
 2017    0000000E 04D0                  BEQ     FEND            // Count is zero
 2018    00000010 8B18                  ADDS    x, n, w
 2019                           FLOOP:
 2020    00000012 1070                  STRB    t, [w]
 2021    00000014 521C                  ADDS    w, w, #1
 2022    00000016 9A42                  CMP     w, x
 2023    00000018 FBD1                  BNE     FLOOP
 2024                           FEND:
 2025                           #ifdef TOSCT
 2027                           #endif
 2028                                   NEXT
 2028.1                         // ARMv7-M Thumb = .+5
 2028.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2028.3                         // ARMv6-M Thumb = .+4
 2028.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2028                                   NEXT1
 2028.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2028.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2028.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2028.4                         // ARMv6-M Thumb = .+4
 2028.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2028.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2028.7                                 ENDM
 2028.8                                 ENDM
 2029                           
 2030                           
 2031                           //      ERASE ERASE:    ( addr n -- )
 2032                           //      Clear a region of memory to zero from addr over n addresses.
 2033                           
 2034                            SECTION .text : CONST (2)
 2035                           ERASE_NFA:
 2036    00000000 85                    DC8     0x85
 2037    00000001 45524153              DC8     'ERAS'
 2038    00000005 C5                    DC8     'E'+0x80
 2039    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2040    00000008 ........              DC32    FILL_NFA
 2041                           ERASE:
 2042    0000000C ........              DC32    DOCOL
 2043    00000010 ........              DC32    ZERO
 2044    00000014 ........              DC32    FILL
 2045    00000018 ........              DC32    SEMIS
 2046                           
 2047                           
 2048                           //      BLANKS BLANKS:  ( addr count -- )
 2049                           //      Fill an area of memory beginning at addr with blanks (0x20).
 2050                           
 2051                            SECTION .text : CONST (2)
 2052                           BLANKS_NFA:
 2053    00000000 86                    DC8     0x86
 2054    00000001 424C414E4B            DC8     'BLANK'
 2055    00000006 D3                    DC8     'S'+0x80
 2056    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2057    00000008 ........              DC32    ERASE_NFA
 2058                           BLANKS:
 2059    0000000C ........              DC32    DOCOL
 2060    00000010 ........              DC32    BLANK
 2061    00000014 ........              DC32    FILL
 2062    00000018 ........              DC32    SEMIS
 2063                           
 2064                           
 2065                           //      +! PSTORE:      ( n addr -- )
 2066                           //      Add n to the value at the address.
 2067                           //      Pronounced Plus Store
 2068                           
 2069                            SECTION .text : CONST (2)
 2070                           PSTORE_NFA:
 2071    00000000 82                    DC8     0x82
 2072    00000001 2B                    DC8     '+'
 2073    00000002 A1                    DC8     '!'+0x80
 2074    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2075    00000004 ........              DC32    BLANKS_NFA
 2076                           PSTORE:
 2077    00000008 ........              DC32    .+5
 2078                            SECTION .text : CODE (2)
 2079                                   POP2n                   // ADDRESS
 2079.1  00000000 57F8041B              LDR     n, [p],#4
 2079.2                         //      LDR     n, [p]
 2079.3                         //      ADDS    p, p, #4
 2079.4                                 ENDM
 2080                           #ifdef TOSCT
 2082                           #endif
 2083                                   POP2t                   // INCREMENT
 2083.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 2083.2                         //#ifndef TOSCT
 2083.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2083.4                         //#endif
 2083.5                         //      ADDS    p, p, #4
 2083.6                                 ENDM
 2084    00000008 0A68                  LDR     w, [n]
 2085    0000000A 8018                  ADDS    t, t, w
 2086    0000000C 0860                  STR     t, [n]
 2087                                   NEXT
 2087.1                         // ARMv7-M Thumb = .+5
 2087.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2087.3                         // ARMv6-M Thumb = .+4
 2087.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2087                                   NEXT1
 2087.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2087.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2087.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2087.4                         // ARMv6-M Thumb = .+4
 2087.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2087.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2087.7                                 ENDM
 2087.8                                 ENDM
 2088                           
 2089                           
 2090                           //      @ AT:   ( addr -- n )
 2091                           //      Read 32 bit contents of address to TOS.
 2092                           //      Pronounced Fetch, as in Fetch word at addr.
 2093                           
 2094                            SECTION .text : CONST (2)
 2095                           AT_NFA:
 2096    00000000 81                    DC8     0x81
 2097    00000001 C0                    DC8     '@'+0x80 //C0H
 2098    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2099                           //      DC32    TOGGLE_NFA
 2100    00000004 ........              DC32    PSTORE_NFA
 2101                           AT:
 2102    00000008 ........              DC32    .+5
 2103                            SECTION .text : CODE (2)
 2104                           //#ifdef TOSCT
 2105                           //        LDR     t, [t]
 2106                           //        STR     t, [p]
 2107                           //        NEXT
 2108                           //#else AT:
 2109                                   POP2n
 2109.1  00000000 57F8041B              LDR     n, [p],#4
 2109.2                         //      LDR     n, [p]
 2109.3                         //      ADDS    p, p, #4
 2109.4                                 ENDM
 2110    00000004 0868                  LDR     t, [n]
 2111                                   TPUSH
 2111                                   PUSHt   // push t to p, pre decrement p
 2111.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 2111.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 2111.3                         //      STR     t, [p]
 2111.4                                 ENDM
 2111                                   NEXT
 2111.1                         // ARMv7-M Thumb = .+5
 2111.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2111.3                         // ARMv6-M Thumb = .+4
 2111.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2111                                   NEXT1
 2111.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2111.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2111.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2111.4                         // ARMv6-M Thumb = .+4
 2111.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2111.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2111.7                                 ENDM
 2111.8                                 ENDM
 2111.9                                 ENDM
 2112                           //#endif
 2113                                   
 2114                           //      C@ CAT: ( addr -- b )
 2115                           //      Leave the 8 bit contents of addr on the stack.
 2116                           //      Pronounced "Char Fetch", as in Fetch byte at addr.
 2117                           
 2118                            SECTION .text : CONST (2)
 2119                           CAT_NFA:
 2120    00000000 82                    DC8     0x82
 2121    00000001 43                    DC8     'C'
 2122    00000002 C0                    DC8     '@'+0x80 //C0H
 2123    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2124    00000004 ........              DC32    AT_NFA
 2125                           CAT:
 2126    00000008 ........              DC32    .+5
 2127                            SECTION .text : CODE (2)
 2128                                   POP2n
 2128.1  00000000 57F8041B              LDR     n, [p],#4
 2128.2                         //      LDR     n, [p]
 2128.3                         //      ADDS    p, p, #4
 2128.4                                 ENDM
 2129    00000004 0878                  LDRB    t, [n]
 2130                                   TPUSH
 2130                                   PUSHt   // push t to p, pre decrement p
 2130.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 2130.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 2130.3                         //      STR     t, [p]
 2130.4                                 ENDM
 2130                                   NEXT
 2130.1                         // ARMv7-M Thumb = .+5
 2130.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2130.3                         // ARMv6-M Thumb = .+4
 2130.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2130                                   NEXT1
 2130.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2130.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2130.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2130.4                         // ARMv6-M Thumb = .+4
 2130.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2130.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2130.7                                 ENDM
 2130.8                                 ENDM
 2130.9                                 ENDM
 2131                           
 2132                           
 2133                           //      ! STORE:        ( n addr -- )
 2134                           //      Store n at address. Pronounced "Store".
 2135                           
 2136                            SECTION .text : CONST (2)
 2137                           STORE_NFA:
 2138    00000000 81                    DC8     0x81
 2139    00000001 A1                    DC8     '!'+0x80
 2140    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2141    00000004 ........              DC32    CAT_NFA
 2142                           STORE:
 2143    00000008 ........              DC32    .+5
 2144                            SECTION .text : CODE (2)
 2145                                   POP2t           // ADDR
 2145.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2145.2                         //#ifndef TOSCT
 2145.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2145.4                         //#endif
 2145.5                         //      ADDS    p, p, #4
 2145.6                                 ENDM
 2146                                   POP2n           // DATA
 2146.1  00000004 57F8041B              LDR     n, [p],#4
 2146.2                         //      LDR     n, [p]
 2146.3                         //      ADDS    p, p, #4
 2146.4                                 ENDM
 2147    00000008 0160                  STR     n, [t]
 2148                                   NEXT
 2148.1                         // ARMv7-M Thumb = .+5
 2148.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2148.3                         // ARMv6-M Thumb = .+4
 2148.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2148                                   NEXT1
 2148.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2148.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2148.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2148.4                         // ARMv6-M Thumb = .+4
 2148.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2148.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2148.7                                 ENDM
 2148.8                                 ENDM
 2149                           
 2150                           
 2151                           //      C! CSTORE:      ( n addr -- )
 2152                           //      Store LS 8 bits of n at address. Pronounced "Char Store".
 2153                           
 2154                            SECTION .text : CONST (2)
 2155                           CSTORE_NFA:
 2156    00000000 82                    DC8     0x82
 2157    00000001 43                    DC8     'C'
 2158    00000002 A1                    DC8     '!'+0x80
 2159    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2160    00000004 ........              DC32    STORE_NFA
 2161                           CSTORE:
 2162    00000008 ........              DC32    .+5
 2163                            SECTION .text : CODE (2)
 2164                                   POP2t
 2164.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2164.2                         //#ifndef TOSCT
 2164.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2164.4                         //#endif
 2164.5                         //      ADDS    p, p, #4
 2164.6                                 ENDM
 2165                                   POP2n
 2165.1  00000004 57F8041B              LDR     n, [p],#4
 2165.2                         //      LDR     n, [p]
 2165.3                         //      ADDS    p, p, #4
 2165.4                                 ENDM
 2166    00000008 0170                  STRB    n, [t]
 2167                                   NEXT
 2167.1                         // ARMv7-M Thumb = .+5
 2167.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2167.3                         // ARMv6-M Thumb = .+4
 2167.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2167                                   NEXT1
 2167.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2167.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2167.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2167.4                         // ARMv6-M Thumb = .+4
 2167.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2167.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2167.7                                 ENDM
 2167.8                                 ENDM
 2168                           
 2169                           
 2170                           //=============================== WORDCAT ====================================//
 2171                           //NOEXEC HEADERFORWORDCATEGORIES
 2172                           //      WC_RWMEMORY_NFA = Read and Write Memory With: CATEGORY
 2173                           
 2174                            SECTION .text : CONST (2)
 2175                           WC_RWMEMORY_NFA:
 2176    00000000 9F                    DC8     0x80+31
 2177    00000001 0D0A                  DC8     0x0D, 0x0A
 2178    00000003 5265616420616         DC8     'Read and Write Memory With:'
                  E642057726974
                  65204D656D6F7
                  2792057697468
                  3A           
 2179    0000001E 0D8A                  DC8     0x0D, 0x0A+0x80
 2180                            ALIGNROM 2,0xFFFFFFFF
 2181    00000020 ........              DC32    CSTORE_NFA
 2182                           
 2183                           
 2184                           //      ] RBRAC:        ( -- )
 2185                           //      Resume compilation, by STATE back to 0xC0 (zero is interpreting)
 2186                           //      0xC0 STATE  used in INTERPRET to execute Immediate words while compiling
 2187                           //      See [.
 2188                           
 2189                            SECTION .text : CONST (2)
 2190                           RBRAC_NFA:
 2191    00000000 81                    DC8     0x81
 2192    00000001 DD                    DC8     ']'+0x80
 2193    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2194                           //      DC32    SMUDGE_NFA
 2195    00000004 ........              DC32    WC_RWMEMORY_NFA
 2196                           RBRAC:
 2197    00000008 ........              DC32    DOCOL
 2198    0000000C ........C0000         DC32    strva, 0xC0, CSTATE
                  000........  
 2199    00000018 ........              DC32    SEMIS
 2200                           
 2201                           
 2202                           //      [ LBRAC:        ( -- ) IMMEDIATE
 2203                           //      Used in a colon-definition in form
 2204                           //              xxx    [  words   ]    more
 2205                           //      Suspend compilation by setting STATE to zero (0xC0 is compiling).
 2206                           //      The words after [ are executed, not compiled. This allows calculation
 2207                           //      or compilation exceptions before resuming compilation with ] .
 2208                           //      See LITERAL and ]
 2209                           
 2210                            SECTION .text : CONST (2)
 2211                           LBRAC_NFA:
 2212    00000000 C1                    DC8     0x0C1
 2213    00000001 DB                    DC8     '['+0x80
 2214    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2215    00000004 ........              DC32    RBRAC_NFA
 2216                           LBRAC:
 2217    00000008 ........              DC32    DOCOL
 2218    0000000C ........00000         DC32    strva, 0, CSTATE
                  000........  
 2219    00000018 ........              DC32    SEMIS
 2220                           
 2221                           
 2222                           //      [COMPILE] BCOMP:        ( -- ) IMMEDIATE
 2223                           //      Used in a colon-definition in form:
 2224                           //              :  xxx    [COMPILE]   immediate_word   ;
 2225                           //      [COMPILE] will force the compilation of an IMMEDIATE WORD
 2226                           //      that would otherwise execute during compilation. The above example
 2227                           //      will select the FORTH vocabulary then xxx executes, rather than at
 2228                           //      compile time.
 2229                           
 2230                            SECTION .text : CONST (2)
 2231                           BCOMP_NFA:
 2232    00000000 C9                    DC8     0x0C9
 2233    00000001 5B434F4D50494         DC8     '[COMPILE'
                  C45          
 2234    00000009 DD                    DC8     ']'+0x80
 2235    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2236    0000000C ........              DC32    LBRAC_NFA
 2237                           BCOMP:
 2238    00000010 ........              DC32    DOCOL
 2239    00000014 ........              DC32    DFIND   // noop there for TIB entry
 2240                           //      -FIND \ --- pfa len tf (found) \ --- ff (not found)
 2241    00000018 ........              DC32    ZEQU
 2242    0000001C .............         DC32    LIT, msg_qstack
                  ...          
 2243    00000024 ........              DC32    QERROR    // \ f nullstr-addr --
 2244    00000028 ........              DC32    DROP
 2245    0000002C ........              DC32    CFA
 2246    00000030 ........              DC32    COMMA   // alighned, INCREMENTS DP REFLECTED by HERE
 2247    00000034 ........              DC32    SEMIS
 2248                           
 2249                           
 2250                           //      DLITERAL DLITERAL:      ( d -- d ) IMMEDIATE
 2251                           //                              ( d -- )   (compiling)
 2252                           //      If compiling, compile a stack double number into a literal. Later
 2253                           //      execution of the definition containing the literal will push it to
 2254                           //      the stack. If executing, the number will remain on the stack.
 2255                           //      : xxx    [ calculate ]  DLITERAL  ; //
 2256                           
 2257                            SECTION .text : CONST (2)
 2258                           DLITERAL_NFA:
 2259    00000000 C8                    DC8     0x0C8
 2260    00000001 444C495445524         DC8     'DLITERA'
                  1            
 2261    00000008 CC                    DC8     'L'+0x80
 2262    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2263    0000000C ........              DC32    BCOMP_NFA
 2264                           DLITERAL:
 2265    00000010 ........              DC32    DOCOL
 2266    00000014 ........              DC32    STATE_SV
 2267    00000018 ........              DC32    AT
 2268    0000001C ........              DC32    ZBRAN   // IF
 2269    00000020 10000000              DC32     DLIT1-.
 2270                           
 2271    00000024 ........              DC32    SWAP
 2272    00000028 ........              DC32    LITERAL
 2273    0000002C ........              DC32    LITERAL // endif
 2274                           DLIT1:
 2275    00000030 ........              DC32    SEMIS
 2276                           
 2277                           
 2278                           //      LITERAL LITERAL:        ( n -- ) IMMEDIATE
 2279                           //      If compiling, then compile the stack value n as a 32 bit literal.
 2280                           //      This definition is immediate so that it will execute during a colon
 2281                           //      definition. The intended use is:
 2282                           //      : xxx    [ calculate ]  LITERAL  ; //
 2283                           //      Compilation is suspended for the compile time calculation of value.
 2284                           //      Compilation is resumed and LITERAL compiles this value.
 2285                           
 2286                            SECTION .text : CONST (2)
 2287                           LITERAL_NFA:
 2288    00000000 C7                    DC8     0x0C7
 2289    00000001 4C4954455241          DC8     'LITERA'
 2290    00000007 CC                    DC8     'L'+0x80
 2291                            ALIGNROM 2,0xFFFFFFFF
 2292    00000008 ........              DC32    DLITERAL_NFA
 2293                           LITERAL:
 2294    0000000C ........              DC32    DOCOL
 2295    00000010 ........              DC32    STATE_SV
 2296    00000014 ........              DC32    AT
 2297    00000018 ........              DC32    ZBRAN           // If not compiling
 2298    0000001C 10000000              DC32     LITE1-.        // go here
 2299                           
 2300    00000020 ........              DC32    COMP            // Compile
 2301    00000024 ........              DC32    LIT             // Literal
 2302    00000028 ........              DC32    COMMA           // Then COMPILE THE LITERAL VALUE
 2303                           LITE1:
 2304    0000002C ........              DC32    SEMIS
 2305                           
 2306                           
 2307                           //      #> EDIGS:       ( d=(LSW MSW) -- addr count )
 2308                           //      Terminates numeric output conversion by dropping dnum,
 2309                           //      leaving the text address and character count suitable for type.
 2310                           
 2311                            SECTION .text : CONST (2)
 2312                           EDIGS_NFA:
 2313    00000000 82                    DC8     0x82
 2314    00000001 23                    DC8     '#'
 2315    00000002 BE                    DC8     '>'+0x80
 2316    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2317    00000004 ........              DC32    LITERAL_NFA
 2318                           EDIGS:
 2319    00000008 ........              DC32    DOCOL
 2320    0000000C ........              DC32    DROP
 2321    00000010 ........              DC32    DROP
 2322    00000014 ........              DC32    HLD_SV
 2323    00000018 ........              DC32    AT
 2324    0000001C ........              DC32    PAD_SV
 2325    00000020 ........              DC32    OVER
 2326    00000024 ........              DC32    SUBB
 2327    00000028 ........              DC32    SEMIS
 2328                           
 2329                           
 2330                           //      HOLD HOLD:      ( c -- )
 2331                           //      Used between <# and #> to insert an ascii character into a pictured
 2332                           //      numeric output string.
 2333                           //      e.g. 0x2E HOLD will place a decimal point.
 2334                           
 2335                            SECTION .text : CONST (2)
 2336                           HOLD_NFA:
 2337    00000000 84                    DC8     0x84
 2338    00000001 484F4C                DC8     'HOL'
 2339    00000004 C4                    DC8     'D'+0x80
 2340    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2341    00000008 ........              DC32    EDIGS_NFA
 2342                           HOLD:
 2343    0000000C ........              DC32    DOCOL
 2344    00000010 ........FFFFF         DC32    LIT,-1
                  FFF          
 2345    00000018 ........              DC32    HLD_SV
 2346    0000001C ........              DC32    PSTORE
 2347    00000020 ........              DC32    HLD_SV
 2348    00000024 ........              DC32    AT
 2349    00000028 ........              DC32    CSTORE
 2350    0000002C ........              DC32    SEMIS
 2351                           
 2352                           
 2353                           //      SIGN SIGN:      ( n d=<LSW MSW> -- d=<LSW MSW> )
 2354                           //      Place an ascii "-" sign just before a converted numeric output
 2355                           //      string in the text output buffer when n is negative. n is discarded
 2356                           //      but double number dnum is maintained. Must be used between <# and #>.
 2357                           
 2358                            SECTION .text : CONST (2)
 2359                           SIGN_NFA:
 2360    00000000 84                    DC8     0x84
 2361    00000001 534947                DC8     'SIG'
 2362    00000004 CE                    DC8     'N'+0x80
 2363    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2364    00000008 ........              DC32    HOLD_NFA
 2365                           SIGN:
 2366    0000000C ........              DC32    DOCOL
 2367    00000010 ........              DC32    ROT
 2368    00000014 ........              DC32    ZLESS
 2369    00000018 ........              DC32    ZBRAN           // If
 2370    0000001C 10000000              DC32     SIGN1-.
 2371                           
 2372    00000020 ........2D000         DC32    LIT, '-'        // 0x2D
                  000          
 2373    00000028 ........              DC32    HOLD            // Endif
 2374                           SIGN1:
 2375    0000002C ........              DC32    SEMIS
 2376                           
 2377                           
 2378                           //      #S DIGS:        ( d1=<LSW MSW> -- d2=<LSW MSW> )
 2379                           //      Generates ascii text in the text output buffer, by the use of #,
 2380                           //      until a zero double number d2 results.
 2381                           //      Used between <# and #>.
 2382                           //      EACH NUMBER = BASE*number+(character-'0')
 2383                           
 2384                            SECTION .text : CONST (2)
 2385                           DIGS_NFA:
 2386    00000000 82                    DC8     0x82
 2387    00000001 23                    DC8     '#'
 2388    00000002 D3                    DC8     'S'+0x80
 2389    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2390    00000004 ........              DC32    SIGN_NFA
 2391                           DIGS:
 2392    00000008 ........              DC32    DOCOL
 2393                           DIGS1:                          // Begin generating ascii chars by DIG
 2394    0000000C ........              DC32    DIG             //\ d1=<LSW MSW> -- d2=QUO=<LSW MSW>
 2395    00000010 ........              DC32    OVER
 2396    00000014 ........              DC32    OVER
 2397    00000018 ........              DC32    OR
 2398    0000001C ........              DC32    ZEQU
 2399    00000020 ........              DC32    ZBRAN           //UNTIL
 2400    00000024 E8FFFFFF              DC32     DIGS1-.
 2401    00000028 ........              DC32    SEMIS
 2402                           
 2403                           
 2404                           //      # DIG:  ( d1=<LSW MSW> -- d2=QUO=<LSW MSW> ) BASE MUST BE SET!
 2405                           //      Generate from a double number d1, the next ascii character which is
 2406                           //      placed in an output string. Result d2 is the quotient after division
 2407                           //      by base, and is maintained for further processing.
 2408                           //      Used between <# and #>.
 2409                           //      See #S.
 2410                           //      EACH NUMBER = BASE*number+(character-'0')
 2411                           
 2412                            SECTION .text : CONST (2)
 2413                           DIG_NFA:
 2414    00000000 81                    DC8     0x81
 2415    00000001 A3                    DC8     '#'+0x80
 2416    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2417    00000004 ........              DC32    DIGS_NFA
 2418                           DIG:
 2419    00000008 ........              DC32    DOCOL
 2420    0000000C ........              DC32    BASE_SV         // EX 0 1 0
 2421    00000010 ........              DC32    AT              // -- 0 1 0 A
 2422    00000014 ........              DC32    MSMOD           // -- 0 1 0 0
 2423    00000018 ........              DC32    ROT             // -- 0 0 0 1
 2424    0000001C ........09000         DC32    LIT,9
                  000          
 2425    00000024 ........              DC32    OVER
 2426    00000028 ........              DC32    LESSTHAN
 2427    0000002C ........              DC32    ZBRAN           // If
 2428    00000030 10000000              DC32     DIG1-.
 2429                           
 2430    00000034 ........07000         DC32    LIT,7
                  000          
 2431    0000003C ........              DC32    PLUS            // Endif
 2432                           DIG1:
 2433    00000040 ........30000         DC32    LIT, 0x30
                  000          
 2434    00000048 ........              DC32    PLUS
 2435    0000004C ........              DC32    HOLD
 2436    00000050 ........              DC32    SEMIS
 2437                           
 2438                           
 2439                           //      <# BDIGS:       ( -- )
 2440                           //      Setup for pictured numeric output formatting using the words:
 2441                           //              <# # #S SIGN HOLD #>
 2442                           //      The conversion is done on a double number producing text at Pad
 2443                           
 2444                            SECTION .text : CONST (2)
 2445                           BDIGS_NFA:
 2446    00000000 82                    DC8     0x82
 2447    00000001 3C                    DC8     '<'
 2448    00000002 A3                    DC8     '#'+0x80
 2449    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2450    00000004 ........              DC32    DIG_NFA
 2451                           BDIGS:
 2452    00000008 ........              DC32    DOCOL
 2453    0000000C .............         DC32    strva, PAD, NHLD
                  ...........  
 2454    00000018 ........              DC32    SEMIS
 2455                           
 2456                           
 2457                           //      DOES> DOES:     ( pfa -- ) MODIFIED:
 2458                           //      A word which defines the run-time action within a high-level
 2459                           //      defining word. DOES> alters the code field and first parameter of
 2460                           //      the new word to execute the sequence of compiled word addresses
 2461                           //      following DOES>. Used in combination with <BUILDS. When the DOES>
 2462                           //      part executes it begins with the address of the first parameter of
 2463                           //      the new word on the stack. This allows interpretation using this
 2464                           //      area or its contents. Typical uses include the Forth assembler,
 2465                           //      multidimensional arrays, and compiler generation.
 2466                           
 2467                            SECTION .text : CONST (2)
 2468                           DOES_NFA:
 2469    00000000 85                    DC8     0x85
 2470    00000001 444F4553              DC8     'DOES'
 2471    00000005 BE                    DC8     '>'+0x80
 2472    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2473    00000008 ........              DC32    BDIGS_NFA
 2474                           DOES:
 2475    0000000C ........              DC32    DOCOL
 2476    00000010 ........              DC32    RFROM   // Get the addr of the first word after DOES>
 2477    00000014 ........              DC32    LATEST  // ( -- addr ) nfa OF the current <creator> word
 2478    00000018 ........              DC32    PFA     // Use the pfa to store a run-time cfa
 2479    0000001C .............         DC32    DUP, CFA
                  ...          
 2480    00000024 .............         DC32    LIT, CREATE_DOES_GOTO
                  ...          
 2481    0000002C .............         DC32    SWAP, STORE     // STORE GOTO
                  ...          
 2482    00000034 ........              DC32    STORE   // Store the run-time cfa as 1rst pfa Parameter.
 2483    00000038 ........              DC32    SEMIS
 2484                           
 2485                           
 2486                           //      <BUILDS BUILDS: ( -- )  MODIFIED: See CREATE and DOES>
 2487                           //      Used within a colon-definition
 2488                           //              CCcc  <BUILDS  ...  DOES>     ...
 2489                           //      Each time CCcc is executed, <BUILDS defines a new word with a
 2490                           //      high-level execution proceedure. Executing CCcc in the form
 2491                           //              CCcc nnnn
 2492                           //      uses <BUILDS to create a dictionary entry for nnnn with a call to
 2493                           //      the DOES> part for nnnn. When nnnn is later executed, it has the
 2494                           //      address of its parameter area on the stack and executes the words
 2495                           //      after DOES> in CCcc. <BUILDS and DOES> allow runtime proceedures to
 2496                           //      written in high-level code.
 2497                           
 2498                            SECTION .text : CONST (2)
 2499                           BUILDS_NFA:
 2500    00000000 87                    DC8     0x87
 2501    00000001 3C4255494C44          DC8     '<BUILD'
 2502    00000007 D3                    DC8     'S'+0x80
 2503                            ALIGNROM 2,0xFFFFFFFF
 2504    00000008 ........              DC32    DOES_NFA
 2505                           BUILDS:
 2506    0000000C ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 2507    00000010 ........              DC32    CREATE                  // CREATE's A CON POINTING TO IT'S PFA
 2508    00000014 ........              DC32    SEMIS
 2509                           
 2510                           
 2511                           //      +LOOP PLOOP:    ( n1 -- ) IMMEDIATE
 2512                           //                      ( addr n2 -- ) COMPILE
 2513                           //      At run time, DO begins a sequence with repetitive execution
 2514                           //      controlled by a loop limit n1 and an index with initial value n2. DO
 2515                           //      removes these from the stack. Upon reaching LOOP the index is
 2516                           //      incremented by one.
 2517                           //      Until the new index equals or exceeds the limit, execution loops
 2518                           //      back to just after DO// otherwise the loop parameters are discarded
 2519                           //      and execution continues ahead. Both n1 and n2 are determined at
 2520                           //      run-time and may be the result of other operations.
 2521                           //      Within a loop 'I' will copy the current value of the index to the
 2522                           //      stack. See I, LOOP, +LOOP, LEAVE.
 2523                           //
 2524                           //      When compiling within the colon definition, DO compiles (DO), leaves
 2525                           //      the following address addr and n for later error checking.
 2526                           
 2527                            SECTION .text : CONST (2)
 2528                           PLOOP_NFA:
 2529    00000000 C5                    DC8     0x0C5
 2530    00000001 2B4C4F4F              DC8     '+LOO'
 2531    00000005 D0                    DC8     'P'+0x80
 2532    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2533    00000008 ........              DC32    BUILDS_NFA
 2534                           PLOOP:
 2535    0000000C ........              DC32    DOCOL
 2536    00000010 ........              DC32    THREE
 2537    00000014 ........              DC32    QPAIR
 2538    00000018 ........              DC32    COMP
 2539    0000001C ........              DC32    XPLOOP
 2540    00000020 ........              DC32    BACK
 2541    00000024 ........              DC32    SEMIS
 2542                           
 2543                           
 2544                           //      LOOP LOOP:      ( addr n -- ) IMMEDIATE
 2545                           //      Occurs in a colon-definition in form:
 2546                           //              DO ... LOOP
 2547                           //      At run-time, LOOP selectively controls branching back to the
 2548                           //      corresponding DO based on the loop index and limit. The loop index
 2549                           //      is incremented by one and compared to the limit. The branch back to
 2550                           //      DO occurs until the index equals or exceeds the limit, then
 2551                           //      the parameters are discarded and execution continues ahead.
 2552                           //
 2553                           //      At compile-time. LOOP compiles (LOOP) and uses addr to calculate an
 2554                           //      offset to DO. n is used for error testing.
 2555                           
 2556                            SECTION .text : CONST (2)
 2557                           LOOP_NFA:
 2558    00000000 C4                    DC8     0x0C4
 2559    00000001 4C4F4F                DC8     'LOO'
 2560    00000004 D0                    DC8     'P'+0x80
 2561    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2562    00000008 ........              DC32    PLOOP_NFA
 2563                           LOOP:
 2564    0000000C ........              DC32    DOCOL
 2565    00000010 ........              DC32    THREE
 2566    00000014 ........              DC32    QPAIR
 2567    00000018 ........              DC32    COMP
 2568    0000001C ........              DC32    XLOOP
 2569    00000020 ........              DC32    BACK
 2570    00000024 ........              DC32    SEMIS
 2571                           
 2572                           
 2573                           //      DO DO:  ( n1 n2 -- ) IMMEDIATE
 2574                           //              (addr n -- ) COMPILE
 2575                           //      Occurs in a colon-definition in form:
 2576                           //      DO ... LOOP
 2577                           
 2578                            SECTION .text : CONST (2)
 2579                           DO_NFA:
 2580    00000000 C2                    DC8     0x0C2
 2581    00000001 44                    DC8     'D'
 2582    00000002 CF                    DC8     'O'+0x80
 2583    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2584    00000004 ........              DC32    LOOP_NFA
 2585                           DO:
 2586    00000008 ........              DC32    DOCOL
 2587    0000000C ........              DC32    COMP
 2588    00000010 ........              DC32    XDO
 2589    00000014 ........              DC32    HERE
 2590    00000018 ........              DC32    THREE
 2591    0000001C ........              DC32    SEMIS
 2592                           
 2593                           
 2594                           //      ENDIF ENDIF:    ( addr n -- ) IMMEDIATE
 2595                           //      Occurs in a colon-definition in form:
 2596                           //              IF ... ENDIF
 2597                           //              IF ... ELSE ... ENDIF
 2598                           //      At run-time, ENDIF serves only as the destination of a forward
 2599                           //      branch from IF or ELSE. It marks the conclusion of the conditional
 2600                           //      structure. THEN is another name for ENDIF. Both names are supported
 2601                           //      in fig-FORTH. See also IF and ELSE.
 2602                           //
 2603                           //      At compile-time, ENDIF computes the forward branch offset from addr
 2604                           //      to HERE and stores it at addr. n is used for error tests.
 2605                           
 2606                            SECTION .text : CONST (2)
 2607                           ENDIF_NFA:
 2608    00000000 C5                    DC8     0x0C5
 2609    00000001 454E4449              DC8     'ENDI'
 2610    00000005 C6                    DC8     'F'+0x80
 2611    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2612    00000008 ........              DC32    DO_NFA
 2613                           ENDIF:
 2614    0000000C ........              DC32    DOCOL
 2615    00000010 ........              DC32    QCOMP
 2616    00000014 ........              DC32    TWO     // 2 is the Error checking number for if.
 2617    00000018 ........              DC32    QPAIR
 2618    0000001C ........              DC32    HERE
 2619    00000020 ........              DC32    OVER
 2620    00000024 ........              DC32    SUBB
 2621    00000028 ........              DC32    SWAP
 2622    0000002C ........              DC32    STORE
 2623    00000030 ........              DC32    SEMIS
 2624                           
 2625                           
 2626                           //      THEN THEN:      ( -- ) IMMEDIATE
 2627                           //      An alias for ENDIF.
 2628                           
 2629                            SECTION .text : CONST (2)
 2630                           THEN_NFA:
 2631    00000000 C4                    DC8     0x0C4
 2632    00000001 544845                DC8     'THE'
 2633    00000004 CE                    DC8     'N'+0x80
 2634    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2635    00000008 ........              DC32    ENDIF_NFA
 2636                           THEN:
 2637    0000000C ........              DC32    DOCOL
 2638    00000010 ........              DC32    ENDIF
 2639    00000014 ........              DC32    SEMIS
 2640                           
 2641                           
 2642                           //      ELSE ELSE:      ( addr1 n1 -- ) IMMEDIATE
 2643                           //                      ( addr2 n2 -- ) COMPILING
 2644                           //      Occurs within a colon-definition in the form:
 2645                           //              IF ... ELSE ... ENDIF
 2646                           //      At run-time, ELSE executes after the true part following IF. ELSE
 2647                           //      forces execution to skip over the following false part and resumes
 2648                           //      execution after the ENDIF. It has no stack effect.
 2649                           //
 2650                           //      At compile-time ELSE emplaces BRANCH reserving a branch offset,
 2651                           //      leaves the address addr2 and n2 for error testing. ELSE also
 2652                           //      resolves the pending forward branch from IF by calculating the
 2653                           //      offset from addr1 to HERE and storing at addr1.
 2654                           
 2655                            SECTION .text : CONST (2)
 2656                           ELSE_NFA:
 2657    00000000 C4                    DC8     0x0C4
 2658    00000001 454C53                DC8     'ELS'
 2659    00000004 C5                    DC8     'E'+0x80
 2660    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2661    00000008 ........              DC32    THEN_NFA
 2662                           ELSE:
 2663    0000000C ........              DC32    DOCOL
 2664    00000010 ........              DC32    TWO
 2665    00000014 ........              DC32    QPAIR
 2666    00000018 ........              DC32    COMP
 2667    0000001C ........              DC32    BRAN
 2668    00000020 ........              DC32    HERE
 2669    00000024 ........              DC32    ZERO
 2670    00000028 ........              DC32    COMMA   // aligned, INCREMENTS DP REFLECTED by HERE
 2671    0000002C ........              DC32    SWAP
 2672    00000030 ........              DC32    TWO
 2673    00000034 ........              DC32    ENDIF
 2674    00000038 ........              DC32    TWO
 2675    0000003C ........              DC32    SEMIS
 2676                           
 2677                           
 2678                           //      IF IF:  ( f -- ) IMMEDIATE
 2679                           //              ( -- addr n ) COMPILE
 2680                           //      Occurs is a colon-definition in form:
 2681                           //              IF (tp) ...  ENDIF      .
 2682                           //              IF (tp) ... ELSE (fp) ... ENDIF
 2683                           //      At run-time, IF selects execution based on a boolean flag. If f is
 2684                           //      true (non-zero), execution continues ahead thru the true part. If f
 2685                           //      is false (zero), execution skips till just after ELSE to execute
 2686                           //      the false part. After either part, execution resumes after ENDIF.
 2687                           //      ELSE and its false part are optional.; if missing, false execution
 2688                           //      skips to just after ENDIF..
 2689                           //
 2690                           //      At compile-time IF compiles 0BRANCH and reserves space for an offset
 2691                           //      at addr. addr and n are used later for resolution of the offset and
 2692                           //      error testing.
 2693                           
 2694                            SECTION .text : CONST (2)
 2695                           IF_NFA:
 2696    00000000 C2                    DC8     0x0C2
 2697    00000001 49                    DC8     'I'
 2698    00000002 C6                    DC8     'F'+0x80
 2699    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2700    00000004 ........              DC32    ELSE_NFA
 2701                           IF:
 2702    00000008 ........              DC32    DOCOL
 2703    0000000C ........              DC32    COMP
 2704    00000010 ........              DC32    ZBRAN
 2705    00000014 ........              DC32    HERE
 2706    00000018 ........              DC32    ZERO
 2707    0000001C ........              DC32    COMMA
 2708    00000020 ........              DC32    TWO     // 2 is the Error checking number for if.
 2709    00000024 ........              DC32    SEMIS
 2710                           
 2711                           
 2712                           //      UNTIL UNTIL:    ( f -- ) IMMEDIATE
 2713                           //                      ( addr n -- ) COMPILE:
 2714                           //      Occurs within a colon-definition in the form:
 2715                           //              BEGIN ... UNTIL
 2716                           //      At run-time, UNTIL controls the conditional branch back to the
 2717                           //      corresponding BEGIN. If f is false, execution returns to just after.
 2718                           //      BEGIN:  if true, execution continues ahead.
 2719                           //      At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to
 2720                           //      addr. n is used for error tests.
 2721                           
 2722                            SECTION .text : CONST (2)
 2723                           UNTIL_NFA:
 2724    00000000 C5                    DC8     0x0C5
 2725    00000001 554E5449              DC8     'UNTI'
 2726    00000005 CC                    DC8     'L'+0x80
 2727    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2728    00000008 ........              DC32    IF_NFA
 2729                           UNTIL:
 2730    0000000C ........              DC32    DOCOL
 2731    00000010 ........              DC32    ONE
 2732    00000014 ........              DC32    QPAIR
 2733    00000018 ........              DC32    COMP
 2734    0000001C ........              DC32    ZBRAN
 2735    00000020 ........              DC32    BACK
 2736    00000024 ........              DC32    SEMIS
 2737                           
 2738                           
 2739                           //      AGAIN AGAIN:    ( addr n -- ) IMMEDIATE
 2740                           //      Used in a colon-definition in the form:
 2741                           //                      BEGIN ... AGAIN
 2742                           //      At run-time, AGAIN forces execution to return to corresponding BEGIN.
 2743                           //      There is no effect on the stack. Execution cannot leave this loop
 2744                           //      (unless R> DROP is executed one level below).
 2745                           //
 2746                           //      At compile time, AGAIN compiles BRANCH with an offset from HERE to
 2747                           //      addr. n is used for compile-time error checking.
 2748                           
 2749                            SECTION .text : CONST (2)
 2750                           AGAIN_NFA:
 2751    00000000 C5                    DC8     0x0C5
 2752    00000001 41474149              DC8     'AGAI'
 2753    00000005 CE                    DC8     'N'+0x80
 2754    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2755    00000008 ........              DC32    UNTIL_NFA
 2756                           AGAIN:
 2757    0000000C ........              DC32    DOCOL
 2758    00000010 ........              DC32    ONE
 2759    00000014 ........              DC32    QPAIR
 2760    00000018 ........              DC32    COMP
 2761    0000001C ........              DC32    BRAN
 2762    00000020 ........              DC32    BACK
 2763    00000024 ........              DC32    SEMIS
 2764                           
 2765                           
 2766                           //      REPEAT REPEAT:  ( addr n -- ) IMMEDIATE
 2767                           //      Used within a colon-definition in the form:
 2768                           //              BEGIN ... WHILE ... REPEAT
 2769                           //      At run-time, REPEAT forces an unconditional branch back to just
 2770                           //      after the corresponding BEGIN.
 2771                           //
 2772                           //      At compile-time, REPEAT compiles BRANCH and the offset from HERE to
 2773                           //      addr. n is used for error testing.
 2774                           
 2775                            SECTION .text : CONST (2)
 2776                           REPEAT_NFA:
 2777    00000000 C6                    DC8     0x0C6
 2778    00000001 5245504541            DC8     'REPEA'
 2779    00000006 D4                    DC8     'T'+0x80
 2780    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2781    00000008 ........              DC32    AGAIN_NFA
 2782                           REPEAT:
 2783    0000000C ........              DC32    DOCOL
 2784    00000010 ........              DC32    TOR
 2785    00000014 ........              DC32    TOR
 2786    00000018 ........              DC32    AGAIN
 2787    0000001C ........              DC32    RFROM
 2788    00000020 ........              DC32    RFROM
 2789    00000024 ........              DC32    TWO
 2790    00000028 ........              DC32    SUBB
 2791    0000002C ........              DC32    ENDIF
 2792    00000030 ........              DC32    SEMIS
 2793                           
 2794                           
 2795                           //      WHILE WHILE:    ( f -- ) IMMEDIATE
 2796                           //                      (ad1 nl -- ad1 n1 ad2 n2 ) COMPILE
 2797                           //      Occurs in a colon-definition in the form:
 2798                           //              BEGIN ... WHILE (tp) ... REPEAT
 2799                           //      At run-time, WHILE selects conditional execution based on boolean
 2800                           //      flag f. If f is true (non-zero), WHILE continues execution of the
 2801                           //      true part thru to REPEAT, which then branches back to BEGIN. If f is
 2802                           //      false (zero), execution skips to just after REPEAT, exiting the
 2803                           //      structure.
 2804                           //
 2805                           //      At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the
 2806                           //      reserved offset. The stack values will be resolved by REPEAT.
 2807                           
 2808                            SECTION .text : CONST (2)
 2809                           WHILE_NFA:
 2810    00000000 C5                    DC8     0x0C5
 2811    00000001 5748494C              DC8     'WHIL'
 2812    00000005 C5                    DC8     'E'+0x80
 2813    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2814    00000008 ........              DC32    REPEAT_NFA
 2815                           WHILE:
 2816    0000000C ........              DC32    DOCOL
 2817    00000010 ........              DC32    IF
 2818    00000014 ........              DC32    TWOP
 2819    00000018 ........              DC32    SEMIS
 2820                           
 2821                           
 2822                           //      BEGIN BEGIN:    ( -- addr n ) IMMEDIATE
 2823                           //      Occurs in a colon-definition in form:
 2824                           //      BEGIN ... UNTIL
 2825                           //      BEGIN ... AGAIN
 2826                           //      BEGIN ... WHILE ... REPEAT
 2827                           //      At run-time, BEGIN marks the start of a sequence that may be
 2828                           //      repetitively executed. It serves as a return point from the
 2829                           //      corresponding UNTIL, AGAIN or REPEAT. When executing UNTIL, a return
 2830                           //      to BEGIN will occur if the top of the stack is false//
 2831                           //      for AGAIN and REPEAT a return to BEGIN always occurs.
 2832                           //
 2833                           //      At compile time BEGIN leaves its return address and n for compiler
 2834                           //      error checking.
 2835                           
 2836                            SECTION .text : CONST (2)
 2837                           BEGIN_NFA:
 2838    00000000 C5                    DC8     0x0C5
 2839    00000001 42454749              DC8     'BEGI'
 2840    00000005 CE                    DC8     'N'+0x80
 2841    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2842    00000008 ........              DC32    WHILE_NFA
 2843                           BEGIN:
 2844    0000000C ........              DC32    DOCOL
 2845    00000010 ........              DC32    QCOMP
 2846    00000014 ........              DC32    HERE
 2847    00000018 ........              DC32    ONE
 2848    0000001C ........              DC32    SEMIS
 2849                           
 2850                           
 2851                           //=============================== WORDCAT ====================================//
 2852                           //NOEXEC HEADERFORWORDCATEGORIES
 2853                           //      WC_COMPILE_NFA = Inside Colon WORDS: CATEGORY
 2854                           
 2855                            SECTION .text : CONST (2)
 2856                           WC_COMPILE_NFA:
 2857    00000000 97                    DC8     0x80+4+19
 2858    00000001 0D0A                  DC8     0x0D, 0x0A
 2859    00000003 496E736964652         DC8     'Inside Colon WORDS:'
                  0436F6C6F6E20
                  574F5244533A 
 2860    00000016 0D8A                  DC8     0x0D, 0x0A+0x80
 2861                            ALIGNROM 2,0xFFFFFFFF
 2862    00000018 ........              DC32    BEGIN_NFA
 2863                           
 2864                           
 2865                           //      IMMEDIATE IMMED:        ( -- )
 2866                           //      Mark the most recently made definition so that when encountered at
 2867                           //      compile time, it will be executed rather than being compiled. i.e.
 2868                           //      the precedence bit in its header is set.
 2869                           //      This method allows definitions to handle unusual compiling
 2870                           //      situations, rather. than build them into the fundamental compiler.
 2871                           //      The system may force compilation of an immediate definition by
 2872                           //      preceeding it with [COMPILE].
 2873                           
 2874                            SECTION .text : CONST (2)
 2875                           IMMED_NFA:
 2876    00000000 89                    DC8     0x89
 2877    00000001 494D4D4544494         DC8     'IMMEDIAT'
                  154          
 2878    00000009 C5                    DC8     'E'+0x80
 2879    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2880    0000000C ........              DC32    WC_COMPILE_NFA
 2881                           IMMED:
 2882    00000010 ........              DC32    DOCOL
 2883    00000014 ........              DC32    LATEST
 2884    00000018 ........40000         DC32    LIT, 0x40
                  000          
 2885    00000020 ........              DC32    TOGGLE
 2886    00000024 ........              DC32    SEMIS
 2887                           
 2888                           
 2889                           //      CREATE CREATE:  ( -- )
 2890                           //      Create a word in The Dictionary.
 2891                           //      Make searchable and forgetable NFA/LFA, DOCON, ADDR->PFA
 2892                           //      USE <BUILDS with DOES> instead of CREATE.
 2893                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2894                           //
 2895                           //      Saves HERE in CSDP in case there's an error creating a word.
 2896                           //      CSDP is reset when a word is completed, by ; <BUILDS (?) CON and VAR.
 2897                           //
 2898                           //      A defining word used in the form:
 2899                           //              CREATE CCcc
 2900                           //      by such words as VAR, CON AND <BUILDS to create a dictionary header for
 2901                           //      a new word. The code field contains the address of the words
 2902                           //      parameter field.
 2903                           
 2904                            SECTION .text : CONST (2)
 2905                           CREATE_NFA:
 2906    00000000 86                    DC8     0x86
 2907    00000001 4352454154            DC8     'CREAT'
 2908    00000006 C5                    DC8     'E'+0x80
 2909    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2910    00000008 ........              DC32    IMMED_NFA
 2911                           CREATE:
 2912    0000000C ........              DC32    DOCOL
 2913    00000010 ........              DC32    DICTSPACE       //      \ -- n
 2914    00000014 ........0F000         DC32    LIT, 15, SUBB   // One less than smallest definition
                  000........  
 2915    00000020 ........              DC32    ZLESS
 2916    00000024 ........              DC32    ZBRAN
 2917    00000028 08000000              DC32    CREATEOK-.
 2918                           
 2919    0000002C ........              DC32    DICTFULL_ABORT
 2920                           
 2921                           CREATEOK:
 2922    00000030 ........              DC32    DFIND                   // Parse nfa
 2923                           //      -FIND DFIND \ --- pfa len tf (found) \ --- ff (not found)
 2924    00000034 ........              DC32    ZBRAN
 2925    00000038 24000000              DC32     CREA1-.
 2926                           
 2927                           #ifdef IO2TP
 2931                           #endif
 2932    0000003C ........              DC32    DROP
 2933    00000040 ........              DC32    NFA
 2934    00000044 ........              DC32    IDDOT
 2935    00000048 .............         DC32    LIT, msg_wordexists
                  ...          
 2936                           // Nothing created yet so ABORT is correct.
 2937                           //        DC32    ERROR
 2938    00000050 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 2939    00000058 ........              DC32    ABORT
 2940                           
 2941                           CREA1:
 2942                           // Save HERE in CSDP so ERROR can reset DP if this definition fails.
 2943                           // CSDP is reset by SEMIC_CREATE when this definition is completed.
 2944                           // SEMIC_CREATE used in ; CON and VAR to reset CSDP.
 2945                           
 2946                           // This new definitions cstring name has been moved to HERE 
 2947    0000005C .............         DC32    HERE, DUP       // This will become the new CURRENT (this NFA).
                  ...          
 2948    00000064 .............         DC32    CSDP_SV, STORE  // HERE to CSDP to restore in case of error.
                  ...          
 2949                           // Dup HERE-NFA to allot NFAx
 2950    0000006C ........              DC32    DUP
 2951                           // Limit NFA allot to maxwordlen. DOES NOT CHANGE actual count!
 2952                           // If count is larger than MAXWORDLEN behaviour of this def is unpredictable!
 2953    00000070 ........              DC32    CAT
 2954    00000074 ........1F000         DC32    LIT, MAXWORDLEN // ELIMINATED WIDTH AND WIDTH_SV 
                  000          
 2955    0000007C ........              DC32    MIN
 2956    00000080 ........              DC32    ALLOT_PRIM      // HERE (DP) at end of NFA with padding.
 2957                           // Dup HERE-NFA to set count byte, and to be consumed later
 2958                           // for setting CURRENT after previous CURRENT compiled into LFA.
 2959    00000084 ........              DC32    DUP
 2960                           // Make regular (not immediate) NFA count byte
 2961    00000088 ........80000         DC32    LIT, 0x80
                  000          
 2962    00000090 ........              DC32    TOGGLE          // Count Byte = 80+count
 2963                           // HERE is new now. Mark end of NFA for PFIND search
 2964    00000094 ........              DC32    HERE            // DP after allot of NFA
 2965    00000098 ........80000         DC32    LIT,0x80        // Set last character in NFA
                  000          
 2966    000000A0 ........              DC32    TOGGLE          // smudge bit
 2967                           // Bump DP to LFA
 2968    000000A4 .............         DC32    ONE, DP_SV      // MOVE HERE (DP)
                  ...          
 2969    000000AC ........              DC32    PSTORE          // TO LFA
 2970                           // Set LFA
 2971    000000B0 ........              DC32    LATEST          // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
 2972    000000B4 ........              DC32    COMMA           // Compile last words NFA into this link field.
 2973                                                           // DUP'd HERE should be on stack
 2974                           // Have to set CURRENT with last dup's HERE-NFA after LATEST is compiled
 2975    000000B8 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
 2976    000000BC ........              DC32    STORE           // so storing NEWWORD_NFA into CURRENT.
 2977    000000C0 .............         DC32    COMP, DOCON     // Compile DOCON as CFA
                  ...          
 2978    000000C8 .............         DC32    HERE, FOURP     // Compute and
                  ...          
 2979    000000D0 ........              DC32    COMMA           // COMPILE Addr of PFA
 2980                           //      DC32    SMUDGE          // ELIMINATED
 2981                           //      DC32    SEMIC_CREATE    // USED IN CALLERS OF CREATE, NOT HERE!
 2982    000000D4 ........              DC32    SEMIS
 2983                           
 2984                           
 2985                           //      CON CON:        ( n -- )  MODIFIED: and CONSTANT renamed CON
 2986                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2987                           //      A defining word used in the form:
 2988                           //              n CONSTANT CCcc
 2989                           //      to create word CCcc, with its parameter field containing n. When
 2990                           //      CCcc is later executed, it will push the value of n to the stack.
 2991                           
 2992                            SECTION .text : CONST (2)
 2993                           CONSTANT_NFA:
 2994    00000000 88                    DC8     0x88
 2995    00000001 434F4E5354414         DC8     'CONSTAN'
                  E            
 2996    00000008 D4                    DC8     'T'+0x80
 2997    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2998    0000000C ........              DC32    CREATE_NFA
 2999                           CONSTANT:
 3000    00000010 .............         DC32    DOCOL, CON, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3001                           
 3002                           
 3003                            SECTION .text : CONST (2)
 3004                           CON_NFA:
 3005    00000000 83                    DC8     0x83
 3006    00000001 434F                  DC8     'CO'
 3007    00000003 CE                    DC8     'N'+0x80
 3008                            ALIGNROM 2,0xFFFFFFFF
 3009                           //      DC32    CREATE_NFA
 3010    00000004 ........              DC32    CONSTANT_NFA
 3011                           CON:
 3012    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3013    0000000C ........              DC32    CREATE  // Make Header NFA/LFA, DOCON, ADDR->PFA
 3014    00000010 ........FCFFF         DC32    LIT, -4, DP_SV, PSTORE  // back up to ADDR->PFA
                  FFF..........
                  ......       
 3015    00000020 ........              DC32    COMMA                   // Replace with Con value
 3016    00000024 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3017                           //        DC32    DOTDICTSPACE
 3018    00000028 ........              DC32    SEMIS
 3019                           
 3020                           
 3021                           //      VAR VAR:        ( -- ) RENAMED: VARIABLE to VAR
 3022                           //      IF RAMVARSPACE FULL PRINT Error MESSAGE AND Abort.
 3023                           //      A defining word used in the form:
 3024                           //              VARIABLE CCcc
 3025                           //      When VARIABLE is executed, it creates the definition CCcc with its
 3026                           //      with its cell space uninitialized. When CCcc is executed,
 3027                           //      its cell space address is put on the stack. Use with @ or !
 3028                           //      NOTE: VAR's cell space is allocated in ram. See UP and VARALLOT.
 3029                           
 3030                            SECTION .text : CONST (2)
 3031                           VARIABLE_NFA:
 3032    00000000 88                    DC8     0x88
 3033    00000001 5641524941424         DC8     'VARIABL'
                  C            
 3034    00000008 C5                    DC8     'E'+0x80
 3035    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3036    0000000C ........              DC32    CON_NFA
 3037                           VARIABLE:
 3038    00000010 .............         DC32    DOCOL, VAR_, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3039                           
 3040                            SECTION .text : CONST (2)
 3041                           VAR_NFA:
 3042    00000000 83                    DC8     0x83
 3043    00000001 5641                  DC8     'VA'
 3044    00000003 D2                    DC8     'R'+0x80
 3045                            ALIGNROM 2,0xFFFFFFFF
 3046                           //      DC32    CON_NFA
 3047    00000004 ........              DC32    VARIABLE_NFA
 3048                           VAR_:
 3049    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3050    0000000C ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3051    00000010 ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3052    00000020 .............         DC32    COMP, DOVAR     // CFA of VAR's
                  ...          
 3053                           //        DC32    COMP, DOCON     // CFA of VAR's
 3054                           // aligned, INCREMENTS DP REFLECTED by HERE
 3055                           // compile the value \ v --
 3056    00000028 ........              DC32    ONE
 3057    0000002C ........              DC32    VARALLOT        // Do .VS check and return VAR addr.
 3058    00000030 ........              DC32    COMMA           // Compile address of the ram allotment.
 3059    00000034 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3060                           //        DC32    DOTDICTSPACE
 3061                           //        DC32    DOTVARSPACE
 3062    00000038 ........              DC32    SEMIS
 3063                           
 3064                           
 3065                           //      ; SEMI: ( -- ) IMMEDIATE
 3066                           //      Terminate a colon-definition and stop further compilation.
 3067                           //      Compiles the run-time ;S.
 3068                           
 3069                            SECTION .text : CONST (2)
 3070                           SEMI_NFA:
 3071    00000000 C1                    DC8     0x0C1
 3072    00000001 BB                    DC8     ';'+0x80
 3073    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3074    00000004 ........              DC32    VAR_NFA
 3075                           SEMI:
 3076    00000008 ........              DC32    DOCOL
 3077    0000000C ........              DC32    QCSP
 3078    00000010 ........              DC32    COMP
 3079    00000014 ........              DC32    SEMIS
 3080    00000018 ........              DC32    LBRAC
 3081    0000001C ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3082                           //        DC32    DOTDICTSPACE
 3083    00000020 ........              DC32    SEMIS
 3084                           
 3085                           
 3086                           //      : COLON:        ( -- ) IMMEDIATE
 3087                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 3088                           //      Used in the form called a colon-definition:
 3089                           //              : CCcc     ...     //
 3090                           //      Creates a dictionary entry defining CCcc as equivalent to the
 3091                           //      following sequence of Forth word definitions '...' until the next
 3092                           //      ';' or ';CODE'.
 3093                           //      The compiling process is done by the text interpreter as long as
 3094                           //      STATE is non-zero. Other details are that the CONTEXT vocabulary is
 3095                           //      set to the CURRENT vocabulary and that words with the precedence bit
 3096                           //      set (P) are executed rather than being compiled.
 3097                           
 3098                            SECTION .text : CONST (2)
 3099                           COLON_NFA:
 3100    00000000 C1                    DC8     0x0C1
 3101    00000001 BA                    DC8     ':'+0x80
 3102    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3103    00000004 ........              DC32    SEMI_NFA
 3104                           COLON:
 3105    00000008 ........              DC32    DOCOL
 3106                           //      DICTSPACE TEST DONE IN CREATE
 3107    0000000C ........              DC32    QEXEC
 3108    00000010 ........              DC32    SCSP    // Save the stack position in CSP. Compiler security.
 3109    00000014 ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3110    00000018 ........              DC32    RBRAC   // Resume compiliting by setting STATE_SV to 0xC0
 3111    0000001C ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3112    0000002C .............         DC32    COMP, DOCOL     // aligned, INCREMENTS DP REFLECTED by HERE
                  ...          
 3113    00000034 ........              DC32    SEMIS
 3114                           
 3115                           
 3116                           //=============================== WORDCAT ====================================//
 3117                           //NOEXEC HEADERFORWORDCATEGORIES
 3118                           //      WC_CREATE_NFA = CREATE WORDS With: CATEGORY
 3119                           
 3120                            SECTION .text : CONST (2)
 3121                           WC_CREATE_NFA:
 3122    00000000 96                    DC8     0x80+22
 3123    00000001 0D0A                  DC8     0x0D, 0x0A
 3124    00000003 4352454154452         DC8     'CREATE WORDS With:'
                  0574F52445320
                  576974683A   
 3125    00000015 0D8A                  DC8     0x0D, 0x0A+0x80
 3126    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 3127    00000018 ........              DC32    COLON_NFA
 3128                           
 3129                           //      DABS DABS: ( sd=(LSW MSW) -- ud=(LSW MSW) )
 3130                           //      Leave the absolute value ud of a signed double number.
 3131                           
 3132                            SECTION .text : CONST (2)
 3133                           DABS_NFA:
 3134    00000000 84                    DC8     0x84
 3135    00000001 444142                DC8     'DAB'
 3136    00000004 D3                    DC8     'S'+0x80
 3137    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3138    00000008 ........              DC32    WC_CREATE_NFA
 3139                           DABSF:
 3140                           DABS:
 3141    0000000C ........              DC32    DOCOL
 3142    00000010 ........              DC32    DUP
 3143    00000014 ........              DC32    DPM
 3144    00000018 ........              DC32    SEMIS
 3145                           
 3146                           
 3147                           //      DNEGATE DNEGATE: ( d1 -- d<2>=(LSW MSW) ) RENAMED: DMINUS to DNEGATE
 3148                           //      Convert d1 to its double number two's complement d2.
 3149                           
 3150                            SECTION .text : CONST (2)
 3151                           DNEGATE_NFA:
 3152    00000000 87                    DC8     0x87
 3153    00000001 444E45474154          DC8     'DNEGAT'
 3154    00000007 C5                    DC8     'E'+0x80
 3155                            ALIGNROM 2,0xFFFFFFFF
 3156    00000008 ........              DC32    DABS_NFA
 3157                           DNEGATE:
 3158    0000000C ........              DC32    .+5
 3159                            SECTION .text : CODE (2)
 3160                                   POP2t                   // MSW   //POP  BX
 3160.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3160.2                         //#ifndef TOSCT
 3160.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3160.4                         //#endif
 3160.5                         //      ADDS    p, p, #4
 3160.6                                 ENDM
 3161                                   POP2w                   // LSW   //POP  CX
 3161.1  00000004 57F8042B              LDR     w, [p],#4
 3161.2                         //      LDR     w, [p]
 3161.3                         //      ADDS    p, p, #4
 3161.4                                 ENDM
 3162    00000008 C043                  MVNS    t, t            // negate MSW
 3163    0000000A D243                  MVNS    w, w            // negate LSW
 3164    0000000C 521C                  ADDS    w, w, #1        // add 1 to LSW
 3165                                   DPUSH                   //  --  LSW MSW )
 3165                                   PUSHw   // push w to p, post decrement p
 3165.1  0000000E 47F8042D              STR     w, [p, #-4]!
 3165.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3165.3                         //      STR     w, [p]
 3165.4                                 ENDM
 3165                                   TPUSH
 3165                                   PUSHt   // push t to p, pre decrement p
 3165.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3165.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3165.3                         //      STR     t, [p]
 3165.4                                 ENDM
 3165                                   NEXT
 3165.1                         // ARMv7-M Thumb = .+5
 3165.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3165.3                         // ARMv6-M Thumb = .+4
 3165.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3165                                   NEXT1
 3165.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3165.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3165.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3165.4                         // ARMv6-M Thumb = .+4
 3165.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3165.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3165.7                                 ENDM
 3165.8                                 ENDM
 3165.9                                 ENDM
 3165.10                                ENDM
 3166                           
 3167                           
 3168                           //      DPL_SV: ( -- addr of NDPL ) Contains # of digits after . in double number
 3169                           //      A system variable containing the number of digits to the right of the
 3170                           //      decimal on double integer input. It may also be used to hold output
 3171                           //      column location of a decimal point, in system generated formating. The
 3172                           //      default value on single number input is -1.
 3173                            SECTION .text : CONST (2)
 3174                           DPL_NFA:
 3175    00000000 83                    DC8     0x83
 3176    00000001 4450                  DC8     'DP'
 3177    00000003 CC                    DC8     'L'+0x80
 3178                            ALIGNROM 2,0xFFFFFFFF
 3179    00000004 ........              DC32    DNEGATE_NFA
 3180                           DPL_SV:
 3181    00000008 .............         DC32    DOCON, NDPL
                  ...          
 3182                           
 3183                           
 3184                           //      D.R DDOTR:      ( sd=<LSW MSW> n -- ) SIGNED:
 3185                           //      Print a signed double number sd right aligned
 3186                           //      in a field n characters wide.
 3187                           
 3188                            SECTION .text : CONST (2)
 3189                           DDOTR_NFA:
 3190    00000000 83                    DC8     0x83
 3191    00000001 442E                  DC8     'D.'
 3192    00000003 D2                    DC8     'R'+0x80
 3193                            ALIGNROM 2,0xFFFFFFFF
 3194    00000004 ........              DC32    DPL_NFA
 3195                           DDOTR:
 3196    00000008 ........              DC32    DOCOL
 3197    0000000C ........              DC32    TOR     // N CHAR FIELD LEN to r
 3198    00000010 ........              DC32    SWAP    // ( LSW MSW -- MSW LSW )
 3199    00000014 ........              DC32    OVER    // ( MSW LSW -- MSW LSW MSW )
 3200    00000018 ........              DC32    DABS    // ( MSW LSW MSW -- MSW uLSW uMSW )
 3201    0000001C ........              DC32    BDIGS   // <# SET HLD to Pad
 3202    00000020 ........              DC32    DIGS    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3203    00000024 ........              DC32    SIGN    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3204    00000028 ........              DC32    EDIGS   //      #>  ( d=<LSW MSW>  ---  addr  count )
 3205    0000002C ........              DC32    RFROM   // GET THE N CHAR FIELD LEN
 3206    00000030 ........              DC32    OVER    // ( addr count n -- addr count n count )
 3207    00000034 ........              DC32    SUBB    // ( n addr count addr -- n addr count-n )
 3208    00000038 ........              DC32    SPACES  // SPACES  ( n -- )
 3209    0000003C ........              DC32    TYPE    // ( n addr -- )
 3210    00000040 ........              DC32    SEMIS
 3211                           
 3212                           
 3213                           //      D. DDOT:        ( S32-2'S COMPLEMET = (d=<LSW MSW> -- )
 3214                           //      Print a signed double number from a 32 bit two's complement value.
 3215                           //      The high-order 32 bits are most accessable on the stack. Conversion
 3216                           //      is performed according to the current base. A blank follows.
 3217                           
 3218                            SECTION .text : CONST (2)
 3219                           DDOT_NFA:
 3220    00000000 82                    DC8     0x82
 3221    00000001 44                    DC8     'D'
 3222    00000002 AE                    DC8     '.'+0x80
 3223    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3224    00000004 ........              DC32    DDOTR_NFA
 3225                           DDOT:
 3226    00000008 ........              DC32    DOCOL
 3227    0000000C ........              DC32    ZERO
 3228    00000010 ........              DC32    DDOTR
 3229    00000014 ........              DC32    SPACE
 3230    00000018 ........              DC32    SEMIS
 3231                           
 3232                           
 3233                           //      D+ DPLUS:       ( LSW1 MSW1 LSW2 MSW2 --- LSW MSW )  SIGNED:
 3234                           //      Leave the signed double number sum of two signed double numbers.
 3235                           
 3236                            SECTION .text : CONST (2)
 3237                           DPLUS_NFA:
 3238    00000000 82                    DC8     0x82
 3239    00000001 44                    DC8     'D'
 3240    00000002 AB                    DC8     '+'+0x80
 3241    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3242    00000004 ........              DC32    DDOT_NFA
 3243                           DPLUS:
 3244    00000008 ........              DC32    .+5
 3245                            SECTION .text : CODE (2)
 3246                                   POP2t   //    ldr     t, [p],#4       // MS
 3246.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3246.2                         //#ifndef TOSCT
 3246.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3246.4                         //#endif
 3246.5                         //      ADDS    p, p, #4
 3246.6                                 ENDM
 3247                                   POP2n   //    ldr     n, [p],#4       // LS
 3247.1  00000004 57F8041B              LDR     n, [p],#4
 3247.2                         //      LDR     n, [p]
 3247.3                         //      ADDS    p, p, #4
 3247.4                                 ENDM
 3248                                   POP2x   //    ldr     x, [p],#4       // MS
 3248.1  00000008 57F8043B              LDR     x, [p],#4
 3248.2                         //      LDR     x, [p]
 3248.3                         //      ADDS    p, p, #4
 3248.4                                 ENDM
 3249                                   POP2w   //    ldr     w, [p],#4       // LS
 3249.1  0000000C 57F8042B              LDR     w, [p],#4
 3249.2                         //      LDR     w, [p]
 3249.3                         //      ADDS    p, p, #4
 3249.4                                 ENDM
 3250    00000010 5218                  ADDS    w, w, n         // LS sum, set status flags
 3251    00000012 5841                  ADCS    t, t, x         // MS sum + carry
 3252                                   DPUSH                   //  --  LSW MSW )
 3252                                   PUSHw   // push w to p, post decrement p
 3252.1  00000014 47F8042D              STR     w, [p, #-4]!
 3252.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3252.3                         //      STR     w, [p]
 3252.4                                 ENDM
 3252                                   TPUSH
 3252                                   PUSHt   // push t to p, pre decrement p
 3252.1  00000018 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3252.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3252.3                         //      STR     t, [p]
 3252.4                                 ENDM
 3252                                   NEXT
 3252.1                         // ARMv7-M Thumb = .+5
 3252.2  0000001C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3252.3                         // ARMv6-M Thumb = .+4
 3252.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3252                                   NEXT1
 3252.1  00000020 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3252.2  00000024 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3252.3  00000028 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3252.4                         // ARMv6-M Thumb = .+4
 3252.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3252.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3252.7                                 ENDM
 3252.8                                 ENDM
 3252.9                                 ENDM
 3252.10                                ENDM
 3253                           
 3254                           
 3255                           //      S->D STOD:      ( n -- d=<LSW MSW> ) SIGNED:
 3256                           //      Sign extend a single number to form a double number.
 3257                           //      : S->D DUP 0< NEGATE // hi level equivalent
 3258                           
 3259                            SECTION .text : CONST (2)
 3260                           STOD_NFA:
 3261    00000000 84                    DC8     0x84
 3262    00000001 532D3E                DC8     'S->'
 3263    00000004 C4                    DC8     'D'+0x80
 3264    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3265    00000008 ........              DC32    DPLUS_NFA
 3266                           STOD:
 3267    0000000C ........              DC32    .+5
 3268                            SECTION .text : CODE (2)
 3269                                   POP2w                   // POP LSW
 3269.1  00000000 57F8042B              LDR     w, [p],#4
 3269.2                         //      LDR     w, [p]
 3269.3                         //      ADDS    p, p, #4
 3269.4                                 ENDM
 3270    00000004 4040                  EORS    t, t            // Zero MSW
 3271    00000006 1243                  ORRS    w, w, w         // OR LSW
 3272    00000008 00D5                  BPL     STOD1           // LSW is POS
 3273                           
 3274    0000000A 401E                  SUBS     t, t, #1       // LSW is NEG
 3275                           STOD1:
 3276                                   DPUSH                   //  --  LSW MSW )
 3276                                   PUSHw   // push w to p, post decrement p
 3276.1  0000000C 47F8042D              STR     w, [p, #-4]!
 3276.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3276.3                         //      STR     w, [p]
 3276.4                                 ENDM
 3276                                   TPUSH
 3276                                   PUSHt   // push t to p, pre decrement p
 3276.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3276.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3276.3                         //      STR     t, [p]
 3276.4                                 ENDM
 3276                                   NEXT
 3276.1                         // ARMv7-M Thumb = .+5
 3276.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3276.3                         // ARMv6-M Thumb = .+4
 3276.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3276                                   NEXT1
 3276.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3276.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3276.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3276.4                         // ARMv6-M Thumb = .+4
 3276.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3276.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3276.7                                 ENDM
 3276.8                                 ENDM
 3276.9                                 ENDM
 3276.10                                ENDM
 3277                           
 3278                           
 3279                           //      2* TWOSTAR:     ( n -- n*2 ) LSL 1
 3280                           
 3281                            SECTION .text : CONST (2)
 3282                           TWOSTAR_NFA:
 3283    00000000 82                    DC8     0x82
 3284    00000001 32                    DC8     '2'
 3285    00000002 AA                    DC8     '*'+0x80
 3286    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3287    00000004 ........              DC32    STOD_NFA
 3288                           TWOSTAR:
 3289    00000008 ........              DC32    .+5
 3290                            SECTION .text : CODE (2)
 3291                                   POP2t
 3291.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3291.2                         //#ifndef TOSCT
 3291.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3291.4                         //#endif
 3291.5                         //      ADDS    p, p, #4
 3291.6                                 ENDM
 3292    00000004 4000                  LSLS    t, t, #1        //
 3293                                   TPUSH
 3293                                   PUSHt   // push t to p, pre decrement p
 3293.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3293.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3293.3                         //      STR     t, [p]
 3293.4                                 ENDM
 3293                                   NEXT
 3293.1                         // ARMv7-M Thumb = .+5
 3293.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3293.3                         // ARMv6-M Thumb = .+4
 3293.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3293                                   NEXT1
 3293.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3293.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3293.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3293.4                         // ARMv6-M Thumb = .+4
 3293.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3293.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3293.7                                 ENDM
 3293.8                                 ENDM
 3293.9                                 ENDM
 3294                           
 3295                           
 3296                           //      2/ TWOSLASH:    ( n -- n/1 ) ASR 1 (FLOORED)
 3297                           
 3298                            SECTION .text : CONST (2)
 3299                           TWOSLASH_NFA:
 3300    00000000 82                    DC8     0x82
 3301    00000001 32                    DC8     '2'
 3302    00000002 AF                    DC8     '/'+0x80
 3303    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3304    00000004 ........              DC32    TWOSTAR_NFA
 3305                           TWOSLASH:
 3306    00000008 ........              DC32    .+5
 3307                            SECTION .text : CODE (2)
 3308                                   POP2t
 3308.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3308.2                         //#ifndef TOSCT
 3308.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3308.4                         //#endif
 3308.5                         //      ADDS    p, p, #4
 3308.6                                 ENDM
 3309    00000004 4010                  ASRS    t, t, #1        //
 3310                                   TPUSH
 3310                                   PUSHt   // push t to p, pre decrement p
 3310.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3310.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3310.3                         //      STR     t, [p]
 3310.4                                 ENDM
 3310                                   NEXT
 3310.1                         // ARMv7-M Thumb = .+5
 3310.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3310.3                         // ARMv6-M Thumb = .+4
 3310.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3310                                   NEXT1
 3310.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3310.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3310.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3310.4                         // ARMv6-M Thumb = .+4
 3310.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3310.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3310.7                                 ENDM
 3310.8                                 ENDM
 3310.9                                 ENDM
 3311                                   
 3312                           
 3313                           //      1- ONEM:        ( n -- n-1 )
 3314                           
 3315                            SECTION .text : CONST (2)
 3316                           ONEM_NFA:
 3317    00000000 82                    DC8     0x82
 3318    00000001 31                    DC8     '1'
 3319    00000002 AD                    DC8     '-'+0x80
 3320    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3321    00000004 ........              DC32    TWOSLASH_NFA
 3322                           ONEM:
 3323    00000008 ........              DC32    .+5
 3324                            SECTION .text : CODE (2)
 3325                                   POP2t
 3325.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3325.2                         //#ifndef TOSCT
 3325.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3325.4                         //#endif
 3325.5                         //      ADDS    p, p, #4
 3325.6                                 ENDM
 3326    00000004 401E                  SUBS    t, t, #1        //
 3327                                   TPUSH
 3327                                   PUSHt   // push t to p, pre decrement p
 3327.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3327.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3327.3                         //      STR     t, [p]
 3327.4                                 ENDM
 3327                                   NEXT
 3327.1                         // ARMv7-M Thumb = .+5
 3327.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3327.3                         // ARMv6-M Thumb = .+4
 3327.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3327                                   NEXT1
 3327.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3327.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3327.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3327.4                         // ARMv6-M Thumb = .+4
 3327.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3327.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3327.7                                 ENDM
 3327.8                                 ENDM
 3327.9                                 ENDM
 3328                           
 3329                           
 3330                           //      1+ ONEP:        ( n -- n+1 )
 3331                           
 3332                            SECTION .text : CONST (2)
 3333                           ONEP_NFA:
 3334    00000000 82                    DC8     0x82
 3335    00000001 31                    DC8     '1'
 3336    00000002 AB                    DC8     '+'+0x80
 3337    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3338    00000004 ........              DC32    ONEM_NFA
 3339                           ONEP:
 3340    00000008 ........              DC32    .+5
 3341                            SECTION .text : CODE (2)
 3342                                   POP2t
 3342.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3342.2                         //#ifndef TOSCT
 3342.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3342.4                         //#endif
 3342.5                         //      ADDS    p, p, #4
 3342.6                                 ENDM
 3343    00000004 401C                  ADDS    t, t, #1        //
 3344                                   TPUSH
 3344                                   PUSHt   // push t to p, pre decrement p
 3344.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3344.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3344.3                         //      STR     t, [p]
 3344.4                                 ENDM
 3344                                   NEXT
 3344.1                         // ARMv7-M Thumb = .+5
 3344.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3344.3                         // ARMv6-M Thumb = .+4
 3344.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3344                                   NEXT1
 3344.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3344.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3344.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3344.4                         // ARMv6-M Thumb = .+4
 3344.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3344.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3344.7                                 ENDM
 3344.8                                 ENDM
 3344.9                                 ENDM
 3345                           
 3346                           
 3347                           //      2+ TWOP:        ( n -- n+2 )
 3348                           
 3349                            SECTION .text : CONST (2)
 3350                           TWOP_NFA:
 3351    00000000 82                    DC8     0x82
 3352    00000001 32                    DC8     '2'
 3353    00000002 AB                    DC8     '+'+0x80
 3354    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3355    00000004 ........              DC32    ONEP_NFA
 3356                           TWOP:
 3357    00000008 ........              DC32    .+5
 3358                            SECTION .text : CODE (2)
 3359                                   POP2t
 3359.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3359.2                         //#ifndef TOSCT
 3359.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3359.4                         //#endif
 3359.5                         //      ADDS    p, p, #4
 3359.6                                 ENDM
 3360    00000004 801C                  ADDS    t, t, #2
 3361                                   TPUSH
 3361                                   PUSHt   // push t to p, pre decrement p
 3361.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3361.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3361.3                         //      STR     t, [p]
 3361.4                                 ENDM
 3361                                   NEXT
 3361.1                         // ARMv7-M Thumb = .+5
 3361.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3361.3                         // ARMv6-M Thumb = .+4
 3361.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3361                                   NEXT1
 3361.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3361.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3361.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3361.4                         // ARMv6-M Thumb = .+4
 3361.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3361.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3361.7                                 ENDM
 3361.8                                 ENDM
 3361.9                                 ENDM
 3362                           
 3363                           
 3364                           //      4+ FOURP:       ( n -- n+4 )
 3365                           
 3366                            SECTION .text : CONST (2)
 3367                           FOURP_NFA:
 3368    00000000 82                    DC8     0x82
 3369    00000001 34                    DC8     '4'
 3370    00000002 AB                    DC8     '+'+0x80
 3371    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3372    00000004 ........              DC32    TWOP_NFA
 3373                           FOURP:
 3374    00000008 ........              DC32    .+5
 3375                            SECTION .text : CODE (2)
 3376                                   POP2t
 3376.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3376.2                         //#ifndef TOSCT
 3376.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3376.4                         //#endif
 3376.5                         //      ADDS    p, p, #4
 3376.6                                 ENDM
 3377    00000004 001D                  ADDS    t, t, #4
 3378                                   TPUSH
 3378                                   PUSHt   // push t to p, pre decrement p
 3378.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3378.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3378.3                         //      STR     t, [p]
 3378.4                                 ENDM
 3378                                   NEXT
 3378.1                         // ARMv7-M Thumb = .+5
 3378.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3378.3                         // ARMv6-M Thumb = .+4
 3378.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3378                                   NEXT1
 3378.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3378.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3378.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3378.4                         // ARMv6-M Thumb = .+4
 3378.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3378.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3378.7                                 ENDM
 3378.8                                 ENDM
 3378.9                                 ENDM
 3379                           
 3380                           
 3381                           //      4- FOURM:       ( n -- n-4 )
 3382                           
 3383                            SECTION .text : CONST (2)
 3384                           FOURM_NFA:
 3385    00000000 82                    DC8     0x82
 3386    00000001 34                    DC8     '4'
 3387    00000002 AD                    DC8     '-'+0x80
 3388    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3389    00000004 ........              DC32    FOURP_NFA
 3390                           FOURM:
 3391    00000008 ........              DC32    .+5
 3392                            SECTION .text : CODE (2)
 3393                                   POP2t
 3393.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3393.2                         //#ifndef TOSCT
 3393.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3393.4                         //#endif
 3393.5                         //      ADDS    p, p, #4
 3393.6                                 ENDM
 3394    00000004 001F                  SUBS    t, t, #4
 3395                                   TPUSH
 3395                                   PUSHt   // push t to p, pre decrement p
 3395.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3395.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3395.3                         //      STR     t, [p]
 3395.4                                 ENDM
 3395                                   NEXT
 3395.1                         // ARMv7-M Thumb = .+5
 3395.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3395.3                         // ARMv6-M Thumb = .+4
 3395.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3395                                   NEXT1
 3395.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3395.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3395.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3395.4                         // ARMv6-M Thumb = .+4
 3395.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3395.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3395.7                                 ENDM
 3395.8                                 ENDM
 3395.9                                 ENDM
 3396                           
 3397                           
 3398                           //      0 ZERO: ( -- 0 )
 3399                           
 3400                            SECTION .text : CONST (2)
 3401                           ZERO_NFA:
 3402    00000000 81                    DC8     0x81
 3403    00000001 B0                    DC8     '0'+0x80
 3404    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3405    00000004 ........              DC32    FOURM_NFA
 3406                           ZERO:
 3407    00000008 ........00000         DC32    DOCON, 0
                  000          
 3408                           
 3409                           
 3410                           //      1 ONE: ( -- 1 )
 3411                           
 3412                            SECTION .text : CONST (2)
 3413                           ONE_NFA:
 3414    00000000 81                    DC8     0x81
 3415    00000001 B1                    DC8     '1'+0x80
 3416    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3417    00000004 ........              DC32    ZERO_NFA
 3418                           ONE:
 3419    00000008 ........01000         DC32    DOCON, 1
                  000          
 3420                           
 3421                           
 3422                           //      2 TWO: ( -- 2 )
 3423                           
 3424                            SECTION .text : CONST (2)
 3425                           TWO_NFA:
 3426    00000000 81                    DC8     0x81
 3427    00000001 B2                    DC8     '2'+0x80
 3428    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3429    00000004 ........              DC32    ONE_NFA
 3430                           TWO:
 3431    00000008 ........02000         DC32    DOCON, 2
                  000          
 3432                           
 3433                           
 3434                           //      3 THREE: ( -- 3 )
 3435                           
 3436                            SECTION .text : CONST (2)
 3437                           THREE_NFA:
 3438    00000000 81                    DC8     0x81
 3439    00000001 B3                    DC8     '3'+0x80
 3440    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3441    00000004 ........              DC32    TWO_NFA
 3442                           THREE:
 3443    00000008 ........03000         DC32    DOCON, 3
                  000          
 3444                           
 3445                           
 3446                           //      4 FOUR: ( -- 4 )
 3447                           
 3448                            SECTION .text : CONST (2)
 3449                           FOUR_NFA:
 3450    00000000 81                    DC8     0x81
 3451    00000001 B4                    DC8     '4'+0x80
 3452    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3453    00000004 ........              DC32    THREE_NFA
 3454                           FOUR:
 3455    00000008 ........04000         DC32    DOCON, 4
                  000          
 3456                           
 3457                           
 3458                           //      M* MSTAR:       ( n1 n2 -- d=<S32LSW S32MSW> )  SIGNED:
 3459                           //      A mixed magnitude math operation which leaves the double number
 3460                           //      signed product of two signed number.
 3461                           
 3462                            SECTION .text : CONST (2)
 3463                           MSTAR_NFA:
 3464    00000000 82                    DC8     0x82
 3465    00000001 4D                    DC8     'M'
 3466    00000002 AA                    DC8     '*'+0x80
 3467    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3468    00000004 ........              DC32    FOUR_NFA
 3469                           MSTAR:
 3470    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3471    00000010 ........              DC32    XORR
 3472    00000014 ........              DC32    TOR
 3473    00000018 ........              DC32    ABS
 3474    0000001C ........              DC32    SWAP
 3475    00000020 ........              DC32    ABS
 3476    00000024 ........              DC32    USTAR
 3477    00000028 ........              DC32    RFROM
 3478    0000002C ........              DC32    DPM
 3479    00000030 ........              DC32    SEMIS
 3480                           
 3481                           
 3482                           //      M/ MSLASH:      ( sd  n1  ---  d=<s32REM  S32QUO> )
 3483                           //      A mixed magnitude math operator which leaves the signed remainder
 3484                           //      and signed quotient from sd, a double number dividend and divisor n1.
 3485                           //      The remainder takes its sign from the dividend.
 3486                           
 3487                            SECTION .text : CONST (2)
 3488                           MSLASH_NFA:
 3489    00000000 82                    DC8     0x82
 3490    00000001 4D                    DC8     'M'
 3491    00000002 AF                    DC8     '/'+0x80
 3492    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3493    00000004 ........              DC32    MSTAR_NFA
 3494                           MSLASH:
 3495    00000008 ........              DC32    DOCOL
 3496    0000000C ........              DC32    OVER
 3497    00000010 ........              DC32    TOR
 3498    00000014 ........              DC32    TOR
 3499    00000018 ........              DC32    DABS    // ( LSW MSW -- uLSW uMSW )
 3500    0000001C ........              DC32    R
 3501    00000020 ........              DC32    ABS
 3502    00000024 ........              DC32    USLASH
 3503    00000028 ........              DC32    RFROM
 3504    0000002C ........              DC32    R
 3505    00000030 ........              DC32    XORR
 3506    00000034 ........              DC32    PM
 3507    00000038 ........              DC32    SWAP
 3508    0000003C ........              DC32    RFROM
 3509    00000040 ........              DC32    PM
 3510    00000044 ........              DC32    SWAP
 3511    00000048 ........              DC32    SEMIS
 3512                           
 3513                           
 3514                           //      * STAR: ( n1 n2 -- prod=n3 )
 3515                           //      Leave the signed product n3 of two (32bit) signed numbers n1 and n2.
 3516                           
 3517                            SECTION .text : CONST (2)
 3518                           STAR_NFA:
 3519    00000000 81                    DC8     0x81
 3520    00000001 AA                    DC8     '*'+0x80
 3521    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3522    00000004 ........              DC32    MSLASH_NFA
 3523                           STAR:
 3524    00000008 ........              DC32    DOCOL
 3525    0000000C ........              DC32    MSTAR
 3526    00000010 ........              DC32    DROP
 3527    00000014 ........              DC32    SEMIS
 3528                           
 3529                           
 3530                           //      /MOD SLMOD:     ( n1 n2 -- rem quot )   SIGNED:
 3531                           //      Leave the remainder and signed quotient of n1/n2. The remainder has
 3532                           //      the sign of the dividend.
 3533                           
 3534                            SECTION .text : CONST (2)
 3535                           SLMOD_NFA:
 3536    00000000 84                    DC8     0x84
 3537    00000001 2F4D4F                DC8     '/MO'
 3538    00000004 C4                    DC8     'D'+0x80
 3539    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3540    00000008 ........              DC32    STAR_NFA
 3541                           SLMOD:
 3542    0000000C ........              DC32    DOCOL
 3543    00000010 ........              DC32    TOR
 3544    00000014 ........              DC32    STOD
 3545    00000018 ........              DC32    RFROM
 3546    0000001C ........              DC32    MSLASH
 3547    00000020 ........              DC32    SEMIS
 3548                           
 3549                           
 3550                           //      / SLASH:        ( sn1 sn2 -- sn ) SIGNED:
 3551                           //      Leave the signed quotient sn of sn1/sn2.
 3552                           
 3553                            SECTION .text : CONST (2)
 3554                           SLASH_NFA:
 3555    00000000 81                    DC8     0x81
 3556    00000001 AF                    DC8     '/'+0x80
 3557    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3558    00000004 ........              DC32    SLMOD_NFA
 3559                           SLASH:
 3560    00000008 ........              DC32    DOCOL
 3561    0000000C ........              DC32    SLMOD
 3562    00000010 ........              DC32    SWAP
 3563    00000014 ........              DC32    DROP
 3564    00000018 ........              DC32    SEMIS
 3565                           
 3566                           
 3567                           //      MOD MOD:        ( sn1 n2 -- modulo )
 3568                           //      Leave the remainder of sn1/n2, with the same sign as sn1.
 3569                           
 3570                            SECTION .text : CONST (2)
 3571                           MODD_NFA:
 3572    00000000 83                    DC8     0x83
 3573    00000001 4D4F                  DC8     'MO'
 3574    00000003 C4                    DC8     'D'+0x80
 3575                            ALIGNROM 2,0xFFFFFFFF
 3576    00000004 ........              DC32    SLASH_NFA
 3577                           MOD:
 3578    00000008 ........              DC32    DOCOL
 3579    0000000C ........              DC32    SLMOD
 3580    00000010 ........              DC32    DROP
 3581    00000014 ........              DC32    SEMIS
 3582                           
 3583                           
 3584                           //      */MOD SSMOD:    ( n1 n2 n3 -- n4 n5 )
 3585                           //      Leave the quotient n5 and remainder n4 of the operation n1*n2/n3 A
 3586                           //      31 bit intermediate product is used as for */.
 3587                           
 3588                            SECTION .text : CONST (2)
 3589                           SSMOD_NFA:
 3590    00000000 85                    DC8     0x85
 3591    00000001 2A2F4D4F              DC8     '*/MO'
 3592    00000005 C4                    DC8     'D'+0x80
 3593    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 3594    00000008 ........              DC32    MODD_NFA
 3595                           SSMOD:
 3596    0000000C ........              DC32    DOCOL
 3597    00000010 ........              DC32    TOR
 3598    00000014 ........              DC32    MSTAR
 3599    00000018 ........              DC32    RFROM
 3600    0000001C ........              DC32    MSLASH
 3601    00000020 ........              DC32    SEMIS
 3602                           
 3603                           
 3604                           //      */ SSLASH:      ( n1 n2 n3 -- n4 )
 3605                           //      Leave the ratio n4 = n1*n2/n3 where all are signed numbers.
 3606                           //      Retention of an intermediate 31 bit product permits greater accuracy
 3607                           //      than would. be available with the sequence:
 3608                           //              n1  n2  *  n3  /
 3609                           
 3610                            SECTION .text : CONST (2)
 3611                           SSLASH_NFA:
 3612    00000000 82                    DC8     0x82
 3613    00000001 2A                    DC8     '*'
 3614    00000002 AF                    DC8     '/'+0x80
 3615    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3616    00000004 ........              DC32    SSMOD_NFA
 3617                           SSLASH:
 3618    00000008 ........              DC32    DOCOL
 3619    0000000C ........              DC32    SSMOD
 3620    00000010 ........              DC32    SWAP
 3621    00000014 ........              DC32    DROP
 3622    00000018 ........              DC32    SEMIS
 3623                           
 3624                           
 3625                           //      + PLUS: ( n1 n2 -- n3 )
 3626                           //      Add n1 and n2, leaving sum n3
 3627                           
 3628                            SECTION .text : CONST (2)
 3629                           PLUS_NFA:
 3630    00000000 81                    DC8     0x81
 3631    00000001 AB                    DC8     0xAB    // '+' + 0x80
 3632    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3633    00000004 ........              DC32    SSLASH_NFA
 3634                           PLUS:
 3635    00000008 ........              DC32    .+5
 3636                            SECTION .text : CODE (2)
 3637                                   POP2t
 3637.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3637.2                         //#ifndef TOSCT
 3637.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3637.4                         //#endif
 3637.5                         //      ADDS    p, p, #4
 3637.6                                 ENDM
 3638                                   POP2n
 3638.1  00000004 57F8041B              LDR     n, [p],#4
 3638.2                         //      LDR     n, [p]
 3638.3                         //      ADDS    p, p, #4
 3638.4                                 ENDM
 3639    00000008 4018                  ADDS    t, t, n
 3640                                   TPUSH
 3640                                   PUSHt   // push t to p, pre decrement p
 3640.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3640.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3640.3                         //      STR     t, [p]
 3640.4                                 ENDM
 3640                                   NEXT
 3640.1                         // ARMv7-M Thumb = .+5
 3640.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3640.3                         // ARMv6-M Thumb = .+4
 3640.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3640                                   NEXT1
 3640.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3640.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3640.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3640.4                         // ARMv6-M Thumb = .+4
 3640.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3640.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3640.7                                 ENDM
 3640.8                                 ENDM
 3640.9                                 ENDM
 3641                           
 3642                           
 3643                           //      - SUBB: ( n1 n2 -- n3 )
 3644                           //      Leave the difference of n1-n2 as n3.
 3645                           //      1 2 - . -1
 3646                           //      2 1 - .  1
 3647                           
 3648                            SECTION .text : CONST (2)
 3649                           SUB_NFA:
 3650    00000000 81                    DC8     0x81
 3651    00000001 AD                    DC8     '-'+0x80
 3652    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3653    00000004 ........              DC32    PLUS_NFA
 3654                           SUBB:
 3655    00000008 ........              DC32    .+5
 3656                            SECTION .text : CODE (2)
 3657                                   POP2t
 3657.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3657.2                         //#ifndef TOSCT
 3657.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3657.4                         //#endif
 3657.5                         //      ADDS    p, p, #4
 3657.6                                 ENDM
 3658                                   POP2n
 3658.1  00000004 57F8041B              LDR     n, [p],#4
 3658.2                         //      LDR     n, [p]
 3658.3                         //      ADDS    p, p, #4
 3658.4                                 ENDM
 3659    00000008 081A                  SUBS    t, n, t
 3660                                   TPUSH
 3660                                   PUSHt   // push t to p, pre decrement p
 3660.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3660.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3660.3                         //      STR     t, [p]
 3660.4                                 ENDM
 3660                                   NEXT
 3660.1                         // ARMv7-M Thumb = .+5
 3660.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3660.3                         // ARMv6-M Thumb = .+4
 3660.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3660                                   NEXT1
 3660.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3660.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3660.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3660.4                         // ARMv6-M Thumb = .+4
 3660.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3660.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3660.7                                 ENDM
 3660.8                                 ENDM
 3660.9                                 ENDM
 3661                           
 3662                           
 3663                           //      = EQUAL:        (n1 n2 -- f )
 3664                           //      Leave a true flag if n1=n2// otherwise leave a false flag.
 3665                           
 3666                            SECTION .text : CONST (2)
 3667                           EQUAL_NFA:
 3668    00000000 81                    DC8     0x81
 3669    00000001 BD                    DC8     '='+0x80
 3670    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3671    00000004 ........              DC32    SUB_NFA
 3672                           EQUAL:
 3673    00000008 ........              DC32    .+5
 3674                            SECTION .text : CODE (2)
 3675                           #ifdef TRUE_EQU_NEG_ONE
 3676    00000000 4040                  EORS    t, t
 3677                           #endif
 3678                                   POP2t
 3678.1  00000002 57F8040B              LDR     t, [p],#4       // Post-increment
 3678.2                         //#ifndef TOSCT
 3678.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3678.4                         //#endif
 3678.5                         //      ADDS    p, p, #4
 3678.6                                 ENDM
 3679                                   POP2n
 3679.1  00000006 57F8041B              LDR     n, [p],#4
 3679.2                         //      LDR     n, [p]
 3679.3                         //      ADDS    p, p, #4
 3679.4                                 ENDM
 3680    0000000A 401A                  SUBS    t, t, n
 3681    0000000C 09D0                  BEQ     EQUAL_TRUE
 3682    0000000E 4040                  EORS    t, t
 3683                                   TPUSH
 3683                                   PUSHt   // push t to p, pre decrement p
 3683.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3683.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3683.3                         //      STR     t, [p]
 3683.4                                 ENDM
 3683                                   NEXT
 3683.1                         // ARMv7-M Thumb = .+5
 3683.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3683.3                         // ARMv6-M Thumb = .+4
 3683.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3683                                   NEXT1
 3683.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3683.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3683.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3683.4                         // ARMv6-M Thumb = .+4
 3683.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3683.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3683.7                                 ENDM
 3683.8                                 ENDM
 3683.9                                 ENDM
 3684                           
 3685                           EQUAL_TRUE:
 3686                           #ifdef TRUE_EQU_NEG_ONE
 3687    00000022 0138                  SUBS    t, #1 // -1
 3688                           #else
 3690                           #endif
 3691                                   TPUSH
 3691                                   PUSHt   // push t to p, pre decrement p
 3691.1  00000024 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3691.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3691.3                         //      STR     t, [p]
 3691.4                                 ENDM
 3691                                   NEXT
 3691.1                         // ARMv7-M Thumb = .+5
 3691.2  00000028 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3691.3                         // ARMv6-M Thumb = .+4
 3691.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3691                                   NEXT1
 3691.1  0000002C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3691.2  00000030 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3691.3  00000034 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3691.4                         // ARMv6-M Thumb = .+4
 3691.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3691.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3691.7                                 ENDM
 3691.8                                 ENDM
 3691.9                                 ENDM
 3692                           /*
 3693                                   DC32    DOCOL
 3694                                   DC32    SUBB
 3695                                   DC32    ZEQU
 3696                                   DC32    SEMIS
 3697                           */
 3698                           
 3699                           
 3700                           //      < LESSTHAN:     ( n1 n2 -- f ) SIGNED:
 3701                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3702                           //      C0 1 < . 0  -1 C0 < . 1
 3703                           
 3704                            SECTION .text : CONST (2)
 3705                           LESSTHAN_NFA:
 3706    00000000 81                    DC8     0x81
 3707    00000001 BC                    DC8     '<'+0x80
 3708    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3709    00000004 ........              DC32    EQUAL_NFA
 3710                           LESSTHAN:
 3711    00000008 ........              DC32    .+5
 3712                            SECTION .text : CODE (2)
 3713                           #ifdef TRUE_EQU_NEG_ONE
 3714    00000000 4040                  EORS    t, t    // zero t
 3715    00000002 0138                  SUBS    t, #1   // -1
 3716                           #else
 3718                           #endif
 3719                                   POP2n                           // n2
 3719.1  00000004 57F8041B              LDR     n, [p],#4
 3719.2                         //      LDR     n, [p]
 3719.3                         //      ADDS    p, p, #4
 3719.4                                 ENDM
 3720                                   POP2w                           // n1
 3720.1  00000008 57F8042B              LDR     w, [p],#4
 3720.2                         //      LDR     w, [p]
 3720.3                         //      ADDS    p, p, #4
 3720.4                                 ENDM
 3721    0000000C 9142                  CMP     n, w        // n1 < n2
 3722    0000000E 00DC                  BGT     LESS1
 3723                           
 3724    00000010 4040                  EORS    t, t    // zero t =< n
 3725                           LESS1:
 3726                                   TPUSH
 3726                                   PUSHt   // push t to p, pre decrement p
 3726.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3726.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3726.3                         //      STR     t, [p]
 3726.4                                 ENDM
 3726                                   NEXT
 3726.1                         // ARMv7-M Thumb = .+5
 3726.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3726.3                         // ARMv6-M Thumb = .+4
 3726.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3726                                   NEXT1
 3726.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3726.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3726.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3726.4                         // ARMv6-M Thumb = .+4
 3726.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3726.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3726.7                                 ENDM
 3726.8                                 ENDM
 3726.9                                 ENDM
 3727                           
 3728                           
 3729                           //      U< ULESSTHAN:   ( n1 n2 -- f )  UNSIGNED:
 3730                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3731                           //      -1 -2 U< . 0  -1 2 U< . 0  1 2 U< . 1
 3732                           
 3733                            SECTION .text : CONST (2)
 3734                           ULESSTHAN_NFA:
 3735    00000000 82                    DC8     0x82
 3736    00000001 55                    DC8     'U'
 3737    00000002 BC                    DC8     '<'+0x80
 3738    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3739    00000004 ........              DC32    LESSTHAN_NFA
 3740                           ULESSTHAN:
 3741    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3742    00000010 .............         DC32    XORR, ZLESS
                  ...          
 3743    00000018 ........              DC32    ZBRAN
 3744    0000001C 18000000              DC32    ULES1-. //IF
 3745                           
 3746    00000020 .............         DC32    DROP, ZLESS
                  ...          
 3747    00000028 ........              DC32    ZEQU
 3748    0000002C ........              DC32    BRAN
 3749    00000030 0C000000              DC32    ULES2-.
 3750                           
 3751                           ULES1:
 3752    00000034 .............         DC32    SUBB,ZLESS      //ELSE
                  ...          
 3753                           
 3754                           ULES2:
 3755    0000003C ........              DC32    SEMIS           //endif
 3756                           
 3757                           
 3758                           //      > GREATERTHAN:  ( n1 n2 --  f ) SIGNED: L0
 3759                           //      Leave a true flag if n1 is greater than n2 otherwise a false flag.
 3760                           //      -1 1 > . 0  1 -1 > . 1
 3761                           
 3762                            SECTION .text : CONST (2)
 3763                           GREATERTHAN_NFA:
 3764    00000000 81                    DC8     0x81
 3765    00000001 BE                    DC8     '>'+0x80
 3766    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3767    00000004 ........              DC32    ULESSTHAN_NFA
 3768                           GREATERTHAN:
 3769    00000008 ........              DC32    DOCOL
 3770    0000000C ........              DC32    SWAP
 3771    00000010 ........              DC32    LESSTHAN
 3772    00000014 ........              DC32    SEMIS
 3773                           
 3774                           
 3775                           //      0= ZEQU:        ( n -- f )
 3776                           //      Leave a true flag is the number is equal to zero, otherwise leave a
 3777                           //      false flag. CHANGED Code dependent on true flag being 1 FOR -1 TRUE
 3778                           
 3779                            SECTION .text : CONST (2)
 3780                           ZEQU_NFA:
 3781    00000000 82                    DC8     0x82
 3782    00000001 30                    DC8     '0'
 3783    00000002 BD                    DC8     '='+0x80
 3784    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3785    00000004 ........              DC32    GREATERTHAN_NFA
 3786                           ZEQU:
 3787    00000008 ........              DC32    .+5
 3788                            SECTION .text : CODE (2)
 3789    00000000 4040                  EORS    t, t
 3790                                   POP2n
 3790.1  00000002 57F8041B              LDR     n, [p],#4
 3790.2                         //      LDR     n, [p]
 3790.3                         //      ADDS    p, p, #4
 3790.4                                 ENDM
 3791    00000006 0029                  CMP     n, #0
 3792    00000008 00D1                  BNE     ZEQU_ZERO
 3793                           
 3794                           #ifdef TRUE_EQU_NEG_ONE
 3795    0000000A 401E                  SUBS    t, t, #1
 3796                           #else
 3798                           #endif
 3799                           
 3800                           ZEQU_ZERO:
 3801                                   TPUSH
 3801                                   PUSHt   // push t to p, pre decrement p
 3801.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3801.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3801.3                         //      STR     t, [p]
 3801.4                                 ENDM
 3801                                   NEXT
 3801.1                         // ARMv7-M Thumb = .+5
 3801.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3801.3                         // ARMv6-M Thumb = .+4
 3801.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3801                                   NEXT1
 3801.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3801.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3801.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3801.4                         // ARMv6-M Thumb = .+4
 3801.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3801.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3801.7                                 ENDM
 3801.8                                 ENDM
 3801.9                                 ENDM
 3802                           
 3803                           
 3804                           //      0< ZLESS:       ( n -- f )
 3805                           //      Leave a true flag if the number is less than zero (negative),
 3806                           //      otherwise leave a false flag.
 3807                           
 3808                            SECTION .text : CONST (2)
 3809                           ZLESS_NFA:
 3810    00000000 82                    DC8     0x82
 3811    00000001 30                    DC8     '0'
 3812    00000002 BC                    DC8     '<'+0x80
 3813    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3814    00000004 ........              DC32    ZEQU_NFA
 3815                           ZLESS:
 3816    00000008 ........              DC32    .+5
 3817                            SECTION .text : CODE (2)
 3818                           #ifdef TOSCT    // REPLACING t SO THIS IS FASTER THAN POP2n
 3821                           #else
 3822                                   POP2n
 3822.1  00000000 57F8041B              LDR     n, [p],#4
 3822.2                         //      LDR     n, [p]
 3822.3                         //      ADDS    p, p, #4
 3822.4                                 ENDM
 3823                           #endif
 3824                           #ifdef TRUE_EQU_NEG_ONE
 3825    00000004 4040                  EORS    t, t
 3826    00000006 0138                  SUBS    t, #1   // TRUE -1
 3827                           #else
 3829                           #endif
 3830    00000008 0943                  ORRS    n, n, n // SET FLAGS
 3831    0000000A 00D4                  BMI     ZLESS1  // JS   ZLESS1
 3832                           
 3833    0000000C 4040                  EORS    t, t    // FALSE
 3834                           ZLESS1:
 3835                                   TPUSH
 3835                                   PUSHt   // push t to p, pre decrement p
 3835.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3835.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3835.3                         //      STR     t, [p]
 3835.4                                 ENDM
 3835                                   NEXT
 3835.1                         // ARMv7-M Thumb = .+5
 3835.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3835.3                         // ARMv6-M Thumb = .+4
 3835.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3835                                   NEXT1
 3835.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3835.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3835.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3835.4                         // ARMv6-M Thumb = .+4
 3835.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3835.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3835.7                                 ENDM
 3835.8                                 ENDM
 3835.9                                 ENDM
 3836                           
 3837                           
 3838                           //      BIN BIN:        ( -- )
 3839                           //      Set the numeric conversion base to TWO (bianry).
 3840                           
 3841                            SECTION .text : CONST (2)
 3842                           BIN_NFA:
 3843    00000000 83                    DC8     0x83
 3844    00000001 4249                  DC8     'BI'
 3845    00000003 CE                    DC8     'N'+0x80
 3846                            ALIGNROM 2,0xFFFFFFFF
 3847    00000004 ........              DC32    ZLESS_NFA
 3848                           BIN:
 3849    00000008 ........              DC32    DOCOL
 3850    0000000C ........02000         DC32    STRVA, 2, NBASE
                  000........  
 3851    00000018 ........              DC32    SEMIS
 3852                           
 3853                           
 3854                           //      HEX HEX:        ( -- )
 3855                           //      Set the numeric conversion base to sixteen (hexadecimal).
 3856                           
 3857                            SECTION .text : CONST (2)
 3858                           HEX_NFA:
 3859    00000000 83                    DC8     0x83
 3860    00000001 4845                  DC8     'HE'
 3861    00000003 D8                    DC8     'X'+0x80
 3862                            ALIGNROM 2,0xFFFFFFFF
 3863    00000004 ........              DC32    BIN_NFA
 3864                           HEX:
 3865    00000008 ........              DC32    DOCOL
 3866    0000000C ........10000         DC32    STRVA, 16, NBASE
                  000........  
 3867    00000018 ........              DC32    SEMIS
 3868                           
 3869                           
 3870                           //      DECIMAL DECIMAL:        ( -- )
 3871                           //      Set the numeric conversion base to TEN (decimal).
 3872                           //      DEC IS A NUMBER!
 3873                           
 3874                            SECTION .text : CONST (2)
 3875                           DECIMAL_NFA:
 3876    00000000 87                    DC8     0x87
 3877    00000001 444543494D41          DC8     'DECIMA'
 3878    00000007 CC                    DC8     'L'+0x80
 3879                            ALIGNROM 2,0xFFFFFFFF
 3880    00000008 ........              DC32    HEX_NFA
 3881                           DECIMAL:
 3882    0000000C ........              DC32    DOCOL
 3883    00000010 ........0A000         DC32    STRVA, 10, NBASE
                  000........  
 3884    0000001C ........              DC32    SEMIS
 3885                           
 3886                           
 3887                           //      NEGATE NEGATE: ( n1 -- n2 ) RENAMED: MINUS to NEGATE
 3888                           //      Leave the two's complement of a number.
 3889                           
 3890                            SECTION .text : CONST (2)
 3891                           NEGATE_NFA:
 3892    00000000 86                    DC8     0x86
 3893    00000001 4E45474154            DC8     'NEGAT'
 3894    00000006 C5                    DC8     'E'+0x80
 3895    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 3896    00000008 ........              DC32    DECIMAL_NFA
 3897                           NEGATE:
 3898    0000000C ........              DC32    .+5
 3899                            SECTION .text : CODE (2)
 3900                                   POP2t                   // MVN YES
 3900.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3900.2                         //#ifndef TOSCT
 3900.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3900.4                         //#endif
 3900.5                         //      ADDS    p, p, #4
 3900.6                                 ENDM
 3901    00000004 C043                  MVNS     t, t           // 1's compliment
 3902    00000006 401C                  ADDS     t, t, #1       // 2's compliment
 3903                                   TPUSH
 3903                                   PUSHt   // push t to p, pre decrement p
 3903.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3903.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3903.3                         //      STR     t, [p]
 3903.4                                 ENDM
 3903                                   NEXT
 3903.1                         // ARMv7-M Thumb = .+5
 3903.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3903.3                         // ARMv6-M Thumb = .+4
 3903.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3903                                   NEXT1
 3903.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3903.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3903.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3903.4                         // ARMv6-M Thumb = .+4
 3903.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3903.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3903.7                                 ENDM
 3903.8                                 ENDM
 3903.9                                 ENDM
 3904                           
 3905                           
 3906                           //      ABS ABS:        ( n -- ub )
 3907                           //      Leave the absolute value of n as un.
 3908                           
 3909                            SECTION .text : CONST (2)
 3910                           ABS1_NFA:
 3911    00000000 83                    DC8     0x83
 3912    00000001 4142                  DC8     'AB'
 3913    00000003 D3                    DC8     'S'+0x80
 3914                            ALIGNROM 2,0xFFFFFFFF
 3915    00000004 ........              DC32    NEGATE_NFA
 3916                           ABS:
 3917    00000008 ........              DC32    DOCOL
 3918    0000000C ........              DC32    DUP
 3919    00000010 ........              DC32    PM
 3920    00000014 ........              DC32    SEMIS
 3921                           
 3922                           
 3923                           //      MIN MIN:        ( n1 n2 -- min )
 3924                           //      Leave the smaller of two numbers.
 3925                           
 3926                            SECTION .text : CONST (2)
 3927                           MIN_NFA:
 3928    00000000 83                    DC8     0x83
 3929    00000001 4D49                  DC8     'MI'
 3930    00000003 CE                    DC8     'N'+0x80
 3931                            ALIGNROM 2,0xFFFFFFFF
 3932    00000004 ........              DC32    ABS1_NFA
 3933                           MIN:
 3934    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3935    00000010 ........              DC32    GREATERTHAN
 3936    00000014 ........              DC32    ZBRAN   //IF
 3937    00000018 08000000              DC32     MIN1-.
 3938                           
 3939    0000001C ........              DC32    SWAP    //endif
 3940                           MIN1:
 3941    00000020 ........              DC32    DROP
 3942    00000024 ........              DC32    SEMIS
 3943                           
 3944                           
 3945                           //      MAX MAX:        ( n1 n2 -- max )
 3946                           //      Leave the greater of two numbers.
 3947                           
 3948                            SECTION .text : CONST (2)
 3949                           MAX_NFA:
 3950    00000000 83                    DC8     0x83
 3951    00000001 4D41                  DC8     'MA'
 3952    00000003 D8                    DC8     'X'+0x80
 3953                            ALIGNROM 2,0xFFFFFFFF
 3954    00000004 ........              DC32    MIN_NFA
 3955                           MAX:
 3956    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3957    00000010 ........              DC32    LESSTHAN
 3958    00000014 ........              DC32    ZBRAN   //IF
 3959    00000018 08000000              DC32     MAX1-.
 3960                           
 3961    0000001C ........              DC32    SWAP    //endif
 3962                           MAX1:
 3963    00000020 ........              DC32    DROP
 3964    00000024 ........              DC32    SEMIS
 3965                           
 3966                           
 3967                           //      AND ANDD:       ( n1 n2 -- n2 )
 3968                           //      Leave the bitwise logical and of n1 and n2 as n3.
 3969                           
 3970                            SECTION .text : CONST (2)
 3971                           ANDD_NFA:
 3972    00000000 83                    DC8     0x83
 3973    00000001 414E                  DC8     'AN'
 3974    00000003 C4                    DC8     'D'+0x80
 3975                            ALIGNROM 2,0xFFFFFFFF
 3976    00000004 ........              DC32    MAX_NFA
 3977                           ANDD:
 3978    00000008 ........              DC32    .+5
 3979                            SECTION .text : CODE (2)
 3980                                   POP2t
 3980.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3980.2                         //#ifndef TOSCT
 3980.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3980.4                         //#endif
 3980.5                         //      ADDS    p, p, #4
 3980.6                                 ENDM
 3981                                   POP2n
 3981.1  00000004 57F8041B              LDR     n, [p],#4
 3981.2                         //      LDR     n, [p]
 3981.3                         //      ADDS    p, p, #4
 3981.4                                 ENDM
 3982    00000008 0840                  ANDS     t, t, n
 3983                                   TPUSH
 3983                                   PUSHt   // push t to p, pre decrement p
 3983.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3983.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3983.3                         //      STR     t, [p]
 3983.4                                 ENDM
 3983                                   NEXT
 3983.1                         // ARMv7-M Thumb = .+5
 3983.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3983.3                         // ARMv6-M Thumb = .+4
 3983.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3983                                   NEXT1
 3983.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3983.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3983.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3983.4                         // ARMv6-M Thumb = .+4
 3983.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3983.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3983.7                                 ENDM
 3983.8                                 ENDM
 3983.9                                 ENDM
 3984                           
 3985                           
 3986                           //      OR OR:  ( n1 n2 -- n3 )
 3987                           //      Leave the bit-wise logical or of n1 and n2 as n3.
 3988                           
 3989                            SECTION .text : CONST (2)
 3990                           OR_NFA:
 3991    00000000 82                    DC8     0x82
 3992    00000001 4F                    DC8     'O'
 3993    00000002 D2                    DC8     'R'+0x80
 3994    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3995    00000004 ........              DC32    ANDD_NFA
 3996                           OR:
 3997    00000008 ........              DC32    .+5
 3998                            SECTION .text : CODE (2)
 3999                                   POP2t
 3999.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3999.2                         //#ifndef TOSCT
 3999.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3999.4                         //#endif
 3999.5                         //      ADDS    p, p, #4
 3999.6                                 ENDM
 4000                                   POP2n
 4000.1  00000004 57F8041B              LDR     n, [p],#4
 4000.2                         //      LDR     n, [p]
 4000.3                         //      ADDS    p, p, #4
 4000.4                                 ENDM
 4001    00000008 0843                  ORRS     t, t, n
 4002                                   TPUSH
 4002                                   PUSHt   // push t to p, pre decrement p
 4002.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4002.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4002.3                         //      STR     t, [p]
 4002.4                                 ENDM
 4002                                   NEXT
 4002.1                         // ARMv7-M Thumb = .+5
 4002.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4002.3                         // ARMv6-M Thumb = .+4
 4002.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4002                                   NEXT1
 4002.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4002.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4002.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4002.4                         // ARMv6-M Thumb = .+4
 4002.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4002.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4002.7                                 ENDM
 4002.8                                 ENDM
 4002.9                                 ENDM
 4003                           
 4004                           
 4005                           //      NOT NOT: ( nl -- n2 )
 4006                           //      Leave the bitwise logical not of n1 as n2
 4007                           
 4008                            SECTION .text : CONST (2)
 4009                           NOT_NFA:
 4010    00000000 83                    DC8     0x83
 4011    00000001 4E4F                  DC8     'NO'
 4012    00000003 D4                    DC8     'T'+0x80
 4013                            ALIGNROM 2,0xFFFFFFFF
 4014    00000004 ........              DC32    OR_NFA
 4015                           NOT:
 4016    00000008 ........              DC32    .+5
 4017                            SECTION .text : CODE (2)
 4018                                   POP2t
 4018.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4018.2                         //#ifndef TOSCT
 4018.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4018.4                         //#endif
 4018.5                         //      ADDS    p, p, #4
 4018.6                                 ENDM
 4019    00000004 C043                  MVNS            t, t    // 1's compliment
 4020                                   TPUSH
 4020                                   PUSHt   // push t to p, pre decrement p
 4020.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4020.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4020.3                         //      STR     t, [p]
 4020.4                                 ENDM
 4020                                   NEXT
 4020.1                         // ARMv7-M Thumb = .+5
 4020.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4020.3                         // ARMv6-M Thumb = .+4
 4020.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4020                                   NEXT1
 4020.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4020.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4020.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4020.4                         // ARMv6-M Thumb = .+4
 4020.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4020.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4020.7                                 ENDM
 4020.8                                 ENDM
 4020.9                                 ENDM
 4021                           
 4022                           
 4023                           //      XORR XOR:       ( nl n2 -- n3 )
 4024                           //      Leave the bitwise logical exclusive or n1 and n2 as n3
 4025                           
 4026                            SECTION .text : CONST (2)
 4027                           XORR_NFA:
 4028    00000000 83                    DC8     0x83
 4029    00000001 584F                  DC8     'XO'
 4030    00000003 D2                    DC8     'R'+0x80
 4031                            ALIGNROM 2,0xFFFFFFFF
 4032    00000004 ........              DC32    NOT_NFA
 4033                           XORR:
 4034    00000008 ........              DC32    .+5
 4035                            SECTION .text : CODE (2)
 4036                                   POP2t
 4036.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4036.2                         //#ifndef TOSCT
 4036.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4036.4                         //#endif
 4036.5                         //      ADDS    p, p, #4
 4036.6                                 ENDM
 4037                                   POP2n
 4037.1  00000004 57F8041B              LDR     n, [p],#4
 4037.2                         //      LDR     n, [p]
 4037.3                         //      ADDS    p, p, #4
 4037.4                                 ENDM
 4038    00000008 4840                  EORS     t, t, n
 4039                                   TPUSH
 4039                                   PUSHt   // push t to p, pre decrement p
 4039.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4039.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4039.3                         //      STR     t, [p]
 4039.4                                 ENDM
 4039                                   NEXT
 4039.1                         // ARMv7-M Thumb = .+5
 4039.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4039.3                         // ARMv6-M Thumb = .+4
 4039.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4039                                   NEXT1
 4039.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4039.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4039.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4039.4                         // ARMv6-M Thumb = .+4
 4039.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4039.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4039.7                                 ENDM
 4039.8                                 ENDM
 4039.9                                 ENDM
 4040                           
 4041                           //      SXTH SXH:       ( nl -- n3 )
 4042                           //      Sign extend HALFWORD on the stack
 4043                           
 4044                            SECTION .text : CONST (2)
 4045                           SXTH_NFA:
 4046    00000000 84                    DC8     0x84
 4047    00000001 535854                DC8     'SXT'
 4048    00000004 C8                    DC8     'H'+0x80
 4049    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4050    00000008 ........              DC32    XORR_NFA
 4051                           SXH:
 4052    0000000C ........              DC32    .+5
 4053                            SECTION .text : CODE (2)
 4054                                   POP2t
 4054.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4054.2                         //#ifndef TOSCT
 4054.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4054.4                         //#endif
 4054.5                         //      ADDS    p, p, #4
 4054.6                                 ENDM
 4055    00000004 00B2                  SXTH     t, t
 4056                                   TPUSH
 4056                                   PUSHt   // push t to p, pre decrement p
 4056.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4056.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4056.3                         //      STR     t, [p]
 4056.4                                 ENDM
 4056                                   NEXT
 4056.1                         // ARMv7-M Thumb = .+5
 4056.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4056.3                         // ARMv6-M Thumb = .+4
 4056.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4056                                   NEXT1
 4056.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4056.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4056.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4056.4                         // ARMv6-M Thumb = .+4
 4056.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4056.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4056.7                                 ENDM
 4056.8                                 ENDM
 4056.9                                 ENDM
 4057                           
 4058                           
 4059                           //      SXTB SXB:       ( nl -- n3 )
 4060                           //      Signe extend byte in the word on the stack
 4061                           
 4062                            SECTION .text : CONST (2)
 4063                           SXTB_NFA:
 4064    00000000 84                    DC8     0x84
 4065    00000001 535854                DC8     'SXT'
 4066    00000004 C2                    DC8     'B'+0x80
 4067    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4068    00000008 ........              DC32    SXTH_NFA
 4069                           SXB:
 4070    0000000C ........              DC32    .+5
 4071                            SECTION .text : CODE (2)
 4072                                   POP2t
 4072.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4072.2                         //#ifndef TOSCT
 4072.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4072.4                         //#endif
 4072.5                         //      ADDS    p, p, #4
 4072.6                                 ENDM
 4073    00000004 40B2                  SXTB     t, t
 4074                                   TPUSH
 4074                                   PUSHt   // push t to p, pre decrement p
 4074.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4074.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4074.3                         //      STR     t, [p]
 4074.4                                 ENDM
 4074                                   NEXT
 4074.1                         // ARMv7-M Thumb = .+5
 4074.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4074.3                         // ARMv6-M Thumb = .+4
 4074.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4074                                   NEXT1
 4074.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4074.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4074.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4074.4                         // ARMv6-M Thumb = .+4
 4074.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4074.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4074.7                                 ENDM
 4074.8                                 ENDM
 4074.9                                 ENDM
 4075                           
 4076                           
 4077                           //      REVW REVW:      ( n -- n )
 4078                           //      Reverse bytes in n.
 4079                           
 4080                            SECTION .text : CONST (2)
 4081                           REVW_NFA:
 4082    00000000 84                    DC8     0x84
 4083    00000001 524556                DC8     'REV'
 4084    00000004 D7                    DC8     'W'+0x80
 4085    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4086    00000008 ........              DC32    SXTB_NFA
 4087                           REVW:
 4088    0000000C ........              DC32    .+5
 4089                            SECTION .text : CODE (2)
 4090                                   POP2t
 4090.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4090.2                         //#ifndef TOSCT
 4090.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4090.4                         //#endif
 4090.5                         //      ADDS    p, p, #4
 4090.6                                 ENDM
 4091    00000004 00BA                  REV     t, t
 4092                                   TPUSH
 4092                                   PUSHt   // push t to p, pre decrement p
 4092.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4092.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4092.3                         //      STR     t, [p]
 4092.4                                 ENDM
 4092                                   NEXT
 4092.1                         // ARMv7-M Thumb = .+5
 4092.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4092.3                         // ARMv6-M Thumb = .+4
 4092.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4092                                   NEXT1
 4092.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4092.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4092.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4092.4                         // ARMv6-M Thumb = .+4
 4092.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4092.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4092.7                                 ENDM
 4092.8                                 ENDM
 4092.9                                 ENDM
 4093                           
 4094                           
 4095                           //      ASR ASR:   ( sn count -- sn' )  
 4096                           //      Shift sn (sign-extended) right by count.
 4097                           //      Valid count values are 0 to 31.
 4098                           
 4099                            SECTION .text : CONST (2)
 4100                           ASR_NFA:
 4101    00000000 83                    DC8     0x83
 4102    00000001 4153                  DC8     'AS'
 4103    00000003 D2                    DC8     'R'+0x80
 4104                            ALIGNROM 2,0xFFFFFFFF
 4105    00000004 ........              DC32    REVW_NFA
 4106                           ASR:
 4107    00000008 ........              DC32    .+5
 4108                            SECTION .text : CODE (2)
 4109                                   POP2w           ; shift count
 4109.1  00000000 57F8042B              LDR     w, [p],#4
 4109.2                         //      LDR     w, [p]
 4109.3                         //      ADDS    p, p, #4
 4109.4                                 ENDM
 4110                                   POP2t           ; original data
 4110.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4110.2                         //#ifndef TOSCT
 4110.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4110.4                         //#endif
 4110.5                         //      ADDS    p, p, #4
 4110.6                                 ENDM
 4111    00000008 1041                  ASRS    t, t, w
 4112                                   TPUSH           ; shifted data
 4112                                   PUSHt   // push t to p, pre decrement p
 4112.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4112.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4112.3                         //      STR     t, [p]
 4112.4                                 ENDM
 4112                                   NEXT
 4112.1                         // ARMv7-M Thumb = .+5
 4112.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4112.3                         // ARMv6-M Thumb = .+4
 4112.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4112                                   NEXT1
 4112.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4112.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4112.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4112.4                         // ARMv6-M Thumb = .+4
 4112.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4112.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4112.7                                 ENDM
 4112.8                                 ENDM
 4112.9                                 ENDM
 4113                           
 4114                           
 4115                           //      LSR LSR:   ( n count -- n' )
 4116                           //      Logical (zero-extended) shift right by count.
 4117                           //      Valid count values are 0 to 31.
 4118                           
 4119                            SECTION .text : CONST (2)
 4120                           LSR_NFA:
 4121    00000000 83                    DC8     0x83
 4122    00000001 4C53                  DC8     'LS'
 4123    00000003 D2                    DC8     'R'+0x80
 4124                            ALIGNROM 2,0xFFFFFFFF
 4125    00000004 ........              DC32    ASR_NFA
 4126                           LSR:
 4127    00000008 ........              DC32    .+5
 4128                            SECTION .text : CODE (2)
 4129                                   POP2w           ; shift count
 4129.1  00000000 57F8042B              LDR     w, [p],#4
 4129.2                         //      LDR     w, [p]
 4129.3                         //      ADDS    p, p, #4
 4129.4                                 ENDM
 4130                                   POP2t           ; original data
 4130.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4130.2                         //#ifndef TOSCT
 4130.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4130.4                         //#endif
 4130.5                         //      ADDS    p, p, #4
 4130.6                                 ENDM
 4131    00000008 D040                  LSRS    t, t, w
 4132                                   TPUSH           ; shifted data
 4132                                   PUSHt   // push t to p, pre decrement p
 4132.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4132.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4132.3                         //      STR     t, [p]
 4132.4                                 ENDM
 4132                                   NEXT
 4132.1                         // ARMv7-M Thumb = .+5
 4132.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4132.3                         // ARMv6-M Thumb = .+4
 4132.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4132                                   NEXT1
 4132.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4132.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4132.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4132.4                         // ARMv6-M Thumb = .+4
 4132.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4132.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4132.7                                 ENDM
 4132.8                                 ENDM
 4132.9                                 ENDM
 4133                           
 4134                           
 4135                           //      LSL LSL:   ( n count -- n' )
 4136                           //      Logical (zero-extended) shift left by count.
 4137                           //      Valid count values are 0 to 31.
 4138                           
 4139                            SECTION .text : CONST (2)
 4140                           LSL_NFA:
 4141    00000000 83                    DC8     0x83
 4142    00000001 4C53                  DC8     'LS'
 4143    00000003 CC                    DC8     'L'+0x80
 4144                            ALIGNROM 2,0xFFFFFFFF
 4145    00000004 ........              DC32    LSR_NFA
 4146                           LSL:
 4147    00000008 ........              DC32    .+5
 4148                            SECTION .text : CODE (2)
 4149                                   POP2w           ; shift count
 4149.1  00000000 57F8042B              LDR     w, [p],#4
 4149.2                         //      LDR     w, [p]
 4149.3                         //      ADDS    p, p, #4
 4149.4                                 ENDM
 4150                                   POP2t           ; original data
 4150.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4150.2                         //#ifndef TOSCT
 4150.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4150.4                         //#endif
 4150.5                         //      ADDS    p, p, #4
 4150.6                                 ENDM
 4151    00000008 9040                  LSLS    t, t, w
 4152                                   TPUSH           ; shifted data---
 4152                                   PUSHt   // push t to p, pre decrement p
 4152.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4152.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4152.3                         //      STR     t, [p]
 4152.4                                 ENDM
 4152                                   NEXT
 4152.1                         // ARMv7-M Thumb = .+5
 4152.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4152.3                         // ARMv6-M Thumb = .+4
 4152.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4152                                   NEXT1
 4152.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4152.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4152.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4152.4                         // ARMv6-M Thumb = .+4
 4152.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4152.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4152.7                                 ENDM
 4152.8                                 ENDM
 4152.9                                 ENDM
 4153                           
 4154                           
 4155                           //      .R DOTR:        ( sn1 n2 -- ) SIGNED:
 4156                           //      Print the signed number sn1 right aligned in a field whose width is n2.
 4157                           //      No following blank is printed.
 4158                           
 4159                            SECTION .text : CONST (2)
 4160                           DOTR_NFA:
 4161    00000000 82                    DC8     0x82
 4162    00000001 2E                    DC8     '.'
 4163    00000002 D2                    DC8     'R'+0x80
 4164    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4165    00000004 ........              DC32    LSL_NFA
 4166                           DOTR:
 4167    00000008 ........              DC32    DOCOL
 4168    0000000C ........              DC32    TOR
 4169    00000010 ........              DC32    STOD
 4170    00000014 ........              DC32    RFROM
 4171    00000018 ........              DC32    DDOTR
 4172    0000001C ........              DC32    SEMIS
 4173                           
 4174                           
 4175                           //      .RU DOTRU:      ( n1 n2 -- ) UNSIGNED:
 4176                           //      Print the unsigned number n1 right aligned in a field whose width is n2.
 4177                           //      No following blank is printed.
 4178                           
 4179                            SECTION .text : CONST (2)
 4180                           DOTRU_NFA:
 4181    00000000 83                    DC8     0x83
 4182    00000001 2E52                  DC8     '.R'
 4183    00000003 D5                    DC8     'U'+0x80
 4184                            ALIGNROM 2,0xFFFFFFFF
 4185    00000004 ........              DC32    DOTR_NFA
 4186                           DOTRU:
 4187    00000008 ........              DC32    DOCOL
 4188    0000000C ........              DC32    TOR
 4189    00000010 ........              DC32    ZERO
 4190    00000014 .............         DC32    BDIGS, DIGS, EDIGS
                  ...........  
 4191    00000020 .............         DC32    DUP, RFROM
                  ...          
 4192    00000028 .............         DC32    SWAP, SUBB, SPACES, TYPE
                  .............
                  ......       
 4193                           #ifdef IO2TP
 4196                           #endif
 4197    00000038 ........              DC32    SEMIS
 4198                           
 4199                           
 4200                           //      U. UDOT:        ( n -- ) USIGNED DOT
 4201                           
 4202                            SECTION .text : CONST (2)
 4203                           UDOT_NFA:
 4204    00000000 82                    DC8     0x82
 4205    00000001 55                    DC8     'U'
 4206    00000002 AE                    DC8     '.'+0x80
 4207    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4208    00000004 ........              DC32    DOTRU_NFA
 4209                           UDOT:
 4210    00000008 ........              DC32    DOCOL
 4211    0000000C ........              DC32    ZERO
 4212    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4213    00000014 ........              DC32    SEMIS
 4214                           
 4215                           
 4216                           //      ? QUES: ( addr -- )
 4217                           //      Print the value contained at the address in free format according to
 4218                           //      the current base using DOT.
 4219                           
 4220                            SECTION .text : CONST (2)
 4221                           QUES_NFA:
 4222    00000000 81                    DC8     0x81
 4223    00000001 BF                    DC8     '?'+0x80
 4224    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4225    00000004 ........              DC32    UDOT_NFA
 4226                           QUES:
 4227    00000008 ........              DC32    DOCOL
 4228    0000000C ........              DC32    AT
 4229    00000010 ........              DC32    DOT
 4230    00000014 ........              DC32    SEMIS
 4231                           
 4232                           
 4233                           //      . DOT:  ( n -- ) SIGNED 2'S COMPLEMENT:
 4234                           //      Print a number from a signed 32 bit two's complement value,
 4235                           //      converted according to the numeric base.
 4236                           //      A trailing blanks follows.
 4237                           
 4238                            SECTION .text : CONST (2)
 4239                           DOT_NFA:
 4240    00000000 81                    DC8     0x81
 4241    00000001 AE                    DC8     '.'+0x80
 4242    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4243    00000004 ........              DC32    QUES_NFA
 4244                           DOT:
 4245    00000008 ........              DC32    DOCOL
 4246    0000000C ........              DC32    STOD
 4247    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4248    00000014 ........              DC32    SEMIS
 4249                           
 4250                           
 4251                           //------------------------------ DOTBASE SECTION -------------------------------
 4252                           //      .H DOTHEX:      ( n -- )
 4253                           //      Prints TOS in Hex using DOT, not affecting Base in the system
 4254                           
 4255                           #ifndef SRM
 4256                           //      .B DOTBIN:      ( n -- )
 4257                           //      Prints TOS in BINARY using DOT, not affecting Base in the system
 4258                           
 4259                            SECTION .text : CONST (2)
 4260                           DOTBIN_NFA:
 4261    00000000 82                    DC8     0x82
 4262    00000001 2E                    DC8     '.'
 4263    00000002 C2                    DC8     'B'+0x80
 4264    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4265    00000004 ........              DC32    DOT_NFA
 4266                           DOTBIN:
 4267    00000008 ........              DC32    DOCOL
 4268    0000000C .............         DC32    TWO, DOTBASE
                  ...          
 4269    00000014 ........              DC32    SEMIS
 4270                           #endif  // not SRM
 4271                           
 4272                           
 4273                            SECTION .text : CONST (2)
 4274                           DOTHEX_NFA:
 4275    00000000 82                    DC8     0x82
 4276    00000001 2E                    DC8     '.'
 4277    00000002 C8                    DC8     'H'+0x80
 4278    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4279    00000004 ........              DC32    DOTBIN_NFA
 4280                           DOTHEX:
 4281    00000008 ........              DC32    DOCOL
 4282                           #ifdef SRM
 4284                           #else
 4285    0000000C ........10000         DC32    LIT, 16, DOTBASE        // this version appends BASE Suffix
                  000........  
 4286                           #endif
 4287    00000018 ........              DC32    SEMIS
 4288                           
 4289                           
 4290                           #ifndef SRM
 4291                           //      .D DOTDEC:      ( n -- )
 4292                           //      Prints TOS in DECIMAL using DOT, not affecting Base in the system
 4293                           
 4294                            SECTION .text : CONST (2)
 4295                           DOTDEC_NFA:
 4296    00000000 82                    DC8     0x82
 4297    00000001 2E                    DC8     '.'
 4298    00000002 C4                    DC8     'D'+0x80
 4299    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4300    00000004 ........              DC32    DOTHEX_NFA
 4301                           DOTDEC:
 4302    00000008 ........              DC32    DOCOL
 4303    0000000C ........0A000         DC32    LIT, 10, DOTBASE
                  000........  
 4304    00000018 ........              DC32    SEMIS
 4305                           #endif  // not SRM
 4306                           
 4307                           
 4308                           //=============================== WORDCAT ====================================//
 4309                           //NOEXEC HEADERFORWORDCATEGORIES
 4310                           //      WC_NUMBERS_NFA = NUMBER Stuff: CATEGORY
 4311                           
 4312                            SECTION .text : CONST (2)
 4313                           WC_NUMBERS_NFA:
 4314    00000000 91                    DC8     0x80+4+13
 4315    00000001 0D0A                  DC8     0x0D, 0x0A
 4316    00000003 4E554D4245522         DC8     'NUMBER Stuff:'
                  053747566663A
 4317    00000010 0D8A                  DC8     0x0D, 0x0A+0x80
 4318    00000012 FFFF           ALIGNROM 2,0xFFFFFFFF
 4319    00000014 ........              DC32    DOTDEC_NFA
 4320                           
 4321                           
 4322                           //=============================== UART0_INIT =================================//
 4323                           
 4324                           // LFA ABOVE NEEDS TO BE WC_NUMBERS_NFA
 4325                           $FISH_STM32F4_UART3_INIT.s
 4326                           // LFA BELOW NEEDS TO BE UART3_INIT_NFA
 4327                           
 4328                           //=============================== UART0_INIT =================================//
 4329                           
 4330                           //      MYBAUD MYBAUD: ( n -- ) BAUD MUST BE IN DECIMAL or EQUIVALENT!!!
 4331                           //      MUST BE USED BEFORE USING UART0_INIT!!!
 4332                           //      Because FISH does a reset if you invoke a HARD FAULT RESET
 4333                           //      THIS MECHANISM IS ESSENTIAL TO STAYING AT USER SET BAUDRATE THRU A RESET!
 4334                           //      SET NON-INIT RAM VARIABLES DBAUD TO ZERO AND UBAUD n.
 4335                           //      See UART0_INIT
 4336                           
 4337                            SECTION .text : CONST (2)
 4338                           MYBAUD_NFA:
 4339    00000000 86                    DC8     0x86
 4340    00000001 4D59424155            DC8     'MYBAU'
 4341    00000006 C4                    DC8     'D'+0x80
 4342    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4343    00000008 ........              DC32    UART3_INIT_NFA
 4344                           MYBAUD:
 4345    0000000C ........              DC32    DOCOL
 4346    00000010 ........00000         DC32    strva, 0, DBAUD
                  000........  
 4347    0000001C .............         DC32    LIT, UBAUD, STORE       // SET UBAUD TO NEW BAUD FOR UART0_INIT
                  ...........  
 4348    00000028 ........              DC32    SEMIS
 4349                           
 4350                           
 4351                           //      STM32F4 UART3_LSR UART3_LSR: ( -- value )
 4352                           
 4353                            SECTION .text : CONST (2)
 4354                           UART3_LSR_NFA:
 4355    00000000 89                    DC8     0x89
 4356    00000001 55415254335F4         DC8     'UART3_LS'
                  C53          
 4357    00000009 D2                    DC8     'R'+0x80
 4358    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 4359    0000000C ........              DC32    MYBAUD_NFA
 4360                           UART3_LSR:
 4361    00000010 ........              DC32    .+5
 4362                            SECTION .text : CODE (2)
 4363    00000000 0549                  LDR     n, = USART3_SR
 4364    00000002 0878                  LDRB    t, [n]
 4365                                   TPUSH
 4365                                   PUSHt   // push t to p, pre decrement p
 4365.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4365.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4365.3                         //      STR     t, [p]
 4365.4                                 ENDM
 4365                                   NEXT
 4365.1                         // ARMv7-M Thumb = .+5
 4365.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4365.3                         // ARMv6-M Thumb = .+4
 4365.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4365                                   NEXT1
 4365.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4365.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4365.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4365.4                         // ARMv6-M Thumb = .+4
 4365.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4365.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4365.7                                 ENDM
 4365.8                                 ENDM
 4365.9                                 ENDM
 4366    00000016 0000           LTORG
 4366.1                                  TABLE
 4366.2  00000018 00480040              Reference on line 4363
 4367                           
 4368                           
 4369                           //      STM32F4 UART3_RX UART3_RX: ( -- addr )
 4370                           //      This is the serial terminal.
 4371                           
 4372                            SECTION .text : CONST (2)
 4373                           UART3_RX_NFA:
 4374    00000000 88                    DC8     0x88
 4375    00000001 55415254335F5         DC8     'UART3_R'
                  2            
 4376    00000008 D8                    DC8     'X'+0x80
 4377    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4378    0000000C ........              DC32    UART3_LSR_NFA
 4379                           UART0_RX:
 4380    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4381                           
 4382                           //      STM32F4 UART3_TX UART3_TX: ( -- addr )
 4383                           //      This is the serial terminal.
 4384                           
 4385                            SECTION .text : CONST (2)
 4386                           UART3_TX_NFA:
 4387    00000000 88                    DC8     0x88
 4388    00000001 55415254335F5         DC8     'UART3_T'
                  4            
 4389    00000008 D8                    DC8     'X'+0x80
 4390    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4391    0000000C ........              DC32    UART3_RX_NFA
 4392                           UART3_TX:
 4393    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4394                           
 4395                           
 4396                           #ifdef XON_XOFF
 4397                           //      XOFF XOFF: ( -- ) Send XOFF
 4398                           
 4399                            SECTION .text : CONST (2)
 4400                           XOFF_NFA:
 4401    00000000 84                    DC8     0x84
 4402    00000001 584F46                DC8     'XOF'
 4403    00000004 C6                    DC8     'F'+0x80
 4404    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4405    00000008 ........              DC32    UART3_TX_NFA
 4406                           XOFF:
 4407    0000000C ........              DC32    .+5
 4408                            SECTION .text : CODE (2)       // Does not incr OUT and wait for line status
 4409                           #ifdef IO2TP
 4411                           #else
 4412    00000000 ........              BL      TXRDY_SUBR
 4413    00000004 ........              BL      XOFF_SUBR
 4414                                   NEXT
 4414.1                         // ARMv7-M Thumb = .+5
 4414.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4414.3                         // ARMv6-M Thumb = .+4
 4414.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4414                                   NEXT1
 4414.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4414.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4414.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4414.4                         // ARMv6-M Thumb = .+4
 4414.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4414.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4414.7                                 ENDM
 4414.8                                 ENDM
 4415                           #endif // #else IO2TP
 4416                           //#endif // XON_XOFF after XON:
 4417                           
 4418                           
 4419                           //      XON XON: ( -- ) Send XON
 4420                           
 4421                            SECTION .text : CONST (2)
 4422                           XON_NFA:
 4423    00000000 83                    DC8     0x83
 4424    00000001 584F                  DC8     'XO'
 4425    00000003 CE                    DC8     'N'+0x80
 4426                            ALIGNROM 2,0xFFFFFFFF
 4427    00000004 ........              DC32    XOFF_NFA
 4428                           XON:
 4429    00000008 ........              DC32    .+5
 4430                            SECTION .text : CODE (2)       // Does not incr OUT or wait for line status.
 4431                           #ifdef IO2TP
 4433                           #else
 4434                           // Required, no 'quick send'
 4435    00000000 ........              BL      TXRDY_SUBR
 4436    00000004 ........              BL      XON_SUBR
 4437                                   NEXT
 4437.1                         // ARMv7-M Thumb = .+5
 4437.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4437.3                         // ARMv6-M Thumb = .+4
 4437.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4437                                   NEXT1
 4437.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4437.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4437.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4437.4                         // ARMv6-M Thumb = .+4
 4437.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4437.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4437.7                                 ENDM
 4437.8                                 ENDM
 4438                           #endif // #else IO2TP
 4439                           #endif // XON_XOFF
 4440                           
 4441                           //---------------- EMIT KEY ?KEY CR SECTION ------------------------------
 4442                           
 4443                           //      SPACES SPACES:  ( n -- )
 4444                           //      Transmit n ascii blanks (0x20) to the output device.
 4445                           
 4446                            SECTION .text : CONST (2)
 4447                           SPACES_NFA:
 4448    00000000 86                    DC8     0x86
 4449    00000001 5350414345            DC8     'SPACE'
 4450    00000006 D3                    DC8     'S'+0x80
 4451    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4452                           #ifdef XON_XOFF
 4453    00000008 ........              DC32    XON_NFA
 4454                           #else
 4456                           #endif
 4457                           SPACES:
 4458    0000000C ........              DC32    DOCOL
 4459    00000010 ........              DC32    ZERO
 4460    00000014 ........              DC32    MAX
 4461    00000018 ........              DC32    ZNDUP
 4462    0000001C ........              DC32    ZBRAN
 4463    00000020 18000000              DC32     SPACES_DONE-.
 4464                           
 4465    00000024 ........              DC32    ZERO
 4466    00000028 ........              DC32    XDO     //DO
 4467                           
 4468                           SPACES_DO:
 4469    0000002C ........              DC32    SPACE
 4470    00000030 ........              DC32    XLOOP   //LOOP
 4471    00000034 F8FFFFFF              DC32     SPACES_DO-.
 4472                           
 4473                           SPACES_DONE:
 4474    00000038 ........              DC32    SEMIS
 4475                           
 4476                           
 4477                           //      SPACE SPACE: ( -- )
 4478                           //      Emit a space character, 0x20.
 4479                           
 4480                            SECTION .text : CONST (2)
 4481                           SPACE_NFA:
 4482    00000000 85                    DC8     0x85
 4483    00000001 53504143              DC8     'SPAC'
 4484    00000005 C5                    DC8     'E'+0x80
 4485    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4486    00000008 ........              DC32    SPACES_NFA
 4487                           SPACE:
 4488    0000000C ........              DC32    DOCOL
 4489    00000010 ........              DC32    BLANK
 4490    00000014 ........              DC32    EMIT
 4491    00000018 ........              DC32    SEMIS
 4492                           
 4493                           
 4494                           //      ID. IDDOT:      ( NFA-addr -- ) ?RENAME .NFA
 4495                           //      Print a definition's name from its name field address.
 4496                           
 4497                            SECTION .text : CONST (2)
 4498                           IDDOT_NFA:
 4499    00000000 83                    DC8     0x83
 4500    00000001 4944                  DC8     'ID'
 4501    00000003 AE                    DC8     '.'+0x80
 4502                            ALIGNROM 2,0xFFFFFFFF
 4503    00000004 ........              DC32    SPACE_NFA
 4504                           IDDOT:
 4505    00000008 ........              DC32    DOCOL
 4506                           //      NOW COUNT is on NFA, fig code copied it out to pad
 4507    0000000C ........              DC32    COUNT   // Count could be SMUDGE'd.
 4508    00000010 ........1F000         DC32    LIT, MAXWORDLEN // Strip SMUDGEing from count
                  000          
 4509    00000018 ........              DC32    ANDD            // only time 
 4510    0000001C ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4511    00000020 ........              DC32    SPACE
 4512    00000024 ........              DC32    SEMIS
 4513                           
 4514                           
 4515                           //      ." DOTQ:        ( -- ) IMMEDIATE
 4516                           //      Type quoted string out or compile inline string to be typed at runtime
 4517                           //      CHANGED COMPILE TIME ACTION TO WORK WITH 4 byte alighment REQUIREMENT.
 4518                           //      Used in the form:
 4519                           //              .' CCcc"
 4520                           //      Compiles an in-line string CCcc (delimited by the trailing ") with
 4521                           //      an execution proceedure to transmit the text to the output device.
 4522                           //      If executed outside a definition, ." will immediately print the text
 4523                           //      until the final ',. The maximum number of characters may be an
 4524                           //      installation dependent value. See (.").
 4525                           
 4526                            SECTION .text : CONST (2)
 4527                           DOTQ_NFA:
 4528    00000000 C2                    DC8     0x0C2
 4529    00000001 2E                    DC8     '.'
 4530    00000002 A2                    DC8     '"'+0x80
 4531    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4532    00000004 ........              DC32    IDDOT_NFA
 4533                           DOTQ:
 4534    00000008 ........              DC32    DOCOL
 4535    0000000C ........22000         DC32    LIT, '"'        // 0x22 ending qoute delimiter for WORD
                  000          
 4536    00000014 ........              DC32    STATE_SV
 4537    00000018 ........              DC32    AT
 4538    0000001C ........              DC32    ZBRAN   // IF Not COMPILING
 4539    00000020 2C000000              DC32     DOTQ1-.
 4540                           
 4541    00000024 ........              DC32    COMP    // COMPILING
 4542    00000028 ........              DC32    PDOTQ   // compile LIT, cnt-str-addr, count, type
 4543    0000002C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4544    00000030 ........              DC32    HERE
 4545    00000034 ........              DC32    CAT
 4546    00000038 ........              DC32    ONEP
 4547    0000003C ........              DC32    ALIGNED
 4548    00000040 ........              DC32    ALLOT_PRIM
 4549    00000044 ........              DC32    BRAN    // ELSE
 4550    00000048 14000000              DC32     DOTQ2-.
 4551                           DOTQ1:
 4552    0000004C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4553    00000050 ........              DC32    HERE
 4554    00000054 ........              DC32    COUNT
 4555    00000058 ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4556                                                   // endif
 4557                           #ifdef IO2TP
 4561                           #endif
 4562                           DOTQ2:
 4563    0000005C ........              DC32    SEMIS
 4564                           
 4565                           
 4566                           //      TYPE TYPE:      ( addr count -- )
 4567                           //      ADDR must be ALIGNED!
 4568                           //      OUT MUST BE INITIALIZED!!
 4569                           //      EMIT COUNT OF 8-bits in a string, preferably ascii characters,
 4570                           //      (last nfa char (+80h)ok!) from addr thru count,
 4571                           
 4572                            SECTION .text : CONST (2)
 4573                           TYPE_NFA:
 4574    00000000 84                    DC8     0x84
 4575    00000001 545950                DC8     'TYP'
 4576    00000004 C5                    DC8     'E'+0x80
 4577    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4578    00000008 ........              DC32    DOTQ_NFA
 4579                           TYPE:
 4580    0000000C ........              DC32    DOCOL
 4581    00000010 ........              DC32    ZNDUP
 4582    00000014 ........              DC32    ZBRAN   // IF NOTHING TO TYPE
 4583    00000018 34000000              DC32     TYPE1-.
 4584                           
 4585                           #ifdef XON_XOFF
 4586    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 4587                           #endif
 4588    00000020 ........              DC32    OVER
 4589    00000024 ........              DC32    PLUS
 4590    00000028 ........              DC32    SWAP
 4591    0000002C ........              DC32    XDO     // DO
 4592                           TYPE2:
 4593    00000030 ........              DC32    I
 4594    00000034 ........              DC32    CATLT7F // Limit output to ASCII characters under 80h
 4595    00000038 ........              DC32    EMIT
 4596                           tt1:
 4597    0000003C ........              DC32    XLOOP   // LOOP
 4598                           tt2:
 4599    00000040 F0FFFFFF              DC32     TYPE2-.
 4600                           
 4601    00000044 ........              DC32    BRAN    // ELSE
 4602    00000048 08000000              DC32     TYPE3-.
 4603                           TYPE1:
 4604    0000004C ........              DC32    DROP    // endif
 4605                           TYPE3:
 4606    00000050 ........              DC32    SEMIS
 4607                           
 4608                           
 4609                           //      EMIT EMIT:      ( c -- )
 4610                           //      Transmit ascii character c to the selected output device. OUT is
 4611                           //      incremented for each character output.
 4612                           
 4613                            SECTION .text : CONST (2)
 4614                           EMIT_NFA:
 4615    00000000 84                    DC8     0x84
 4616    00000001 454D49                DC8     'EMI'
 4617    00000004 D4                    DC8     'T'+0x80
 4618    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4619    00000008 ........              DC32    TYPE_NFA
 4620                           EMIT:
 4621                           #ifndef IO2TP
 4622                           // NOT IO2TP SECTION:
 4623    0000000C ........              DC32    .+5
 4624                            SECTION .text : CODE (2)
 4625                                   POP2t                   // GET CHAR
 4625.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4625.2                         //#ifndef TOSCT
 4625.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4625.4                         //#endif
 4625.5                         //      ADDS    p, p, #4
 4625.6                                 ENDM
 4626    00000004 ........              BL      TXRDY_SUBR
 4627    00000008 0649                  LDR     n, = USART3_DR // 
 4628                           // BSOUT handles negative out issue
 4629    0000000A 0870                  STRB    t, [n]          // EMIT (Send) Char
 4630    0000000C 0649                  LDR     n, = OUT        // Increment Out
 4631    0000000E 0868                  LDR     t, [n]
 4632    00000010 401C                  ADDS    t, t, #1
 4633    00000012 0860                  STR     t, [n]
 4634                                   NEXT
 4634.1                         // ARMv7-M Thumb = .+5
 4634.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4634.3                         // ARMv6-M Thumb = .+4
 4634.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4634                                   NEXT1
 4634.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4634.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4634.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4634.4                         // ARMv6-M Thumb = .+4
 4634.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4634.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4634.7                                 ENDM
 4634.8                                 ENDM
 4635                           #else // if IO2TP Transmit char to PAD, increment OUT
 4650                           #endif  // IO2TP
 4651    00000022 0000           LTORG
 4651.1                                  TABLE
 4651.2  00000024 04480040              Reference on line 4627
 4651.3  00000028 ........              Reference on line 4630
 4652                           
 4653                           
 4654                           //      KEY KEY:        (  -- ch )
 4655                           
 4656                            SECTION .text : CONST (2)
 4657                           KEY_NFA:
 4658    00000000 83                    DC8     0x83
 4659    00000001 4B45                  DC8     'KE'
 4660    00000003 D9                    DC8     'Y'+0x80
 4661                            ALIGNROM 2,0xFFFFFFFF
 4662    00000004 ........              DC32    EMIT_NFA
 4663                           KEY_INTERPRETED_ENTRY:
 4664                           #ifndef IO2TP
 4665    00000008 ........              DC32    DOCOL
 4666    0000000C ........              DC32    XON     // EXEC SETS XOFF SO UNDO IT
 4667    00000010 ........              DC32    KEY     // TE GET KEY!
 4668    00000014 ........              DC32    SEMIS
 4669                           
 4670                           
 4671                           //:NONAME KEY KEY:      ( -- CH ) 0-7Fh
 4672                           KEY:
 4673    00000018 ........              DC32    .+5
 4674                            SECTION .text : CODE (2)
 4675    00000000 074A                  LDR     w, = USART3_DR // 
 4676    00000002 084B                  LDR     x, = USART3_SR // 
 4677                           rxRDY?:
 4678    00000004 1968                  LDR     n, [x]          // Get Line Status
 4679                           //      LSRS    n, n, #5        // Bit 5 RXNE: Read data register not empty
 4680                           // THIS IS ___ AND FAILS TEXT DOWNLOAD
 4681    00000006 8909                  LSRS    n, n, #6        // Bit 6 ORIG - REQ'D FOR TEXT FILE DOWNLOAD
 4682    00000008 FCD3                  BCC     rxRDY?          // sets carry flag
 4683                           
 4684    0000000A 1068                  LDR     t, [w]
 4685                                   TPUSH
 4685                                   PUSHt   // push t to p, pre decrement p
 4685.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4685.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4685.3                         //      STR     t, [p]
 4685.4                                 ENDM
 4685                                   NEXT
 4685.1                         // ARMv7-M Thumb = .+5
 4685.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4685.3                         // ARMv6-M Thumb = .+4
 4685.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4685                                   NEXT1
 4685.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4685.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4685.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4685.4                         // ARMv6-M Thumb = .+4
 4685.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4685.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4685.7                                 ENDM
 4685.8                                 ENDM
 4685.9                                 ENDM
 4686                           #else
 4688                           #endif  // IO2TP
 4689    0000001E 0000           LTORG
 4689.1                                  TABLE
 4689.2  00000020 04480040              Reference on line 4675
 4689.3  00000024 00480040              Reference on line 4676
 4690                           
 4691                           
 4692                           //      ?KEY QKEY: ( -- f )
 4693                           //      Return zero unless key in fifo - key is not consumed.
 4694                           //      : TB BEGIN ?KEY UNTIL ; Will execute until any key is entered.
 4695                           
 4696                            SECTION .text : CONST (2)
 4697                           QKEY_NFA:
 4698    00000000 84                    DC8     0x84
 4699    00000001 3F4B45                DC8     '?KE'
 4700    00000004 D9                    DC8     'Y'+0x80
 4701    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4702    00000008 ........              DC32    KEY_NFA // -1
 4703                           QKEY:
 4704    0000000C ........              DC32    .+5
 4705                            SECTION .text : CODE (2)
 4706                           #ifdef IO2TP
 4708                           #else
 4709                           #ifdef XON_XOFF // XON IN QKEY
 4710    00000000 ........              BL      TXRDY_SUBR
 4711    00000004 ........              BL      XON_SUBR
 4712                           #endif
 4713    00000008 4040                  EORS    t, t    // zero t
 4714    0000000A 074B                  LDR     x, = USART3_SR
 4715    0000000C 1968                  LDR     n, [x]          // Get Line Status
 4716    0000000E 8909                  LSRS    n, n, #6        // Char available
 4717    00000010 00D3                  BCC     NO_KEY          // No char, not Ready
 4718                           
 4719                           // HAVE A KEY - DON'T CONSUME IT
 4720                           #ifdef TRUE_EQU_NEG_ONE
 4721    00000012 0138                  SUBS    t, #1   // -1
 4722                           #else
 4724                           #endif
 4725                           #endif  // DEFAULT TO NO KEY IF IO2TP
 4726                           NO_KEY:
 4727                                   TPUSH
 4727                                   PUSHt   // push t to p, pre decrement p
 4727.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4727.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4727.3                         //      STR     t, [p]
 4727.4                                 ENDM
 4727                                   NEXT
 4727.1                         // ARMv7-M Thumb = .+5
 4727.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4727.3                         // ARMv6-M Thumb = .+4
 4727.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4727                                   NEXT1
 4727.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4727.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4727.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4727.4                         // ARMv6-M Thumb = .+4
 4727.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4727.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4727.7                                 ENDM
 4727.8                                 ENDM
 4727.9                                 ENDM
 4728    00000026 0000           LTORG
 4728.1                                  TABLE
 4728.2  00000028 00480040              Reference on line 4714
 4729                           
 4730                           
 4731                           //      CRS CRS:        ( n -- )
 4732                           //      Emit n cr'S (0x0d) and lf (0x0A)
 4733                           
 4734                            SECTION .text : CONST (2)
 4735                           CRS_NFA:
 4736    00000000 83                    DC8     0x83
 4737    00000001 4352                  DC8     'CR'
 4738    00000003 D3                    DC8     'S'+0x80
 4739                            ALIGNROM 2,0xFFFFFFFF
 4740    00000004 ........              DC32    QKEY_NFA
 4741                           CRS:
 4742    00000008 ........              DC32    DOCOL
 4743    0000000C ........              DC32    ZERO
 4744    00000010 ........              DC32    XDO
 4745                           CRS_BEGIN:
 4746    00000014 ........              DC32    CR
 4747    00000018 ........              DC32    XLOOP
 4748    0000001C F8FFFFFF              DC32     CRS_BEGIN-.
 4749    00000020 ........              DC32    SEMIS
 4750                           
 4751                           
 4752                           //      CR CR:  ( -- )
 4753                           //      Emit cr (0x0d) and lf (0x0A)
 4754                           
 4755                            SECTION .text : CONST (2)
 4756                           CR_NFA:
 4757    00000000 82                    DC8     0x82
 4758    00000001 43                    DC8     'C'
 4759    00000002 D2                    DC8     'R'+0x80
 4760    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4761    00000004 ........              DC32    CRS_NFA
 4762                           CR:
 4763                           #ifdef IO2TP
 4766                           #else
 4767    00000008 ........              DC32    DOCOL
 4768    0000000C ........              DC32    zero_OUT
 4769    00000010 ........              DC32    PDOTQ
 4770    00000014 02                    DC8     2
 4771    00000015 0D0A                  DC8     0x0D, 0x0A
 4772    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 4773    00000018 ........              DC32    SEMIS
 4774                           #endif
 4775                           
 4776                           
 4777                           //=============================== WORDCAT ====================================//
 4778                           //NOEXEC HEADERFORWORDCATEGORIES
 4779                           //      WC_UART0_NFA = FISH IO: CATEGORY
 4780                           
 4781                            SECTION .text : CONST (2)
 4782                           WC_UARTx_NFA:
 4783    00000000 8C                    DC8     0x80+4+8
 4784    00000001 0D0A                  DC8     0x0D, 0x0A
 4785    00000003 4649534820494         DC8     'FISH IO:'
                  F3A          
 4786    0000000B 0D8A                  DC8     0x0D, 0x0A+0x80
 4787    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4788    00000010 ........              DC32    CR_NFA
 4789                           
 4790                           //      CMSIS_ENABLE_IRQS IRQS_RESUME:  ( -- )
 4791                            SECTION .text : CONST (2)
 4792                           IRQS_RESUME_NFA:
 4793    00000000 8B                    DC8     0x8B
 4794    00000001 495251535F524         DC8     'IRQS_RESUM'
                  553554D      
 4795    0000000B C5                    DC8     'E'+0x80
 4796                            ALIGNROM 2,0xFFFFFFFF
 4797    0000000C ........              DC32    WC_UARTx_NFA
 4798                           CMSIS_ENABLE_IRQS:
 4799    00000010 ........              DC32 .+5
 4800                            SECTION .text : CODE (2)
 4801                            ALIGNROM 2,0xFFFFFFFF
 4802                            IMPORT C_CMSIS_ENABLE_IRQS
 4803    00000000 ........              BL      C_CMSIS_ENABLE_IRQS
 4804                                   NEXT
 4804.1                         // ARMv7-M Thumb = .+5
 4804.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4804.3                         // ARMv6-M Thumb = .+4
 4804.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4804                                   NEXT1
 4804.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4804.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4804.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4804.4                         // ARMv6-M Thumb = .+4
 4804.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4804.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4804.7                                 ENDM
 4804.8                                 ENDM
 4805                           
 4806                           //      CMSIS_DISABLE_IRQS IRQS_SUSPEND:        ( -- )
 4807                            SECTION .text : CONST (2)
 4808                           IRQS_SUSPEND_NFA:
 4809    00000000 8C                    DC8     0x8C
 4810    00000001 495251535F535         DC8     'IRQS_SUSPEN'
                  55350454E    
 4811    0000000C C4                    DC8     'D'+0x80
 4812    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4813    00000010 ........              DC32    IRQS_RESUME_NFA
 4814                           CMSIS_DISABLE_IRQS:
 4815    00000014 ........              DC32 .+5
 4816                            SECTION .text : CODE (2)
 4817                            ALIGNROM 2,0xFFFFFFFF
 4818                            IMPORT C_CMSIS_DISABLE_IRQS
 4819    00000000 ........              BL      C_CMSIS_DISABLE_IRQS
 4820                                   NEXT
 4820.1                         // ARMv7-M Thumb = .+5
 4820.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4820.3                         // ARMv6-M Thumb = .+4
 4820.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4820                                   NEXT1
 4820.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4820.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4820.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4820.4                         // ARMv6-M Thumb = .+4
 4820.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4820.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4820.7                                 ENDM
 4820.8                                 ENDM
 4821                           
 4822                           
 4823                           //      SYSTICK_IRQ_OFF SYSTICK_IRQ_OFF:        ( -- )
 4824                           //      Turn SYSTICK interrupt off.
 4825                           //      STCTR only incremented when SYSTICK interrupt is on.
 4826                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4827                            SECTION .text : CONST (2)
 4828                           SYSTICK_IRQ_OFF_NFA:
 4829    00000000 8F                    DC8     0x8F
 4830    00000001 5359535449434         DC8     'SYSTICK_IRQ_OF'
                  B5F4952515F4F
                  46           
 4831    0000000F C6                    DC8     'F'+0x80
 4832                            ALIGNROM 2,0xFFFFFFFF
 4833    00000010 ........              DC32    IRQS_SUSPEND_NFA
 4834                           SYSTICK_IRQ_OFF:
 4835    00000014 ........              DC32    .+5
 4836                            SECTION .text : CODE (2)
 4837    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4838    00000002 0520                  MOVS    t, #5
 4839    00000004 0860                  STR     t, [n]
 4840                                   NEXT
 4840.1                         // ARMv7-M Thumb = .+5
 4840.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4840.3                         // ARMv6-M Thumb = .+4
 4840.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4840                                   NEXT1
 4840.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4840.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4840.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4840.4                         // ARMv6-M Thumb = .+4
 4840.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4840.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4840.7                                 ENDM
 4840.8                                 ENDM
 4841                           // LTORG         //Always outside of code, else data in words
 4842                           
 4843                           
 4844                           //      SYSTICK_IRQ_ON SYSTICK_IRQ_ON:  ( -- )
 4845                           //      Turn SYSTICK interrupt on.
 4846                           //      STCTR only incremented when SYSTICK interrupt is on.
 4847                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4847.1                                  TABLE
 4847.2  00000014 10E000E0              Reference on line 4837
 4848                            SECTION .text : CONST (2)
 4849                           SYSTICK_IRQ_ON_NFA:
 4850    00000000 8E                    DC8     0x8E
 4851    00000001 5359535449434         DC8     'SYSTICK_IRQ_O'
                  B5F4952515F4F
 4852    0000000E CE                    DC8     'N'+0x80
 4853    0000000F FF             ALIGNROM 2,0xFFFFFFFF
 4854    00000010 ........              DC32    SYSTICK_IRQ_OFF_NFA
 4855                           SYSTICK_IRQ_ON:
 4856    00000014 ........              DC32    .+5
 4857                            SECTION .text : CODE (2)
 4858    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4859    00000002 0720                  MOVS    t, #7
 4860    00000004 0860                  STR     t, [n]
 4861                                   NEXT
 4861.1                         // ARMv7-M Thumb = .+5
 4861.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4861.3                         // ARMv6-M Thumb = .+4
 4861.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4861                                   NEXT1
 4861.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4861.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4861.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4861.4                         // ARMv6-M Thumb = .+4
 4861.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4861.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4861.7                                 ENDM
 4861.8                                 ENDM
 4862                            LTORG   //Always outside of code, else data in words
 4862.1                                  TABLE
 4862.2  00000014 10E000E0              Reference on line 4858
 4863                           
 4864                           //=============================== WORDCAT ====================================//
 4865                           //NOEXEC HEADERFORWORDCATEGORIES
 4866                           //      WC_IRQ_NFA = INTERRUPTS: CATEGORY
 4867                           
 4868                            SECTION .text : CONST (2)
 4869                           WC_IRQ_NFA:
 4870    00000000 8F                    DC8     0x80+4+11
 4871    00000001 0D0A                  DC8     0x0D, 0x0A
 4872    00000003 494E544552525         DC8     'INTERRUPTS:'
                  55054533A    
 4873    0000000E 0D8A                  DC8     0x0D, 0x0A+0x80
 4874                            ALIGNROM 2,0xFFFFFFFF
 4875    00000010 ........              DC32    SYSTICK_IRQ_ON_NFA
 4876                           
 4877                           
 4878                           //------------------------------------------------------------------------------
 4879                           $FISH_STM32F4_FLASH.s       // FLASH_SAVE and FLASH_FORGET Words
 4880                           // LFA BELOW NEEDS TO BE FLASH_FORGET_NFA
 4881                           //------------------------------------------------------------------------------
 4882                           
 4883                           //-------------------------- PROMPT VECTOR SECTION -----------------------------
 4884                           
 4885                           //      POFF ( -- )   Set NULL$ address in PROMPT to zero so quit does CR only.
 4886                           
 4887                            SECTION .text : CONST (2)
 4888                           POFF_NFA:
 4889    00000000 84                    DC8     0x84
 4890    00000001 504F46                DC8     'POF'
 4891    00000004 C6                    DC8     'F'+0x80
 4892    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4893    00000008 ........              DC32    FLASH_FORGET_NFA
 4894                           POFF:
 4895    0000000C ........              DC32    DOCOL
 4896    00000010 ........00000         DC32    STRVA, 0, PROMPT
                  000........  
 4897    0000001C ........              DC32    SEMIS
 4898                           
 4899                           //      PON ( -- )   Set NULL$ address in PROMPT to msg_MY_OK
 4900                           
 4901                            SECTION .text : CONST (2)
 4902                           PON_NFA:
 4903    00000000 83                    DC8     0x83
 4904    00000001 504F                  DC8     'PO'
 4905    00000003 CE                    DC8     'N'+0x80
 4906                            ALIGNROM 2,0xFFFFFFFF
 4907    00000004 ........              DC32    POFF_NFA
 4908                           PON:
 4909    00000008 ........              DC32    DOCOL
 4910    0000000C .............         DC32    STRVA, msg_MY_OK, PROMPT
                  ...........  
 4911    00000018 ........              DC32    SEMIS
 4912                           
 4913                           //      P ( -- addr )   Address of PROMPT, contains 0 or NULL$ address.
 4914                           
 4915                            SECTION .text : CONST (2)
 4916                           P_NFA:
 4917    00000000 81                    DC8     0x81
 4918    00000001 D0                    DC8     'P'+0x80
 4919    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4920    00000004 ........              DC32    PON_NFA
 4921                           P:
 4922    00000008 .............         DC32    DOCON, PROMPT
                  ...          
 4923                           
 4924                           //-------------------------- ERROR_HALT SECTION -----------------------------
 4925                           
 4926                           //      EHOFF ( -- )   Set ERROR_HALT to 0
 4927                           
 4928                            SECTION .text : CONST (2)
 4929                           EHOFF_NFA:
 4930    00000000 85                    DC8     0x85
 4931    00000001 45484F46              DC8     'EHOF'
 4932    00000005 C6                    DC8     'F'+0x80
 4933    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4934    00000008 ........              DC32    P_NFA
 4935                           EHOFF:
 4936    0000000C .............         DC32    DOCOL, ZERO, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 4937                           
 4938                           //      EHON ( -- )   Set ERROR_HALT to 1
 4939                           
 4940                            SECTION .text : CONST (2)
 4941                           EHON_NFA:
 4942    00000000 84                    DC8     0x84
 4943    00000001 45484F                DC8     'EHO'
 4944    00000004 CE                    DC8     'N'+0x80
 4945    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4946    00000008 ........              DC32    EHOFF_NFA
 4947                           EHON:
 4948    0000000C .............         DC32    DOCOL, ONE, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 4949                           
 4950                           //-------------------------- DOTDICTSPACE SECTION ------------------------------
 4951                           
 4952                           //      .DS DOTDICTSPACE:       ( n -- )
 4953                           //      Prints number of bytes availble in dictionary in DECIMAL using DOT,
 4954                           //      not affecting Base in the system
 4955                           
 4956                            SECTION .text : CONST (2)
 4957                           DOTDICTSPACE_NFA:
 4958    00000000 83                    DC8     0x83
 4959    00000001 2E44                  DC8     '.D'
 4960    00000003 D3                    DC8     'S'+0x80
 4961                            ALIGNROM 2,0xFFFFFFFF
 4962                           //      DC32    FLASH_FORGET_NFA
 4963                           //      DC32    P_NFA
 4964    00000004 ........              DC32    EHON_NFA
 4965                           DOTDICTSPACE:
 4966    00000008 ........              DC32    DOCOL
 4967    0000000C ........              DC32    DICTSPACE
 4968    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 4969    00000014 ........              DC32    DOTDEC
 4970    00000018 ........              DC32    BASE_FROM_R12   // Restore BASE
 4971    0000001C .............         DC32    LIT, msg_dictspace
                  ...          
 4972    00000024 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 4973                           #ifdef IO2TP
 4977                           #endif
 4978    0000002C ........              DC32    SEMIS
 4979                           
 4980                           
 4981                           //-------------------------- DOTVARSPACE SECTION -------------------------------
 4982                           
 4983                           //      .VS DOTVARSPACE:        ( n -- )
 4984                           //      Prints number of bytes availble in RAM VAR SPACE in DECIMAL using DOT,
 4985                           //      not affecting Base in the system.
 4986                           
 4987                            SECTION .text : CONST (2)
 4988                           DOTVARSPACE_NFA:
 4989    00000000 83                    DC8     0x83
 4990    00000001 2E56                  DC8     '.V'
 4991    00000003 D3                    DC8     'S'+0x80
 4992                            ALIGNROM 2,0xFFFFFFFF
 4993    00000004 ........              DC32    DOTDICTSPACE_NFA
 4994                           DOTVARSPACE:
 4995    00000008 ........              DC32    DOCOL
 4996    0000000C ........              DC32    VARSPACE
 4997    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 4998    00000014 .............         DC32    FOUR, SLASH
                  ...          
 4999    0000001C ........              DC32    DOTDEC
 5000    00000020 ........              DC32    BASE_FROM_R12   // Restore BASE
 5001    00000024 .............         DC32    LIT, msg_uvspace
                  ...          
 5002    0000002C .............         DC32    NULLSTRLEN, TYPE
                  ...          
 5003                           #ifdef IO2TP
 5007                           #endif
 5008    00000034 ........              DC32    SEMIS
 5009                           
 5010                           
 5011                           //      DUMP DUMP:      ( addr n -- )
 5012                           //      Print adrr and n lines of 4 columns of memory values in hexadecimal.
 5013                           //      Address must be even and a multiple of 4 else error message issued.
 5014                           //      Any key presssed will stop DUMP.
 5015                           
 5016                            SECTION .text : CONST (2)
 5017                           DUMP_NFA:
 5018    00000000 84                    DC8     0x84
 5019    00000001 44554D                DC8     'DUM'
 5020    00000004 D0                    DC8     'P'+0x80
 5021    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5022    00000008 ........              DC32    DOTVARSPACE_NFA
 5023                           DUMP:
 5024    0000000C ........              DC32    DOCOL
 5025                           
 5026    00000010 .............         DC32    OVER, QALIGNED  // \ -- addr n
                  ...          
 5027                           // DON'T SAVE BASE UNTIL AFTER ALIGNED TEST
 5028    00000018 ........              DC32    BASE_TO_R12     // Save current BASE
 5029    0000001C ........              DC32    HEX
 5030    00000020 .............         DC32    ZERO, XDO
                  ...          
 5031                           DUMP_ADDR_LINE:
 5032    00000028 ........              DC32    CR
 5033    0000002C .............         DC32    DUP, LIT, 10, DOTRU     // Print addr in Field
                  ...0A000000..
                  ......       
 5034    0000003C .............         DC32    FOUR, ZERO, XDO         // Four colum loop
                  ...........  
 5035                           DUMP_EACH_LOC:
 5036    00000048 .............         DC32    DUP, AT
                  ...          
 5037                           // Little Endian means addresses will print correctly
 5038                           // but to see character strings REVW is needed
 5039                           // but the addresses are scrambled!
 5040                           //        DC32    REVW                    // Reverse bytes in word
 5041    00000050 ........0E000         DC32    LIT, 14, DOTRU          // Diplay in Field
                  000........  
 5042    0000005C ........              DC32    FOURP
 5043    00000060 ........              DC32    XLOOP
 5044    00000064 E4FFFFFF              DC32     DUMP_EACH_LOC-.
 5045                           
 5046                           #ifdef IO2TP
 5050                           #endif
 5051    00000068 ........              DC32    QKEY
 5052    0000006C ........              DC32    ZBRAN
 5053    00000070 08000000              DC32     DUMP_CONT-.
 5054    00000074 ........              DC32    LEAVE
 5055                           DUMP_CONT:
 5056    00000078 ........              DC32    XLOOP
 5057    0000007C ACFFFFFF              DC32    DUMP_ADDR_LINE-.
 5058                           
 5059    00000080 .............         DC32    DROP, CR
                  ...          
 5060    00000088 ........              DC32    BASE_FROM_R12   // Restore BASE
 5061    0000008C ........              DC32    SEMIS
 5062                           
 5063                           
 5064                           //      VBASE VBASE:    ( -- addr )
 5065                           //      Return base addr of VAR's .
 5066                           
 5067                            SECTION .text : CONST (2)
 5068                           VBASE_NFA:
 5069    00000000 85                    DC8     0x85
 5070    00000001 56424153              DC8     'VBAS'
 5071    00000005 C5                    DC8     'E'+0x80
 5072    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5073    00000008 ........              DC32    DUMP_NFA
 5074                           VBASE:
 5075    0000000C .............         DC32    DOCON,  RAMVARSPACE_START
                  ...          
 5076                           
 5077                           
 5078                           //      DBASE DBASE:    ( -- addr )
 5079                           //      Return base addr of the dictionary.
 5080                           
 5081                            SECTION .text : CONST (2)
 5082                           DBASE_NFA:
 5083    00000000 85                    DC8     0x85
 5084    00000001 44424153              DC8     'DBAS'
 5085    00000005 C5                    DC8     'E'+0x80
 5086    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5087    00000008 ........              DC32    VBASE_NFA
 5088                           DBASE:
 5089    0000000C .............         DC32    DOCON,  ORIG
                  ...          
 5090                           
 5091                           
 5092                           //      RBASE RBASE:    ( -- addr )
 5093                           //      Return base addr of RAM THE DICTIONARY IS IN!.
 5094                           
 5095                            SECTION .text : CONST (2)
 5096                           RBASE_NFA:
 5097    00000000 85                    DC8     0x85
 5098    00000001 52424153              DC8     'RBAS'
 5099    00000005 C5                    DC8     'E'+0x80
 5100    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5101    00000008 ........              DC32    DBASE_NFA
 5102                           RBASE:
 5103    0000000C .............         DC32    DOCON,  RAM_START    // RAM WHERE DICT ALLOACTED IN MEMMAP
                  ...          
 5104                           
 5105                           
 5106                           //      CLS CLS:        ( -- )
 5107                           //      Clear serial terminal screen using a formfeed character
 5108                           
 5109                            SECTION .text : CONST (2)
 5110                           CLS_NFA:
 5111    00000000 83                    DC8     0x83
 5112    00000001 434C                  DC8     'CL'
 5113    00000003 D3                    DC8     'S'+0x80
 5114                            ALIGNROM 2,0xFFFFFFFF
 5115    00000004 ........              DC32    RBASE_NFA
 5116                           CLS:
 5117    00000008 ........              DC32    DOCOL
 5118    0000000C ........              DC32    PDOTQ
 5119    00000010 04                    DC8     4
 5120    00000011 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT100 ESC SETUP
 5121    00000013 324A                  DC8     '2J'            // Clearscreen
 5122    00000015 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5123    00000018 ........              DC32    PDOTQ
 5124    0000001C 04                    DC8     4
 5125    0000001D 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT00 ESC SETUP
 5126    0000001F 3B48                  DC8     ';H'            // CURSORHOME \ upper left corner
 5127    00000021 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5128    00000024 ........              DC32    CR              // Reset OUT
 5129    00000028 ........              DC32    SEMIS
 5130                           
 5131                           
 5132                           //      ( PAREN:        ( -- ) IMMEDIATE
 5133                           //      Used in the form:
 5134                           //              ( CCcc )
 5135                           //      Ignore comments within parenthesis. A right parenthesis ends comment.
 5136                           //      The comments may be multi-line but a space or tab is required
 5137                           //      for any line that is otherwise empty for formatting purposes,
 5138                           //      else a comment error will be printed. May occur during execution or in a
 5139                           //      colon-definition. A blank after the leading parenthesis is required.
 5140                           
 5141                            SECTION .text : CONST (2)
 5142                           PAREN_NFA:
 5143    00000000 C1                    DC8     0x0C1
 5144    00000001 A8                    DC8     '('+0x80
 5145    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5146    00000004 ........              DC32    CLS_NFA
 5147                           PAREN:
 5148                           // Slow Single line comment
 5149                           //      DC32    DOCOL, LIT, ')', WORD, SEMIS
 5150    00000008 ........              DC32    DOCOL
 5151                           PML_LOOP:
 5152    0000000C ........29000         DC32    LIT, ')'
                  000          
 5153    00000014 ........              DC32    TIB_CHAR_SCAN   // ( c -- f )
 5154                           //
 5155    00000018 ........              DC32    ZEQU            // If null
 5156    0000001C ........              DC32    ZBRAN           // found fall thru
 5157    00000020 34000000              DC32      PE_DONE-.     // else were done
 5158                           
 5159                           // Acting like the outer interpreter here, signal DLE
 5160    00000024 .............         DC32    CR, LIT, 0x10, EMIT
                  ...10000000..
                  ......       
 5161    00000034 ........              DC32    QUERY
 5162                           //  AND IF ONLY CR (null) ERR
 5163                           //        DC32    TIB_SV, CAT
 5164    00000038 .............         DC32    LIT, TIB+1, CAT // PAST COUNT BYTE
                  ...........  
 5165    00000044 ........              DC32    ZBRAN
 5166    00000048 10000000              DC32      PAREN_ERR-.
 5167                           
 5168                           //  If closing paren not in this line LOOP
 5169    0000004C ........              DC32    BRAN
 5170    00000050 BCFFFFFF              DC32      PML_LOOP-.
 5171                           
 5172                           PE_DONE:
 5173    00000054 ........              DC32    SEMIS
 5174                           
 5175                           PAREN_ERR:
 5176    00000058 .............         DC32    LIT, msg_paren_err
                  ...          
 5177    00000060 .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 5178    00000068 ........              DC32    SEMIS
 5179                           
 5180                           
 5181                           //      BACKSLASH BACKSLASH:    ( --  )
 5182                           //      After a trailing space treat the rest of the line as a comment.
 5183                           //      By setting a null terminator in TIB
 5184                           
 5185                            SECTION .text : CONST (2)
 5186                           BACKSLASH_NFA:
 5187    00000000 C1                    DC8     0x0C1
 5188    00000001 DC                    DC8     '\\'+0x80
 5189    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5190    00000004 ........              DC32    PAREN_NFA
 5191                           BACKSLASH:
 5192    00000008 ........              DC32    DOCOL
 5193    0000000C .............         DC32    ZERO, TIB_SV, IN_SV, AT, PLUS, CSTORE
                  .............
                  .............
                  .........    
 5194    00000024 ........              DC32    SEMIS
 5195                           
 5196                           
 5197                           //      SYSCLK SYSCLK:  ( -- value )
 5198                           //      Returns system clock value in Hz, i.e. 48000000 = 48Mhz.
 5199                           
 5200                            SECTION .text : CONST (2)
 5201                           SYSCLK_NFA:
 5202    00000000 86                    DC8     0x86
 5203    00000001 535953434C            DC8     'SYSCL'
 5204    00000006 CB                    DC8     'K'+0x80
 5205    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 5206    00000008 ........              DC32    BACKSLASH_NFA
 5207                           SYSCLK:
 5208    0000000C ........              DC32    .+5
 5209                            SECTION .text : CODE (2)
 5210    00000000 0549                  LDR     n, = SYSCLOCK   // SystemCoreClock
 5211    00000002 0868                  LDR     t, [n]
 5212                                   TPUSH   // Push -- t
 5212                                   PUSHt   // push t to p, pre decrement p
 5212.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 5212.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 5212.3                         //      STR     t, [p]
 5212.4                                 ENDM
 5212                                   NEXT
 5212.1                         // ARMv7-M Thumb = .+5
 5212.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5212.3                         // ARMv6-M Thumb = .+4
 5212.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5212                                   NEXT1
 5212.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5212.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5212.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5212.4                         // ARMv6-M Thumb = .+4
 5212.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5212.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5212.7                                 ENDM
 5212.8                                 ENDM
 5212.9                                 ENDM
 5213    00000016 0000           LTORG   //Always outside of code, else data in words
 5213.1                                  TABLE
 5213.2  00000018 ........              Reference on line 5210
 5214                           
 5215                           
 5216                           //      STCTR   ( -- addr ) SYSTICK Interrupt increments this with 32but wrap.
 5217                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5218                            SECTION .text : CONST (2)
 5219                           STCTR_NFA:
 5220    00000000 85                    DC8     0x85
 5221    00000001 53544354              DC8     'STCT'
 5222    00000005 D2                    DC8     'R'+0x80
 5223    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5224                           //      DC32    STI_ON_NFA
 5225    00000008 ........              DC32    SYSCLK_NFA
 5226                           STCTR:
 5227    0000000C .............         DC32    DOCON, STICKER
                  ...          
 5228                           
 5229                           
 5230                           //      DELAY ( n value -- ) 7 E000E010h !   5 E000E010h !
 5231                            SECTION .text : CONST (2)
 5232                           DELAY_NFA:
 5233    00000000 85                    DC8     0x85
 5234    00000001 44454C41              DC8     'DELA'
 5235    00000005 D9                    DC8     'Y'+0x80
 5236    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5237    00000008 ........              DC32    STCTR_NFA
 5238                           DELAY:
 5239    0000000C ........              DC32    .+5
 5240                            SECTION .text : CODE (2)
 5241                                   POP2n   // Reload value in n
 5241.1  00000000 57F8041B              LDR     n, [p],#4
 5241.2                         //      LDR     n, [p]
 5241.3                         //      ADDS    p, p, #4
 5241.4                                 ENDM
 5242                                   POP2t   // loop count in t
 5242.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 5242.2                         //#ifndef TOSCT
 5242.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 5242.4                         //#endif
 5242.5                         //      ADDS    p, p, #4
 5242.6                                 ENDM
 5243                           // SET STCTR TO NEGATIVE LOOP COUNT TO END AT ZERO
 5244    00000008 0C4C                  LDR     y, = STICKER
 5245    0000000A C043                  MVNS    t, t            // 1's compliment
 5246    0000000C 401C                  ADDS    t, t, #1        // 2's compliment
 5247    0000000E 2060                  STR     t, [y]
 5248                           // Load SYST_RVR with countdown value
 5249    00000010 0B4A                  LDR     w, = SYST_RVR
 5250    00000012 1160                  STR     n, [w]
 5251                           // and reset SYST_CVR to start countdown.
 5252    00000014 0B4A                 LDR     w, = SYST_CVR
 5253                           // Writing it clears the System Tick counter and the COUNTFLAG bit in STCTRL.
 5254    00000016 1160                  STR     n, [w]
 5255                           // If n=0 in t user is just setting reload value
 5256    00000018 0028                  CMP     t, #0           // LOOP OF ZERO
 5257    0000001A 06D0                  BEQ     DELAY_DONE
 5258                           // INTERRUPT VERSION: negate n to STCTR and leave when STCTR = 0
 5259                           // STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5260                           // Save and restore user interrupt setting
 5261                           // y = STICKER
 5262    0000001C 0A4A                  LDR     w, = SYST_CSR
 5263    0000001E 1068                  LDR     t, [w]          // Save user SYSTICK interrupt setting
 5264    00000020 0721                  MOVS    n, #7
 5265    00000022 1160                  STR     n, [w]          // Turn SYSTICK interrupt on in case it's off
 5266                           DELAY_LOOP:
 5267    00000024 2168                  LDR     n, [y]
 5268    00000026 0029                  CMP     n, #0
 5269    00000028 FCD1                  BNE     DELAY_LOOP
 5270                           DELAY_DONE:
 5271    0000002A 1060                  STR     t, [w]  // Restore user SYSTICK interrupt setting
 5272                                   NEXT
 5272.1                         // ARMv7-M Thumb = .+5
 5272.2  0000002C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5272.3                         // ARMv6-M Thumb = .+4
 5272.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5272                                   NEXT1
 5272.1  00000030 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5272.2  00000034 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5272.3  00000038 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5272.4                         // ARMv6-M Thumb = .+4
 5272.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5272.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5272.7                                 ENDM
 5272.8                                 ENDM
 5273    0000003A 0000           LTORG
 5273.1                                  TABLE
 5273.2  0000003C ........              Reference on line 5244
 5273.3  00000040 14E000E0              Reference on line 5249
 5273.4  00000044 18E000E0              Reference on line 5252
 5273.5  00000048 10E000E0              Reference on line 5262
 5274                           
 5275                           
 5276                           //      MS MS: ( n -- ) n * 1 millisecond execution time
 5277                           //      SYSTICK_IRQ_ON/OFF  STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! 
 5278                           
 5279                            SECTION .text : CONST (2)
 5280                           MS_NFA:
 5281    00000000 82                    DC8     0x82
 5282    00000001 4D                    DC8     'M'
 5283    00000002 D3                    DC8     'S'+0x80
 5284    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 5285    00000004 ........              DC32    DELAY_NFA
 5286                           MS:
 5287    00000008 ........              DC32    DOCOL
 5288                           #ifdef STM32F4_IRC16_48MHZ
 5290                           #endif
 5291                           #ifdef STM32F205RC_XRC10_118MHZ
 5293                           #endif
 5294                           #ifdef STM32F4_XRC08_168MHZ
 5295    0000000C ........3F900         DC32    LIT, 167999d    // 2903Fh 1ms @ 168mhz RELOAD COUNTER VALUE
                  200          
 5296                           #endif
 5297    00000014 ........              DC32    DELAY
 5298    00000018 ........              DC32    SEMIS
 5299                           
 5300                           
 5301                           //      WORDCAT WORDCAT: ( -- )
 5302                           //      Creates a Word Category NFA and LFA that cannot be searched for,
 5303                           //      but is displayed by WORDS and MYWORDS to label a group of Words.
 5304                           //      Define a group of Words and then add a category name with WORDCAT.
 5305                           //      EX: WORDCAT MY APP WORDS:
 5306                           //      It must be on a line of it's own.
 5307                           //      The colon at the end is FISH convention.
 5308                            SECTION .text : CONST (2)
 5309                           WORDCAT_NFA:
 5310    00000000 87                    DC8     0x87
 5311    00000001 574F52444341          DC8     'WORDCA'
 5312    00000007 D4                    DC8     'T'+0x80
 5313                            ALIGNROM 2,0xFFFFFFFF
 5314    00000008 ........              DC32    MS_NFA
 5315                           WORDCAT:
 5316    0000000C ........              DC32    DOCOL
 5317    00000010 .............         DC32    HERE, TOR
                  ...          
 5318    00000018 .............         DC32    ZERO, CCOMMA    // Count byte place holder
                  ...          
 5319    00000020 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5320    0000002C ........              DC32    HERE
 5321    00000030 ........0D000         DC32    LIT, 0Dh, WORD
                  000........  
 5322    0000003C .............         DC32    DUP, CAT
                  ...          
 5323    00000044 ........0A000         DC32    LIT, 0Ah, ROT, CSTORE
                  000..........
                  ......       
 5324    00000054 .............         DC32    DUP, ONEP, ALLOT
                  ...........  
 5325    00000060 ........84000         DC32    LIT, 084h        // Count before system text
                  000          
 5326    00000068 .............         DC32    PLUS, R, CSTORE
                  ...........  
 5327    00000074 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5328    00000080 ........8A000         DC32    LIT, 08Ah, CCOMMA
                  000........  
 5329    0000008C ........              DC32    ALIGN32_DP_FF_PAD
 5330    00000090 .............         DC32    LATEST, COMMA
                  ...          
 5331    00000098 ........              DC32    RFROM
 5332    0000009C .............         DC32    LIT, CURRENT
                  ...          
 5333    000000A4 ........              DC32    STORE
 5334    000000A8 ........              DC32    SEMIS
 5335                           
 5336                           
 5337                           //      WORDS WORDS:    ( -- ) RENAMED: VLIST to WORDS
 5338                           //      Output list of Words in the dictionary in search order.
 5339                           //      Uses WC_ nfa's to format Word Categories.
 5340                           //      Uses FENCE for where to stop.
 5341                           //      See MYWORDS.
 5342                           
 5343                            SECTION .text : CONST (2)
 5344                           WORDS_NFA:
 5345    00000000 85                    DC8     0x85
 5346    00000001 574F5244              DC8     'WORD'
 5347    00000005 D3                    DC8     'S'+0x80
 5348    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5349    00000008 ........              DC32    WORDCAT_NFA
 5350                           WORDS:
 5351    0000000C ........              DC32    DOCOL
 5352    00000010 .............         DC32    THREE, SPACES
                  ...          
 5353    00000018 ........              DC32    LATEST
 5354                           #ifdef XON_XOFF
 5355    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 5356                           #endif
 5357                           WORDS1:  // ADD nfa length to current out_uv & verify it doesn't violate csll.
 5358                           
 5359    00000020 .............         DC32    ZERO, OVER      // -- nfa zero nfa
                  ...          
 5360    00000028 .............         DC32    ONEP, CAT       // If wc_ header skip
                  ...          
 5361    00000030 ........0D000         DC32    LIT, 0x0D       // -- nfa zero (c@) 0x0D
                  000          
 5362    00000038 .............         DC32    EQUAL, ZEQU     // -- nfa zerro flag
                  ...          
 5363    00000040 ........              DC32    ZBRAN           // -- nfa zero
 5364    00000044 1C000000              DC32     WORDS2-.       // wc_ goto
 5365                                   
 5366    00000048 ........              DC32    DROP            // -- nfa
 5367    0000004C .............         DC32    DUP, PFA, LFA   // -- nfa lfa
                  ...........  
 5368    00000058 .............         DC32    OVER, SUBB      // -- nfa (lfa - nfa)
                  ...          
 5369                           
 5370                           WORDS2: // -- nfa n
 5371                           
 5372    00000060 .............         DC32    OUT_SV, AT
                  ...          
 5373    00000068 ........              DC32    PLUS
 5374    0000006C ........4A000         DC32    LIT, 74         // was :NONAME CSLL - WORDS line length constant.
                  000          
 5375    00000074 ........              DC32    GREATERTHAN
 5376    00000078 ........              DC32    ZBRAN           // If not at end of line
 5377    0000007C 10000000              DC32     WORD21-.        // skip cr and out reset
 5378                           
 5379    00000080 ........              DC32    CR              // Start another line
 5380    00000084 .............         DC32    THREE, SPACES
                  ...          
 5381                           
 5382                           WORD21:
 5383                           #ifdef  IO2TP
 5386                           #endif
 5387                           // For MYWORDS test FENCE and stop if less
 5388    0000008C ........              DC32    DUP             // nfa
 5389    00000090 .............         DC32    FENCE_SV, AT
                  ...          
 5390    00000098 ........              DC32    LESSTHAN
 5391    0000009C ........              DC32    ZBRAN
 5392    000000A0 0C000000              DC32     WORDSCONT-.
 5393                           
 5394    000000A4 ........              DC32    BRAN
 5395    000000A8 54000000              DC32     WORDSDONE-.
 5396                           
 5397                           WORDSCONT:
 5398    000000AC ........              DC32    DUP             // nfa
 5399    000000B0 ........              DC32    IDDOT
 5400    000000B4 .............         DC32    TWO, SPACES
                  ...          
 5401                           
 5402    000000BC .............         DC32    DUP, ONEP, CAT  // Take nfa and look for WORDCAT signature
                  ...........  
 5403    000000C8 ........0D000         DC32    LIT, 0x0D       // which is cr
                  000          
 5404    000000D0 ........              DC32    EQUAL
 5405    000000D4 ........              DC32    ZBRAN           // If not wordcat
 5406    000000D8 08000000              DC32     NOT_WC-.       // skip
 5407                           
 5408    000000DC ........              DC32    zero_OUT
 5409                           
 5410                           NOT_WC:
 5411    000000E0 ........              DC32    PFA             // \ nfa -- pfa
 5412    000000E4 ........              DC32    LFA             // \ pfa -- lfa
 5413    000000E8 ........              DC32    AT              // Is next lfa
 5414    000000EC ........              DC32    DUP
 5415    000000F0 ........              DC32    ZEQU            // Zero = end of dictionary
 5416                           
 5417                           // REMOVED SO WORDS AND MYWORDS CAN BE USED IN DOWNLOAD FILES
 5418                           //      DC32    QKEY           // Zero or break key \ ^C = 0x03
 5419                           //      DC32    OR
 5420                           
 5421    000000F4 ........              DC32    ZBRAN           // Until break key or end of dictionary
 5422    000000F8 28FFFFFF              DC32     WORDS1-.
 5423                           
 5424                           #ifdef  IO2TP
 5427                           #endif
 5428                           WORDSDONE:
 5429    000000FC .............         DC32    DROP, CR
                  ...          
 5430    00000104 ........              DC32    SEMIS
 5431                           
 5432                           
 5433                           //      MYWORDS MYWORDS: ( -- )
 5434                           //      Print only system defined words by manipulating FENCE.
 5435                           
 5436                            SECTION .text : CONST (2)
 5437                           MYWORDS_NFA:
 5438    00000000 87                    DC8     0x87
 5439    00000001 4D59574F5244          DC8     'MYWORD'
 5440    00000007 D3                    DC8     'S'+0x80
 5441                            ALIGNROM 2,0xFFFFFFFF
 5442    00000008 ........              DC32    WORDS_NFA
 5443                           MYWORDS:
 5444    0000000C ........              DC32    DOCOL
 5445    00000010 ........00000         DC32    strva , FLASH_SPAGE, FENCE
                  208........  
 5446    0000001C ........              DC32    WORDS                   // now print words in ram
 5447    00000020 ........00000         DC32    strva, 0 , FENCE
                  000........  
 5448    0000002C ........              DC32    SEMIS
 5449                           
 5450                           
 5451                           //      FISH_ONLY FISH_ONLY     ( -- ) MODIFIED:
 5452                           //      RESET DP, UP AND CURRENT TO ORIGINAL FLASH IMAGE
 5453                           
 5454                            SECTION .text : CONST (2)
 5455                           FISH_ONLY_NFA:
 5456    00000000 89                    DC8     0x80+9
 5457    00000001 464953485F4F4         DC8     'FISH_ONL'
                  E4C          
 5458    00000009 D9                    DC8     'Y'+0x80
 5459    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 5460    0000000C ........              DC32    MYWORDS_NFA
 5461                           FISH_ONLY:
 5462    00000010 ........              DC32    .+5
 5463                            SECTION .text : CODE (2)
 5464                           //      LDR     n, = TASK_NFA           // preserve TOS
 5465                           #ifdef FISH_PubRel_WORDSET
 5466    00000000 0949                  LDR     n, = WC_FISH_PubRel_NFA
 5467                           #endif
 5468                           #ifdef FISH_STM32M407vg_PRO_WORDCAT
 5470                           #endif
 5471    00000002 0A4C                  LDR     y, = CURRENT            // CURRENT SETTING
 5472    00000004 2160                  STR     n, [y]
 5473    00000006 0A4C                  LDR     y, = FPC                // FLASH CURRENT
 5474    00000008 2160                  STR     n, [y]
 5475    0000000A 0A49                  LDR     n, = RAMVARSPACE_START
 5476    0000000C 0A4C                  LDR     y, = UP                 // UP SETTING
 5477    0000000E 2160                  STR     n, [y]
 5478    00000010 0A4C                  LDR     y, = FPSV                // FLASH USER VARS
 5479    00000012 2160                  STR     n, [y]
 5480    00000014 0A49                  LDR     n, = ORIG
 5481    00000016 0B4C                  LDR     y, = DP                 // DP SETTING
 5482    00000018 2160                  STR     n, [y]
 5483                                   NEXT
 5483.1                         // ARMv7-M Thumb = .+5
 5483.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5483.3                         // ARMv6-M Thumb = .+4
 5483.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5483                                   NEXT1
 5483.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5483.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5483.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5483.4                         // ARMv6-M Thumb = .+4
 5483.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5483.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5483.7                                 ENDM
 5483.8                                 ENDM
 5484                            LTORG
 5484.1                                  TABLE
 5484.2  00000028 ........              Reference on line 5466
 5484.3  0000002C ........              Reference on line 5471
 5484.4  00000030 ........              Reference on line 5473
 5484.5  00000034 ........              Reference on line 5475
 5484.6  00000038 ........              Reference on line 5476
 5484.7  0000003C ........              Reference on line 5478
 5484.8  00000040 ........              Reference on line 5480
 5484.9  00000044 ........              Reference on line 5481
 5485                           
 5486                           
 5487                           //      FISH FISH:      ( -- )
 5488                           //      Print Flash Status and FISH Signon Message.
 5489                           
 5490                           
 5491                            SECTION .text : CONST (2)
 5492                           FISH_NFA:
 5493    00000000 84                    DC8     0x84
 5494    00000001 464953                DC8     'FIS'
 5495    00000004 C8                    DC8     'H'+0x80
 5496    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5497    00000008 ........              DC32    FISH_ONLY_NFA
 5498                           FISH:
 5499    0000000C ........              DC32    DOCOL
 5500    00000010 ........              DC32    FLASH_SCAN
 5501    00000014 ........              DC32    SIGNON
 5502    00000018 ........              DC32    SEMIS
 5503                           
 5504                           //=============================== WORDCAT ====================================//
 5505                           //NOEXEC HEADERFORWORDCATEGORIES
 5506                           //      WC_FISH_PubRel: = FISH Reference Model: CATEGORY
 5507                            SECTION .text : CONST (2)
 5508                           WC_FISH_PubRel_NFA:
 5509    00000000 99                    DC8     0x80+4+21
 5510    00000001 0D0A                  DC8     0x0D, 0x0A
 5511    00000003 4649534820526         DC8     'FISH Reference Model:'
                  5666572656E63
                  65204D6F64656
                  C3A          
 5512    00000018 0D8A                  DC8     0x0D, 0x0A+0x80
 5513    0000001A FFFF           ALIGNROM 2,0xFFFFFFFF
 5514    0000001C ........              DC32    FISH_NFA
 5515                           
 5516                           ;**** FIRST WORD LISTED****
 5517                           
 5518                           //=============================== WORDCAT ====================================//
 5519                           
 5520                           #ifdef FISH_STM_M3_PRO_WORDCAT
 5522                           #endif
 5523                           // FIRST WORDCAT
 5524                           
 5525                           //------------------------------------------------------------------------------
 5526                           // FOR MULTI TASKING MUST BE PLACED IN RAM AND OFFSET USED IN SYSTEM VARS!!!!!!
 5527                           //            T A S K 
 5528                           //
 5529                           ;.data          // Place TASK at beginning of RAM, or not.
 5530                           /*
 5531                            SECTION .text : CONST (2)
 5532                           TASK_NFA:
 5533                                   DC8     0x84
 5534                                   DC8     'TAS'
 5535                                   DC8     'K'+0x80
 5536                            ALIGNROM 2,0xFFFFFFFF
 5537                           //      TASK Is top of dictionary until new definitionsa added
 5538                           //      PATCH CONTEXT or LATEST else LFA in TASK FROM SYM TABLE
 5539                           //      To debug dictionary searches - see - PFIND & DFIND
 5540                           //      DC32    ZEQU_NFA        // 4 (no match) bombing at +
 5541                           //      DC32    NOOP_NFA        // Patch here to shorten test of PFIND
 5542                           //      DC32    CAT_NFA         // C@ before @
 5543                           //      DC32    LESS_NFA        // < before =
 5544                           //       DC32   SoCinit_NFA     //XON_NFA               // FULL DICT SEARCH
 5545                                   DC32    MS_NFA
 5546                           TASK:
 5547                                   DC32    DOCOL
 5548                                   DC32    SEMIS
 5549                           */
 5550                           
 5551                           //------------------------------------------------------------------------------
 5552                           //:NONAME SECTION:
 5553                           // THESE STAY HERE (INSTEAD OF SLLIB) BECAUSE THEY ARE CONDITIONALLY INCLUDED
 5554                           // HI-LEVEL THEM ASM SECTIONS
 5555                           #ifdef IO2TP
 5564                           #endif
 5565                           
 5566                           #ifdef IO2TP
 5575                           #endif
 5576                           
 5577                           #ifdef USE_CMAIN
 5587                           #endif
 5588                           
 5589                           #ifdef TESTRAM
 5695                           #endif  // TESTRAM
 5696                           //------------------------------------------------------------------------------
 5697                           // Placing blocks that can change at end of link map
 5698                           // Place :NONAME for static Library first in FISH_STM_M3_SLIB.s
 5699                           
 5700                           // $PROJ_DIR$\..\FISH_RM_COMMON
 5701                           // $PROJ_DIR$\..\FISH_RM_CORTEX_M_COMMON_CODE
 5702                           // In Assembler preprocessor set additional include directories 
 5703                           $FISH_RM_MSGS.h
 5704                           // equals below
 5705                           //#include ".\..\FISH_COMMON_CODE\FISH_RM_MSGS.h"
 5706                           
 5707                           // SYSTEMCLOCK #define set in FISH_M0_EQUATES.s for SYSCLOCK value.
 5708                           // THIS IS A :NONAME WORDSET
 5709                           
 5710                           $FISH_STM32F4_SOC_INIT.s
 5711                           
 5712                            END
##############################
#           CRC:0            #
#        Errors:   0         #
#        Warnings: 0         #
#        Bytes: 83903        #
##############################




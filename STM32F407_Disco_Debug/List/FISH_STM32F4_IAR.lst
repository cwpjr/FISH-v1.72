###################################################################################################
#                                                                                                 #
#     IAR Assembler V8.22.1.15669/W32 for ARM 19/Apr/2018  11:28:01                               #
#     Copyright 1999-2018 IAR Systems AB.                                                         #
#                                                                                                 #
#           Source file   =  C:\Users\Clyde W Phillips Jr\Desktop\FISH v1.72\FISH_STM32F4_IAR.s   #
#           List file     =  C:\Users\Clyde W Phillips Jr\Desktop\FISH v1.72\STM32F407_Disco_Debug\List\FISH_STM32F4_IAR.lst#
#           Object file   =  C:\Users\Clyde W Phillips Jr\Desktop\FISH v1.72\STM32F407_Disco_Debug\Obj\FISH_STM32F4_IAR.o#
#           Command line  =  -f C:\Users\CLYDEW~1\AppData\Local\Temp\EWE8A8.tmp                   #
#                            (C:\Users\Clyde W Phillips Jr\Desktop\FISH v1.72\FISH_STM32F4_IAR.s  #
#                            -OC:\Users\Clyde W Phillips Jr\Desktop\FISH v1.72\STM32F407_Disco_Debug\Obj #
#                            -s+ -M<> -w+ -r -DFISH_PubRel_WORDSET -DFISH_Debug_WORDSET           #
#                            -DSTM32F4_XRC08_168MHZ                                               #
#                            -LC:\Users\Clyde W Phillips Jr\Desktop\FISH v1.72\STM32F407_Disco_Debug\List #
#                            -t8 --cpu Cortex-M4 --fpu VFPv4_sp                                   #
#                            -IC:\Users\Clyde W Phillips Jr\Desktop\FISH v1.72\..\FISH_Libs\FISH_RM_COMMON\ #
#                            -IC:\Users\Clyde W Phillips Jr\Desktop\FISH v1.72\..\FISH_Libs\FISH_RM_COMMON_CODE_CORTEX_M\) #
#                                                                                                 #
###################################################################################################

    1                           // FISH_STM32F4_IAR.s - FULL WORD v1.7.2
    2                           // FISH FOR THE STM IS CURRENTLY SUPPORTING F2 TO F4
    3                           // Code is common, seperate linker files used for memory map differences.
    4                           $FISH_STM32F4_MAIN_INCLUDES.h
    5                           //------------------------------------------------------------------------------
    6                           
    7                           // 2DO: Add VIO_UARTX, VIO_KEY, VIO_?KEY and VIO_EMIT
    8                           // (EMIT), (KEY?), and (KEY).
    9                           
   10                           // v1.8 SPI for Smart-IO
   11                           
   12                           // v1.7.2 Fix backspace issue
   13                           
   14                           // v1.7:
   15                           
   16                           // Fix NUMBER by merge with NXP which works correctly!
   17                           // 2DO: Restore SYSTICK ISR to ASM version
   18                           // 2DO: Signon updated. (FOR TEST - FIX B4 SHIP)
   19                           // 2DO: Updated .hex .out and sym.bat
   20                           
   21                           // #define EOL_DLE // DLE 0x10/16d in QUIT>CR after last word interpreted.
   22                           // #define EOL_NAK // NAK 0x15/21d in error messages for STDLED editor highlight
   23                           // The EOL_NAK makes SPACE NAK end of string in FISH_RM_MSGS.h
   24                           
   25                           // Split out files to FISH_RM_COMMON and FISH_RM_COMMON_CODE_CORTEX_M
   26                           
   27                           // ADDED EHON and EHOFF to FISH RM
   28                           // Changes iar.s COLD, ERROR and ABORT
   29                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM:
   30                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - ERROR_HALT: SV 
   31                           
   32                           // ADDED P(PROMPT), PON(PROMPTON) and POFF(PROMPTOFF) to FISH RM
   33                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM: & QUIT:
   34                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - PROMPT: SV 
   35                           
   36                           // Added #define TRUE_EQU_NEG_ONE
   37                           // Changed all user visible true flags to -1
   38                           
   39                           // Added SXTB Rd, Rm  and SXTH Rd, Rm
   40                           
   41                           // Number Stuff Wordcat reorganized (search NOEXEC or WC_NUMBERS_NFA)
   42                           // EXPECT does counted null strings:
   43                           // NUMBER to look for null terminatiion instead of BLANK.
   44                           // WORD changed to expect null string and elimated BLANKS fill of HERE.
   45                           //      SPEEDS UP TOKENIZATION OF TIB INPUT!
   46                           // ALL IN AND IN_SV INIT SET TO 1 in QUERY SV_INIT_VALUES CLRTIB
   47                           // NUMBERSUFFIX changed to replace suffix with null
   48                           // PAREN ( changed to use TIB+1
   49                           // DPL restored to dictionairy.
   50                           
   51                           //------------------------------------------------------------------------------
   52                            SECTION .text : CONST (2)
   53                           msg_FISH:
   54                           // DC8 "?" IS A NULL TERMINATED STRING
   55                           // DC8 '?' IS NOT
   56                           //#if FISH_PubRel_WORDSET | FISH_DebugSrc_WORDSET
   57    00000000 4649534820415         DC8     'FISH ARM '
                  24D20        
   58                           //#endif
   59                           #if FISH_PubRel_WORDSET & FISH_Debug_WORDSET
   60    00000009 20313031302C3         DC8     ' 1010,1100 - EHON/EHOFF '
                  1313030202D20
                  45484F4E2F454
                  84F464620    
   61                           //        DC8     '-1 True Flag '
   62                           #endif
   63                           #if VTOR_PATCH & STM32F205RC
   65                           #endif
   66                           #ifdef FISH_Debug_WORDSET
   67    00000021 4465627567537         DC8     'DebugSrc '
                  26320        
   68                           #endif
   69                           #ifdef  STM32F4_XRC08_168MHZ
   70    0000002A 53544D3332463         DC8     'STM32F407VG DISCO @168Mhz '
                  4303756472044
                  4953434F20403
                  136384D687A20
   71                           #endif
   72                           #ifdef STM32F205RC_XRC10_118MHZ
   74                           #endif
   75                           #ifdef FISH_PRO_WORDCAT
   77                           #endif
   78    00000044 524D2056312E3         DC8     'RM V1.7.2 (C)2014-2018 A-TEAM FORTH : '
                  72E3220284329
                  323031342D323
                  0313820412D54
                  45414D20464F5
                  25448203A20  
   79    0000006A 4170722031392         DC8     __DATE__        // Null string
                  03230313800  
   80                           msg_FISH_TIMESTAMP:
   81    00000076 20617420              DC8     ' at '
   82    0000007A 31313A32383A3         DC8     __TIME__        // Null string
                  03100        
   83                           #ifdef EOL_NAK
   84                           msg_SIGNON_DLE:
   85    00000083 1500                  DC8     0x15, 0
   86                           #endif
   87                           msg_MY_OK:
   88    00000085 206F6B2C20676         DC8     " ok, go fish in BASE "
                  F206669736820
                  696E204241534
                  52000        
   89                           //-----------------START OF DICTIONARY = Last word in search--------------------
   90                           // Conditionally include FISH_STM32F4_Peripheral_Register_ADDRS.h include here
   91                           #ifdef FISH_STM32F4_Peripheral_Register_ADDRS
   92                           $FISH_STM32F4_Peripheral_Register_ADDRS.h
   93                           // If included link below will point to the GPIO WORDCAT
   94                           #endif
   95                           // 
   96                           //      NOOP NOOP:      ( -- )
   97                            SECTION .text : CONST (2)
   98                           NOOP_NFA:
   99    00000000 84                    DC8     0x84
  100    00000001 4E4F4F                DC8     'NOO'
  101    00000004 D0                    DC8     'P'+0x80
  102    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  103                           #ifdef FISH_STM32F4_Peripheral_Register_ADDRS
  104    00000008 ........              DC32    WC_FISH_Peripheral_REG_ADDR_GPIO
  105                           #else
  107                           #endif
  108                           NOOP:
  109    0000000C ........              DC32    .+5
  110                            SECTION .text : CODE (2)
  111                                   NEXT
  111.1                         // ARMv7-M Thumb = .+5
  111.2  00000000 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  111.3                         // ARMv6-M Thumb = .+4
  111.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  111                                   NEXT1
  111.1  00000004 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  111.2  00000008 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  111.3  0000000C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  111.4                         // ARMv6-M Thumb = .+4
  111.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  111.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  111.7                                 ENDM
  111.8                                 ENDM
  112                           
  113                           
  114                           //      EXECUTE EXEC:   ( cfa -- ) RENAMED: EXECUTE to EXEC
  115                           //      Execute a single word whose cfa is on the stack
  116                           
  117                            SECTION .text : CONST (2)
  118                           EXEC_NFA:
  119    00000000 87                    DC8     0x87
  120    00000001 455845435554          DC8     'EXECUT'
  121    00000007 C5                    DC8     'E'+0x80
  122                            ALIGNROM 2,0xFFFFFFFF
  123    00000008 ........              DC32    NOOP_NFA
  124                           EXEC:
  125    0000000C ........              DC32    .+5
  126                            SECTION .text : CODE (2)
  127                           #ifndef IO2TP
  128                           #ifdef XON_XOFF
  129    00000000 ........              BL      TXRDY_SUBR
  130    00000004 ........              BL      XOFF_SUBR
  131                           #endif
  132                           #endif
  133                           EXEC_ACTION:
  134                                   POPp2w // as in xeq token at ToS setup for exec LDM     p!, {w}
  134.1                                 // as in xeq token on ToS setup for exec
  134.2  00000008 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
  134.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
  134.4                                 ENDM
  135                                   NEXT1
  135.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  135.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  135.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  135.4                         // ARMv6-M Thumb = .+4
  135.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  135.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  135.7                                 ENDM
  136                           
  137                           #ifndef IO2TP
  138                           // TXRDY_SUBR:
  139                            SECTION .text : CODE (2)
  140                           TXRDY_SUBR:
  141    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  142    00000002 024C                  LDR     y, = USART3_SR  // Line Status Register
  143                           txRDY?:
  144    00000004 2168                  LDR     n, [y]          // Get Line Status
  145                           // THIS IS TXE TEST AND FAILS IN TEXT DOWNLOAD
  146                           //        LSRS    n, n, #7      // 80h Bit 7 TXE: Transmit data register empty
  147                           // THIS IS ___ AND WORKS IN TEXT DOWNLOAD
  148    00000006 090A                  LSRS    n, n, #8        // 100h Bit 8 ORIG
  149    00000008 FCD3                  BCC     txRDY?          // Ready
  150    0000000A 1047                  BX      w               // lr  - SUBR RETURN
  151                           
  152                           // XOFF_SUBR:
  153                           #ifdef XON_XOFF
  153.1                                  TABLE
  153.2  0000000C 00480040              Reference on line 142
  154                            SECTION .text : CODE (2)
  155                           XOFF_SUBR:
  156    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  157    00000002 0249                  LDR     n,= USART3_DR
  158    00000004 1324                  LDR     y,  = XOFF_CHAR
  159    00000006 0C70                  STRB    y, [n]
  160    00000008 1047                  BX      w               // lr  - SUBR RETURN
  161                           #endif // XON_XOFF
  162                           
  163                           // XON_SUBR:
  164                           #ifdef XON_XOFF
  164.1                                  TABLE
  164.2  0000000C 04480040              Reference on line 157
  165                            SECTION .text : CODE (2)
  166                           XON_SUBR:
  167    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  168    00000002 0249                  LDR     n,= USART3_DR
  169    00000004 1124                  LDR     y, = XON_CHAR   // preserve TOS 11 24 01 49
  170    00000006 0C70                  STRB    y, [n]
  171    00000008 1047                  BX      w       //lr              // SUBR RETURN
  172                           #endif // XON_XOFF
  173                           #endif // IO2TP
  174    0000000A 0000           LTORG
  174.1                                  TABLE
  174.2  0000000C 04480040              Reference on line 168
  175                           
  176                           //      BL BLANK:       ( -- n )
  177                           //      Push ascii space character as n to TOS.
  178                           
  179                            SECTION .text : CONST (2)
  180                           BLANK_NFA:
  181    00000000 82                    DC8     0x82
  182    00000001 42                    DC8     'B'
  183    00000002 CC                    DC8     'L'+0x80
  184    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  185    00000004 ........              DC32    EXEC_NFA
  186                           BLANK:
  187    00000008 ........20000         DC32    DOCON, 0x20
                  000          
  188                           
  189                           
  190                           //========================= START SYSTEM VARIABLES ===========================//
  191                           // _SV IS cfa label of WORD's that return their address.
  192                           // MODIFIED ALL to be label based vs. offset based.
  193                           
  194                           
  195                           //      UP UP_SV:       ( -- addr of UP ) Value stored here is ALIGNED
  196                           //      A system variable, the RAM VAR pointer, which contains
  197                           //      the address of the next free memory above in the USERRAMSPACE.
  198                           //      The value may be read by .UV and altered by VAR.
  199                           
  200                            SECTION .text : CONST (2)
  201                           UP_NFA:
  202    00000000 82                    DC8     0x82
  203    00000001 55                    DC8     'U'
  204    00000002 D0                    DC8     'P'+0x80
  205    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  206    00000004 ........              DC32    BLANK_NFA
  207                           UP_SV:
  208    00000008 .............         DC32    DOCON, UP
                  ...          
  209                           
  210                           
  211                           //      FENCE FENCE_SV: ( -- addr of FENCE )
  212                           //      A system variable containing an address below which FORGET ting is
  213                           //      trapped. To forget below this point the system must alter the contents
  214                           //      of FENCE.
  215                           
  216                            SECTION .text : CONST (2)
  217                           FENCE_NFA:
  218    00000000 85                    DC8     0x85
  219    00000001 46454E43              DC8     'FENC'
  220    00000005 C5                    DC8     'E'+0x80
  221    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  222    00000008 ........              DC32    UP_NFA
  223                           FENCE_SV:
  224    0000000C .............         DC32    DOCON, FENCE
                  ...          
  225                           
  226                           
  227                           //      DP DP_SV:       ( -- addr of DP ) Value stored here is ALIGNED
  228                           //      A system variable, the dictionary pointer, which contains the address
  229                           //      of the next free memory above the dictionary. The value may be read
  230                           //      by HERE and altered by COMMA (ALIGNED) , ALLOT and CALLOT (UNALIGNED) .
  231                           
  232                            SECTION .text : CONST (2)
  233                           DP_NFA:
  234    00000000 82                    DC8     0x82
  235    00000001 44                    DC8     'D'
  236    00000002 D0                    DC8     'P'+0x80
  237    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  238    00000004 ........              DC32    FENCE_NFA
  239                           DP_SV:
  240    00000008 .............         DC32    DOCON, DP
                  ...          
  241                           
  242                           
  243                           //      BASE BASE_SV:   ( -- addr of NBASE )
  244                           //      A system variable containing the current number base used for input
  245                           //      and output conversion.
  246                           
  247                            SECTION .text : CONST (2)
  248                           BASE_NFA:
  249    00000000 84                    DC8     0x84
  250    00000001 424153                DC8     'BAS'
  251    00000004 C5                    DC8     'E'+0x80
  252    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  253    00000008 ........              DC32    DP_NFA
  254                           BASE_SV:
  255    0000000C .............         DC32    DOCON, NBASE
                  ...          
  256                           
  257                           
  258                           //      CURRENT CURRENT_SV:     ( -- addr of CURRENT )
  259                           //      CURRENT searched everytime. CONTEXT is not used
  260                           //      Used by Create, Definitions, etc and by Latest
  261                           //      to leave the nfa of the topmost word in the CURRENT
  262                           //      vocabulary.  See LATEST NOTE:(FIG) CURR @ @ this CURR @
  263                           
  264                            SECTION .text : CONST (2)
  265                           CURRENT_NFA:
  266    00000000 87                    DC8     0x87
  267    00000001 43555252454E          DC8     'CURREN'
  268    00000007 D4                    DC8     'T'+0x80
  269                            ALIGNROM 2,0xFFFFFFFF
  270    00000008 ........              DC32    BASE_NFA
  271                           CURRENT_SV:
  272    0000000C .............         DC32    DOCON, CURRENT  // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
                  ...          
  273                           
  274                           
  275                           //      STATE STATE_SV: ( -- addr of CSTATE )
  276                           //      A system variable containing the compilation state. A non-zero value
  277                           //      indicates compilation. The value itself may be implementation
  278                           //      dependent. 0xC0 must be used for INTERPRET to execute IMMEDIATE words.
  279                           
  280                            SECTION .text : CONST (2)
  281                           STATE_NFA:
  282    00000000 85                    DC8     0x85
  283    00000001 53544154              DC8     'STAT'
  284    00000005 C5                    DC8     'E'+0x80
  285    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  286    00000008 ........              DC32    CURRENT_NFA
  287                           STATE_SV:
  288    0000000C .............         DC32    DOCON, CSTATE       //Compile STATE
                  ...          
  289                           
  290                           
  291                           //      OUT OUT_SV:     ( -- addr of OUT )
  292                           //      A system variable that contains a value incremented by EMIT. The system
  293                           //      may alter and examine OUT to control display formating.
  294                           
  295                            SECTION .text : CONST (2)
  296                           OUT_NFA:
  297    00000000 83                    DC8     0x83
  298    00000001 4F55                  DC8     'OU'
  299    00000003 D4                    DC8     'T'+0x80
  300                            ALIGNROM 2,0xFFFFFFFF
  301    00000004 ........              DC32    STATE_NFA
  302                           OUT_SV:
  303    00000008 .............         DC32    DOCON, OUT
                  ...          
  304                           
  305                           
  306                           //      IN IN_SV:       ( -- addr of IN )
  307                           //      A system variable containing the byte offset within (TIB),
  308                           //      from which the tokens are parsed by WORD and moved to HERE,
  309                           //      as a counted null terminated string (created by EXPECT).
  310                           //      Initialized to 1 to skip count byte produced by EXPECT.
  311                           
  312                            SECTION .text : CONST (2)
  313                           IN_NFA:
  314    00000000 82                    DC8     0x82
  315    00000001 49                    DC8     'I'
  316    00000002 CE                    DC8     'N'+0x80
  317    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  318    00000004 ........              DC32    OUT_NFA
  319                           IN_SV:
  320    00000008 .............          DC32   DOCON, IN
                  ...          
  321                           
  322                           
  323                           //      PAD PAD_SV:     ( -- addr of PAD )
  324                           //      Leave the address of the text output buffer PAD on the stack.
  325                           //      Typically at least 82 bytes long.
  326                           
  327                            SECTION .text : CONST (2)
  328                           PAD_NFA:
  329    00000000 83                    DC8     0x83
  330    00000001 5041                  DC8     'PA'
  331    00000003 C4                    DC8     'D'+0x80
  332                            ALIGNROM 2,0xFFFFFFFF
  333    00000004 ........              DC32    IN_NFA
  334                           PAD_SV:
  335    00000008 .............         DC32    DOCON, PAD
                  ...          
  336                           
  337                           
  338                           //      TIB TIB_SV:     ( -- addr of INITTIB )
  339                           //      Leave the address of the text input buffer TIB on the stack.
  340                           //      Typically at least 82 bytes long.
  341                           
  342                            SECTION .text : CONST (2)
  343                           TIB_NFA:
  344    00000000 83                    DC8     0x83
  345    00000001 5449                  DC8     'TI'
  346    00000003 C2                    DC8     'B'+0x80
  347                            ALIGNROM 2,0xFFFFFFFF
  348    00000004 ........              DC32    PAD_NFA
  349                           TIB_SV:
  350    00000008 .............         DC32    DOCON, TIB
                  ...          
  351                           
  352                           
  353                           //======================== END SYSTEM VARIABLES ==============================//
  354                           
  355                           
  356                           //      HERE HERE:      ( -- addr ) Value stored here is ALIGNED
  357                           //      Leave the address of the next available dictionary location.
  358                           
  359                            SECTION .text : CONST (2)
  360                           HERE_NFA:
  361    00000000 84                    DC8     0x84
  362    00000001 484552                DC8     'HER'
  363    00000004 C5                    DC8     'E'+0x80
  364    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  365    00000008 ........              DC32    TIB_NFA
  366                           HERE:
  367    0000000C ........              DC32    DOCOL
  368    00000010 ........              DC32    DP_SV
  369    00000014 ........              DC32    AT
  370    00000018 ........              DC32    SEMIS
  371                           
  372                           
  373                           //      ALLOT ALLOT:    ( sn -- ) Warning: UNALIGNED:
  374                           //      IF DICTIONAIRY FULL PRINT error MESSAGE AND abort.
  375                           //      Add the signed number to the dictionary pointer DP. May be used to
  376                           //      reserve dictionary space or re-origin memory.
  377                           //      CAUTION!
  378                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  379                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  380                           
  381                            SECTION .text : CONST (2)
  382                           ALLOT_NFA:
  383    00000000 85                    DC8     0x85
  384    00000001 414C4C4F              DC8     'ALLO'
  385    00000005 D4                    DC8     'T'+0x80
  386    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  387    00000008 ........              DC32    HERE_NFA
  388                           ALLOT:
  389    0000000C ........              DC32    DOCOL
  390    00000010 ........              DC32    DICTSPACE       // \ -- n_r0
  391    00000014 .............         DC32    OVER, SUBB
                  ...          
  392    0000001C ........              DC32    ZLESS
  393    00000020 ........              DC32    ZBRAN
  394    00000024 08000000              DC32    ALLOTOK-.
  395                           
  396    00000028 ........              DC32    DICTFULL_ABORT
  397                           
  398                           ALLOTOK:
  399    0000002C ........              DC32    DP_SV
  400    00000030 ........              DC32    PSTORE
  401    00000034 ........              DC32    SEMIS
  402                           
  403                           
  404                           //      ALIGNED ALIGNED:        ( addr -- a-addr ) DPANS94
  405                           
  406                            SECTION .text : CONST (2)
  407                           ALIGNED_NFA:
  408    00000000 87                    DC8     0x87
  409    00000001 414C49474E45          DC8     'ALIGNE'
  410    00000007 C4                    DC8     'D'+0x80
  411                            ALIGNROM 2,0xFFFFFFFF
  412    00000008 ........              DC32    ALLOT_NFA
  413                           ALIGNED:
  414    0000000C ........              DC32    .+5
  415                            SECTION .text : CODE (2)
  416                                   POP2t
  416.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  416.2                         //#ifndef TOSCT
  416.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  416.4                         //#endif
  416.5                         //      ADDS    p, p, #4
  416.6                                 ENDM
  417    00000004 C01C                  ADDS    t, t, #3
  418    00000006 0549                  LDR     n, =-4
  419    00000008 0840                  ANDS    t, t, n
  420                                   TPUSH
  420                                   PUSHt   // push t to p, pre decrement p
  420.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  420.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  420.3                         //      STR     t, [p]
  420.4                                 ENDM
  420                                   NEXT
  420.1                         // ARMv7-M Thumb = .+5
  420.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  420.3                         // ARMv6-M Thumb = .+4
  420.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  420                                   NEXT1
  420.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  420.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  420.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  420.4                         // ARMv6-M Thumb = .+4
  420.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  420.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  420.7                                 ENDM
  420.8                                 ENDM
  420.9                                 ENDM
  421                            LTORG
  421.1                                  TABLE
  421.2  0000001C FCFFFFFF              Reference on line 418
  422                           
  423                           
  424                           //      ALIGN32_DP_FF_PAD ALIGN:        ( -- ) DPANS94
  425                           //      Align DP_SV primitive. Pads current DP with 0xFF until aligned.
  426                           //      USED IN , (COMMA:) .  Reflected by HERE .
  427                           //      CAUTION! USE AFTER ALLOT or C, (CCOMMA:) .
  428                           //      See , (COMMA:) which is ALIGNED.
  429                           
  430                            SECTION .text : CONST (2)
  431                           ALIGN_NFA:
  432    00000000 85                    DC8     0x85
  433    00000001 414C4947              DC8     'ALIG'
  434    00000005 CE                    DC8     'N'+0x80
  435    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  436    00000008 ........              DC32    ALIGNED_NFA
  437                           ALIGN:
  438                           ALIGN32_DP_FF_PAD:
  439    0000000C ........              DC32    DOCOL
  440    00000010 ........              DC32    HERE
  441                                   // COULD ADD CODE TO SEE IF ALIGNED ALREADY
  442    00000014 .............         DC32    THREE, PLUS             // 3PLUS
                  ...          
  443    0000001C .............         DC32    DUP, TOR
                  ...          
  444    00000024 ........              DC32    HERE
  445    00000028 ........              DC32    XDO
  446                           ALIGN_PAD_DO:
  447    0000002C ........FF000         DC32    LIT, 0xFF, I, CSTORE
                  000..........
                  ......       
  448    0000003C ........              DC32    XLOOP
  449    00000040 ECFFFFFF              DC32    ALIGN_PAD_DO-.
  450                           
  451    00000044 ........              DC32    RFROM
  452    00000048 ........FCFFF         DC32    LIT, 0xFFFFFFFC // -4
                  FFF          
  453    00000050 ........              DC32    ANDD
  454    00000054 .............         DC32    DP_SV, STORE
                  ...          
  455    0000005C ........              DC32    SEMIS
  456                           
  457                           
  458                           //      , COMMA:        ( n_r0 -- ) ALIGNED
  459                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  460                           //      Write n_r0 into next ALIGNED dictionary memory cell, DP reflected by HERE
  461                           
  462                            SECTION .text : CONST (2)
  463                           COMMA_NFA:
  464    00000000 81                    DC8     0x81
  465    00000001 AC                    DC8     ','+0x80
  466    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  467    00000004 ........              DC32    ALIGN_NFA
  468                           COMMA:
  469    00000008 ........              DC32    DOCOL
  470    0000000C ........              DC32    DICTSPACE       // \ -- n_r0
  471    00000010 ........              DC32    ZLESS
  472    00000014 ........              DC32    ZBRAN
  473    00000018 08000000              DC32    COMMA_OK-.
  474                           
  475    0000001C ........              DC32    DICTFULL_ABORT
  476                           
  477                           COMMA_OK:
  478    00000020 ........              DC32    COMMA_PRIM
  479    00000024 ........              DC32    SEMIS
  480                           
  481                           
  482                           //      C, CCOMMA:      ( n_r0 -- ) Warning: UNALIGNED:
  483                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  484                           //      Store LS 8 bits of n_r0 into the next available dictionary byte, advancing
  485                           //      the dictionary pointer.
  486                           //      CAUTION!
  487                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  488                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  489                           //      See , (COMMA:) which is ALIGNED.
  490                           
  491                            SECTION .text : CONST (2)
  492                           CCOMMA_NFA:
  493    00000000 82                    DC8     0x82
  494    00000001 43                    DC8     'C'
  495    00000002 AC                    DC8     ','+0x80
  496    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  497    00000004 ........              DC32    COMMA_NFA
  498                           CCOMMA:
  499    00000008 ........              DC32    DOCOL
  500    0000000C ........              DC32    DICTSPACE       // \ -- n_r0
  501    00000010 ........              DC32    ZLESS
  502    00000014 ........              DC32    ZBRAN
  503    00000018 08000000              DC32    CCOMMA_OK-.
  504                           
  505    0000001C ........              DC32    DICTFULL_ABORT
  506                           
  507                           CCOMMA_OK:
  508    00000020 ........              DC32    HERE
  509    00000024 ........              DC32    CSTORE
  510    00000028 ........              DC32    ONE
  511    0000002C ........              DC32    ALLOT_PRIM
  512    00000030 ........              DC32    SEMIS
  513                           
  514                           
  515                           //      VARALLOT VARALLOT:      ( n_r0 -- addr ) Value stored here is ALIGNED
  516                           //      IF USERVAR SPACE FULL PRINT Error MESSAGE AND Abort.
  517                           //      Add n_r0 * 32 bits to the RAMVARSPACE pointer UP.
  518                           //      Used to allocate space in Ram for VAR's and other system data structures
  519                           
  520                            SECTION .text : CONST (2)
  521                           VARALLOT_NFA:
  522    00000000 88                    DC8     0x88
  523    00000001 564152414C4C4         DC8     'VARALLO'
                  F            
  524    00000008 D4                    DC8     'T'+0x80
  525    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  526    0000000C ........              DC32    CCOMMA_NFA
  527                           VARALLOT:
  528    00000010 ........              DC32    DOCOL
  529    00000014 ........              DC32    VARSPACE                // \ -- n_r0
  530    00000018 .............         DC32    FOUR, SLASH, OVER, SUBB
                  .............
                  ......       
  531    00000028 ........              DC32    ZLESS
  532    0000002C ........              DC32    ZBRAN
  533    00000030 18000000              DC32    VALLOT_OK-.
  534                           
  535    00000034 .............         DC32    LIT, msg_uvfull
                  ...          
  536    0000003C .............         DC32    NULLSTRLEN, TYPE
                  ...          
  537                           #ifdef IO2TP
  541                           #endif
  542    00000044 ........              DC32    ABORT
  543                           
  544                           VALLOT_OK:
  545    00000048 .............         DC32    UP_SV, AT       // Address of this allotment
                  ...          
  546    00000050 ........              DC32    SWAP            // n_r0
  547    00000054 .............         DC32    FOUR, STAR      // n_r0 = 4 bytes
                  ...          
  548    0000005C ........              DC32    UP_SV
  549    00000060 ........              DC32    PSTORE          // Address of next var available
  550    00000064 ........              DC32    SEMIS
  551                           
  552                           
  553                           //      LATEST LATEST: ( -- nfa )
  554                           //      Initially ADDR OF LAST WORD IN THE DICTIONARY
  555                           //      Leave the nfa of the topmost word in the dictionary.
  556                           
  557                            SECTION .text : CONST (2)
  558                           LATEST_NFA:
  559    00000000 86                    DC8     0x86
  560    00000001 4C41544553            DC8     'LATES'
  561    00000006 D4                    DC8     'T'+0x80
  562    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  563    00000008 ........              DC32    VARALLOT_NFA
  564                           LATEST:
  565    0000000C ........              DC32    DOCOL
  566    00000010 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
  567    00000014 ........              DC32    AT
  568    00000018 ........              DC32    SEMIS
  569                           
  570                           
  571                           //      LFA LFA:        ( pfa -- lfa )
  572                           //      Convert the parameter field address of a dictionary definition to
  573                           //      its link field address.
  574                           
  575                            SECTION .text : CONST (2)
  576                           LFA_NFA:
  577    00000000 83                    DC8     0x83
  578    00000001 4C46                  DC8     'LF'
  579    00000003 C1                    DC8     'A'+0x80
  580                            ALIGNROM 2,0xFFFFFFFF
  581    00000004 ........              DC32    LATEST_NFA
  582                           LFA:
  583    00000008 ........              DC32    .+5
  584                            SECTION .text : CODE (2)
  585                                   POP2t
  585.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  585.2                         //#ifndef TOSCT
  585.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  585.4                         //#endif
  585.5                         //      ADDS    p, p, #4
  585.6                                 ENDM
  586    00000004 0838                  SUBS     t, t, #8
  587                                   TPUSH
  587                                   PUSHt   // push t to p, pre decrement p
  587.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  587.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  587.3                         //      STR     t, [p]
  587.4                                 ENDM
  587                                   NEXT
  587.1                         // ARMv7-M Thumb = .+5
  587.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  587.3                         // ARMv6-M Thumb = .+4
  587.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  587                                   NEXT1
  587.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  587.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  587.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  587.4                         // ARMv6-M Thumb = .+4
  587.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  587.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  587.7                                 ENDM
  587.8                                 ENDM
  587.9                                 ENDM
  588                           
  589                           
  590                           //      CFA CFA:        ( pfa -- cfa )
  591                           //      Convert the parameter field address of a dictionary definition to
  592                           //      its code field address. <if thumb2 execution addr smudged>
  593                           
  594                            SECTION .text : CONST (2)
  595                           CFA_NFA:
  596    00000000 83                    DC8     0x83
  597    00000001 4346                  DC8     'CF'
  598    00000003 C1                    DC8     'A'+0x80
  599                            ALIGNROM 2,0xFFFFFFFF
  600    00000004 ........              DC32    LFA_NFA
  601                           CFA:
  602    00000008 ........              DC32    .+5
  603                            SECTION .text : CODE (2)
  604                                   POP2t
  604.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  604.2                         //#ifndef TOSCT
  604.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  604.4                         //#endif
  604.5                         //      ADDS    p, p, #4
  604.6                                 ENDM
  605    00000004 001F                  SUBS     t, t, #4
  606                                   TPUSH
  606                                   PUSHt   // push t to p, pre decrement p
  606.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  606.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  606.3                         //      STR     t, [p]
  606.4                                 ENDM
  606                                   NEXT
  606.1                         // ARMv7-M Thumb = .+5
  606.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  606.3                         // ARMv6-M Thumb = .+4
  606.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  606                                   NEXT1
  606.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  606.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  606.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  606.4                         // ARMv6-M Thumb = .+4
  606.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  606.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  606.7                                 ENDM
  606.8                                 ENDM
  606.9                                 ENDM
  607                           
  608                           
  609                           //      NFA NFA:        ( pfa -- nfa )
  610                           //      Convert the parameter field address of a definition to its name
  611                           //      field. Modified for nfa alighnment padding
  612                           
  613                            SECTION .text : CONST (2)
  614                           NFA_NFA:
  615    00000000 83                    DC8     0x83
  616    00000001 4E46                  DC8     'NF'
  617    00000003 C1                    DC8     'A'+0x80
  618                            ALIGNROM 2,0xFFFFFFFF
  619    00000004 ........              DC32    CFA_NFA
  620                           NFA:
  621    00000008 ........              DC32    DOCOL
  622    0000000C .............         DC32    EIGHT, SUBB     // Addr OF lfa, DUPED TO TRAVERSE Padding
                  ...          
  623                           
  624                           NFA_ALIGN_BEGIN:
  625    00000014 .............         DC32    ONE, SUBB       // ADDR 1 BEFORE lfa, eliminate padding
                  ...          
  626    0000001C .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  627    00000024 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  628    00000030 ........              DC32    ZBRAN           // UNTIL
  629    00000034 E0FFFFFF              DC32    NFA_ALIGN_BEGIN-.
  630                                       
  631    00000038 ........FFFFF         DC32    LIT,-1          // DIRECTION FOR TRAVERSE = Toward nfa
                  FFF          
  632    00000040 ........              DC32    TRAVERSE                // \ -- addr2
  633    00000044 ........              DC32    SEMIS
  634                           
  635                           
  636                           //      PFA PFA:        ( nfa -- pfa )
  637                           //      Convert the name field address of a compiled definition to its
  638                           //      parameter field address.
  639                           
  640                            SECTION .text : CONST (2)
  641                           PFA_NFA:
  642    00000000 83                    DC8     0x83
  643    00000001 5046                  DC8     'PF'
  644    00000003 C1                    DC8     'A'+0x80
  645                            ALIGNROM 2,0xFFFFFFFF
  646    00000004 ........              DC32    NFA_NFA
  647                           PFA:
  648    00000008 ........              DC32    DOCOL           // \ NFA --
  649    0000000C ........              DC32    ONE             // DIRECTION FOR TRAVERSE = Toward CFA
  650    00000010 ........              DC32    TRAVERSE        // \ NFA 1 -- addr2
  651                           
  652                           PFA_ALIGN_BEGIN:
  653    00000014 ........              DC32    ONEP            // ADDR 1 BEFORE lfa, eliminate padding
  654    00000018 .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  655    00000020 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  656    0000002C ........              DC32    ZBRAN           // UNTIL
  657    00000030 E4FFFFFF              DC32    PFA_ALIGN_BEGIN-.
  658                           
  659    00000034 ........              DC32    EIGHT
  660    00000038 ........              DC32    PLUS
  661    0000003C ........              DC32    SEMIS
  662                           
  663                           
  664                           //      ?ALIGNED QALIGNED: ( value -- )
  665                           //      If value not aligned by 4 issue message and ABORT.
  666                           
  667                            SECTION .text : CONST (2)
  668                           QALIGNED_NFA:
  669    00000000 88                    DC8     0x88
  670    00000001 3F414C49474E4         DC8     '?ALIGNE'
                  5            
  671    00000008 C4                    DC8     'D'+0x80
  672    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  673    0000000C ........              DC32    PFA_NFA
  674                           QALIGNED:
  675    00000010 ........              DC32    DOCOL
  676    00000014 ........03000         DC32    LIT, 3, ANDD
                  000........  
  677    00000020 ........              DC32    ZBRAN           //IF no err leave
  678    00000024 3C000000              DC32     QALIGN_OK-.
  679                           
  680    00000028 ........              DC32    PDOTQ
  681    0000002C 2E                    DC8     46
  682    0000002D 56414C5545204         DC8     'VALUE MUST BE EVEN NOT ODD AND MULTIPLE OF 4! '
                  D555354204245
                  204556454E204
                  E4F54204F4444
                  20414E44204D5
                  54C5449504C45
                  204F462034212
                  0            
  683    0000005B FF             ALIGNROM 2,0xFFFFFFFF
  684    0000005C ........              DC32    ABORT
  685                           
  686                           QALIGN_OK:
  687    00000060 ........              DC32    SEMIS
  688                           
  689                           
  690                           //      ?ERROR QERROR: ( f nullstr -- )
  691                           //      If f NON ZERO type error message (nullstr) and ABORT.
  692                           
  693                            SECTION .text : CONST (2)
  694                           QERROR_NFA:
  695    00000000 86                    DC8     0x86
  696    00000001 3F4552524F            DC8     '?ERRO'
  697    00000006 D2                    DC8     'R'+0x80
  698    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  699    00000008 ........              DC32    QALIGNED_NFA
  700                           QERROR:
  701    0000000C ........              DC32    DOCOL
  702    00000010 ........              DC32    SWAP
  703    00000014 ........              DC32    ZBRAN   //IF no err leave
  704    00000018 10000000              DC32     QERROR_FINISH-.
  705                           
  706    0000001C ........              DC32    ERROR   // nullstr-addr ---  ABORT's
  707    00000020 ........              DC32    BRAN    // ELSE
  708    00000024 08000000              DC32     QERROR_DONE-.
  709                           
  710                           QERROR_FINISH:
  711    00000028 ........              DC32    DROP    //endif
  712                           
  713                           QERROR_DONE:
  714    0000002C ........              DC32    SEMIS
  715                           
  716                           
  717                           //      DIGIT DIGIT:    ( c base -- digit 1 ) (ok)
  718                           //                      ( c base -- 0 (bad)
  719                           //      Converts the ascii character c using base to its binary
  720                           //      equivalent digit, accompanied by a true flag. If the conversion is
  721                           //      invalid, leaves only a false flag.
  722                           
  723                           //      If digit gets 0, space, dot, comma or any non number it returns 0 
  724                           
  725                            SECTION .text : CONST (2)
  726                           DIGIT_NFA:
  727    00000000 85                    DC8     0x85
  728    00000001 44494749              DC8     'DIGI'
  729    00000005 D4                    DC8     'T'+0x80
  730    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  731    00000008 ........              DC32    QERROR_NFA
  732                           DIGIT:
  733    0000000C ........              DC32    .+5
  734                            SECTION .text : CODE (2)
  735                                   POP2w                   // Number base
  735.1  00000000 57F8042B              LDR     w, [p],#4
  735.2                         //      LDR     w, [p]
  735.3                         //      ADDS    p, p, #4
  735.4                                 ENDM
  736                                   POP2t                   // ASCII DIGIT
  736.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
  736.2                         //#ifndef TOSCT
  736.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  736.4                         //#endif
  736.5                         //      ADDS    p, p, #4
  736.6                                 ENDM
  737    00000008 3038                  SUBS   t, t, #'0'
  738    0000000A 13D4                  BMI   DIGI2             // Number error
  739                           
  740    0000000C 0928                  CMP   t, #9
  741    0000000E 02DD                  BLE   DIGI1             // Number = 0 THRU 9
  742                           
  743                                   // Combine?
  744    00000010 C01F                  SUBS   t, t, #7
  745    00000012 0A28                  CMP   t, #10            // Number 'A' THRU 'Z'?
  746    00000014 0EDB                  BLT   DIGI2             // NO
  747                           
  748                           DIGI1:
  749    00000016 9042                  CMP     t, w            // COMPARE Number TO base
  750    00000018 0CDA                  BGE     DIGI2
  751                           
  752    0000001A 0246                  MOV     w, t            // NEW BINARY Number
  753    0000001C 0120                  MOVS    t, #1           // TRUE FLAG
  754                                   DPUSH
  754                                   PUSHw   // push w to p, post decrement p
  754.1  0000001E 47F8042D              STR     w, [p, #-4]!
  754.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  754.3                         //      STR     w, [p]
  754.4                                 ENDM
  754                                   TPUSH
  754                                   PUSHt   // push t to p, pre decrement p
  754.1  00000022 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  754.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  754.3                         //      STR     t, [p]
  754.4                                 ENDM
  754                                   NEXT
  754.1                         // ARMv7-M Thumb = .+5
  754.2  00000026 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  754.3                         // ARMv6-M Thumb = .+4
  754.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  754                                   NEXT1
  754.1  0000002A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  754.2  0000002E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  754.3  00000032 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  754.4                         // ARMv6-M Thumb = .+4
  754.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  754.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  754.7                                 ENDM
  754.8                                 ENDM
  754.9                                 ENDM
  754.10                                ENDM
  755                           
  756                                   // Number error
  757                           DIGI2:
  758    00000034 0020                  MOVS   t, #0            // FALSE FLAG
  759                                   TPUSH
  759                                   PUSHt   // push t to p, pre decrement p
  759.1  00000036 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  759.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  759.3                         //      STR     t, [p]
  759.4                                 ENDM
  759                                   NEXT
  759.1                         // ARMv7-M Thumb = .+5
  759.2  0000003A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  759.3                         // ARMv6-M Thumb = .+4
  759.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  759                                   NEXT1
  759.1  0000003E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  759.2  00000042 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  759.3  00000046 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  759.4                         // ARMv6-M Thumb = .+4
  759.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  759.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  759.7                                 ENDM
  759.8                                 ENDM
  759.9                                 ENDM
  760                           
  761                           
  762                           //      ENCLOSE ENCL:   ( addr1 c -- addr1 n1 n2 n3 )
  763                           //      A text scanning iterative primitive used only in WORD.
  764                           //      IN is used before and after callS for the iteration
  765                           //      Typically TIB + IN = addr1
  766                           //      noop EX: \ TIB   32 -- TIB   0 4 5
  767                           //      NULL EX: \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  768                           //      NULL EX: \ WORD/ENCL -> TIB 1, 0, 20'S
  769                           //      From the text address addr1 and an ascii delimiting character c,
  770                           //      is determined the byte offset to the first non-delimiter character n1,
  771                           //      the offset to the first delimiter after the text n2,
  772                           //      and the offset to the first character not included.
  773                           //      This procedure will not process past an ASCII 'null', treating it
  774                           //      as an unconditional delimiter. NULL termination by EXPECT in QUERY.
  775                           
  776                            SECTION .text : CONST (2)
  777                           ENCL_NFA:
  778    00000000 87                    DC8     0x87
  779    00000001 454E434C4F53          DC8     'ENCLOS'
  780    00000007 C5                    DC8     'E'+0x80
  781                            ALIGNROM 2,0xFFFFFFFF
  782    00000008 ........              DC32    DIGIT_NFA
  783                           ENCL:
  784    0000000C ........              DC32    .+5
  785                            SECTION .text : CODE (2)
  786                                   POP2t                   // TERMINATOR CHAR
  786.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  786.2                         //#ifndef TOSCT
  786.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  786.4                         //#endif
  786.5                         //      ADDS    p, p, #4
  786.6                                 ENDM
  787    00000004 3968                  LDR     n, [p]          // get text address but leave on stack
  788    00000006 0022                  MOVS    w, #0
  789    00000008 521E                  SUBS    w, w, #1        // CHAR  COUNTER
  790    0000000A 491E                  SUBS    n, n, #1        // ADDR -1
  791                           
  792                           //  SCAN TO FIRST NON-TERMINATOR CHARACTER
  793                           //      and PUSH count to stack leaving last 2 params to compute
  794                           ENCL1:
  795    0000000C 491C                  ADDS    n, n, #1        // ADDR+1
  796    0000000E 521C                  ADDS    w, w, #1        // COUNT+1
  797    00000010 0B78                  LDRB    x, [n]
  798    00000012 9842                  CMP     t, x            //CMP   AL,[BX]
  799    00000014 FAD0                  BEQ     ENCL1           //JZ    ENCL1   // WAIT FOR NON-TERMINATOR
  800                                   PUSHw                   //offset to the first non-delimiter character
  800.1  00000016 47F8042D              STR     w, [p, #-4]!
  800.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  800.3                         //      STR     w, [p]
  800.4                                 ENDM
  801                                                           //EXiT is now only DPUSH
  802    0000001A 002B                  CMP     x, #0           //CMP   AH,[BX] // null CHAR?
  803    0000001C 0CD1                  BNE     ENCL2           //JNZ   ENCL2   // NO
  804                           
  805                           // FOUND null BEFORE 1ST NON-TERM CHAR
  806                           // RETURN ok args = NULL EX//
  807                           // \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  808                           //
  809    0000001E 1846                  MOV     t, x
  810    00000020 521C                  ADDS    w, w, #1        // w = offset to the delimiter after the text
  811                                   DPUSH
  811                                   PUSHw   // push w to p, post decrement p
  811.1  00000022 47F8042D              STR     w, [p, #-4]!
  811.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  811.3                         //      STR     w, [p]
  811.4                                 ENDM
  811                                   TPUSH
  811                                   PUSHt   // push t to p, pre decrement p
  811.1  00000026 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  811.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  811.3                         //      STR     t, [p]
  811.4                                 ENDM
  811                                   NEXT
  811.1                         // ARMv7-M Thumb = .+5
  811.2  0000002A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  811.3                         // ARMv6-M Thumb = .+4
  811.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  811                                   NEXT1
  811.1  0000002E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  811.2  00000032 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  811.3  00000036 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  811.4                         // ARMv6-M Thumb = .+4
  811.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  811.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  811.7                                 ENDM
  811.8                                 ENDM
  811.9                                 ENDM
  811.10                                ENDM
  812                           
  813                           //   FOUND FIRST TEXT CHAR - COUNT THE CHARS
  814                           ENCL2:
  815    00000038 491C                  ADDS    n, n, #1        // ADDR+1
  816    0000003A 521C                  ADDS    w, w, #1        //COUNT+1
  817    0000003C 0B78                  LDRB    x, [n]
  818    0000003E 9842                  CMP     t, x            //TERMINATOR CHAR?
  819    00000040 01D0                  BEQ     ENCL4           //YES
  820                           
  821    00000042 002B                  CMP     x, #0           //null CHAR?
  822    00000044 F8D1                  BNE     ENCL2           //NO, LOOP AGAIN
  823                           
  824                           ENCL3:  //   FOUND null AT END OF TEXT
  825                           ENCL4:  //   FOUND TERMINATOR CHARACTER
  826    00000046 1046                  MOV     t, w            // COUNT+1 =
  827    00000048 401C                  ADDS    t, t, #1        // offset to the first character not included
  828                                   DPUSH
  828                                   PUSHw   // push w to p, post decrement p
  828.1  0000004A 47F8042D              STR     w, [p, #-4]!
  828.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  828.3                         //      STR     w, [p]
  828.4                                 ENDM
  828                                   TPUSH
  828                                   PUSHt   // push t to p, pre decrement p
  828.1  0000004E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  828.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  828.3                         //      STR     t, [p]
  828.4                                 ENDM
  828                                   NEXT
  828.1                         // ARMv7-M Thumb = .+5
  828.2  00000052 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  828.3                         // ARMv6-M Thumb = .+4
  828.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  828                                   NEXT1
  828.1  00000056 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  828.2  0000005A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  828.3  0000005E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  828.4                         // ARMv6-M Thumb = .+4
  828.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  828.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  828.7                                 ENDM
  828.8                                 ENDM
  828.9                                 ENDM
  828.10                                ENDM
  829                           
  830                           
  831                           //      0 NULL: ( -- ) IMMEDIATE
  832                           //      Don't return to Interpret, return to Quit at end of a line of input.
  833                           //      Executed at end of TIB when QUERY lenght or CR entered.
  834                           
  835                            SECTION .text : CONST (2)
  836                           NULL_NFA:
  837    00000000 C1                    DC8     0x0C1                   // A BINARY ZER
  838    00000001 80                    DC8     0x80
  839    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  840    00000004 ........              DC32    ENCL_NFA
  841                           NULL:
  842                           //      DC32    SEMIS                   // Actual Semis code below
  843    00000008 ........              DC32    .+5
  844                            SECTION .text : CODE (2)
  845                                   POPr2i  // pop docol saved IP from Rstack
  845.1  00000000 56F8045B              LDR     i, [r],#4       ; pop DOCOL'd IP from Rstack
  845.2                         //      LDR i, [r]              //  pop r to i, post increment r
  845.3                         //      ADDS    r, r, #4
  845.4                                 ENDM
  846                                   NEXT
  846.1                         // ARMv7-M Thumb = .+5
  846.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  846.3                         // ARMv6-M Thumb = .+4
  846.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  846                                   NEXT1
  846.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  846.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  846.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  846.4                         // ARMv6-M Thumb = .+4
  846.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  846.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  846.7                                 ENDM
  846.8                                 ENDM
  847                           
  848                           
  849                           //      WORD WORD:      ( c -- )
  850                           //      Parse the text in TIB , until a delimiter c is found, tokenizing input.
  851                           //      Move the token to HERE, with a count byte and 2 nulls at the end.
  852                           //      Leading occurrences of c are ignored. IN is incremented.
  853                           //      See IN. Usually used inside a definition.
  854                           
  855                            SECTION .text : CONST (2)
  856                           WORD_NFA:
  857    00000000 84                    DC8     0x84
  858    00000001 574F52                DC8     'WOR'
  859    00000004 C4                    DC8     'D'+0x80
  860    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  861    00000008 ........              DC32    NULL_NFA
  862                           WORD:
  863    0000000C ........              DC32    DOCOL
  864                           WORD1:
  865                           //      This is required for number suffix's at least ???
  866                           // NOT WITH NEW COUNTED NULL STRING EXPECT
  867                           //      DC32    HERE, LIT, MAXWORDLEN+2, BLANKS
  868    00000010 ........              DC32    TIB_SV
  869                           WORD2:
  870    00000014 ........              DC32    IN_SV
  871    00000018 ........              DC32    AT
  872    0000001C ........              DC32    PLUS
  873    00000020 ........              DC32    SWAP    // ( TIB+IN CH-DELIM -- )
  874    00000024 ........              DC32    ENCL    // ( TIB+IN 32 -- TIB+IN   0 4 5 )
  875                           WENCL:
  876    00000028 ........              DC32    IN_SV   // encl TOS = end of word offset to be added to IN
  877    0000002C ........              DC32    PSTORE  // TIB+IN   0 4
  878    00000030 ........              DC32    OVER    // 
  879    00000034 ........              DC32    SUBB    // Char cnt going to R and HERE
  880    00000038 ........              DC32    TOR
  881    0000003C ........              DC32    R
  882    00000040 ........              DC32    HERE
  883    00000044 ........              DC32    CSTORE   // CHAR CNT OF word
  884    00000048 ........              DC32    PLUS
  885    0000004C ........              DC32    HERE
  886    00000050 ........              DC32    ONEP
  887                           //      DC32    RFROM
  888                           // MOVE word TO DICT FOR finding ENDING WITH NULLS
  889    00000054 ........              DC32    R
  890    00000058 ........              DC32    CMOVE   // ( from to count -- )
  891                           // add null to end of token - NUMBER adjusted        
  892    0000005C .............         DC32    ZERO, HERE, ONEP, RFROM, PLUS, CSTORE
                  .............
                  .............
                  .........    
  893                           #ifdef  IOBUFS_DEBUG
  895                           #endif        
  896    00000074 ........              DC32    SEMIS
  897                           
  898                           
  899                           //      NUMBER NUMBER:  ( addr -- sd )
  900                           //      If error print message and ABORT.
  901                           //      Convert a character string left at addr with a preceeding count,
  902                           //      and a terminating null, to a signed number, in the current numeric base.
  903                           //      If a decimal point is encountered in the text, its position will be
  904                           //      given in DPL, but no other effect occurs. If numeric conversion is
  905                           //      not possible, an error message will be given.
  906                           
  907                           //      Added support for , as a single number formatter.
  908                           
  909                           #define comma_test
  910                           
  911                            SECTION .text : CONST (2)
  912                           NUMBER_NFA:
  913    00000000 86                    DC8     0x86
  914    00000001 4E554D4245            DC8     'NUMBE'
  915    00000006 D2                    DC8     'R'+0x80
  916    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  917    00000008 ........              DC32    WORD_NFA
  918                           NUMBER:
  919    0000000C ........              DC32    DOCOL
  920    00000010 ........              DC32    BASE_TO_R12     // Save current BASE.
  921    00000014 ........              DC32    NUMBERSUFFIX    // (addr -- sddr) Change BASE if suffix used.
  922                           
  923                           // SETUP: stack arguments for PNUMBER.
  924    00000018 .............         DC32    ZERO, ZERO
                  ...          
  925    00000020 ........              DC32    ROT             // ( 0 0 addr -- )
  926                           
  927                           // SETUP: reeturn stack with sign flag
  928                           // NONAME CANDIDATE!
  929                           // START: Handle minus sign by saving status on Return Stack.
  930                           // and incrementing to addr after it.
  931    00000024 .............         DC32    DUP, ONEP       // ( 0 0 addr addr+1 -- )
                  ...          
  932    0000002C ........              DC32    CAT             // ( 0 0 addr 1rstchar -- )
  933    00000030 ........2D000         DC32    LIT, '-'        // ( 0 0 addr 1rstchar 0x2D --- )
                  000          
  934    00000038 ........              DC32    EQUAL           // ( 0 0 addr f -- )
  935                           #ifdef TRUE_EQU_NEG_ONE         // EQUAL returns -1 NEED 0 or 1 here!
  936    0000003C .............         DC32    ONE, ANDD       // ( 0 0 addr f -- ) MAKE FLAG ONE OR ZERO!
                  ...          
  937                           #endif
  938    00000044 .............         DC32    DUP, TOR        // ( 0 0 addr f -- ) copy of f >R
                  ...          
  939                           // END: Handle - by saving status on Return Stack.
  940                           
  941                           // SETUP: addr pointing to 1rst digit.
  942                           // If minus sign, flag from above will increment to next char.
  943    0000004C ........              DC32    PLUS            // Increment (OR NOT) addr to next char
  944                           
  945                           // So could be at 1rst OR 2nd character in string here!
  946                           
  947                           // ENTER LOOP WITH -1 DPL = single number and sign flag on return stack.
  948    00000050 ........FFFFF         DC32    LIT, -1
                  FFF          
  949                           // PNUMBER is used in loop to convert string segment until non-mumeric chracter.
  950                           // A period in the string manipulates DPL to create a double number.
  951                           // A comma in the string resets DPL to create a single number.
  952                           // A null indicates the end of the string.
  953                           NUMB1:                          // Begin
  954    00000058 .............         DC32    DPL_SV, STORE   // PNUMBER creates whole, dot or comma number segment
                  ...          
  955                           
  956                           // PNUMBER converts one or more characters until first unconvertable digit.
  957                           // ud and addr in string is maintained while in loop.
  958    00000060 ........              DC32    PNUMBER         // ( 0 0 addr -- ud=(LSW MSW) ADDR=PAST#)
  959                           // Perform check for period, comma and null.
  960                           // Any other character here invalidates this number conversion.
  961                           
  962                           // Null Test: = end of string.
  963    00000064 .............         DC32    DUP, CAT
                  ...          
  964    0000006C ........              DC32    ZERO            // End of string used to be BLANK, is now Null.
  965    00000070 ........              DC32    SUBB
  966    00000074 ........              DC32    ZBRAN           // IF emd of number string conversion is
  967    00000078 6C000000              DC32      NUMB2-.       // DONE UNLESS IT NEEDS TO BE NEGATED.
  968                           
  969                           // Period Test: = increment DPL.
  970    0000007C .............         DC32    DUP, CAT
                  ...          
  971    00000084 ........2E000         DC32    LIT, '.'        // 2Eh = period.
                  000          
  972    0000008C ........              DC32    SUBB
  973    00000090 ........              DC32    ZBRAN
  974    00000094 44000000              DC32      DPL_ZERO_INCR-.
  975                           
  976                           #ifdef  comma_test
  977                           // Comma Test: = reset DPL.
  978    00000098 .............         DC32    DUP, CAT
                  ...          
  979    000000A0 ........2C000         DC32    LIT, ','        // 2CH comma
                  000          
  980    000000A8 ........              DC32    EQUAL
  981    000000AC ........              DC32    ZBRAN
  982    000000B0 14000000              DC32      BASE_RESET_THEN_ERROR-.
  983                           
  984                           // Fall thru if comma so reset DPL to create a single number.
  985                           DPL_RESET:        
  986    000000B4 ........FFFFF         DC32    LIT, -1
                  FFF          
  987    000000BC ........              DC32    BRAN
  988    000000C0 98FFFFFF              DC32      NUMB1-.
  989                           #endif
  990                           
  991                           BASE_RESET_THEN_ERROR:
  992                           // GOING TO ERROR SO RESTORE BASE!
  993    000000C4 ........              DC32    BASE_FROM_R12   // Restore BASE
  994                           //NO_BASE_RESTORE:
  995    000000C8 ........              DC32    ONE     // provide non zero flag for error
  996    000000CC .............         DC32    LIT, msg_number_error
                  ...          
  997    000000D4 ........              DC32    QERROR // ( f nullstr-addr -- ) IF f TRUE EXECUTE ERROR!
  998                           
  999                           DPL_ZERO_INCR:      // set DPL to zero
 1000    000000D8 ........              DC32    ZERO
 1001    000000DC ........              DC32    BRAN
 1002    000000E0 78FFFFFF              DC32      NUMB1-.
 1003                           
 1004                           NUMB2:
 1005    000000E4 ........              DC32    DROP
 1006    000000E8 ........              DC32    RFROM           // FLAG OF "-" TEST
 1007                                                           // IF
 1008    000000EC ........              DC32    ZBRAN
 1009    000000F0 08000000              DC32      NUMB3-.
 1010                           
 1011    000000F4 ........              DC32    DNEGATE
 1012                           
 1013                           NUMB3:                          // endif
 1014    000000F8 ........              DC32    BASE_FROM_R12   // Restore BASE
 1015    000000FC ........              DC32    SEMIS
 1016                           
 1017                           
 1018                           //      ERROR ERROR:    ( nullstr --- )
 1019                           //      Execute error notification and restart of system.
 1020                           //      IN_SV is saved to assist in determining the location of the error.
 1021                           
 1022                            SECTION .text : CONST (2)
 1023                           ERROR_NFA:
 1024    00000000 85                    DC8     0x85
 1025    00000001 4552524F              DC8     'ERRO'
 1026    00000005 D2                    DC8     'R'+0x80
 1027    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1028                           //      DC32    DFIND_NFA
 1029    00000008 ........              DC32    NUMBER_NFA
 1030                           ERROR:
 1031    0000000C ........              DC32    DOCOL
 1032    00000010 .............         DC32    HERE, COUNT, TYPE       // Offending item
                  ...........  
 1033    0000001C .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 1034                           #ifdef IO2TP
 1038                           #endif
 1039                           #ifdef XON_XOFF
 1040    00000024 ........              DC32    XOFF    // TEMP TEST THRE
 1041                           #endif
 1042                                   
 1043                           //      DO THIS WHERE STATE IS SET BACK TO ZERO
 1044    00000028 .............         DC32    STATE_SV, AT
                  ...          
 1045    00000030 ........              DC32    ZBRAN
 1046    00000034 40000000              DC32     CREATED_OK-.
 1047                           
 1048                           //      NON-ZERO CSDP = RESTORE DP TO forget DAMAGED WORDS
 1049    00000038 .............         DC32    CSDP_SV, AT   // Create saves dp here for if word exists err
                  ...          
 1050    00000040 ........              DC32    ZBRAN
 1051    00000044 30000000              DC32     CREATED_OK-.
 1052                           
 1053                           // assume ITS A CREATE'd WORD!!!!
 1054                           ERROR_FIXUP:     // CSDP_SV contains NFA of definition that has error.
 1055    00000048 .............         DC32    CSDP_SV, AT     // SHOULD BE AT NFA!!
                  ...          
 1056    00000050 ........              DC32    PFA     // \ nfa -- pfa
 1057    00000054 .............         DC32    LFA, AT // \ pfa --- lfa
                  ...          
 1058    0000005C .............         DC32    CURRENT_SV, STORE       // Has to be NFA of last good word
                  ...          
 1059                           // RESET DP!
 1060    00000064 .............         DC32    CSDP_SV, AT
                  ...          
 1061    0000006C .............         DC32    DP_SV, STORE
                  ...          
 1062                           
 1063                           CREATED_OK:
 1064    00000074 ........              DC32    SEMIC_CREATE            // RESET CSDP FOR AUTO FORGET
 1065                           #ifdef ABORT_STOP_TILL_CO
 1066    00000078 ........              DC32    ABORT
 1067                           #else
 1069                           #endif
 1070                           //      DC32    QUIT    // FROM Error
 1071                           
 1072                           
 1073                           //      ' TICK: ( -- pfa ) IMMEDIATE
 1074                           //      Used in the form: .
 1075                           //      ' CCcc
 1076                           //      Leaves the parameter field address of dictionary word CCcc.
 1077                           //      If the word is not found after a search of CURRENT,
 1078                           //      an appropriate error message is given.
 1079                           //      As a compiler directive, executed in a colon-definition to compile
 1080                           //      the address as a literal.
 1081                           //      Pronounced "TICK".
 1082                           
 1083                            SECTION .text : CONST (2)
 1084                           TICK_NFA:
 1085    00000000 C1                    DC8     0x0C1
 1086    00000001 A7                    DC8     ''''+0x80
 1087    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1088    00000004 ........              DC32    ERROR_NFA
 1089                           TICK:
 1090    00000008 ........              DC32    DOCOL
 1091    0000000C ........              DC32    DFIND   // noop there for TIB entry
 1092    00000010 ........              DC32    ZEQU
 1093    00000014 .............         DC32    LIT, msg_word_error
                  ...          
 1094    0000001C ........              DC32    QERROR    // \ f nullstr-addr --
 1095    00000020 ........              DC32    DROP
 1096    00000024 ........              DC32    LITERAL
 1097    00000028 ........              DC32    SEMIS
 1098                           
 1099                           
 1100                           //      EXPECT EXPECT:  ( addr count -- )
 1101                           //      Transfer characters from the terminal to the buffer starting at addr+1,
 1102                           //      until a "return" or the count of characters have been received.
 1103                           //      One or two nulls are added at the end creating a null-terminated string.
 1104                           //      A count byte is placed at addr, the count being derived by $LEN
 1105                           //      Use COUNT with TYPE for strings saved this way.
 1106                           //      Strings longer that 255 will have an invalid count byte. Use $LEN:
 1107                           //      $LEN and TYPE can be used when the argument to $LEN is addr+1.
 1108                           
 1109                           //      Comments below use TIB input (QUERY in INTERPRET) as an example.
 1110                           
 1111                            SECTION .text : CONST (2)
 1112                           EXPECT_NFA:
 1113    00000000 86                    DC8     0x86
 1114    00000001 4558504543            DC8     'EXPEC'
 1115    00000006 D4                    DC8     'T'+0x80
 1116    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1117    00000008 ........              DC32    TICK_NFA
 1118                           EXPECT:                 // ( NOS TOS -- NOS TOS )
 1119    0000000C ........              DC32    DOCOL   // ( TIB LEN -- )
 1120    00000010 ........              DC32    ONEP    // ( TIB LEN+1 -- ) (Index and Limit)+1 for count byte
 1121    00000014 ........              DC32    OVER    // ( TIB LEN+1 TIB -- )
 1122    00000018 ........              DC32    PLUS    // ( TIB TIB+LEN+1 -- )
 1123    0000001C ........              DC32    OVER    // ( TIB TIB+LEN+1 TIB -- )
 1124    00000020 ........              DC32    ONEP    // ( TIB TIB+LEN+1 TIB+1 -- ) SKIP COUNT BYTE
 1125                           #ifdef XON_XOFF
 1126    00000024 ........              DC32    XON
 1127                           #endif
 1128                           // ( ORGIGINAL-TIB TIB+LEN+1 TIB+1 -- ORGIGINAL-TIB ) 
 1129                           //                (Index & Limit)+1 for count byte
 1130    00000028 ........              DC32    XDO     // DO   Index = addr, Limit = addr+cnt
 1131                           EXPE1:
 1132    0000002C ........              DC32    KEY     // CAN BREAKPOINT OR CHANGE TO BE 0x0D ONLY
 1133                           #ifdef XON_XOFF
 1134    00000030 ........              DC32    IF_EOL_SEND_XOFF        // IF CR QUICK XOFF!
 1135                           #endif
 1136                           // goto main branch (EL1:)if not tab
 1137    00000034 .............         DC32    DUP, LIT, 9, EQUAL      // ? TAB
                  ...09000000..
                  ......       
 1138    00000044 ........              DC32    ZBRAN                   // Not tab
 1139    00000048 0C000000              DC32     EL1-.                  // Goto MAIN LOOP
 1140                                   
 1141                           // REPLACE TAB WITH SPACE               // -- ch f
 1142    0000004C .............         DC32    DROP, BLANK             // Convert tab to space
                  ...          
 1143                           EL1:
 1144                           // MAIN LOOP ENTERED WITH CHAR ON TOS
 1145    00000054 ........              DC32    DUP             // ( TIB key key -- )
 1146                           // FALL THRU IF BACKSPACE OR DELETE KEY
 1147    00000058 ........              DC32    BACKSPACE_CHAR
 1148    0000005C ........              DC32    EQUAL
 1149    00000060 ........              DC32    OVER
 1150    00000064 ........7F000         DC32    LIT, 07Fh       // DEL KEY
                  000          
 1151    0000006C ........              DC32    EQUAL
 1152    00000070 ........              DC32    OR
 1153                           // BRANCH IF NOT BACKSPACE OR DELETE KEY
 1154    00000074 ........              DC32    ZBRAN           // If not backspace
 1155    00000078 50000000              DC32     EXPE2-.        // go here
 1156                           
 1157                           // CASE OF BACKSPACE/DELETE KEY
 1158    0000007C ........              DC32    DROP            // ( TOS> 8 TIB -- TIB ) Drop Backspace on stack
 1159    00000080 ........              DC32    DUP             // ( TOS> TIB -- TOS> TIB TIB )  Current TIB addr
 1160    00000084 ........              DC32    I               // ( TOS> TIB TIB -- I=TIB+? TIB TIB )
 1161                           // COMPENSATE FOR COUNT BYTE - BUMP ADDR+1 (NEXT CHAR LOCATION) BACK TO CURRENT
 1162    00000088 ........              DC32    ONEM
 1163    0000008C ........              DC32    EQUAL           // ( TOS> I=TIB+? TIB TIB -- f TIB )
 1164    00000090 ........              DC32    DUP             // ( TOS> f TIB -- f f TIB )
 1165                           // I AND RFROM STARTS AT TIB+1 
 1166                           // REMOVE INDEX FROM LOOP TO REPLACE IT WITH BACKSPACE CORRECTED ADDRESS
 1167    00000094 ........              DC32    RFROM           // ( TOS> f f TIB -- TIB+1 f f TIB )
 1168                           // ADDING 2 BECAUSE TIB+1 IS FROM I AND FLAG MAKES IT = TO 1
 1169                           // WHEN AT THE BEGIINING (ADDR+1) OF THE ADDR BUFFER
 1170    00000098 ........              DC32    TWO
 1171    0000009C ........              DC32    SUBB
 1172                           // ADD FLAG 
 1173    000000A0 ........              DC32    PLUS
 1174    000000A4 ........              DC32    TOR
 1175    000000A8 ........              DC32    ZBRAN           // If not at beginning of line
 1176    000000AC 10000000              DC32     EXPE6-.        // Goto bsout
 1177                           
 1178    000000B0 ........              DC32    BELL            // At beginning of TIB issue bell
 1179    000000B4 ........              DC32    BRAN            // Goto end of loop
 1180    000000B8 60000000              DC32     EXPE33-.
 1181                           
 1182                           EXPE6:
 1183    000000BC ........              DC32    BSOUT           // endif
 1184                           EXPE7:  // LABEL NOT USED BECAUSE BELL AND BSOUT Emit THEMSELVES
 1185    000000C0 ........              DC32    BRAN            // Goto end of loop
 1186    000000C4 54000000              DC32     EXPE33-.
 1187                           
 1188                           EXPE2:
 1189    000000C8 ........              DC32    DUP
 1190    000000CC ........0D000         DC32    LIT, 0x0D       // cr
                  000          
 1191    000000D4 ........              DC32    EQUAL
 1192    000000D8 ........              DC32    ZBRAN           // If not cr
 1193    000000DC 1C000000              DC32     EXPE4-.        // Goto save this char and loop again
 1194                                   
 1195    000000E0 ........              DC32    LEAVE           // ( TOS> ODh TIB --  )
 1196                           #ifdef  IOBUFS_DEBUG        
 1198                           #endif
 1199                                   // CR DROPPED HERE I USED AT END FOR CASE OF EXPECT COUNT REACHED
 1200    000000E4 ........              DC32    DROP            // ( TOS> TIB -- )
 1201    000000E8 ........              DC32    BLANK           // ( TOS> 20h TIB -- ) space IS FOR EMIT!
 1202    000000EC ........              DC32    ZERO            // ( TOS> 0 20h TIB -- ) null
 1203    000000F0 ........              DC32    BRAN            // Goto store these at end of loop
 1204    000000F4 08000000              DC32     EXPE5-.
 1205                           
 1206                           EXPE4:
 1207    000000F8 ........              DC32    DUP             // Regular char 
 1208                           
 1209                           EXPE5:
 1210    000000FC ........              DC32    I               // I=TIB Store char
 1211    00000100 ........              DC32    CSTORE          // or 1rst null in CASE OF CR
 1212    00000104 ........              DC32    ZERO            // 1rst or second null if cr
 1213                                   // CASE OF CR ( TOS> 0 20h TIB -- )
 1214    00000108 ........              DC32    I
 1215    0000010C ........              DC32    ONEP
 1216    00000110 ........              DC32    CSTORE
 1217                           EXPE3:
 1218                                   // CASE OF CR ( TOS> 20H TIB -- )
 1219    00000114 ........              DC32    EMIT
 1220                           EXPE33:
 1221    00000118 ........              DC32    XLOOP
 1222    0000011C 10FFFFFF              DC32     EXPE1-.        // Loop is LEAVE'd
 1223                           
 1224                           #ifdef XON_XOFF
 1225    00000120 ........              DC32    XOFF            // FOR CASE OF count reached befor cr
 1226                           #endif
 1227                           // Creat count byte        
 1228                                   // ( ORIGINAL ADDR -- )
 1229                                   // ORIGINAL ADDR (TIB) ON STACK HERE SO CORRECT FOR $LEN
 1230    00000124 ........              DC32    ONEP            // PAST COUNT BYTE FOR CORRECT COUNT
 1231                                   // NULLSTRLEN:          // ( addr -- addr len )
 1232    00000128 ........              DC32    NULLSTRLEN      // ( TOS> LEN TIB+1 -- )
 1233    0000012C .............         DC32    SWAP, ONEM      // BACK UP TO COUNT BYTE
                  ...          
 1234    00000134 ........              DC32    CSTORE
 1235    00000138 ........              DC32    SEMIS
 1236                           
 1237                           
 1238                           //      COUNT COUNT:    ( addr1 --- addr2 n_r0 )
 1239                           //      Leave the byte address addr2 and byte count n_r0 of a count byte string,
 1240                           //      beginning at address addr1. It is presumed that the first byte at
 1241                           //      addr1 contains the text byte count and the actual text starts with
 1242                           //      the second byte. NFA's may report SMUDGE'd byte counts, handled only
 1243                           //      by ID. User Strings may be up to 255 characters.
 1244                           //      Typically COUNT is followed by TYPE.
 1245                           //      See TYPE $LEN and EXPECT
 1246                           
 1247                            SECTION .text : CONST (2)
 1248                           COUNT_NFA:
 1249    00000000 85                    DC8     0x85
 1250    00000001 434F554E              DC8     'COUN'
 1251    00000005 D4                    DC8     'T'+0x80
 1252    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1253    00000008 ........              DC32    EXPECT_NFA
 1254                           COUNT:
 1255    0000000C ........              DC32    DOCOL
 1256    00000010 ........              DC32    DUP
 1257    00000014 ........              DC32    ONEP
 1258    00000018 ........              DC32    SWAP
 1259                           //        DC32    CATLT7F
 1260    0000001C ........              DC32    CAT     // n_r0 could be SMUDGE'd count from NFA's
 1261    00000020 ........              DC32    SEMIS   // Only internal usage is ID.
 1262                           
 1263                           
 1264                           //      $LEN NULLSTRLEN:        ( addr - addr len )
 1265                           //      Count length of null terminated string.
 1266                           //      TYPE can be used after this word.
 1267                           
 1268                            SECTION .text : CONST (2)
 1269                           NULLSTRLEN_NFA:
 1270    00000000 84                    DC8     0x84
 1271    00000001 244C45                DC8     '$LE'
 1272    00000004 CE                    DC8     'N'+0x80
 1273    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1274    00000008 ........              DC32    COUNT_NFA
 1275                           NULLSTRLEN:
 1276    0000000C ........              DC32    .+5
 1277                            SECTION .text : CODE (2)
 1278                                   NDPOP2w                         // Get but leave addr on stack
 1278.1  00000000 3A68                  LDR     w, [p]
 1278.2                                 ENDM
 1279    00000002 4040                  EORS            t, t, t         // zero count
 1280                           
 1281                           NSLEN_LOOP:
 1282    00000004 115C                  LDRB            n, [w,t]
 1283    00000006 0943                  ORRS            n, n, n
 1284    00000008 01D0                  BEQ             NSLEN_DONE
 1285    0000000A 401C                  ADDS            t, t, #1
 1286    0000000C FAE7                  B               NSLEN_LOOP
 1287                           
 1288                           NSLEN_DONE:
 1289                                   TPUSH
 1289                                   PUSHt   // push t to p, pre decrement p
 1289.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1289.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1289.3                         //      STR     t, [p]
 1289.4                                 ENDM
 1289                                   NEXT
 1289.1                         // ARMv7-M Thumb = .+5
 1289.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1289.3                         // ARMv6-M Thumb = .+4
 1289.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1289                                   NEXT1
 1289.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1289.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1289.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1289.4                         // ARMv6-M Thumb = .+4
 1289.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1289.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1289.7                                 ENDM
 1289.8                                 ENDM
 1289.9                                 ENDM
 1290                           
 1291                           
 1292                           //      FORGET FORGET:  ( -- )
 1293                           //      PRINTS NEW HERE IF SUCCESSFUL. FIXED FIG VERSION MEMORY LEAK.
 1294                           //      Executed in the form:
 1295                           //      FORGET CCcc
 1296                           //      Deletes definition named CCcc from the dictionary with all entries
 1297                           //      physically following it. In fig-FORTH, an error message will occur
 1298                           //      if the CURRENT and CONTEXT vocabularies are not currently the same.
 1299                           //      MODIFIED: To update Current along with context and reset DP,
 1300                           //      and execute .DS and .VS
 1301                           
 1302                            SECTION .text : CONST (2)
 1303                           FORGET_NFA:
 1304    00000000 86                    DC8     0x86
 1305    00000001 464F524745            DC8     'FORGE'
 1306    00000006 D4                    DC8     'T'+0x80
 1307    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1308    00000008 ........              DC32    NULLSTRLEN_NFA
 1309                           FORGET:
 1310    0000000C ........              DC32    DOCOL
 1311    00000010 ........              DC32    TICK                    // \ -- pfa ELSE error message
 1312    00000014 ........              DC32    DUP
 1313    00000018 ........00000         DC32    LIT, FLASH_SPAGE        // DONT FORGET FISH WORDS SAVED IN FLASH
                  208          
 1314    00000020 ........              DC32    LESSTHAN
 1315    00000024 .............         DC32    LIT, msg_forget_fish
                  ...          
 1316    0000002C ........              DC32    QERROR                  // \ f nullstr-addr --
 1317    00000030 ........              DC32    DUP
 1318    00000034 ........00001         DC32    LIT, FLASH_PPAGE        // DONT FORGET USER WORDS IN FLASH
                  008          
 1319    0000003C ........              DC32    LESSTHAN
 1320    00000040 .............         DC32    LIT, msg_forget_saved
                  ...          
 1321    00000048 ........              DC32    QERROR                  // \ f nullstr-addr --
 1322                           //      MOVE NFA update of the DP to after Currrent and Context
 1323    0000004C ........              DC32    DUP                     // PFA PFA --
 1324    00000050 ........              DC32    LFA                     // PFA LFA --
 1325                           
 1326                           // VAR space reclamation starts here:
 1327                           // PFA LFA --
 1328    00000054 ........              DC32    TOR                     // LFA_BOT
 1329                           
 1330                           VS_RECVR_LOOP:
 1331    00000058 .............         DC32    LATEST, PFA, LFA        // LFA_TOP
                  ...........  
 1332    00000064 .............         DC32    DUP, AT                 // LFA NEXT_LFA
                  ...          
 1333    0000006C .............         DC32    CURRENT_SV, STORE       // SET NEXT WORD TO CHECK
                  ...          
 1334    00000074 .............         DC32    DUP, FOURP, AT          // GET CFA
                  ...........  
 1335    00000080 .............         DC32    LIT, DOVAR, EQUAL       // IS IT A DOVAR
                  ...........  
 1336    0000008C ........              DC32    ZBRAN
 1337    00000090 14000000              DC32     VS_RECVR_NEXT-.
 1338                                   
 1339    00000094 ........FCFFF         DC32    LIT, -4, UP_SV, PSTORE  // DECREMENT UP
                  FFF..........
                  ......       
 1340                           
 1341                           VS_RECVR_NEXT:
 1342    000000A4 .............         DC32    R, EQUAL
                  ...          
 1343    000000AC ........              DC32    ZBRAN
 1344    000000B0 A8FFFFFF              DC32     VS_RECVR_LOOP-.
 1345                           
 1346    000000B4 ........              DC32    RFROM
 1347                           // VAR SPACE RECLAMATION DONE
 1348                           
 1349                           // PFA LFA --
 1350    000000B8 ........              DC32    AT              // LFA
 1351    000000BC ........              DC32    CURRENT_SV
 1352    000000C0 ........              DC32    STORE
 1353    000000C4 ........              DC32    NFA             // FROM PFA
 1354    000000C8 ........              DC32    DP_SV
 1355    000000CC ........              DC32    STORE
 1356    000000D0 .............         DC32    DOTVARSPACE, DOTDICTSPACE
                  ...          
 1357    000000D8 ........              DC32    SEMIS
 1358                           
 1359                           
 1360                           //      BYE BYE: ( -- ) COLD RESTART WITH SERIAL INITIALIZATION
 1361                           
 1362                            SECTION .text : CONST (2)
 1363                           BYE_NFA:
 1364    00000000 83                    DC8     0x83
 1365    00000001 4259                  DC8     'BY'
 1366    00000003 C5                    DC8     'E'+0x80
 1367                            ALIGNROM 2,0xFFFFFFFF
 1368    00000004 ........              DC32    FORGET_NFA
 1369                           BYE:
 1370    00000008 ........              DC32    .+5
 1371                            SECTION .text : CODE (2)
 1372    00000000 ........              B       FM3_COLD      // __iar_program_start
 1373                            LTORG
 1374                           
 1375                           
 1376                           //      ABORT ABORT:    ( -- )
 1377                           //      Clear the stacks, zero out and execute RUN or QUIT
 1378                           //      DOES NOT RESET DICTIONAIRY. SEE COLD.
 1379                           
 1380                            SECTION .text : CONST (2)
 1381                           ABORT_NFA:
 1382    00000000 85                    DC8     0x85
 1383    00000001 41424F52              DC8     'ABOR'
 1384    00000005 D4                    DC8     'T'+0x80
 1385    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1386    00000008 ........              DC32    BYE_NFA
 1387                           ABORT:
 1388    0000000C ........              DC32    DOCOL
 1389    00000010 ........              DC32    SPSTO
 1390    00000014 ........              DC32    RPSTO
 1391                           #ifdef IO2TP
 1396                           #endif
 1397    00000018 ........              DC32    zero_OUT
 1398                           //      DC32    QSTACK  // IF STACK error abort using QERROR->ERROR
 1399                           
 1400                           // LOOK UP RUN AND EXEC IT
 1401    0000001C .............         DC32    LIT, msg_RUN
                  ...          
 1402    00000024 ........              DC32    LATEST
 1403                           //ABORT_BP1_B4_PFIND_RUN:
 1404                           // DC32 NOOP
 1405    00000028 ........              DC32    PFIND   // 0 OR pfa len 1
 1406    0000002C ........              DC32    ZBRAN
 1407    00000030 10000000              DC32      ABORT_QUIT-.
 1408                           
 1409    00000034 ........              DC32    DROP    // LEN
 1410    00000038 .............         DC32    CFA, EXEC
                  ...          
 1411                           ABORT_QUIT:
 1412                           //      DC32    SEMIC_CREATE // Use ERROR if need to recover from bad definition
 1413                           #ifdef ABORT_STOP_TILL_CO
 1414    00000040 .............         DC32    LIT, ERROR_HALT, AT
                  ...........  
 1415    0000004C ........              DC32    ZBRAN
 1416    00000050 6C000000              DC32      CO_END-.
 1417                           // halt on all errors until "CO" entered
 1418                           // BEGIN
 1419    00000054 .............         DC32    LIT, msg_CO, NULLSTRLEN, TYPE
                  .............
                  ......       
 1420                           NOT_CO:
 1421    00000064 ........              DC32    QKEY
 1422    00000068 ........              DC32    ZBRAN
 1423    0000006C F8FFFFFF              DC32      NOT_CO-.
 1424                           // IF KEY = "C'
 1425    00000070 .............         DC32    KEY, LIT, 43h, EQUAL
                  ...43000000..
                  ......       
 1426    00000080 ........              DC32    ZBRAN
 1427    00000084 E0FFFFFF              DC32      NOT_CO-.
 1428                           // NEXT KEY "0"
 1429    00000088 .............         DC32    KEY, LIT, 4Fh, EQUAL
                  ...4F000000..
                  ......       
 1430    00000098 ........              DC32    ZBRAN
 1431    0000009C C8FFFFFF              DC32      NOT_CO-.
 1432                           // NEXT KEY "Enter"
 1433    000000A0 .............         DC32    KEY, LIT, 0Dh, EQUAL
                  ...0D000000..
                  ......       
 1434    000000B0 ........              DC32    ZBRAN
 1435    000000B4 B0FFFFFF              DC32      NOT_CO-.
 1436                           // UNTIL
 1437    000000B8 ........              DC32    CR
 1438                           CO_END:
 1439                           #endif
 1440    000000BC ........              DC32    QUIT    // OI
 1441                           #ifdef ABORT_STOP_TILL_CO
 1442                           $FISH_CO_MSGS.h
 1443                           #endif
 1444                           
 1445                           //      COLD COLD:      ( -- )  MODIFIED:
 1446                           //      FIGISH SYSTEM COLD = WARM (INIT RAMVARSPACE) -> type signon MSG ->ABORT
 1447                           //      CLEARS DICTIONAIRY. SEE ABORT.
 1448                           
 1449                            SECTION .text : CONST (2)
 1450                           COLD_NFA:
 1451    00000000 84                    DC8     0x84
 1452    00000001 434F4C                DC8     'COL'
 1453    00000004 C4                    DC8     'D'+0x80
 1454    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1455    00000008 ........              DC32    ABORT_NFA
 1456                           COLD:
 1457    0000000C ........              DC32    DOCOL
 1458    00000010 ........              DC32    WARM            // FISH System VAR init.
 1459    00000014 ........              DC32    SIGNON
 1460                           #ifdef ABORT_STOP_TILL_CO
 1461    00000018 ........              DC32    QUIT
 1462                           #else
 1464                           #endif
 1465                           
 1466                           //=============================== WORDCAT ====================================//
 1467                           //NOEXEC HEADERFORWORDCATEGORIES
 1468                           //      WC_FISH_SYS: = FISH System: CATEGORY
 1469                           
 1470                            SECTION .text : CONST (2)
 1471                           WC_FISH_SYS_NFA:
 1472    00000000 90                    DC8     0x80+4+12
 1473    00000001 0D0A                  DC8     0x0D, 0x0A
 1474    00000003 4649534820537         DC8     'FISH System:'
                  97374656D3A  
 1475    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1476    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1477    00000014 ........              DC32    COLD_NFA
 1478                           
 1479                           
 1480                           //----------------------------- DOTSTACK SECTION -------------------------------
 1481                           
 1482                           //      .SH DOTSHEX:    ( -- )
 1483                           //      Nondestructively print items on stack in HEX, preserving base.
 1484                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1485                           
 1486                            SECTION .text : CONST (2)
 1487                           DOTSHEX_NFA:
 1488    00000000 83                    DC8     0x83
 1489    00000001 2E53                  DC8     '.S'
 1490    00000003 C8                    DC8     'H'+0x80
 1491                            ALIGNROM 2,0xFFFFFFFF
 1492    00000004 ........              DC32    WC_FISH_SYS_NFA
 1493                           DOTSHEX:
 1494    00000008 ........              DC32    DOCOL
 1495    0000000C ........10000         DC32    LIT, 16, DOTSBASE
                  000........  
 1496    00000018 ........              DC32    SEMIS
 1497                           
 1498                           
 1499                           //      .SD DOTSDEC:    ( -- )
 1500                           //      Nondestructively print items on stack in DECIMAL, preserving base.
 1501                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1502                           
 1503                            SECTION .text : CONST (2)
 1504                           DOTSDEC_NFA:
 1505    00000000 83                    DC8     0x83
 1506    00000001 2E53                  DC8     '.S'
 1507    00000003 C4                    DC8     'D'+0x80
 1508                            ALIGNROM 2,0xFFFFFFFF
 1509    00000004 ........              DC32    DOTSHEX_NFA
 1510                           DOTSDEC:
 1511    00000008 ........              DC32    DOCOL
 1512    0000000C ........0A000         DC32    LIT, 10, DOTSBASE
                  000........  
 1513    00000018 ........              DC32    SEMIS
 1514                           
 1515                           
 1516                           //      .SB DOTSBIN:    ( -- )
 1517                           //      Nondestructively print items on stack in BINARY, preserving base.
 1518                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1519                           
 1520                            SECTION .text : CONST (2)
 1521                           DOTSBIN_NFA:
 1522    00000000 83                    DC8     0x83
 1523    00000001 2E53                  DC8     '.S'
 1524    00000003 C2                    DC8     'B'+0x80
 1525                            ALIGNROM 2,0xFFFFFFFF
 1526    00000004 ........              DC32    DOTSDEC_NFA
 1527                           DOTSBIN:
 1528    00000008 ........              DC32    DOCOL
 1529    0000000C .............         DC32    TWO, DOTSBASE
                  ...          
 1530    00000014 ........              DC32    SEMIS
 1531                           
 1532                           
 1533                           //      .S DOTS:        ( -- )
 1534                           //      Nondestructively print items on stack in current base.
 1535                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1536                           
 1537                            SECTION .text : CONST (2)
 1538                           DOTS_NFA:
 1539    00000000 82                    DC8     0x82
 1540    00000001 2E                    DC8     '.'
 1541    00000002 D3                    DC8     'S'+0x80
 1542    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1543    00000004 ........              DC32    DOTSBIN_NFA
 1544                           DOTS:
 1545    00000008 ........              DC32    DOCOL
 1546    0000000C .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1547    0000001C .............         DC32    EQUAL, ZEQU, ZBRAN
                  ...........  
 1548    00000028 68000000              DC32    DOTSEND-.                       // IF NOTHING ON STACK
 1549                           
 1550    0000002C ........              DC32    PDOTQ
 1551    00000030 05                    DC8     5
 1552    00000031 544F533E20            DC8     'TOS> '
 1553    00000036 FFFF           ALIGNROM 2,0xFFFFFFFF
 1554                                 
 1555    00000038 .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1556    00000048 ........              DC32    XDO
 1557                           
 1558                           DOTSLOOP:
 1559    0000004C .............         DC32    I, AT
                  ...          
 1560    00000054 .............         DC32    BASE_SV, AT
                  ...          
 1561    0000005C ........0A000         DC32    LIT, 10, EQUAL                  // 
                  000........  
 1562    00000068 ........              DC32    ZBRAN                           // NOT = DECIMAL
 1563    0000006C 10000000              DC32    DBSUSEDUDOT-.
 1564    00000070 ........              DC32    DOT_BASE_SUFFIX
 1565    00000074 ........              DC32    BRAN
 1566    00000078 08000000              DC32    DBSUSEDOT-.
 1567                           
 1568                           DBSUSEDUDOT:
 1569    0000007C ........              DC32    UDOT_BASE_SUFFIX
 1570                           
 1571                           DBSUSEDOT:
 1572    00000080 ........              DC32    SPACE
 1573    00000084 .............         DC32    FOUR, XPLOOP
                  ...          
 1574    0000008C C0FFFFFF              DC32    DOTSLOOP-.
 1575                           
 1576                           DOTSEND:
 1577    00000090 ........              DC32    SEMIS
 1578                           
 1579                           
 1580                           //      2DUP TDUP:      ( n2 n1 -- n2 n1 n2 n1 )
 1581                           //      Duplicate top two stack items. The prefix 2 convention means
 1582                           //      an operation on the top two stack items.
 1583                           
 1584                            SECTION .text : CONST (2)
 1585                           TDUP_NFA:
 1586    00000000 84                    DC8     0x84
 1587    00000001 324455                DC8     '2DU'
 1588    00000004 D0                    DC8     'P'+0x80
 1589    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1590    00000008 ........              DC32    DOTS_NFA
 1591                           TDUP:
 1592    0000000C ........              DC32    .+5
 1593                            SECTION .text : CODE (2)
 1594                           // TDUP: OPT by picking pops
 1595    00000000 3868                  LDR     t, [p]          //
 1596    00000002 7A68                  LDR     w, [p, #4]      //
 1597                                   DPUSH                   // 
 1597                                   PUSHw   // push w to p, post decrement p
 1597.1  00000004 47F8042D              STR     w, [p, #-4]!
 1597.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1597.3                         //      STR     w, [p]
 1597.4                                 ENDM
 1597                                   TPUSH
 1597                                   PUSHt   // push t to p, pre decrement p
 1597.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1597.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1597.3                         //      STR     t, [p]
 1597.4                                 ENDM
 1597                                   NEXT
 1597.1                         // ARMv7-M Thumb = .+5
 1597.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1597.3                         // ARMv6-M Thumb = .+4
 1597.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1597                                   NEXT1
 1597.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1597.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1597.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1597.4                         // ARMv6-M Thumb = .+4
 1597.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1597.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1597.7                                 ENDM
 1597.8                                 ENDM
 1597.9                                 ENDM
 1597.10                                ENDM
 1598                           
 1599                           
 1600                           //      -DUP ZNDUP:     ( n1 -- n1 (if zero)
 1601                           //                      ( n1 -- n1 n1 (non-zero)
 1602                           //      Reproduce n1 only if it is non-zero. Used in type andSPACES.
 1603                           //      This is usually used to copy a value just before IF, to eliminate
 1604                           //      the need for an ELSE part to drop it. 
 1605                           
 1606                            SECTION .text : CONST (2)
 1607                           DDUP_NFA:
 1608    00000000 84                    DC8     0x84
 1609    00000001 2D4455                DC8     '-DU'
 1610    00000004 D0                    DC8     'P'+0x80
 1611    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1612    00000008 ........              DC32    TDUP_NFA
 1613                           ZNDUP:
 1614    0000000C ........              DC32    DOCOL
 1615    00000010 ........              DC32    DUP
 1616    00000014 ........              DC32    ZBRAN   // IF
 1617    00000018 08000000              DC32    DDUP1-.
 1618                           
 1619    0000001C ........              DC32    DUP     //endif
 1620                           DDUP1:
 1621    00000020 ........              DC32    SEMIS
 1622                           
 1623                           
 1624                           //      ROT ROT: ( nl n2 n3 --- n2 n3 nl )
 1625                           //      Rotate the top three values on the stack, bringing the third to the top.
 1626                           
 1627                            SECTION .text : CONST (2)
 1628                           ROT_NFA:
 1629    00000000 83                    DC8     0x83
 1630    00000001 524F                  DC8     'RO'
 1631    00000003 D4                    DC8     'T'+0x80
 1632                            ALIGNROM 2,0xFFFFFFFF
 1633    00000004 ........              DC32    DDUP_NFA
 1634                           ROT:
 1635    00000008 ........              DC32    .+5
 1636                            SECTION .text : CODE (2)
 1637                                   POP2w
 1637.1  00000000 57F8042B              LDR     w, [p],#4
 1637.2                         //      LDR     w, [p]
 1637.3                         //      ADDS    p, p, #4
 1637.4                                 ENDM
 1638                                   POP2n
 1638.1  00000004 57F8041B              LDR     n, [p],#4
 1638.2                         //      LDR     n, [p]
 1638.3                         //      ADDS    p, p, #4
 1638.4                                 ENDM
 1639                           #ifdef TOSCT
 1641                           #endif
 1642                                   POP2t
 1642.1  00000008 57F8040B              LDR     t, [p],#4       // Post-increment
 1642.2                         //#ifndef TOSCT
 1642.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1642.4                         //#endif
 1642.5                         //      ADDS    p, p, #4
 1642.6                                 ENDM
 1643                                   PUSHn
 1643.1  0000000C 47F8041D              STR     n, [p, #-4]!
 1643.2                         //      SUBS    p, p, #4        // push n to p, pre decrement p
 1643.3                         //      STR     n, [p]
 1643.4                                 ENDM
 1644                                   DPUSH                   //  --  LSW MSW )
 1644                                   PUSHw   // push w to p, post decrement p
 1644.1  00000010 47F8042D              STR     w, [p, #-4]!
 1644.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1644.3                         //      STR     w, [p]
 1644.4                                 ENDM
 1644                                   TPUSH
 1644                                   PUSHt   // push t to p, pre decrement p
 1644.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1644.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1644.3                         //      STR     t, [p]
 1644.4                                 ENDM
 1644                                   NEXT
 1644.1                         // ARMv7-M Thumb = .+5
 1644.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1644.3                         // ARMv6-M Thumb = .+4
 1644.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1644                                   NEXT1
 1644.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1644.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1644.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1644.4                         // ARMv6-M Thumb = .+4
 1644.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1644.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1644.7                                 ENDM
 1644.8                                 ENDM
 1644.9                                 ENDM
 1644.10                                ENDM
 1645                           
 1646                           
 1647                           //      I I:    ( -- n_r0 )
 1648                           //      Used within a DO-LOOP to copy the loop index to the stack. Other use
 1649                           //      is implementation dependent.
 1650                           //      See R.
 1651                           
 1652                            SECTION .text : CONST (2)
 1653                           I_NFA:
 1654    00000000 81                    DC8     0x81
 1655    00000001 C9                    DC8     'I'+0x80
 1656    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1657    00000004 ........              DC32    ROT_NFA
 1658                           I:
 1659    00000008 ........              DC32    .+5
 1660                            SECTION .text : CODE (2)
 1661    00000000 3068                  LDR     t, [r]  // GET INDEX VALUE
 1662                                   TPUSH
 1662                                   PUSHt   // push t to p, pre decrement p
 1662.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1662.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1662.3                         //      STR     t, [p]
 1662.4                                 ENDM
 1662                                   NEXT
 1662.1                         // ARMv7-M Thumb = .+5
 1662.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1662.3                         // ARMv6-M Thumb = .+4
 1662.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1662                                   NEXT1
 1662.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1662.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1662.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1662.4                         // ARMv6-M Thumb = .+4
 1662.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1662.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1662.7                                 ENDM
 1662.8                                 ENDM
 1662.9                                 ENDM
 1663                           
 1664                           
 1665                           //      SP@ SPAT:       ( -- addr )
 1666                           //      \ -- addr = Current TOP of the parameter stack (p) )
 1667                           //      Place the address of the TOP of the parameter stack (p)
 1668                           //      on the parameter stack (p) as it was before RP@ was executed.
 1669                           //      e.g.  1  2  SP@  @  .   .   .     would type 2  2  1
 1670                           
 1671                            SECTION .text : CONST (2)
 1672                           SPAT_NFA:
 1673    00000000 83                    DC8     0x83
 1674    00000001 5350                  DC8     'SP'
 1675    00000003 C0                    DC8     '@'+0x80
 1676                            ALIGNROM 2,0xFFFFFFFF
 1677    00000004 ........              DC32    I_NFA
 1678                           SPAT:
 1679    00000008 ........              DC32    .+5
 1680                            SECTION .text : CODE (2)
 1681    00000000 3846                  MOV     t, p
 1682                                   TPUSH
 1682                                   PUSHt   // push t to p, pre decrement p
 1682.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1682.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1682.3                         //      STR     t, [p]
 1682.4                                 ENDM
 1682                                   NEXT
 1682.1                         // ARMv7-M Thumb = .+5
 1682.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1682.3                         // ARMv6-M Thumb = .+4
 1682.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1682                                   NEXT1
 1682.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1682.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1682.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1682.4                         // ARMv6-M Thumb = .+4
 1682.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1682.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1682.7                                 ENDM
 1682.8                                 ENDM
 1682.9                                 ENDM
 1683                           
 1684                           
 1685                           //      RP@ RPAT:       ( -- addr )
 1686                           //      \ -- addr = Current TOP of the Return Stack (r) )
 1687                           //      Place the address of the TOP of the return stack (r)
 1688                           //      on the parameter stack (p) as it was before RP@ was executed.
 1689                           //      e.g.  1 >R  2 >R  RP@  @  .   .   . would type 2  2  1
 1690                           
 1691                            SECTION .text : CONST (2)
 1692                           RPAT_NFA:
 1693    00000000 83                    DC8     0x83
 1694    00000001 5250                  DC8     'RP'
 1695    00000003 C0                    DC8     '@'+0x80
 1696                            ALIGNROM 2,0xFFFFFFFF
 1697    00000004 ........              DC32    SPAT_NFA
 1698                           RPAT:
 1699    00000008 ........              DC32    .+5
 1700                            SECTION .text : CODE (2)
 1701    00000000 3046                  MOV     t, r
 1702                                   TPUSH
 1702                                   PUSHt   // push t to p, pre decrement p
 1702.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1702.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1702.3                         //      STR     t, [p]
 1702.4                                 ENDM
 1702                                   NEXT
 1702.1                         // ARMv7-M Thumb = .+5
 1702.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1702.3                         // ARMv6-M Thumb = .+4
 1702.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1702                                   NEXT1
 1702.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1702.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1702.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1702.4                         // ARMv6-M Thumb = .+4
 1702.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1702.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1702.7                                 ENDM
 1702.8                                 ENDM
 1702.9                                 ENDM
 1703                           
 1704                           
 1705                           //      LEAVE LEAVE:    ( -- )
 1706                           //      Force termination of a DO-LOOP at the next opportunity by setting
 1707                           //      the loop limit equal to the current value of the index. The index
 1708                           //      itself remains unchanged, and execution proceeds until LOOP
 1709                           //      or +LOOP is encountered.
 1710                           
 1711                            SECTION .text : CONST (2)
 1712                           LEAVE_NFA:
 1713    00000000 85                    DC8     0x85
 1714    00000001 4C454156              DC8     'LEAV'
 1715    00000005 C5                    DC8     'E'+0x80
 1716    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1717                           //      DC32    RPSTO_NFA
 1718    00000008 ........              DC32    RPAT_NFA
 1719                           LEAVE:
 1720    0000000C ........              DC32    .+5
 1721                            SECTION .text : CODE (2)
 1722    00000000 3268                  LDR     w, [r]          // GET Index
 1723    00000002 7260                  STR     w, [r, #4]  // Store it at Limit
 1724                                   NEXT
 1724.1                         // ARMv7-M Thumb = .+5
 1724.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1724.3                         // ARMv6-M Thumb = .+4
 1724.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1724                                   NEXT1
 1724.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1724.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1724.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1724.4                         // ARMv6-M Thumb = .+4
 1724.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1724.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1724.7                                 ENDM
 1724.8                                 ENDM
 1725                           
 1726                           
 1727                           //      R> RFROM:       ( -- n_r0 )
 1728                           //      Remove the top value from the return stack and leave it on the
 1729                           //      computation stack. See >R and R.
 1730                           
 1731                            SECTION .text : CONST (2)
 1732                           RFROM_NFA:
 1733    00000000 82                    DC8     0x82
 1734    00000001 52                    DC8     'R'
 1735    00000002 BE                    DC8     '>'+0x80
 1736    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1737    00000004 ........              DC32    LEAVE_NFA
 1738                           RFROM:
 1739    00000008 ........              DC32    .+5
 1740                            SECTION .text : CODE (2)
 1741                                   POPr2t
 1741.1  00000000 56F8040B              LDR     t, [r],#4
 1741.2                         //      LDR     t, [r]
 1741.3                         //      ADDS    r, r, #4
 1741.4                                 ENDM
 1742                                   TPUSH
 1742                                   PUSHt   // push t to p, pre decrement p
 1742.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1742.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1742.3                         //      STR     t, [p]
 1742.4                                 ENDM
 1742                                   NEXT
 1742.1                         // ARMv7-M Thumb = .+5
 1742.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1742.3                         // ARMv6-M Thumb = .+4
 1742.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1742                                   NEXT1
 1742.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1742.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1742.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1742.4                         // ARMv6-M Thumb = .+4
 1742.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1742.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1742.7                                 ENDM
 1742.8                                 ENDM
 1742.9                                 ENDM
 1743                           
 1744                           
 1745                           //      R R:    ( -- n )
 1746                           //      Copy the top of the return stack to the computation stack.
 1747                           
 1748                            SECTION .text : CONST (2)
 1749                           R_NFA:
 1750    00000000 81                    DC8     0x81
 1751    00000001 D2                    DC8     'R'+0x80
 1752    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1753    00000004 ........              DC32    RFROM_NFA
 1754                           R:
 1755    00000008 ........              DC32    .+5
 1756                            SECTION .text : CODE (2)
 1757    00000000 3068                  LDR     t, [r]  // Get Index
 1758                                   TPUSH
 1758                                   PUSHt   // push t to p, pre decrement p
 1758.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1758.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1758.3                         //      STR     t, [p]
 1758.4                                 ENDM
 1758                                   NEXT
 1758.1                         // ARMv7-M Thumb = .+5
 1758.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1758.3                         // ARMv6-M Thumb = .+4
 1758.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1758                                   NEXT1
 1758.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1758.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1758.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1758.4                         // ARMv6-M Thumb = .+4
 1758.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1758.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1758.7                                 ENDM
 1758.8                                 ENDM
 1758.9                                 ENDM
 1759                           
 1760                           //      >R TOR: ( n_r0 -- )
 1761                           //      Remove a number from the computation stack and place as the most
 1762                           //      accessable on the return stack. Use should be balanced with R> in
 1763                           //      the same definition.
 1764                           
 1765                            SECTION .text : CONST (2)
 1766                           TOR_NFA:
 1767    00000000 82                    DC8     0x82
 1768    00000001 3E                    DC8     '>'
 1769    00000002 D2                    DC8     'R'+0x80
 1770    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1771    00000004 ........              DC32    R_NFA
 1772                           TOR:
 1773    00000008 ........              DC32    .+5
 1774                            SECTION .text : CODE (2)
 1775                                   POP2n   // preserve TOS
 1775.1  00000000 57F8041B              LDR     n, [p],#4
 1775.2                         //      LDR     n, [p]
 1775.3                         //      ADDS    p, p, #4
 1775.4                                 ENDM
 1776                                   PUSHn2r
 1776.1  00000004 46F8041D              STR     n, [r, #-4]!
 1776.2                         //      SUBS    r, r, #4        //  push t to r, pre decrement r
 1776.3                         //      STR     n, [r]
 1776.4                                 ENDM
 1777                           #ifdef TOSCT
 1779                           #endif
 1780                                   NEXT
 1780.1                         // ARMv7-M Thumb = .+5
 1780.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1780.3                         // ARMv6-M Thumb = .+4
 1780.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1780                                   NEXT1
 1780.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1780.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1780.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1780.4                         // ARMv6-M Thumb = .+4
 1780.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1780.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1780.7                                 ENDM
 1780.8                                 ENDM
 1781                           
 1782                           
 1783                           //      OVER OVER:      ( nl n2 -- nl n2 n1 )
 1784                           //      Copy the second stack value, placing it as the new top.
 1785                           
 1786                            SECTION .text : CONST (2)
 1787                           OVER_NFA:
 1788    00000000 84                    DC8     0x84
 1789    00000001 4F5645                DC8     'OVE'
 1790    00000004 D2                    DC8     'R'+0x80
 1791    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1792    00000008 ........              DC32    TOR_NFA
 1793                           OVER:
 1794    0000000C ........              DC32    .+5
 1795                            SECTION .text : CODE (2)
 1796                                   DPUSH           // n2
 1796                                   PUSHw   // push w to p, post decrement p
 1796.1  00000000 47F8042D              STR     w, [p, #-4]!
 1796.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1796.3                         //      STR     w, [p]
 1796.4                                 ENDM
 1796                                   TPUSH
 1796                                   PUSHt   // push t to p, pre decrement p
 1796.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1796.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1796.3                         //      STR     t, [p]
 1796.4                                 ENDM
 1796                                   NEXT
 1796.1                         // ARMv7-M Thumb = .+5
 1796.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1796.3                         // ARMv6-M Thumb = .+4
 1796.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1796                                   NEXT1
 1796.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1796.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1796.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1796.4                         // ARMv6-M Thumb = .+4
 1796.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1796.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1796.7                                 ENDM
 1796.8                                 ENDM
 1796.9                                 ENDM
 1796.10                                ENDM
 1797                           #ifdef TOSCT
 1801                           #else
 1802                                   POP2t           // n1
 1802.1  00000016 57F8040B              LDR     t, [p],#4       // Post-increment
 1802.2                         //#ifndef TOSCT
 1802.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1802.4                         //#endif
 1802.5                         //      ADDS    p, p, #4
 1802.6                                 ENDM
 1803                           #endif
 1804                                   PUSHt           // -- n1 )
 1804.1  0000001A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1804.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1804.3                         //      STR     t, [p]
 1804.4                                 ENDM
 1805                                   DPUSH           //  --  LSW MSW )
 1805                                   PUSHw   // push w to p, post decrement p
 1805.1  0000001E 47F8042D              STR     w, [p, #-4]!
 1805.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1805.3                         //      STR     w, [p]
 1805.4                                 ENDM
 1805                                   TPUSH
 1805                                   PUSHt   // push t to p, pre decrement p
 1805.1  00000022 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1805.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1805.3                         //      STR     t, [p]
 1805.4                                 ENDM
 1805                                   NEXT
 1805.1                         // ARMv7-M Thumb = .+5
 1805.2  00000026 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1805.3                         // ARMv6-M Thumb = .+4
 1805.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1805                                   NEXT1
 1805.1  0000002A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1805.2  0000002E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1805.3  00000032 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1805.4                         // ARMv6-M Thumb = .+4
 1805.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1805.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1805.7                                 ENDM
 1805.8                                 ENDM
 1805.9                                 ENDM
 1805.10                                ENDM
 1806                           
 1807                           
 1808                           //      DROP DROP:      ( n1 -- )
 1809                           //      Drop n1 from the stack.
 1810                           
 1811                            SECTION .text : CONST (2)
 1812                           DROP_NFA:
 1813    00000000 84                    DC8     0x84
 1814    00000001 44524F                DC8     'DRO'
 1815    00000004 D0                    DC8     'P'+0x80
 1816    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1817    00000008 ........              DC32    OVER_NFA
 1818                           DROP:
 1819    0000000C ........              DC32    .+5
 1820                            SECTION .text : CODE (2)
 1821                           #ifdef TOSCT
 1825                           #else // DROP:
 1826                           //        POP2t         // Opt to just do p
 1827    00000000 3F1D                  ADDS    p, p, #4
 1828                           
 1829                           #endif
 1830                                   NEXT
 1830.1                         // ARMv7-M Thumb = .+5
 1830.2  00000002 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1830.3                         // ARMv6-M Thumb = .+4
 1830.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1830                                   NEXT1
 1830.1  00000006 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1830.2  0000000A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1830.3  0000000E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1830.4                         // ARMv6-M Thumb = .+4
 1830.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1830.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1830.7                                 ENDM
 1830.8                                 ENDM
 1831                           
 1832                           
 1833                           //      SWAP SWAP:      ( nl n2 -- n2 n1 )
 1834                           //      Exchange the top two values On the stack.
 1835                           
 1836                            SECTION .text : CONST (2)
 1837                           SWAP_NFA:
 1838    00000000 84                    DC8     0x84
 1839    00000001 535741                DC8     'SWA'
 1840    00000004 D0                    DC8     'P'+0x80
 1841    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1842    00000008 ........              DC32    DROP_NFA
 1843                           SWAP:
 1844    0000000C ........              DC32    .+5
 1845                            SECTION .text : CODE (2)
 1846                           #ifdef TOSCT
 1850                           #else // SWAP:
 1851                                   POP2w           // n2
 1851.1  00000000 57F8042B              LDR     w, [p],#4
 1851.2                         //      LDR     w, [p]
 1851.3                         //      ADDS    p, p, #4
 1851.4                                 ENDM
 1852                                   POP2t           // n1
 1852.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1852.2                         //#ifndef TOSCT
 1852.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1852.4                         //#endif
 1852.5                         //      ADDS    p, p, #4
 1852.6                                 ENDM
 1853                           #endif
 1854                                   DPUSH           //  --  LSW MSW )
 1854                                   PUSHw   // push w to p, post decrement p
 1854.1  00000008 47F8042D              STR     w, [p, #-4]!
 1854.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1854.3                         //      STR     w, [p]
 1854.4                                 ENDM
 1854                                   TPUSH
 1854                                   PUSHt   // push t to p, pre decrement p
 1854.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1854.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1854.3                         //      STR     t, [p]
 1854.4                                 ENDM
 1854                                   NEXT
 1854.1                         // ARMv7-M Thumb = .+5
 1854.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1854.3                         // ARMv6-M Thumb = .+4
 1854.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1854                                   NEXT1
 1854.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1854.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1854.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1854.4                         // ARMv6-M Thumb = .+4
 1854.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1854.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1854.7                                 ENDM
 1854.8                                 ENDM
 1854.9                                 ENDM
 1854.10                                ENDM
 1855                           
 1856                           
 1857                           //      DUP DUP:        ( n1 -- n1 n1 )
 1858                           //      Duplicate the value n1 on the stack.
 1859                           
 1860                            SECTION .text : CONST (2)
 1861                           DUP_NFA:
 1862    00000000 83                    DC8     0x83
 1863    00000001 4455                  DC8     'DU'
 1864    00000003 D0                    DC8     'P'+0x80
 1865                            ALIGNROM 2,0xFFFFFFFF
 1866    00000004 ........              DC32    SWAP_NFA
 1867                           DUP:
 1868    00000008 ........              DC32    .+5
 1869                            SECTION .text : CODE (2)
 1870                           //#ifdef TOSCT
 1871                           // NO NEED TO REFRESH t ?
 1872                           //#else DUP:
 1873                           // OPT by picking pops
 1874    00000000 3868                  LDR     t, [p]
 1875                           //#endif
 1876                                   TPUSH
 1876                                   PUSHt   // push t to p, pre decrement p
 1876.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1876.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1876.3                         //      STR     t, [p]
 1876.4                                 ENDM
 1876                                   NEXT
 1876.1                         // ARMv7-M Thumb = .+5
 1876.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1876.3                         // ARMv6-M Thumb = .+4
 1876.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1876                                   NEXT1
 1876.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1876.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1876.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1876.4                         // ARMv6-M Thumb = .+4
 1876.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1876.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1876.7                                 ENDM
 1876.8                                 ENDM
 1876.9                                 ENDM
 1877                           
 1878                           //=============================== WORDCAT ====================================//
 1879                           //NOEXEC HEADERFORWORDCATEGORIES
 1880                           //      WC_STACK_NFA = Stack Stuff: CATEGORY
 1881                           
 1882                            SECTION .text : CONST (2)
 1883                           WC_STACK_NFA:
 1884    00000000 90                    DC8     0x80+4+12
 1885    00000001 0D0A                  DC8     0x0D, 0x0A
 1886    00000003 537461636B205         DC8     'Stack Stuff:'
                  3747566663A  
 1887    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1888    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1889    00000014 ........              DC32    DUP_NFA
 1890                           
 1891                           
 1892                           //      ANDBITS ANDBITS:        ( addr val -- )
 1893                           
 1894                            SECTION .text : CONST (2)
 1895                           ANDBITS_NFA:
 1896    00000000 87                    DC8     0x87
 1897    00000001 414E44424954          DC8     'ANDBIT'
 1898    00000007 D3                    DC8     'S'+0x80
 1899                            ALIGNROM 2,0xFFFFFFFF
 1900    00000008 ........              DC32    WC_STACK_NFA
 1901                           ANDBITS:
 1902    0000000C ........              DC32    .+5
 1903                            SECTION .text : CODE (2)
 1904                                   POPp2w          // val
 1904.1                                 // as in xeq token on ToS setup for exec
 1904.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1904.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1904.4                                 ENDM
 1905                                   POP2n           // addr
 1905.1  00000004 57F8041B              LDR     n, [p],#4
 1905.2                         //      LDR     n, [p]
 1905.3                         //      ADDS    p, p, #4
 1905.4                                 ENDM
 1906    00000008 0868                  LDR     t, [n]  // read [val]
 1907    0000000A 1040                  ANDS    t, t, w // modify val
 1908    0000000C 0860                  STR     t, [n]  // Write val
 1909                                   NEXT
 1909.1                         // ARMv7-M Thumb = .+5
 1909.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1909.3                         // ARMv6-M Thumb = .+4
 1909.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1909                                   NEXT1
 1909.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1909.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1909.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1909.4                         // ARMv6-M Thumb = .+4
 1909.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1909.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1909.7                                 ENDM
 1909.8                                 ENDM
 1910                           
 1911                           
 1912                           //      SETBITS SETBITS:        ( addr val -- ) OR val bits into addr.
 1913                           //      See also CLRBITS.
 1914                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1915                           
 1916                            SECTION .text : CONST (2)
 1917                           SETBITS_NFA:
 1918    00000000 87                    DC8     0x87
 1919    00000001 534554424954          DC8     'SETBIT'
 1920    00000007 D3                    DC8     'S'+0x80
 1921                            ALIGNROM 2,0xFFFFFFFF
 1922    00000008 ........              DC32    ANDBITS_NFA
 1923                           SETBITS:
 1924    0000000C ........              DC32    .+5
 1925                            SECTION .text : CODE (2)
 1926                                   POPp2w          // val
 1926.1                                 // as in xeq token on ToS setup for exec
 1926.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1926.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1926.4                                 ENDM
 1927                                   POP2n           // addr
 1927.1  00000004 57F8041B              LDR     n, [p],#4
 1927.2                         //      LDR     n, [p]
 1927.3                         //      ADDS    p, p, #4
 1927.4                                 ENDM
 1928    00000008 0868                  LDR     t, [n]  // read[val]
 1929    0000000A 1043                  ORRS    t, t, w // modify val
 1930    0000000C 0860                  STR     t, [n]  // Write val
 1931                                   NEXT
 1931.1                         // ARMv7-M Thumb = .+5
 1931.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1931.3                         // ARMv6-M Thumb = .+4
 1931.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1931                                   NEXT1
 1931.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1931.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1931.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1931.4                         // ARMv6-M Thumb = .+4
 1931.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1931.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1931.7                                 ENDM
 1931.8                                 ENDM
 1932                           
 1933                           
 1934                           //      CLRBITS CLRBITS:        ( addr val -- )
 1935                           //      XOR val bits into addr. See also SETBITS.
 1936                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1937                           
 1938                            SECTION .text : CONST (2)
 1939                           CLRBITS_NFA:
 1940    00000000 87                    DC8     0x87
 1941    00000001 434C52424954          DC8     'CLRBIT'
 1942    00000007 D3                    DC8     'S'+0x80
 1943                            ALIGNROM 2,0xFFFFFFFF
 1944    00000008 ........              DC32    SETBITS_NFA
 1945                           CLRBITS:
 1946    0000000C ........              DC32    .+5
 1947                            SECTION .text : CODE (2)
 1948                                   POPp2w                  // val
 1948.1                                 // as in xeq token on ToS setup for exec
 1948.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1948.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1948.4                                 ENDM
 1949                                   POP2n                   // addr
 1949.1  00000004 57F8041B              LDR     n, [p],#4
 1949.2                         //      LDR     n, [p]
 1949.3                         //      ADDS    p, p, #4
 1949.4                                 ENDM
 1950    00000008 0868                  LDR     t, [n]          // read [val]
 1951    0000000A 9043                  BICS    t, t, w         // modify val  - AND-NOT
 1952    0000000C 0860                  STR     t, [n]          // write val
 1953                                   NEXT
 1953.1                         // ARMv7-M Thumb = .+5
 1953.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1953.3                         // ARMv6-M Thumb = .+4
 1953.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1953                                   NEXT1
 1953.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1953.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1953.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1953.4                         // ARMv6-M Thumb = .+4
 1953.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1953.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1953.7                                 ENDM
 1953.8                                 ENDM
 1954                           
 1955                           
 1956                           //      CMOVE CMOVE:    ( from to count -- )
 1957                           //      Move the specified quantity of bytes beginning at address from to
 1958                           //      address to. The contents of address from is moved first proceeding
 1959                           //      toward high memory. Further specification is necessary on word
 1960                           //      addressing computers.
 1961                           
 1962                            SECTION .text : CONST (2)
 1963                           CMOVE_NFA:
 1964    00000000 85                    DC8     0x85
 1965    00000001 434D4F56              DC8     'CMOV'
 1966    00000005 C5                    DC8     'E'+0x80
 1967    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1968    00000008 ........              DC32    CLRBITS_NFA
 1969                           CMOVE:
 1970    0000000C ........              DC32    .+5
 1971                            SECTION .text : CODE (2)
 1972                                   POP2n //    ldr n, [p],#4      //COUNT
 1972.1  00000000 57F8041B              LDR     n, [p],#4
 1972.2                         //      LDR     n, [p]
 1972.3                         //      ADDS    p, p, #4
 1972.4                                 ENDM
 1973                                   POP2w //    ldr w, [p],#4      //DEST
 1973.1  00000004 57F8042B              LDR     w, [p],#4
 1973.2                         //      LDR     w, [p]
 1973.3                         //      ADDS    p, p, #4
 1973.4                                 ENDM
 1974                                   POP2x //    ldr x, [p],#4      //SOURCE
 1974.1  00000008 57F8043B              LDR     x, [p],#4
 1974.2                         //      LDR     x, [p]
 1974.3                         //      ADDS    p, p, #4
 1974.4                                 ENDM
 1975    0000000C 0029                  CMP     n, #0
 1976    0000000E 07D0                  BEQ     CM2
 1977                           CM1:
 1978                           //not for THUMB
 1979                           //strcpy  LDRB R2, [R1], #1
 1980                           //        STRB R2, [R0], #1
 1981                           //        TST R2, R2      // repeat if R2 is nonzero
 1982                           //        BNE strcpy
 1983    00000010 1878                  LDRB    t, [x]
 1984    00000012 1070                  STRB    t, [w]
 1985    00000014 491E                  SUBS    n, n, #1
 1986    00000016 0029                  CMP     n, #0
 1987    00000018 02D0                  BEQ     CM2
 1988                           
 1989    0000001A 521C                  ADDS    w, w, #1
 1990    0000001C 5B1C                  ADDS    x, x, #1
 1991    0000001E F7D1                  BNE     CM1
 1992                           CM2:
 1993                           #ifdef TOSCT
 1995                           #endif
 1996                                   NEXT
 1996.1                         // ARMv7-M Thumb = .+5
 1996.2  00000020 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1996.3                         // ARMv6-M Thumb = .+4
 1996.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1996                                   NEXT1
 1996.1  00000024 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1996.2  00000028 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1996.3  0000002C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1996.4                         // ARMv6-M Thumb = .+4
 1996.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1996.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1996.7                                 ENDM
 1996.8                                 ENDM
 1997                           
 1998                           
 1999                           //      FILL FILL:      ( addr quan b -- )
 2000                           //      Fill memory at the address with the specified quantity of bytes b.
 2001                           
 2002                            SECTION .text : CONST (2)
 2003                           FILL_NFA:
 2004    00000000 84                    DC8     0x84
 2005    00000001 46494C                DC8     'FIL'
 2006    00000004 CC                    DC8     'L'+0x80
 2007    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2008    00000008 ........              DC32    CMOVE_NFA
 2009                           FILL:
 2010    0000000C ........              DC32    .+5
 2011                            SECTION .text : CODE (2)
 2012                                   POP2t                   // Fill CHAR
 2012.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2012.2                         //#ifndef TOSCT
 2012.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2012.4                         //#endif
 2012.5                         //      ADDS    p, p, #4
 2012.6                                 ENDM
 2013                                   POP2n                   // Fill COUNT
 2013.1  00000004 57F8041B              LDR     n, [p],#4
 2013.2                         //      LDR     n, [p]
 2013.3                         //      ADDS    p, p, #4
 2013.4                                 ENDM
 2014                                   POP2w                   // Beginning ADDR
 2014.1  00000008 57F8042B              LDR     w, [p],#4
 2014.2                         //      LDR     w, [p]
 2014.3                         //      ADDS    p, p, #4
 2014.4                                 ENDM
 2015    0000000C 0029                  CMP     n, #0
 2016    0000000E 04D0                  BEQ     FEND            // Count is zero
 2017    00000010 8B18                  ADDS    x, n, w
 2018                           FLOOP:
 2019    00000012 1070                  STRB    t, [w]
 2020    00000014 521C                  ADDS    w, w, #1
 2021    00000016 9A42                  CMP     w, x
 2022    00000018 FBD1                  BNE     FLOOP
 2023                           FEND:
 2024                           #ifdef TOSCT
 2026                           #endif
 2027                                   NEXT
 2027.1                         // ARMv7-M Thumb = .+5
 2027.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2027.3                         // ARMv6-M Thumb = .+4
 2027.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2027                                   NEXT1
 2027.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2027.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2027.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2027.4                         // ARMv6-M Thumb = .+4
 2027.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2027.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2027.7                                 ENDM
 2027.8                                 ENDM
 2028                           
 2029                           
 2030                           //      ERASE ERASE:    ( addr n_r0 -- )
 2031                           //      Clear a region of memory to zero from addr over n_r0 addresses.
 2032                           
 2033                            SECTION .text : CONST (2)
 2034                           ERASE_NFA:
 2035    00000000 85                    DC8     0x85
 2036    00000001 45524153              DC8     'ERAS'
 2037    00000005 C5                    DC8     'E'+0x80
 2038    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2039    00000008 ........              DC32    FILL_NFA
 2040                           ERASE:
 2041    0000000C ........              DC32    DOCOL
 2042    00000010 ........              DC32    ZERO
 2043    00000014 ........              DC32    FILL
 2044    00000018 ........              DC32    SEMIS
 2045                           
 2046                           
 2047                           //      BLANKS BLANKS:  ( addr count -- )
 2048                           //      Fill an area of memory beginning at addr with blanks (0x20).
 2049                           
 2050                            SECTION .text : CONST (2)
 2051                           BLANKS_NFA:
 2052    00000000 86                    DC8     0x86
 2053    00000001 424C414E4B            DC8     'BLANK'
 2054    00000006 D3                    DC8     'S'+0x80
 2055    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2056    00000008 ........              DC32    ERASE_NFA
 2057                           BLANKS:
 2058    0000000C ........              DC32    DOCOL
 2059    00000010 ........              DC32    BLANK
 2060    00000014 ........              DC32    FILL
 2061    00000018 ........              DC32    SEMIS
 2062                           
 2063                           
 2064                           //      +! PSTORE:      ( n_r0 addr -- )
 2065                           //      Add n_r0 to the value at the address.
 2066                           //      Pronounced Plus Store
 2067                           
 2068                            SECTION .text : CONST (2)
 2069                           PSTORE_NFA:
 2070    00000000 82                    DC8     0x82
 2071    00000001 2B                    DC8     '+'
 2072    00000002 A1                    DC8     '!'+0x80
 2073    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2074    00000004 ........              DC32    BLANKS_NFA
 2075                           PSTORE:
 2076    00000008 ........              DC32    .+5
 2077                            SECTION .text : CODE (2)
 2078                                   POP2n                   // ADDRESS
 2078.1  00000000 57F8041B              LDR     n, [p],#4
 2078.2                         //      LDR     n, [p]
 2078.3                         //      ADDS    p, p, #4
 2078.4                                 ENDM
 2079                           #ifdef TOSCT
 2081                           #endif
 2082                                   POP2t                   // INCREMENT
 2082.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 2082.2                         //#ifndef TOSCT
 2082.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2082.4                         //#endif
 2082.5                         //      ADDS    p, p, #4
 2082.6                                 ENDM
 2083    00000008 0A68                  LDR     w, [n]
 2084    0000000A 8018                  ADDS    t, t, w
 2085    0000000C 0860                  STR     t, [n]
 2086                                   NEXT
 2086.1                         // ARMv7-M Thumb = .+5
 2086.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2086.3                         // ARMv6-M Thumb = .+4
 2086.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2086                                   NEXT1
 2086.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2086.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2086.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2086.4                         // ARMv6-M Thumb = .+4
 2086.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2086.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2086.7                                 ENDM
 2086.8                                 ENDM
 2087                           
 2088                           
 2089                           //      @ AT:   ( addr -- n_r0 )
 2090                           //      Read 32 bit contents of address to TOS.
 2091                           //      Pronounced Fetch, as in Fetch word at addr.
 2092                           
 2093                            SECTION .text : CONST (2)
 2094                           AT_NFA:
 2095    00000000 81                    DC8     0x81
 2096    00000001 C0                    DC8     '@'+0x80 //C0H
 2097    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2098                           //      DC32    TOGGLE_NFA
 2099    00000004 ........              DC32    PSTORE_NFA
 2100                           AT:
 2101    00000008 ........              DC32    .+5
 2102                            SECTION .text : CODE (2)
 2103                           //#ifdef TOSCT
 2104                           //        LDR     t, [t]
 2105                           //        STR     t, [p]
 2106                           //        NEXT
 2107                           //#else AT:
 2108                                   POP2n
 2108.1  00000000 57F8041B              LDR     n, [p],#4
 2108.2                         //      LDR     n, [p]
 2108.3                         //      ADDS    p, p, #4
 2108.4                                 ENDM
 2109    00000004 0868                  LDR     t, [n]
 2110                                   TPUSH
 2110                                   PUSHt   // push t to p, pre decrement p
 2110.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 2110.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 2110.3                         //      STR     t, [p]
 2110.4                                 ENDM
 2110                                   NEXT
 2110.1                         // ARMv7-M Thumb = .+5
 2110.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2110.3                         // ARMv6-M Thumb = .+4
 2110.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2110                                   NEXT1
 2110.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2110.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2110.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2110.4                         // ARMv6-M Thumb = .+4
 2110.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2110.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2110.7                                 ENDM
 2110.8                                 ENDM
 2110.9                                 ENDM
 2111                           //#endif
 2112                                   
 2113                           //      C@ CAT: ( addr -- b )
 2114                           //      Leave the 8 bit contents of addr on the stack.
 2115                           //      Pronounced "Char Fetch", as in Fetch byte at addr.
 2116                           
 2117                            SECTION .text : CONST (2)
 2118                           CAT_NFA:
 2119    00000000 82                    DC8     0x82
 2120    00000001 43                    DC8     'C'
 2121    00000002 C0                    DC8     '@'+0x80 //C0H
 2122    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2123    00000004 ........              DC32    AT_NFA
 2124                           CAT:
 2125    00000008 ........              DC32    .+5
 2126                            SECTION .text : CODE (2)
 2127                                   POP2n
 2127.1  00000000 57F8041B              LDR     n, [p],#4
 2127.2                         //      LDR     n, [p]
 2127.3                         //      ADDS    p, p, #4
 2127.4                                 ENDM
 2128    00000004 0878                  LDRB    t, [n]
 2129                                   TPUSH
 2129                                   PUSHt   // push t to p, pre decrement p
 2129.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 2129.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 2129.3                         //      STR     t, [p]
 2129.4                                 ENDM
 2129                                   NEXT
 2129.1                         // ARMv7-M Thumb = .+5
 2129.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2129.3                         // ARMv6-M Thumb = .+4
 2129.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2129                                   NEXT1
 2129.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2129.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2129.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2129.4                         // ARMv6-M Thumb = .+4
 2129.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2129.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2129.7                                 ENDM
 2129.8                                 ENDM
 2129.9                                 ENDM
 2130                           
 2131                           
 2132                           //      ! STORE:        ( n_r0 addr -- )
 2133                           //      Store n_r0 at address. Pronounced "Store".
 2134                           
 2135                            SECTION .text : CONST (2)
 2136                           STORE_NFA:
 2137    00000000 81                    DC8     0x81
 2138    00000001 A1                    DC8     '!'+0x80
 2139    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2140    00000004 ........              DC32    CAT_NFA
 2141                           STORE:
 2142    00000008 ........              DC32    .+5
 2143                            SECTION .text : CODE (2)
 2144                                   POP2t           // ADDR
 2144.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2144.2                         //#ifndef TOSCT
 2144.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2144.4                         //#endif
 2144.5                         //      ADDS    p, p, #4
 2144.6                                 ENDM
 2145                                   POP2n           // DATA
 2145.1  00000004 57F8041B              LDR     n, [p],#4
 2145.2                         //      LDR     n, [p]
 2145.3                         //      ADDS    p, p, #4
 2145.4                                 ENDM
 2146    00000008 0160                  STR     n, [t]
 2147                                   NEXT
 2147.1                         // ARMv7-M Thumb = .+5
 2147.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2147.3                         // ARMv6-M Thumb = .+4
 2147.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2147                                   NEXT1
 2147.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2147.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2147.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2147.4                         // ARMv6-M Thumb = .+4
 2147.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2147.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2147.7                                 ENDM
 2147.8                                 ENDM
 2148                           
 2149                           
 2150                           //      C! CSTORE:      ( n_r0 addr -- )
 2151                           //      Store LS 8 bits of n_r0 at address. Pronounced "Char Store".
 2152                           
 2153                            SECTION .text : CONST (2)
 2154                           CSTORE_NFA:
 2155    00000000 82                    DC8     0x82
 2156    00000001 43                    DC8     'C'
 2157    00000002 A1                    DC8     '!'+0x80
 2158    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2159    00000004 ........              DC32    STORE_NFA
 2160                           CSTORE:
 2161    00000008 ........              DC32    .+5
 2162                            SECTION .text : CODE (2)
 2163                                   POP2t
 2163.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2163.2                         //#ifndef TOSCT
 2163.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2163.4                         //#endif
 2163.5                         //      ADDS    p, p, #4
 2163.6                                 ENDM
 2164                                   POP2n
 2164.1  00000004 57F8041B              LDR     n, [p],#4
 2164.2                         //      LDR     n, [p]
 2164.3                         //      ADDS    p, p, #4
 2164.4                                 ENDM
 2165    00000008 0170                  STRB    n, [t]
 2166                                   NEXT
 2166.1                         // ARMv7-M Thumb = .+5
 2166.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2166.3                         // ARMv6-M Thumb = .+4
 2166.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2166                                   NEXT1
 2166.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2166.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2166.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2166.4                         // ARMv6-M Thumb = .+4
 2166.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2166.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2166.7                                 ENDM
 2166.8                                 ENDM
 2167                           
 2168                           
 2169                           //=============================== WORDCAT ====================================//
 2170                           //NOEXEC HEADERFORWORDCATEGORIES
 2171                           //      WC_RWMEMORY_NFA = Read and Write Memory With: CATEGORY
 2172                           
 2173                            SECTION .text : CONST (2)
 2174                           WC_RWMEMORY_NFA:
 2175    00000000 9F                    DC8     0x80+31
 2176    00000001 0D0A                  DC8     0x0D, 0x0A
 2177    00000003 5265616420616         DC8     'Read and Write Memory With:'
                  E642057726974
                  65204D656D6F7
                  2792057697468
                  3A           
 2178    0000001E 0D8A                  DC8     0x0D, 0x0A+0x80
 2179                            ALIGNROM 2,0xFFFFFFFF
 2180    00000020 ........              DC32    CSTORE_NFA
 2181                           
 2182                           
 2183                           //      ] RBRAC:        ( -- )
 2184                           //      Resume compilation, by STATE back to 0xC0 (zero is interpreting)
 2185                           //      0xC0 STATE  used in INTERPRET to execute Immediate words while compiling
 2186                           //      See [.
 2187                           
 2188                            SECTION .text : CONST (2)
 2189                           RBRAC_NFA:
 2190    00000000 81                    DC8     0x81
 2191    00000001 DD                    DC8     ']'+0x80
 2192    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2193                           //      DC32    SMUDGE_NFA
 2194    00000004 ........              DC32    WC_RWMEMORY_NFA
 2195                           RBRAC:
 2196    00000008 ........              DC32    DOCOL
 2197    0000000C ........C0000         DC32    strva, 0xC0, CSTATE
                  000........  
 2198    00000018 ........              DC32    SEMIS
 2199                           
 2200                           
 2201                           //      [ LBRAC:        ( -- ) IMMEDIATE
 2202                           //      Used in a colon-definition in form
 2203                           //              xxx    [  words   ]    more
 2204                           //      Suspend compilation by setting STATE to zero (0xC0 is compiling).
 2205                           //      The words after [ are executed, not compiled. This allows calculation
 2206                           //      or compilation exceptions before resuming compilation with ] .
 2207                           //      See LITERAL and ]
 2208                           
 2209                            SECTION .text : CONST (2)
 2210                           LBRAC_NFA:
 2211    00000000 C1                    DC8     0x0C1
 2212    00000001 DB                    DC8     '['+0x80
 2213    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2214    00000004 ........              DC32    RBRAC_NFA
 2215                           LBRAC:
 2216    00000008 ........              DC32    DOCOL
 2217    0000000C ........00000         DC32    strva, 0, CSTATE
                  000........  
 2218    00000018 ........              DC32    SEMIS
 2219                           
 2220                           
 2221                           //      [COMPILE] BCOMP:        ( -- ) IMMEDIATE
 2222                           //      Used in a colon-definition in form:
 2223                           //              :  xxx    [COMPILE]   immediate_word   ;
 2224                           //      [COMPILE] will force the compilation of an IMMEDIATE WORD
 2225                           //      that would otherwise execute during compilation. The above example
 2226                           //      will select the FORTH vocabulary then xxx executes, rather than at
 2227                           //      compile time.
 2228                           
 2229                            SECTION .text : CONST (2)
 2230                           BCOMP_NFA:
 2231    00000000 C9                    DC8     0x0C9
 2232    00000001 5B434F4D50494         DC8     '[COMPILE'
                  C45          
 2233    00000009 DD                    DC8     ']'+0x80
 2234    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2235    0000000C ........              DC32    LBRAC_NFA
 2236                           BCOMP:
 2237    00000010 ........              DC32    DOCOL
 2238    00000014 ........              DC32    DFIND   // noop there for TIB entry
 2239                           //      -FIND \ --- pfa len tf (found) \ --- ff (not found)
 2240    00000018 ........              DC32    ZEQU
 2241    0000001C .............         DC32    LIT, msg_qstack
                  ...          
 2242    00000024 ........              DC32    QERROR    // \ f nullstr-addr --
 2243    00000028 ........              DC32    DROP
 2244    0000002C ........              DC32    CFA
 2245    00000030 ........              DC32    COMMA   // alighned, INCREMENTS DP REFLECTED by HERE
 2246    00000034 ........              DC32    SEMIS
 2247                           
 2248                           
 2249                           //      DLITERAL DLITERAL:      ( d -- d ) IMMEDIATE
 2250                           //                              ( d -- )   (compiling)
 2251                           //      If compiling, compile a stack double number into a literal. Later
 2252                           //      execution of the definition containing the literal will push it to
 2253                           //      the stack. If executing, the number will remain on the stack.
 2254                           //      : xxx    [ calculate ]  DLITERAL  ; //
 2255                           
 2256                            SECTION .text : CONST (2)
 2257                           DLITERAL_NFA:
 2258    00000000 C8                    DC8     0x0C8
 2259    00000001 444C495445524         DC8     'DLITERA'
                  1            
 2260    00000008 CC                    DC8     'L'+0x80
 2261    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2262    0000000C ........              DC32    BCOMP_NFA
 2263                           DLITERAL:
 2264    00000010 ........              DC32    DOCOL
 2265    00000014 ........              DC32    STATE_SV
 2266    00000018 ........              DC32    AT
 2267    0000001C ........              DC32    ZBRAN   // IF
 2268    00000020 10000000              DC32     DLIT1-.
 2269                           
 2270    00000024 ........              DC32    SWAP
 2271    00000028 ........              DC32    LITERAL
 2272    0000002C ........              DC32    LITERAL // endif
 2273                           DLIT1:
 2274    00000030 ........              DC32    SEMIS
 2275                           
 2276                           
 2277                           //      LITERAL LITERAL:        ( n_r0 -- ) IMMEDIATE
 2278                           //      If compiling, then compile the stack value n_r0 as a 32 bit literal.
 2279                           //      This definition is immediate so that it will execute during a colon
 2280                           //      definition. The intended use is:
 2281                           //      : xxx    [ calculate ]  LITERAL  ; //
 2282                           //      Compilation is suspended for the compile time calculation of value.
 2283                           //      Compilation is resumed and LITERAL compiles this value.
 2284                           
 2285                            SECTION .text : CONST (2)
 2286                           LITERAL_NFA:
 2287    00000000 C7                    DC8     0x0C7
 2288    00000001 4C4954455241          DC8     'LITERA'
 2289    00000007 CC                    DC8     'L'+0x80
 2290                            ALIGNROM 2,0xFFFFFFFF
 2291    00000008 ........              DC32    DLITERAL_NFA
 2292                           LITERAL:
 2293    0000000C ........              DC32    DOCOL
 2294    00000010 ........              DC32    STATE_SV
 2295    00000014 ........              DC32    AT
 2296    00000018 ........              DC32    ZBRAN           // If not compiling
 2297    0000001C 10000000              DC32     LITE1-.        // go here
 2298                           
 2299    00000020 ........              DC32    COMP            // Compile
 2300    00000024 ........              DC32    LIT             // Literal
 2301    00000028 ........              DC32    COMMA           // Then COMPILE THE LITERAL VALUE
 2302                           LITE1:
 2303    0000002C ........              DC32    SEMIS
 2304                           
 2305                           
 2306                           //      #> EDIGS:       ( d=(LSW MSW) -- addr count )
 2307                           //      Terminates numeric output conversion by dropping dnum,
 2308                           //      leaving the text address and character count suitable for type.
 2309                           
 2310                            SECTION .text : CONST (2)
 2311                           EDIGS_NFA:
 2312    00000000 82                    DC8     0x82
 2313    00000001 23                    DC8     '#'
 2314    00000002 BE                    DC8     '>'+0x80
 2315    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2316    00000004 ........              DC32    LITERAL_NFA
 2317                           EDIGS:
 2318    00000008 ........              DC32    DOCOL
 2319    0000000C ........              DC32    DROP
 2320    00000010 ........              DC32    DROP
 2321    00000014 ........              DC32    HLD_SV
 2322    00000018 ........              DC32    AT
 2323    0000001C ........              DC32    PAD_SV
 2324    00000020 ........              DC32    OVER
 2325    00000024 ........              DC32    SUBB
 2326    00000028 ........              DC32    SEMIS
 2327                           
 2328                           
 2329                           //      HOLD HOLD:      ( c -- )
 2330                           //      Used between <# and #> to insert an ascii character into a pictured
 2331                           //      numeric output string.
 2332                           //      e.g. 0x2E HOLD will place a decimal point.
 2333                           
 2334                            SECTION .text : CONST (2)
 2335                           HOLD_NFA:
 2336    00000000 84                    DC8     0x84
 2337    00000001 484F4C                DC8     'HOL'
 2338    00000004 C4                    DC8     'D'+0x80
 2339    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2340    00000008 ........              DC32    EDIGS_NFA
 2341                           HOLD:
 2342    0000000C ........              DC32    DOCOL
 2343    00000010 ........FFFFF         DC32    LIT,-1
                  FFF          
 2344    00000018 ........              DC32    HLD_SV
 2345    0000001C ........              DC32    PSTORE
 2346    00000020 ........              DC32    HLD_SV
 2347    00000024 ........              DC32    AT
 2348    00000028 ........              DC32    CSTORE
 2349    0000002C ........              DC32    SEMIS
 2350                           
 2351                           
 2352                           //      SIGN SIGN:      ( n_r0 d=<LSW MSW> -- d=<LSW MSW> )
 2353                           //      Place an ascii "-" sign just before a converted numeric output
 2354                           //      string in the text output buffer when n_r0 is negative. n_r0 is discarded
 2355                           //      but double number dnum is maintained. Must be used between <# and #>.
 2356                           
 2357                            SECTION .text : CONST (2)
 2358                           SIGN_NFA:
 2359    00000000 84                    DC8     0x84
 2360    00000001 534947                DC8     'SIG'
 2361    00000004 CE                    DC8     'N'+0x80
 2362    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2363    00000008 ........              DC32    HOLD_NFA
 2364                           SIGN:
 2365    0000000C ........              DC32    DOCOL
 2366    00000010 ........              DC32    ROT
 2367    00000014 ........              DC32    ZLESS
 2368    00000018 ........              DC32    ZBRAN           // If
 2369    0000001C 10000000              DC32     SIGN1-.
 2370                           
 2371    00000020 ........2D000         DC32    LIT, '-'        // 0x2D
                  000          
 2372    00000028 ........              DC32    HOLD            // Endif
 2373                           SIGN1:
 2374    0000002C ........              DC32    SEMIS
 2375                           
 2376                           
 2377                           //      #S DIGS:        ( d1=<LSW MSW> -- d2=<LSW MSW> )
 2378                           //      Generates ascii text in the text output buffer, by the use of #,
 2379                           //      until a zero double number d2 results.
 2380                           //      Used between <# and #>.
 2381                           //      EACH NUMBER = BASE*number+(character-'0')
 2382                           
 2383                            SECTION .text : CONST (2)
 2384                           DIGS_NFA:
 2385    00000000 82                    DC8     0x82
 2386    00000001 23                    DC8     '#'
 2387    00000002 D3                    DC8     'S'+0x80
 2388    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2389    00000004 ........              DC32    SIGN_NFA
 2390                           DIGS:
 2391    00000008 ........              DC32    DOCOL
 2392                           DIGS1:                          // Begin generating ascii chars by DIG
 2393    0000000C ........              DC32    DIG             //\ d1=<LSW MSW> -- d2=QUO=<LSW MSW>
 2394    00000010 ........              DC32    OVER
 2395    00000014 ........              DC32    OVER
 2396    00000018 ........              DC32    OR
 2397    0000001C ........              DC32    ZEQU
 2398    00000020 ........              DC32    ZBRAN           //UNTIL
 2399    00000024 E8FFFFFF              DC32     DIGS1-.
 2400    00000028 ........              DC32    SEMIS
 2401                           
 2402                           
 2403                           //      # DIG:  ( d1=<LSW MSW> -- d2=QUO=<LSW MSW> ) BASE MUST BE SET!
 2404                           //      Generate from a double number d1, the next ascii character which is
 2405                           //      placed in an output string. Result d2 is the quotient after division
 2406                           //      by base, and is maintained for further processing.
 2407                           //      Used between <# and #>.
 2408                           //      See #S.
 2409                           //      EACH NUMBER = BASE*number+(character-'0')
 2410                           
 2411                            SECTION .text : CONST (2)
 2412                           DIG_NFA:
 2413    00000000 81                    DC8     0x81
 2414    00000001 A3                    DC8     '#'+0x80
 2415    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2416    00000004 ........              DC32    DIGS_NFA
 2417                           DIG:
 2418    00000008 ........              DC32    DOCOL
 2419    0000000C ........              DC32    BASE_SV         // EX 0 1 0
 2420    00000010 ........              DC32    AT              // -- 0 1 0 A
 2421    00000014 ........              DC32    MSMOD           // -- 0 1 0 0
 2422    00000018 ........              DC32    ROT             // -- 0 0 0 1
 2423    0000001C ........09000         DC32    LIT,9
                  000          
 2424    00000024 ........              DC32    OVER
 2425    00000028 ........              DC32    LESSTHAN
 2426    0000002C ........              DC32    ZBRAN           // If
 2427    00000030 10000000              DC32     DIG1-.
 2428                           
 2429    00000034 ........07000         DC32    LIT,7
                  000          
 2430    0000003C ........              DC32    PLUS            // Endif
 2431                           DIG1:
 2432    00000040 ........30000         DC32    LIT, 0x30
                  000          
 2433    00000048 ........              DC32    PLUS
 2434    0000004C ........              DC32    HOLD
 2435    00000050 ........              DC32    SEMIS
 2436                           
 2437                           
 2438                           //      <# BDIGS:       ( -- )
 2439                           //      Setup for pictured numeric output formatting using the words:
 2440                           //              <# # #S SIGN HOLD #>
 2441                           //      The conversion is done on a double number producing text at Pad
 2442                           
 2443                            SECTION .text : CONST (2)
 2444                           BDIGS_NFA:
 2445    00000000 82                    DC8     0x82
 2446    00000001 3C                    DC8     '<'
 2447    00000002 A3                    DC8     '#'+0x80
 2448    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2449    00000004 ........              DC32    DIG_NFA
 2450                           BDIGS:
 2451    00000008 ........              DC32    DOCOL
 2452    0000000C .............         DC32    strva, PAD, NHLD
                  ...........  
 2453    00000018 ........              DC32    SEMIS
 2454                           
 2455                           
 2456                           //      DOES> DOES:     ( pfa -- ) MODIFIED:
 2457                           //      A word which defines the run-time action within a high-level
 2458                           //      defining word. DOES> alters the code field and first parameter of
 2459                           //      the new word to execute the sequence of compiled word addresses
 2460                           //      following DOES>. Used in combination with <BUILDS. When the DOES>
 2461                           //      part executes it begins with the address of the first parameter of
 2462                           //      the new word on the stack. This allows interpretation using this
 2463                           //      area or its contents. Typical uses include the Forth assembler,
 2464                           //      multidimensional arrays, and compiler generation.
 2465                           
 2466                            SECTION .text : CONST (2)
 2467                           DOES_NFA:
 2468    00000000 85                    DC8     0x85
 2469    00000001 444F4553              DC8     'DOES'
 2470    00000005 BE                    DC8     '>'+0x80
 2471    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2472    00000008 ........              DC32    BDIGS_NFA
 2473                           DOES:
 2474    0000000C ........              DC32    DOCOL
 2475    00000010 ........              DC32    RFROM   // Get the addr of the first word after DOES>
 2476    00000014 ........              DC32    LATEST  // ( -- addr ) nfa OF the current <creator> word
 2477    00000018 ........              DC32    PFA     // Use the pfa to store a run-time cfa
 2478    0000001C .............         DC32    DUP, CFA
                  ...          
 2479    00000024 .............         DC32    LIT, CREATE_DOES_GOTO
                  ...          
 2480    0000002C .............         DC32    SWAP, STORE     // STORE GOTO
                  ...          
 2481    00000034 ........              DC32    STORE   // Store the run-time cfa as 1rst pfa Parameter.
 2482    00000038 ........              DC32    SEMIS
 2483                           
 2484                           
 2485                           //      <BUILDS BUILDS: ( -- )  MODIFIED: See CREATE and DOES>
 2486                           //      Used within a colon-definition
 2487                           //              CCcc  <BUILDS  ...  DOES>     ...
 2488                           //      Each time CCcc is executed, <BUILDS defines a new word with a
 2489                           //      high-level execution proceedure. Executing CCcc in the form
 2490                           //              CCcc nnnn
 2491                           //      uses <BUILDS to create a dictionary entry for nnnn with a call to
 2492                           //      the DOES> part for nnnn. When nnnn is later executed, it has the
 2493                           //      address of its parameter area on the stack and executes the words
 2494                           //      after DOES> in CCcc. <BUILDS and DOES> allow runtime proceedures to
 2495                           //      written in high-level code.
 2496                           
 2497                            SECTION .text : CONST (2)
 2498                           BUILDS_NFA:
 2499    00000000 87                    DC8     0x87
 2500    00000001 3C4255494C44          DC8     '<BUILD'
 2501    00000007 D3                    DC8     'S'+0x80
 2502                            ALIGNROM 2,0xFFFFFFFF
 2503    00000008 ........              DC32    DOES_NFA
 2504                           BUILDS:
 2505    0000000C ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 2506    00000010 ........              DC32    CREATE                  // CREATE's A CON POINTING TO IT'S PFA
 2507    00000014 ........              DC32    SEMIS
 2508                           
 2509                           
 2510                           //      +LOOP PLOOP:    ( n1 -- ) IMMEDIATE
 2511                           //                      ( addr n2 -- ) COMPILE
 2512                           //      At run time, DO begins a sequence with repetitive execution
 2513                           //      controlled by a loop limit n1 and an index with initial value n2. DO
 2514                           //      removes these from the stack. Upon reaching LOOP the index is
 2515                           //      incremented by one.
 2516                           //      Until the new index equals or exceeds the limit, execution loops
 2517                           //      back to just after DO// otherwise the loop parameters are discarded
 2518                           //      and execution continues ahead. Both n1 and n2 are determined at
 2519                           //      run-time and may be the result of other operations.
 2520                           //      Within a loop 'I' will copy the current value of the index to the
 2521                           //      stack. See I, LOOP, +LOOP, LEAVE.
 2522                           //
 2523                           //      When compiling within the colon definition, DO compiles (DO), leaves
 2524                           //      the following address addr and n_r0 for later error checking.
 2525                           
 2526                            SECTION .text : CONST (2)
 2527                           PLOOP_NFA:
 2528    00000000 C5                    DC8     0x0C5
 2529    00000001 2B4C4F4F              DC8     '+LOO'
 2530    00000005 D0                    DC8     'P'+0x80
 2531    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2532    00000008 ........              DC32    BUILDS_NFA
 2533                           PLOOP:
 2534    0000000C ........              DC32    DOCOL
 2535    00000010 ........              DC32    THREE
 2536    00000014 ........              DC32    QPAIR
 2537    00000018 ........              DC32    COMP
 2538    0000001C ........              DC32    XPLOOP
 2539    00000020 ........              DC32    BACK
 2540    00000024 ........              DC32    SEMIS
 2541                           
 2542                           
 2543                           //      LOOP LOOP:      ( addr n_r0 -- ) IMMEDIATE
 2544                           //      Occurs in a colon-definition in form:
 2545                           //              DO ... LOOP
 2546                           //      At run-time, LOOP selectively controls branching back to the
 2547                           //      corresponding DO based on the loop index and limit. The loop index
 2548                           //      is incremented by one and compared to the limit. The branch back to
 2549                           //      DO occurs until the index equals or exceeds the limit, then
 2550                           //      the parameters are discarded and execution continues ahead.
 2551                           //
 2552                           //      At compile-time. LOOP compiles (LOOP) and uses addr to calculate an
 2553                           //      offset to DO. n_r0 is used for error testing.
 2554                           
 2555                            SECTION .text : CONST (2)
 2556                           LOOP_NFA:
 2557    00000000 C4                    DC8     0x0C4
 2558    00000001 4C4F4F                DC8     'LOO'
 2559    00000004 D0                    DC8     'P'+0x80
 2560    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2561    00000008 ........              DC32    PLOOP_NFA
 2562                           LOOP:
 2563    0000000C ........              DC32    DOCOL
 2564    00000010 ........              DC32    THREE
 2565    00000014 ........              DC32    QPAIR
 2566    00000018 ........              DC32    COMP
 2567    0000001C ........              DC32    XLOOP
 2568    00000020 ........              DC32    BACK
 2569    00000024 ........              DC32    SEMIS
 2570                           
 2571                           
 2572                           //      DO DO:  ( n1 n2 -- ) IMMEDIATE
 2573                           //              (addr n_r0 -- ) COMPILE
 2574                           //      Occurs in a colon-definition in form:
 2575                           //      DO ... LOOP
 2576                           
 2577                            SECTION .text : CONST (2)
 2578                           DO_NFA:
 2579    00000000 C2                    DC8     0x0C2
 2580    00000001 44                    DC8     'D'
 2581    00000002 CF                    DC8     'O'+0x80
 2582    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2583    00000004 ........              DC32    LOOP_NFA
 2584                           DO:
 2585    00000008 ........              DC32    DOCOL
 2586    0000000C ........              DC32    COMP
 2587    00000010 ........              DC32    XDO
 2588    00000014 ........              DC32    HERE
 2589    00000018 ........              DC32    THREE
 2590    0000001C ........              DC32    SEMIS
 2591                           
 2592                           
 2593                           //      ENDIF ENDIF:    ( addr n_r0 -- ) IMMEDIATE
 2594                           //      Occurs in a colon-definition in form:
 2595                           //              IF ... ENDIF
 2596                           //              IF ... ELSE ... ENDIF
 2597                           //      At run-time, ENDIF serves only as the destination of a forward
 2598                           //      branch from IF or ELSE. It marks the conclusion of the conditional
 2599                           //      structure. THEN is another name for ENDIF. Both names are supported
 2600                           //      in fig-FORTH. See also IF and ELSE.
 2601                           //
 2602                           //      At compile-time, ENDIF computes the forward branch offset from addr
 2603                           //      to HERE and stores it at addr. n_r0 is used for error tests.
 2604                           
 2605                            SECTION .text : CONST (2)
 2606                           ENDIF_NFA:
 2607    00000000 C5                    DC8     0x0C5
 2608    00000001 454E4449              DC8     'ENDI'
 2609    00000005 C6                    DC8     'F'+0x80
 2610    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2611    00000008 ........              DC32    DO_NFA
 2612                           ENDIF:
 2613    0000000C ........              DC32    DOCOL
 2614    00000010 ........              DC32    QCOMP
 2615    00000014 ........              DC32    TWO     // 2 is the Error checking number for if.
 2616    00000018 ........              DC32    QPAIR
 2617    0000001C ........              DC32    HERE
 2618    00000020 ........              DC32    OVER
 2619    00000024 ........              DC32    SUBB
 2620    00000028 ........              DC32    SWAP
 2621    0000002C ........              DC32    STORE
 2622    00000030 ........              DC32    SEMIS
 2623                           
 2624                           
 2625                           //      THEN THEN:      ( -- ) IMMEDIATE
 2626                           //      An alias for ENDIF.
 2627                           
 2628                            SECTION .text : CONST (2)
 2629                           THEN_NFA:
 2630    00000000 C4                    DC8     0x0C4
 2631    00000001 544845                DC8     'THE'
 2632    00000004 CE                    DC8     'N'+0x80
 2633    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2634    00000008 ........              DC32    ENDIF_NFA
 2635                           THEN:
 2636    0000000C ........              DC32    DOCOL
 2637    00000010 ........              DC32    ENDIF
 2638    00000014 ........              DC32    SEMIS
 2639                           
 2640                           
 2641                           //      ELSE ELSE:      ( addr1 n1 -- ) IMMEDIATE
 2642                           //                      ( addr2 n2 -- ) COMPILING
 2643                           //      Occurs within a colon-definition in the form:
 2644                           //              IF ... ELSE ... ENDIF
 2645                           //      At run-time, ELSE executes after the true part following IF. ELSE
 2646                           //      forces execution to skip over the following false part and resumes
 2647                           //      execution after the ENDIF. It has no stack effect.
 2648                           //
 2649                           //      At compile-time ELSE emplaces BRANCH reserving a branch offset,
 2650                           //      leaves the address addr2 and n2 for error testing. ELSE also
 2651                           //      resolves the pending forward branch from IF by calculating the
 2652                           //      offset from addr1 to HERE and storing at addr1.
 2653                           
 2654                            SECTION .text : CONST (2)
 2655                           ELSE_NFA:
 2656    00000000 C4                    DC8     0x0C4
 2657    00000001 454C53                DC8     'ELS'
 2658    00000004 C5                    DC8     'E'+0x80
 2659    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2660    00000008 ........              DC32    THEN_NFA
 2661                           ELSE:
 2662    0000000C ........              DC32    DOCOL
 2663    00000010 ........              DC32    TWO
 2664    00000014 ........              DC32    QPAIR
 2665    00000018 ........              DC32    COMP
 2666    0000001C ........              DC32    BRAN
 2667    00000020 ........              DC32    HERE
 2668    00000024 ........              DC32    ZERO
 2669    00000028 ........              DC32    COMMA   // aligned, INCREMENTS DP REFLECTED by HERE
 2670    0000002C ........              DC32    SWAP
 2671    00000030 ........              DC32    TWO
 2672    00000034 ........              DC32    ENDIF
 2673    00000038 ........              DC32    TWO
 2674    0000003C ........              DC32    SEMIS
 2675                           
 2676                           
 2677                           //      IF IF:  ( f -- ) IMMEDIATE
 2678                           //              ( -- addr n_r0 ) COMPILE
 2679                           //      Occurs is a colon-definition in form:
 2680                           //              IF (tp) ...  ENDIF      .
 2681                           //              IF (tp) ... ELSE (fp) ... ENDIF
 2682                           //      At run-time, IF selects execution based on a boolean flag. If f is
 2683                           //      true (non-zero), execution continues ahead thru the true part. If f
 2684                           //      is false (zero), execution skips till just after ELSE to execute
 2685                           //      the false part. After either part, execution resumes after ENDIF.
 2686                           //      ELSE and its false part are optional.; if missing, false execution
 2687                           //      skips to just after ENDIF..
 2688                           //
 2689                           //      At compile-time IF compiles 0BRANCH and reserves space for an offset
 2690                           //      at addr. addr and n_r0 are used later for resolution of the offset and
 2691                           //      error testing.
 2692                           
 2693                            SECTION .text : CONST (2)
 2694                           IF_NFA:
 2695    00000000 C2                    DC8     0x0C2
 2696    00000001 49                    DC8     'I'
 2697    00000002 C6                    DC8     'F'+0x80
 2698    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2699    00000004 ........              DC32    ELSE_NFA
 2700                           IF:
 2701    00000008 ........              DC32    DOCOL
 2702    0000000C ........              DC32    COMP
 2703    00000010 ........              DC32    ZBRAN
 2704    00000014 ........              DC32    HERE
 2705    00000018 ........              DC32    ZERO
 2706    0000001C ........              DC32    COMMA
 2707    00000020 ........              DC32    TWO     // 2 is the Error checking number for if.
 2708    00000024 ........              DC32    SEMIS
 2709                           
 2710                           
 2711                           //      UNTIL UNTIL:    ( f -- ) IMMEDIATE
 2712                           //                      ( addr n_r0 -- ) COMPILE:
 2713                           //      Occurs within a colon-definition in the form:
 2714                           //              BEGIN ... UNTIL
 2715                           //      At run-time, UNTIL controls the conditional branch back to the
 2716                           //      corresponding BEGIN. If f is false, execution returns to just after.
 2717                           //      BEGIN:  if true, execution continues ahead.
 2718                           //      At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to
 2719                           //      addr. n_r0 is used for error tests.
 2720                           
 2721                            SECTION .text : CONST (2)
 2722                           UNTIL_NFA:
 2723    00000000 C5                    DC8     0x0C5
 2724    00000001 554E5449              DC8     'UNTI'
 2725    00000005 CC                    DC8     'L'+0x80
 2726    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2727    00000008 ........              DC32    IF_NFA
 2728                           UNTIL:
 2729    0000000C ........              DC32    DOCOL
 2730    00000010 ........              DC32    ONE
 2731    00000014 ........              DC32    QPAIR
 2732    00000018 ........              DC32    COMP
 2733    0000001C ........              DC32    ZBRAN
 2734    00000020 ........              DC32    BACK
 2735    00000024 ........              DC32    SEMIS
 2736                           
 2737                           
 2738                           //      AGAIN AGAIN:    ( addr n_r0 -- ) IMMEDIATE
 2739                           //      Used in a colon-definition in the form:
 2740                           //                      BEGIN ... AGAIN
 2741                           //      At run-time, AGAIN forces execution to return to corresponding BEGIN.
 2742                           //      There is no effect on the stack. Execution cannot leave this loop
 2743                           //      (unless R> DROP is executed one level below).
 2744                           //
 2745                           //      At compile time, AGAIN compiles BRANCH with an offset from HERE to
 2746                           //      addr. n_r0 is used for compile-time error checking.
 2747                           
 2748                            SECTION .text : CONST (2)
 2749                           AGAIN_NFA:
 2750    00000000 C5                    DC8     0x0C5
 2751    00000001 41474149              DC8     'AGAI'
 2752    00000005 CE                    DC8     'N'+0x80
 2753    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2754    00000008 ........              DC32    UNTIL_NFA
 2755                           AGAIN:
 2756    0000000C ........              DC32    DOCOL
 2757    00000010 ........              DC32    ONE
 2758    00000014 ........              DC32    QPAIR
 2759    00000018 ........              DC32    COMP
 2760    0000001C ........              DC32    BRAN
 2761    00000020 ........              DC32    BACK
 2762    00000024 ........              DC32    SEMIS
 2763                           
 2764                           
 2765                           //      REPEAT REPEAT:  ( addr n_r0 -- ) IMMEDIATE
 2766                           //      Used within a colon-definition in the form:
 2767                           //              BEGIN ... WHILE ... REPEAT
 2768                           //      At run-time, REPEAT forces an unconditional branch back to just
 2769                           //      after the corresponding BEGIN.
 2770                           //
 2771                           //      At compile-time, REPEAT compiles BRANCH and the offset from HERE to
 2772                           //      addr. n_r0 is used for error testing.
 2773                           
 2774                            SECTION .text : CONST (2)
 2775                           REPEAT_NFA:
 2776    00000000 C6                    DC8     0x0C6
 2777    00000001 5245504541            DC8     'REPEA'
 2778    00000006 D4                    DC8     'T'+0x80
 2779    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2780    00000008 ........              DC32    AGAIN_NFA
 2781                           REPEAT:
 2782    0000000C ........              DC32    DOCOL
 2783    00000010 ........              DC32    TOR
 2784    00000014 ........              DC32    TOR
 2785    00000018 ........              DC32    AGAIN
 2786    0000001C ........              DC32    RFROM
 2787    00000020 ........              DC32    RFROM
 2788    00000024 ........              DC32    TWO
 2789    00000028 ........              DC32    SUBB
 2790    0000002C ........              DC32    ENDIF
 2791    00000030 ........              DC32    SEMIS
 2792                           
 2793                           
 2794                           //      WHILE WHILE:    ( f -- ) IMMEDIATE
 2795                           //                      (ad1 nl -- ad1 n1 ad2 n2 ) COMPILE
 2796                           //      Occurs in a colon-definition in the form:
 2797                           //              BEGIN ... WHILE (tp) ... REPEAT
 2798                           //      At run-time, WHILE selects conditional execution based on boolean
 2799                           //      flag f. If f is true (non-zero), WHILE continues execution of the
 2800                           //      true part thru to REPEAT, which then branches back to BEGIN. If f is
 2801                           //      false (zero), execution skips to just after REPEAT, exiting the
 2802                           //      structure.
 2803                           //
 2804                           //      At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the
 2805                           //      reserved offset. The stack values will be resolved by REPEAT.
 2806                           
 2807                            SECTION .text : CONST (2)
 2808                           WHILE_NFA:
 2809    00000000 C5                    DC8     0x0C5
 2810    00000001 5748494C              DC8     'WHIL'
 2811    00000005 C5                    DC8     'E'+0x80
 2812    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2813    00000008 ........              DC32    REPEAT_NFA
 2814                           WHILE:
 2815    0000000C ........              DC32    DOCOL
 2816    00000010 ........              DC32    IF
 2817    00000014 ........              DC32    TWOP
 2818    00000018 ........              DC32    SEMIS
 2819                           
 2820                           
 2821                           //      BEGIN BEGIN:    ( -- addr n_r0 ) IMMEDIATE
 2822                           //      Occurs in a colon-definition in form:
 2823                           //      BEGIN ... UNTIL
 2824                           //      BEGIN ... AGAIN
 2825                           //      BEGIN ... WHILE ... REPEAT
 2826                           //      At run-time, BEGIN marks the start of a sequence that may be
 2827                           //      repetitively executed. It serves as a return point from the
 2828                           //      corresponding UNTIL, AGAIN or REPEAT. When executing UNTIL, a return
 2829                           //      to BEGIN will occur if the top of the stack is false//
 2830                           //      for AGAIN and REPEAT a return to BEGIN always occurs.
 2831                           //
 2832                           //      At compile time BEGIN leaves its return address and n_r0 for compiler
 2833                           //      error checking.
 2834                           
 2835                            SECTION .text : CONST (2)
 2836                           BEGIN_NFA:
 2837    00000000 C5                    DC8     0x0C5
 2838    00000001 42454749              DC8     'BEGI'
 2839    00000005 CE                    DC8     'N'+0x80
 2840    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2841    00000008 ........              DC32    WHILE_NFA
 2842                           BEGIN:
 2843    0000000C ........              DC32    DOCOL
 2844    00000010 ........              DC32    QCOMP
 2845    00000014 ........              DC32    HERE
 2846    00000018 ........              DC32    ONE
 2847    0000001C ........              DC32    SEMIS
 2848                           
 2849                           
 2850                           //=============================== WORDCAT ====================================//
 2851                           //NOEXEC HEADERFORWORDCATEGORIES
 2852                           //      WC_COMPILE_NFA = Inside Colon WORDS: CATEGORY
 2853                           
 2854                            SECTION .text : CONST (2)
 2855                           WC_COMPILE_NFA:
 2856    00000000 97                    DC8     0x80+4+19
 2857    00000001 0D0A                  DC8     0x0D, 0x0A
 2858    00000003 496E736964652         DC8     'Inside Colon WORDS:'
                  0436F6C6F6E20
                  574F5244533A 
 2859    00000016 0D8A                  DC8     0x0D, 0x0A+0x80
 2860                            ALIGNROM 2,0xFFFFFFFF
 2861    00000018 ........              DC32    BEGIN_NFA
 2862                           
 2863                           
 2864                           //      IMMEDIATE IMMED:        ( -- )
 2865                           //      Mark the most recently made definition so that when encountered at
 2866                           //      compile time, it will be executed rather than being compiled. i.e.
 2867                           //      the precedence bit in its header is set.
 2868                           //      This method allows definitions to handle unusual compiling
 2869                           //      situations, rather. than build them into the fundamental compiler.
 2870                           //      The system may force compilation of an immediate definition by
 2871                           //      preceeding it with [COMPILE].
 2872                           
 2873                            SECTION .text : CONST (2)
 2874                           IMMED_NFA:
 2875    00000000 89                    DC8     0x89
 2876    00000001 494D4D4544494         DC8     'IMMEDIAT'
                  154          
 2877    00000009 C5                    DC8     'E'+0x80
 2878    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2879    0000000C ........              DC32    WC_COMPILE_NFA
 2880                           IMMED:
 2881    00000010 ........              DC32    DOCOL
 2882    00000014 ........              DC32    LATEST
 2883    00000018 ........40000         DC32    LIT, 0x40
                  000          
 2884    00000020 ........              DC32    TOGGLE
 2885    00000024 ........              DC32    SEMIS
 2886                           
 2887                           
 2888                           //      CREATE CREATE:  ( -- )
 2889                           //      Create a word in The Dictionary.
 2890                           //      Make searchable and forgetable NFA/LFA, DOCON, ADDR->PFA
 2891                           //      USE <BUILDS with DOES> instead of CREATE.
 2892                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2893                           //
 2894                           //      Saves HERE in CSDP in case there's an error creating a word.
 2895                           //      CSDP is reset when a word is completed, by ; <BUILDS (?) CON and VAR.
 2896                           //
 2897                           //      A defining word used in the form:
 2898                           //              CREATE CCcc
 2899                           //      by such words as VAR, CON AND <BUILDS to create a dictionary header for
 2900                           //      a new word. The code field contains the address of the words
 2901                           //      parameter field.
 2902                           
 2903                            SECTION .text : CONST (2)
 2904                           CREATE_NFA:
 2905    00000000 86                    DC8     0x86
 2906    00000001 4352454154            DC8     'CREAT'
 2907    00000006 C5                    DC8     'E'+0x80
 2908    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2909    00000008 ........              DC32    IMMED_NFA
 2910                           CREATE:
 2911    0000000C ........              DC32    DOCOL
 2912    00000010 ........              DC32    DICTSPACE       //      \ -- n_r0
 2913    00000014 ........0F000         DC32    LIT, 15, SUBB   // One less than smallest definition
                  000........  
 2914    00000020 ........              DC32    ZLESS
 2915    00000024 ........              DC32    ZBRAN
 2916    00000028 08000000              DC32    CREATEOK-.
 2917                           
 2918    0000002C ........              DC32    DICTFULL_ABORT
 2919                           
 2920                           CREATEOK:
 2921    00000030 ........              DC32    DFIND                   // Parse nfa
 2922                           //      -FIND DFIND \ --- pfa len tf (found) \ --- ff (not found)
 2923    00000034 ........              DC32    ZBRAN
 2924    00000038 24000000              DC32     CREA1-.
 2925                           
 2926                           #ifdef IO2TP
 2930                           #endif
 2931    0000003C ........              DC32    DROP
 2932    00000040 ........              DC32    NFA
 2933    00000044 ........              DC32    IDDOT
 2934    00000048 .............         DC32    LIT, msg_wordexists
                  ...          
 2935                           // Nothing created yet so ABORT is correct.
 2936                           //        DC32    ERROR
 2937    00000050 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 2938    00000058 ........              DC32    ABORT
 2939                           
 2940                           CREA1:
 2941                           // Save HERE in CSDP so ERROR can reset DP if this definition fails.
 2942                           // CSDP is reset by SEMIC_CREATE when this definition is completed.
 2943                           // SEMIC_CREATE used in ; CON and VAR to reset CSDP.
 2944                           
 2945                           // This new definitions cstring name has been moved to HERE 
 2946    0000005C .............         DC32    HERE, DUP       // This will become the new CURRENT (this NFA).
                  ...          
 2947    00000064 .............         DC32    CSDP_SV, STORE  // HERE to CSDP to restore in case of error.
                  ...          
 2948                           // Dup HERE-NFA to allot NFAx
 2949    0000006C ........              DC32    DUP
 2950                           // Limit NFA allot to maxwordlen. DOES NOT CHANGE actual count!
 2951                           // If count is larger than MAXWORDLEN behaviour of this def is unpredictable!
 2952    00000070 ........              DC32    CAT
 2953    00000074 ........1F000         DC32    LIT, MAXWORDLEN // ELIMINATED WIDTH AND WIDTH_SV 
                  000          
 2954    0000007C ........              DC32    MIN
 2955    00000080 ........              DC32    ALLOT_PRIM      // HERE (DP) at end of NFA with padding.
 2956                           // Dup HERE-NFA to set count byte, and to be consumed later
 2957                           // for setting CURRENT after previous CURRENT compiled into LFA.
 2958    00000084 ........              DC32    DUP
 2959                           // Make regular (not immediate) NFA count byte
 2960    00000088 ........80000         DC32    LIT, 0x80
                  000          
 2961    00000090 ........              DC32    TOGGLE          // Count Byte = 80+count
 2962                           // HERE is new now. Mark end of NFA for PFIND search
 2963    00000094 ........              DC32    HERE            // DP after allot of NFA
 2964    00000098 ........80000         DC32    LIT,0x80        // Set last character in NFA
                  000          
 2965    000000A0 ........              DC32    TOGGLE          // smudge bit
 2966                           // Bump DP to LFA
 2967    000000A4 .............         DC32    ONE, DP_SV      // MOVE HERE (DP)
                  ...          
 2968    000000AC ........              DC32    PSTORE          // TO LFA
 2969                           // Set LFA
 2970    000000B0 ........              DC32    LATEST          // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
 2971    000000B4 ........              DC32    COMMA           // Compile last words NFA into this link field.
 2972                                                           // DUP'd HERE should be on stack
 2973                           // Have to set CURRENT with last dup's HERE-NFA after LATEST is compiled
 2974    000000B8 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
 2975    000000BC ........              DC32    STORE           // so storing NEWWORD_NFA into CURRENT.
 2976    000000C0 .............         DC32    COMP, DOCON     // Compile DOCON as CFA
                  ...          
 2977    000000C8 .............         DC32    HERE, FOURP     // Compute and
                  ...          
 2978    000000D0 ........              DC32    COMMA           // COMPILE Addr of PFA
 2979                           //      DC32    SMUDGE          // ELIMINATED
 2980                           //      DC32    SEMIC_CREATE    // USED IN CALLERS OF CREATE, NOT HERE!
 2981    000000D4 ........              DC32    SEMIS
 2982                           
 2983                           
 2984                           //      CON CON:        ( n_r0 -- )  MODIFIED: and CONSTANT renamed CON
 2985                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2986                           //      A defining word used in the form:
 2987                           //              n_r0 CONSTANT CCcc
 2988                           //      to create word CCcc, with its parameter field containing n_r0. When
 2989                           //      CCcc is later executed, it will push the value of n_r0 to the stack.
 2990                           
 2991                            SECTION .text : CONST (2)
 2992                           CONSTANT_NFA:
 2993    00000000 88                    DC8     0x88
 2994    00000001 434F4E5354414         DC8     'CONSTAN'
                  E            
 2995    00000008 D4                    DC8     'T'+0x80
 2996    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2997    0000000C ........              DC32    CREATE_NFA
 2998                           CONSTANT:
 2999    00000010 .............         DC32    DOCOL, CON, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3000                           
 3001                           
 3002                            SECTION .text : CONST (2)
 3003                           CON_NFA:
 3004    00000000 83                    DC8     0x83
 3005    00000001 434F                  DC8     'CO'
 3006    00000003 CE                    DC8     'N'+0x80
 3007                            ALIGNROM 2,0xFFFFFFFF
 3008                           //      DC32    CREATE_NFA
 3009    00000004 ........              DC32    CONSTANT_NFA
 3010                           CON:
 3011    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3012    0000000C ........              DC32    CREATE  // Make Header NFA/LFA, DOCON, ADDR->PFA
 3013    00000010 ........FCFFF         DC32    LIT, -4, DP_SV, PSTORE  // back up to ADDR->PFA
                  FFF..........
                  ......       
 3014    00000020 ........              DC32    COMMA                   // Replace with Con value
 3015    00000024 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3016                           //        DC32    DOTDICTSPACE
 3017    00000028 ........              DC32    SEMIS
 3018                           
 3019                           
 3020                           //      VAR VAR:        ( -- ) RENAMED: VARIABLE to VAR
 3021                           //      IF RAMVARSPACE FULL PRINT Error MESSAGE AND Abort.
 3022                           //      A defining word used in the form:
 3023                           //              VARIABLE CCcc
 3024                           //      When VARIABLE is executed, it creates the definition CCcc with its
 3025                           //      with its cell space uninitialized. When CCcc is executed,
 3026                           //      its cell space address is put on the stack. Use with @ or !
 3027                           //      NOTE: VAR's cell space is allocated in ram. See UP and VARALLOT.
 3028                           
 3029                            SECTION .text : CONST (2)
 3030                           VARIABLE_NFA:
 3031    00000000 88                    DC8     0x88
 3032    00000001 5641524941424         DC8     'VARIABL'
                  C            
 3033    00000008 C5                    DC8     'E'+0x80
 3034    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3035    0000000C ........              DC32    CON_NFA
 3036                           VARIABLE:
 3037    00000010 .............         DC32    DOCOL, VAR_, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3038                           
 3039                            SECTION .text : CONST (2)
 3040                           VAR_NFA:
 3041    00000000 83                    DC8     0x83
 3042    00000001 5641                  DC8     'VA'
 3043    00000003 D2                    DC8     'R'+0x80
 3044                            ALIGNROM 2,0xFFFFFFFF
 3045                           //      DC32    CON_NFA
 3046    00000004 ........              DC32    VARIABLE_NFA
 3047                           VAR_:
 3048    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3049    0000000C ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3050    00000010 ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3051    00000020 .............         DC32    COMP, DOVAR     // CFA of VAR's
                  ...          
 3052                           //        DC32    COMP, DOCON     // CFA of VAR's
 3053                           // aligned, INCREMENTS DP REFLECTED by HERE
 3054                           // compile the value \ v --
 3055    00000028 ........              DC32    ONE
 3056    0000002C ........              DC32    VARALLOT        // Do .VS check and return VAR addr.
 3057    00000030 ........              DC32    COMMA           // Compile address of the ram allotment.
 3058    00000034 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3059                           //        DC32    DOTDICTSPACE
 3060                           //        DC32    DOTVARSPACE
 3061    00000038 ........              DC32    SEMIS
 3062                           
 3063                           
 3064                           //      ; SEMI: ( -- ) IMMEDIATE
 3065                           //      Terminate a colon-definition and stop further compilation.
 3066                           //      Compiles the run-time ;S.
 3067                           
 3068                            SECTION .text : CONST (2)
 3069                           SEMI_NFA:
 3070    00000000 C1                    DC8     0x0C1
 3071    00000001 BB                    DC8     ';'+0x80
 3072    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3073    00000004 ........              DC32    VAR_NFA
 3074                           SEMI:
 3075    00000008 ........              DC32    DOCOL
 3076    0000000C ........              DC32    QCSP
 3077    00000010 ........              DC32    COMP
 3078    00000014 ........              DC32    SEMIS
 3079    00000018 ........              DC32    LBRAC
 3080    0000001C ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3081                           //        DC32    DOTDICTSPACE
 3082    00000020 ........              DC32    SEMIS
 3083                           
 3084                           
 3085                           //      : COLON:        ( -- ) IMMEDIATE
 3086                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 3087                           //      Used in the form called a colon-definition:
 3088                           //              : CCcc     ...     //
 3089                           //      Creates a dictionary entry defining CCcc as equivalent to the
 3090                           //      following sequence of Forth word definitions '...' until the next
 3091                           //      ';' or ';CODE'.
 3092                           //      The compiling process is done by the text interpreter as long as
 3093                           //      STATE is non-zero. Other details are that the CONTEXT vocabulary is
 3094                           //      set to the CURRENT vocabulary and that words with the precedence bit
 3095                           //      set (P) are executed rather than being compiled.
 3096                           
 3097                            SECTION .text : CONST (2)
 3098                           COLON_NFA:
 3099    00000000 C1                    DC8     0x0C1
 3100    00000001 BA                    DC8     ':'+0x80
 3101    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3102    00000004 ........              DC32    SEMI_NFA
 3103                           COLON:
 3104    00000008 ........              DC32    DOCOL
 3105                           //      DICTSPACE TEST DONE IN CREATE
 3106    0000000C ........              DC32    QEXEC
 3107    00000010 ........              DC32    SCSP    // Save the stack position in CSP. Compiler security.
 3108    00000014 ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3109    00000018 ........              DC32    RBRAC   // Resume compiliting by setting STATE_SV to 0xC0
 3110    0000001C ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3111    0000002C .............         DC32    COMP, DOCOL     // aligned, INCREMENTS DP REFLECTED by HERE
                  ...          
 3112    00000034 ........              DC32    SEMIS
 3113                           
 3114                           
 3115                           //=============================== WORDCAT ====================================//
 3116                           //NOEXEC HEADERFORWORDCATEGORIES
 3117                           //      WC_CREATE_NFA = CREATE WORDS With: CATEGORY
 3118                           
 3119                            SECTION .text : CONST (2)
 3120                           WC_CREATE_NFA:
 3121    00000000 96                    DC8     0x80+22
 3122    00000001 0D0A                  DC8     0x0D, 0x0A
 3123    00000003 4352454154452         DC8     'CREATE WORDS With:'
                  0574F52445320
                  576974683A   
 3124    00000015 0D8A                  DC8     0x0D, 0x0A+0x80
 3125    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 3126    00000018 ........              DC32    COLON_NFA
 3127                           
 3128                           //      DABS DABS: ( sd=(LSW MSW) -- ud=(LSW MSW) )
 3129                           //      Leave the absolute value ud of a signed double number.
 3130                           
 3131                            SECTION .text : CONST (2)
 3132                           DABS_NFA:
 3133    00000000 84                    DC8     0x84
 3134    00000001 444142                DC8     'DAB'
 3135    00000004 D3                    DC8     'S'+0x80
 3136    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3137    00000008 ........              DC32    WC_CREATE_NFA
 3138                           DABSF:
 3139                           DABS:
 3140    0000000C ........              DC32    DOCOL
 3141    00000010 ........              DC32    DUP
 3142    00000014 ........              DC32    DPM
 3143    00000018 ........              DC32    SEMIS
 3144                           
 3145                           
 3146                           //      DNEGATE DNEGATE: ( d1 -- d<2>=(LSW MSW) ) RENAMED: DMINUS to DNEGATE
 3147                           //      Convert d1 to its double number two's complement d2.
 3148                           
 3149                            SECTION .text : CONST (2)
 3150                           DNEGATE_NFA:
 3151    00000000 87                    DC8     0x87
 3152    00000001 444E45474154          DC8     'DNEGAT'
 3153    00000007 C5                    DC8     'E'+0x80
 3154                            ALIGNROM 2,0xFFFFFFFF
 3155    00000008 ........              DC32    DABS_NFA
 3156                           DNEGATE:
 3157    0000000C ........              DC32    .+5
 3158                            SECTION .text : CODE (2)
 3159                                   POP2t                   // MSW   //POP  BX
 3159.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3159.2                         //#ifndef TOSCT
 3159.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3159.4                         //#endif
 3159.5                         //      ADDS    p, p, #4
 3159.6                                 ENDM
 3160                                   POP2w                   // LSW   //POP  CX
 3160.1  00000004 57F8042B              LDR     w, [p],#4
 3160.2                         //      LDR     w, [p]
 3160.3                         //      ADDS    p, p, #4
 3160.4                                 ENDM
 3161    00000008 C043                  MVNS    t, t            // negate MSW
 3162    0000000A D243                  MVNS    w, w            // negate LSW
 3163    0000000C 521C                  ADDS    w, w, #1        // add 1 to LSW
 3164                                   DPUSH                   //  --  LSW MSW )
 3164                                   PUSHw   // push w to p, post decrement p
 3164.1  0000000E 47F8042D              STR     w, [p, #-4]!
 3164.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3164.3                         //      STR     w, [p]
 3164.4                                 ENDM
 3164                                   TPUSH
 3164                                   PUSHt   // push t to p, pre decrement p
 3164.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3164.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3164.3                         //      STR     t, [p]
 3164.4                                 ENDM
 3164                                   NEXT
 3164.1                         // ARMv7-M Thumb = .+5
 3164.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3164.3                         // ARMv6-M Thumb = .+4
 3164.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3164                                   NEXT1
 3164.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3164.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3164.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3164.4                         // ARMv6-M Thumb = .+4
 3164.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3164.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3164.7                                 ENDM
 3164.8                                 ENDM
 3164.9                                 ENDM
 3164.10                                ENDM
 3165                           
 3166                           
 3167                           //      DPL_SV: ( -- addr of NDPL ) Contains # of digits after . in double number
 3168                           //      A system variable containing the number of digits to the right of the
 3169                           //      decimal on double integer input. It may also be used to hold output
 3170                           //      column location of a decimal point, in system generated formating. The
 3171                           //      default value on single number input is -1.
 3172                            SECTION .text : CONST (2)
 3173                           DPL_NFA:
 3174    00000000 83                    DC8     0x83
 3175    00000001 4450                  DC8     'DP'
 3176    00000003 CC                    DC8     'L'+0x80
 3177                            ALIGNROM 2,0xFFFFFFFF
 3178    00000004 ........              DC32    DNEGATE_NFA
 3179                           DPL_SV:
 3180    00000008 .............         DC32    DOCON, NDPL
                  ...          
 3181                           
 3182                           
 3183                           //      D.R DDOTR:      ( sd=<LSW MSW> n_r0 -- ) SIGNED:
 3184                           //      Print a signed double number sd right aligned
 3185                           //      in a field n_r0 characters wide.
 3186                           
 3187                            SECTION .text : CONST (2)
 3188                           DDOTR_NFA:
 3189    00000000 83                    DC8     0x83
 3190    00000001 442E                  DC8     'D.'
 3191    00000003 D2                    DC8     'R'+0x80
 3192                            ALIGNROM 2,0xFFFFFFFF
 3193    00000004 ........              DC32    DPL_NFA
 3194                           DDOTR:
 3195    00000008 ........              DC32    DOCOL
 3196    0000000C ........              DC32    TOR     // N CHAR FIELD LEN to r
 3197    00000010 ........              DC32    SWAP    // ( LSW MSW -- MSW LSW )
 3198    00000014 ........              DC32    OVER    // ( MSW LSW -- MSW LSW MSW )
 3199    00000018 ........              DC32    DABS    // ( MSW LSW MSW -- MSW uLSW uMSW )
 3200    0000001C ........              DC32    BDIGS   // <# SET HLD to Pad
 3201    00000020 ........              DC32    DIGS    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3202    00000024 ........              DC32    SIGN    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3203    00000028 ........              DC32    EDIGS   //      #>  ( d=<LSW MSW>  ---  addr  count )
 3204    0000002C ........              DC32    RFROM   // GET THE N CHAR FIELD LEN
 3205    00000030 ........              DC32    OVER    // ( addr count n_r0 -- addr count n_r0 count )
 3206    00000034 ........              DC32    SUBB    // ( n_r0 addr count addr -- n_r0 addr coun_r0t-n )
 3207    00000038 ........              DC32    SPACES  // SPACES  ( n_r0 -- )
 3208    0000003C ........              DC32    TYPE    // ( n_r0 addr -- )
 3209    00000040 ........              DC32    SEMIS
 3210                           
 3211                           
 3212                           //      D. DDOT:        ( S32-2'S COMPLEMET = (d=<LSW MSW> -- )
 3213                           //      Print a signed double number from a 32 bit two's complement value.
 3214                           //      The high-order 32 bits are most accessable on the stack. Conversion
 3215                           //      is performed according to the current base. A blank follows.
 3216                           
 3217                            SECTION .text : CONST (2)
 3218                           DDOT_NFA:
 3219    00000000 82                    DC8     0x82
 3220    00000001 44                    DC8     'D'
 3221    00000002 AE                    DC8     '.'+0x80
 3222    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3223    00000004 ........              DC32    DDOTR_NFA
 3224                           DDOT:
 3225    00000008 ........              DC32    DOCOL
 3226    0000000C ........              DC32    ZERO
 3227    00000010 ........              DC32    DDOTR
 3228    00000014 ........              DC32    SPACE
 3229    00000018 ........              DC32    SEMIS
 3230                           
 3231                           
 3232                           //      D+ DPLUS:       ( LSW1 MSW1 LSW2 MSW2 --- LSW MSW )  SIGNED:
 3233                           //      Leave the signed double number sum of two signed double numbers.
 3234                           
 3235                            SECTION .text : CONST (2)
 3236                           DPLUS_NFA:
 3237    00000000 82                    DC8     0x82
 3238    00000001 44                    DC8     'D'
 3239    00000002 AB                    DC8     '+'+0x80
 3240    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3241    00000004 ........              DC32    DDOT_NFA
 3242                           DPLUS:
 3243    00000008 ........              DC32    .+5
 3244                            SECTION .text : CODE (2)
 3245                                   POP2t   //    ldr     t, [p],#4       // MS
 3245.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3245.2                         //#ifndef TOSCT
 3245.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3245.4                         //#endif
 3245.5                         //      ADDS    p, p, #4
 3245.6                                 ENDM
 3246                                   POP2n   //    ldr     n, [p],#4       // LS
 3246.1  00000004 57F8041B              LDR     n, [p],#4
 3246.2                         //      LDR     n, [p]
 3246.3                         //      ADDS    p, p, #4
 3246.4                                 ENDM
 3247                                   POP2x   //    ldr     x, [p],#4       // MS
 3247.1  00000008 57F8043B              LDR     x, [p],#4
 3247.2                         //      LDR     x, [p]
 3247.3                         //      ADDS    p, p, #4
 3247.4                                 ENDM
 3248                                   POP2w   //    ldr     w, [p],#4       // LS
 3248.1  0000000C 57F8042B              LDR     w, [p],#4
 3248.2                         //      LDR     w, [p]
 3248.3                         //      ADDS    p, p, #4
 3248.4                                 ENDM
 3249    00000010 5218                  ADDS    w, w, n         // LS sum, set status flags
 3250    00000012 5841                  ADCS    t, t, x         // MS sum + carry
 3251                                   DPUSH                   //  --  LSW MSW )
 3251                                   PUSHw   // push w to p, post decrement p
 3251.1  00000014 47F8042D              STR     w, [p, #-4]!
 3251.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3251.3                         //      STR     w, [p]
 3251.4                                 ENDM
 3251                                   TPUSH
 3251                                   PUSHt   // push t to p, pre decrement p
 3251.1  00000018 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3251.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3251.3                         //      STR     t, [p]
 3251.4                                 ENDM
 3251                                   NEXT
 3251.1                         // ARMv7-M Thumb = .+5
 3251.2  0000001C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3251.3                         // ARMv6-M Thumb = .+4
 3251.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3251                                   NEXT1
 3251.1  00000020 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3251.2  00000024 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3251.3  00000028 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3251.4                         // ARMv6-M Thumb = .+4
 3251.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3251.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3251.7                                 ENDM
 3251.8                                 ENDM
 3251.9                                 ENDM
 3251.10                                ENDM
 3252                           
 3253                           
 3254                           //      S->D STOD:      ( n_r0 -- d=<LSW MSW> ) SIGNED:
 3255                           //      Sign extend a single number to form a double number.
 3256                           //      : S->D DUP 0< NEGATE // hi level equivalent
 3257                           
 3258                            SECTION .text : CONST (2)
 3259                           STOD_NFA:
 3260    00000000 84                    DC8     0x84
 3261    00000001 532D3E                DC8     'S->'
 3262    00000004 C4                    DC8     'D'+0x80
 3263    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3264    00000008 ........              DC32    DPLUS_NFA
 3265                           STOD:
 3266    0000000C ........              DC32    .+5
 3267                            SECTION .text : CODE (2)
 3268                                   POP2w                   // POP LSW
 3268.1  00000000 57F8042B              LDR     w, [p],#4
 3268.2                         //      LDR     w, [p]
 3268.3                         //      ADDS    p, p, #4
 3268.4                                 ENDM
 3269    00000004 4040                  EORS    t, t            // Zero MSW
 3270    00000006 1243                  ORRS    w, w, w         // OR LSW
 3271    00000008 00D5                  BPL     STOD1           // LSW is POS
 3272                           
 3273    0000000A 401E                  SUBS     t, t, #1       // LSW is NEG
 3274                           STOD1:
 3275                                   DPUSH                   //  --  LSW MSW )
 3275                                   PUSHw   // push w to p, post decrement p
 3275.1  0000000C 47F8042D              STR     w, [p, #-4]!
 3275.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3275.3                         //      STR     w, [p]
 3275.4                                 ENDM
 3275                                   TPUSH
 3275                                   PUSHt   // push t to p, pre decrement p
 3275.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3275.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3275.3                         //      STR     t, [p]
 3275.4                                 ENDM
 3275                                   NEXT
 3275.1                         // ARMv7-M Thumb = .+5
 3275.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3275.3                         // ARMv6-M Thumb = .+4
 3275.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3275                                   NEXT1
 3275.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3275.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3275.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3275.4                         // ARMv6-M Thumb = .+4
 3275.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3275.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3275.7                                 ENDM
 3275.8                                 ENDM
 3275.9                                 ENDM
 3275.10                                ENDM
 3276                           
 3277                           
 3278                           //      2* TWOSTAR:     ( n_r0 -- n_r0*2 ) LSL 1
 3279                           
 3280                            SECTION .text : CONST (2)
 3281                           TWOSTAR_NFA:
 3282    00000000 82                    DC8     0x82
 3283    00000001 32                    DC8     '2'
 3284    00000002 AA                    DC8     '*'+0x80
 3285    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3286    00000004 ........              DC32    STOD_NFA
 3287                           TWOSTAR:
 3288    00000008 ........              DC32    .+5
 3289                            SECTION .text : CODE (2)
 3290                                   POP2t
 3290.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3290.2                         //#ifndef TOSCT
 3290.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3290.4                         //#endif
 3290.5                         //      ADDS    p, p, #4
 3290.6                                 ENDM
 3291    00000004 4000                  LSLS    t, t, #1        //
 3292                                   TPUSH
 3292                                   PUSHt   // push t to p, pre decrement p
 3292.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3292.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3292.3                         //      STR     t, [p]
 3292.4                                 ENDM
 3292                                   NEXT
 3292.1                         // ARMv7-M Thumb = .+5
 3292.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3292.3                         // ARMv6-M Thumb = .+4
 3292.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3292                                   NEXT1
 3292.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3292.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3292.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3292.4                         // ARMv6-M Thumb = .+4
 3292.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3292.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3292.7                                 ENDM
 3292.8                                 ENDM
 3292.9                                 ENDM
 3293                           
 3294                           
 3295                           //      2/ TWOSLASH:    ( n_r0 -- n_r0/1 ) ASR 1 (FLOORED)
 3296                           
 3297                            SECTION .text : CONST (2)
 3298                           TWOSLASH_NFA:
 3299    00000000 82                    DC8     0x82
 3300    00000001 32                    DC8     '2'
 3301    00000002 AF                    DC8     '/'+0x80
 3302    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3303    00000004 ........              DC32    TWOSTAR_NFA
 3304                           TWOSLASH:
 3305    00000008 ........              DC32    .+5
 3306                            SECTION .text : CODE (2)
 3307                                   POP2t
 3307.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3307.2                         //#ifndef TOSCT
 3307.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3307.4                         //#endif
 3307.5                         //      ADDS    p, p, #4
 3307.6                                 ENDM
 3308    00000004 4010                  ASRS    t, t, #1        //
 3309                                   TPUSH
 3309                                   PUSHt   // push t to p, pre decrement p
 3309.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3309.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3309.3                         //      STR     t, [p]
 3309.4                                 ENDM
 3309                                   NEXT
 3309.1                         // ARMv7-M Thumb = .+5
 3309.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3309.3                         // ARMv6-M Thumb = .+4
 3309.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3309                                   NEXT1
 3309.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3309.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3309.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3309.4                         // ARMv6-M Thumb = .+4
 3309.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3309.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3309.7                                 ENDM
 3309.8                                 ENDM
 3309.9                                 ENDM
 3310                                   
 3311                           
 3312                           //      1- ONEM:        ( n_r0 -- n_r0-1 )
 3313                           
 3314                            SECTION .text : CONST (2)
 3315                           ONEM_NFA:
 3316    00000000 82                    DC8     0x82
 3317    00000001 31                    DC8     '1'
 3318    00000002 AD                    DC8     '-'+0x80
 3319    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3320    00000004 ........              DC32    TWOSLASH_NFA
 3321                           ONEM:
 3322    00000008 ........              DC32    .+5
 3323                            SECTION .text : CODE (2)
 3324                                   POP2t
 3324.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3324.2                         //#ifndef TOSCT
 3324.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3324.4                         //#endif
 3324.5                         //      ADDS    p, p, #4
 3324.6                                 ENDM
 3325    00000004 401E                  SUBS    t, t, #1        //
 3326                                   TPUSH
 3326                                   PUSHt   // push t to p, pre decrement p
 3326.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3326.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3326.3                         //      STR     t, [p]
 3326.4                                 ENDM
 3326                                   NEXT
 3326.1                         // ARMv7-M Thumb = .+5
 3326.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3326.3                         // ARMv6-M Thumb = .+4
 3326.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3326                                   NEXT1
 3326.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3326.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3326.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3326.4                         // ARMv6-M Thumb = .+4
 3326.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3326.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3326.7                                 ENDM
 3326.8                                 ENDM
 3326.9                                 ENDM
 3327                           
 3328                           
 3329                           //      1+ ONEP:        ( n -- n+1 )
 3330                           
 3331                            SECTION .text : CONST (2)
 3332                           ONEP_NFA:
 3333    00000000 82                    DC8     0x82
 3334    00000001 31                    DC8     '1'
 3335    00000002 AB                    DC8     '+'+0x80
 3336    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3337    00000004 ........              DC32    ONEM_NFA
 3338                           ONEP:
 3339    00000008 ........              DC32    .+5
 3340                            SECTION .text : CODE (2)
 3341                                   POP2t
 3341.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3341.2                         //#ifndef TOSCT
 3341.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3341.4                         //#endif
 3341.5                         //      ADDS    p, p, #4
 3341.6                                 ENDM
 3342    00000004 401C                  ADDS    t, t, #1        //
 3343                                   TPUSH
 3343                                   PUSHt   // push t to p, pre decrement p
 3343.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3343.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3343.3                         //      STR     t, [p]
 3343.4                                 ENDM
 3343                                   NEXT
 3343.1                         // ARMv7-M Thumb = .+5
 3343.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3343.3                         // ARMv6-M Thumb = .+4
 3343.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3343                                   NEXT1
 3343.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3343.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3343.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3343.4                         // ARMv6-M Thumb = .+4
 3343.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3343.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3343.7                                 ENDM
 3343.8                                 ENDM
 3343.9                                 ENDM
 3344                           
 3345                           
 3346                           //      2+ TWOP:        ( n -- n+2 )
 3347                           
 3348                            SECTION .text : CONST (2)
 3349                           TWOP_NFA:
 3350    00000000 82                    DC8     0x82
 3351    00000001 32                    DC8     '2'
 3352    00000002 AB                    DC8     '+'+0x80
 3353    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3354    00000004 ........              DC32    ONEP_NFA
 3355                           TWOP:
 3356    00000008 ........              DC32    .+5
 3357                            SECTION .text : CODE (2)
 3358                                   POP2t
 3358.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3358.2                         //#ifndef TOSCT
 3358.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3358.4                         //#endif
 3358.5                         //      ADDS    p, p, #4
 3358.6                                 ENDM
 3359    00000004 801C                  ADDS    t, t, #2
 3360                                   TPUSH
 3360                                   PUSHt   // push t to p, pre decrement p
 3360.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3360.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3360.3                         //      STR     t, [p]
 3360.4                                 ENDM
 3360                                   NEXT
 3360.1                         // ARMv7-M Thumb = .+5
 3360.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3360.3                         // ARMv6-M Thumb = .+4
 3360.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3360                                   NEXT1
 3360.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3360.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3360.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3360.4                         // ARMv6-M Thumb = .+4
 3360.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3360.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3360.7                                 ENDM
 3360.8                                 ENDM
 3360.9                                 ENDM
 3361                           
 3362                           
 3363                           //      4+ FOURP:       ( n_r0 -- n_r0+4 )
 3364                           
 3365                            SECTION .text : CONST (2)
 3366                           FOURP_NFA:
 3367    00000000 82                    DC8     0x82
 3368    00000001 34                    DC8     '4'
 3369    00000002 AB                    DC8     '+'+0x80
 3370    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3371    00000004 ........              DC32    TWOP_NFA
 3372                           FOURP:
 3373    00000008 ........              DC32    .+5
 3374                            SECTION .text : CODE (2)
 3375                                   POP2t
 3375.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3375.2                         //#ifndef TOSCT
 3375.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3375.4                         //#endif
 3375.5                         //      ADDS    p, p, #4
 3375.6                                 ENDM
 3376    00000004 001D                  ADDS    t, t, #4
 3377                                   TPUSH
 3377                                   PUSHt   // push t to p, pre decrement p
 3377.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3377.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3377.3                         //      STR     t, [p]
 3377.4                                 ENDM
 3377                                   NEXT
 3377.1                         // ARMv7-M Thumb = .+5
 3377.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3377.3                         // ARMv6-M Thumb = .+4
 3377.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3377                                   NEXT1
 3377.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3377.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3377.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3377.4                         // ARMv6-M Thumb = .+4
 3377.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3377.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3377.7                                 ENDM
 3377.8                                 ENDM
 3377.9                                 ENDM
 3378                           
 3379                           
 3380                           //      4- FOURM:       ( n_r0 -- n_r0-4 )
 3381                           
 3382                            SECTION .text : CONST (2)
 3383                           FOURM_NFA:
 3384    00000000 82                    DC8     0x82
 3385    00000001 34                    DC8     '4'
 3386    00000002 AD                    DC8     '-'+0x80
 3387    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3388    00000004 ........              DC32    FOURP_NFA
 3389                           FOURM:
 3390    00000008 ........              DC32    .+5
 3391                            SECTION .text : CODE (2)
 3392                                   POP2t
 3392.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3392.2                         //#ifndef TOSCT
 3392.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3392.4                         //#endif
 3392.5                         //      ADDS    p, p, #4
 3392.6                                 ENDM
 3393    00000004 001F                  SUBS    t, t, #4
 3394                                   TPUSH
 3394                                   PUSHt   // push t to p, pre decrement p
 3394.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3394.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3394.3                         //      STR     t, [p]
 3394.4                                 ENDM
 3394                                   NEXT
 3394.1                         // ARMv7-M Thumb = .+5
 3394.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3394.3                         // ARMv6-M Thumb = .+4
 3394.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3394                                   NEXT1
 3394.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3394.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3394.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3394.4                         // ARMv6-M Thumb = .+4
 3394.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3394.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3394.7                                 ENDM
 3394.8                                 ENDM
 3394.9                                 ENDM
 3395                           
 3396                           
 3397                           //      0 ZERO: ( -- 0 )
 3398                           
 3399                            SECTION .text : CONST (2)
 3400                           ZERO_NFA:
 3401    00000000 81                    DC8     0x81
 3402    00000001 B0                    DC8     '0'+0x80
 3403    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3404    00000004 ........              DC32    FOURM_NFA
 3405                           ZERO:
 3406    00000008 ........00000         DC32    DOCON, 0
                  000          
 3407                           
 3408                           
 3409                           //      1 ONE: ( -- 1 )
 3410                           
 3411                            SECTION .text : CONST (2)
 3412                           ONE_NFA:
 3413    00000000 81                    DC8     0x81
 3414    00000001 B1                    DC8     '1'+0x80
 3415    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3416    00000004 ........              DC32    ZERO_NFA
 3417                           ONE:
 3418    00000008 ........01000         DC32    DOCON, 1
                  000          
 3419                           
 3420                           
 3421                           //      2 TWO: ( -- 2 )
 3422                           
 3423                            SECTION .text : CONST (2)
 3424                           TWO_NFA:
 3425    00000000 81                    DC8     0x81
 3426    00000001 B2                    DC8     '2'+0x80
 3427    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3428    00000004 ........              DC32    ONE_NFA
 3429                           TWO:
 3430    00000008 ........02000         DC32    DOCON, 2
                  000          
 3431                           
 3432                           
 3433                           //      3 THREE: ( -- 3 )
 3434                           
 3435                            SECTION .text : CONST (2)
 3436                           THREE_NFA:
 3437    00000000 81                    DC8     0x81
 3438    00000001 B3                    DC8     '3'+0x80
 3439    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3440    00000004 ........              DC32    TWO_NFA
 3441                           THREE:
 3442    00000008 ........03000         DC32    DOCON, 3
                  000          
 3443                           
 3444                           
 3445                           //      4 FOUR: ( -- 4 )
 3446                           
 3447                            SECTION .text : CONST (2)
 3448                           FOUR_NFA:
 3449    00000000 81                    DC8     0x81
 3450    00000001 B4                    DC8     '4'+0x80
 3451    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3452    00000004 ........              DC32    THREE_NFA
 3453                           FOUR:
 3454    00000008 ........04000         DC32    DOCON, 4
                  000          
 3455                           
 3456                           
 3457                           //      M* MSTAR:       ( n1 n2 -- d=<S32LSW S32MSW> )  SIGNED:
 3458                           //      A mixed magnitude math operation which leaves the double number
 3459                           //      signed product of two signed number.
 3460                           
 3461                            SECTION .text : CONST (2)
 3462                           MSTAR_NFA:
 3463    00000000 82                    DC8     0x82
 3464    00000001 4D                    DC8     'M'
 3465    00000002 AA                    DC8     '*'+0x80
 3466    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3467    00000004 ........              DC32    FOUR_NFA
 3468                           MSTAR:
 3469    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3470    00000010 ........              DC32    XORR
 3471    00000014 ........              DC32    TOR
 3472    00000018 ........              DC32    ABS
 3473    0000001C ........              DC32    SWAP
 3474    00000020 ........              DC32    ABS
 3475    00000024 ........              DC32    USTAR
 3476    00000028 ........              DC32    RFROM
 3477    0000002C ........              DC32    DPM
 3478    00000030 ........              DC32    SEMIS
 3479                           
 3480                           
 3481                           //      M/ MSLASH:      ( sd  n1  ---  d=<s32REM  S32QUO> )
 3482                           //      A mixed magnitude math operator which leaves the signed remainder
 3483                           //      and signed quotient from sd, a double number dividend and divisor n1.
 3484                           //      The remainder takes its sign from the dividend.
 3485                           
 3486                            SECTION .text : CONST (2)
 3487                           MSLASH_NFA:
 3488    00000000 82                    DC8     0x82
 3489    00000001 4D                    DC8     'M'
 3490    00000002 AF                    DC8     '/'+0x80
 3491    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3492    00000004 ........              DC32    MSTAR_NFA
 3493                           MSLASH:
 3494    00000008 ........              DC32    DOCOL
 3495    0000000C ........              DC32    OVER
 3496    00000010 ........              DC32    TOR
 3497    00000014 ........              DC32    TOR
 3498    00000018 ........              DC32    DABS    // ( LSW MSW -- uLSW uMSW )
 3499    0000001C ........              DC32    R
 3500    00000020 ........              DC32    ABS
 3501    00000024 ........              DC32    USLASH
 3502    00000028 ........              DC32    RFROM
 3503    0000002C ........              DC32    R
 3504    00000030 ........              DC32    XORR
 3505    00000034 ........              DC32    PM
 3506    00000038 ........              DC32    SWAP
 3507    0000003C ........              DC32    RFROM
 3508    00000040 ........              DC32    PM
 3509    00000044 ........              DC32    SWAP
 3510    00000048 ........              DC32    SEMIS
 3511                           
 3512                           
 3513                           //      * STAR: ( n1 n2 -- prod=n3 )
 3514                           //      Leave the signed product n3 of two (32bit) signed numbers n1 and n2.
 3515                           
 3516                            SECTION .text : CONST (2)
 3517                           STAR_NFA:
 3518    00000000 81                    DC8     0x81
 3519    00000001 AA                    DC8     '*'+0x80
 3520    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3521    00000004 ........              DC32    MSLASH_NFA
 3522                           STAR:
 3523    00000008 ........              DC32    DOCOL
 3524    0000000C ........              DC32    MSTAR
 3525    00000010 ........              DC32    DROP
 3526    00000014 ........              DC32    SEMIS
 3527                           
 3528                           
 3529                           //      /MOD SLMOD:     ( n1 n2 -- rem quot )   SIGNED:
 3530                           //      Leave the remainder and signed quotient of n1/n2. The remainder has
 3531                           //      the sign of the dividend.
 3532                           
 3533                            SECTION .text : CONST (2)
 3534                           SLMOD_NFA:
 3535    00000000 84                    DC8     0x84
 3536    00000001 2F4D4F                DC8     '/MO'
 3537    00000004 C4                    DC8     'D'+0x80
 3538    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3539    00000008 ........              DC32    STAR_NFA
 3540                           SLMOD:
 3541    0000000C ........              DC32    DOCOL
 3542    00000010 ........              DC32    TOR
 3543    00000014 ........              DC32    STOD
 3544    00000018 ........              DC32    RFROM
 3545    0000001C ........              DC32    MSLASH
 3546    00000020 ........              DC32    SEMIS
 3547                           
 3548                           
 3549                           //      / SLASH:        ( sn1 sn2 -- sn ) SIGNED:
 3550                           //      Leave the signed quotient sn of sn1/sn2.
 3551                           
 3552                            SECTION .text : CONST (2)
 3553                           SLASH_NFA:
 3554    00000000 81                    DC8     0x81
 3555    00000001 AF                    DC8     '/'+0x80
 3556    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3557    00000004 ........              DC32    SLMOD_NFA
 3558                           SLASH:
 3559    00000008 ........              DC32    DOCOL
 3560    0000000C ........              DC32    SLMOD
 3561    00000010 ........              DC32    SWAP
 3562    00000014 ........              DC32    DROP
 3563    00000018 ........              DC32    SEMIS
 3564                           
 3565                           
 3566                           //      MOD MOD:        ( sn1 n2 -- modulo )
 3567                           //      Leave the remainder of sn1/n2, with the same sign as sn1.
 3568                           
 3569                            SECTION .text : CONST (2)
 3570                           MODD_NFA:
 3571    00000000 83                    DC8     0x83
 3572    00000001 4D4F                  DC8     'MO'
 3573    00000003 C4                    DC8     'D'+0x80
 3574                            ALIGNROM 2,0xFFFFFFFF
 3575    00000004 ........              DC32    SLASH_NFA
 3576                           MOD:
 3577    00000008 ........              DC32    DOCOL
 3578    0000000C ........              DC32    SLMOD
 3579    00000010 ........              DC32    DROP
 3580    00000014 ........              DC32    SEMIS
 3581                           
 3582                           
 3583                           //      */MOD SSMOD:    ( n1 n2 n3 -- n4 n5 )
 3584                           //      Leave the quotient n5 and remainder n4 of the operation n1*n2/n3 A
 3585                           //      31 bit intermediate product is used as for */.
 3586                           
 3587                            SECTION .text : CONST (2)
 3588                           SSMOD_NFA:
 3589    00000000 85                    DC8     0x85
 3590    00000001 2A2F4D4F              DC8     '*/MO'
 3591    00000005 C4                    DC8     'D'+0x80
 3592    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 3593    00000008 ........              DC32    MODD_NFA
 3594                           SSMOD:
 3595    0000000C ........              DC32    DOCOL
 3596    00000010 ........              DC32    TOR
 3597    00000014 ........              DC32    MSTAR
 3598    00000018 ........              DC32    RFROM
 3599    0000001C ........              DC32    MSLASH
 3600    00000020 ........              DC32    SEMIS
 3601                           
 3602                           
 3603                           //      */ SSLASH:      ( n1 n2 n3 -- n4 )
 3604                           //      Leave the ratio n4 = n1*n2/n3 where all are signed numbers.
 3605                           //      Retention of an intermediate 31 bit product permits greater accuracy
 3606                           //      than would. be available with the sequence:
 3607                           //              n1  n2  *  n3  /
 3608                           
 3609                            SECTION .text : CONST (2)
 3610                           SSLASH_NFA:
 3611    00000000 82                    DC8     0x82
 3612    00000001 2A                    DC8     '*'
 3613    00000002 AF                    DC8     '/'+0x80
 3614    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3615    00000004 ........              DC32    SSMOD_NFA
 3616                           SSLASH:
 3617    00000008 ........              DC32    DOCOL
 3618    0000000C ........              DC32    SSMOD
 3619    00000010 ........              DC32    SWAP
 3620    00000014 ........              DC32    DROP
 3621    00000018 ........              DC32    SEMIS
 3622                           
 3623                           
 3624                           //      + PLUS: ( n1 n2 -- n3 )
 3625                           //      Add n1 and n2, leaving sum n3
 3626                           
 3627                            SECTION .text : CONST (2)
 3628                           PLUS_NFA:
 3629    00000000 81                    DC8     0x81
 3630    00000001 AB                    DC8     0xAB    // '+' + 0x80
 3631    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3632    00000004 ........              DC32    SSLASH_NFA
 3633                           PLUS:
 3634    00000008 ........              DC32    .+5
 3635                            SECTION .text : CODE (2)
 3636                                   POP2t
 3636.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3636.2                         //#ifndef TOSCT
 3636.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3636.4                         //#endif
 3636.5                         //      ADDS    p, p, #4
 3636.6                                 ENDM
 3637                                   POP2n
 3637.1  00000004 57F8041B              LDR     n, [p],#4
 3637.2                         //      LDR     n, [p]
 3637.3                         //      ADDS    p, p, #4
 3637.4                                 ENDM
 3638    00000008 4018                  ADDS    t, t, n
 3639                                   TPUSH
 3639                                   PUSHt   // push t to p, pre decrement p
 3639.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3639.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3639.3                         //      STR     t, [p]
 3639.4                                 ENDM
 3639                                   NEXT
 3639.1                         // ARMv7-M Thumb = .+5
 3639.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3639.3                         // ARMv6-M Thumb = .+4
 3639.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3639                                   NEXT1
 3639.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3639.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3639.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3639.4                         // ARMv6-M Thumb = .+4
 3639.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3639.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3639.7                                 ENDM
 3639.8                                 ENDM
 3639.9                                 ENDM
 3640                           
 3641                           
 3642                           //      - SUBB: ( n1 n2 -- n3 )
 3643                           //      Leave the difference of n1-n2 as n3.
 3644                           //      1 2 - . -1
 3645                           //      2 1 - .  1
 3646                           
 3647                            SECTION .text : CONST (2)
 3648                           SUB_NFA:
 3649    00000000 81                    DC8     0x81
 3650    00000001 AD                    DC8     '-'+0x80
 3651    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3652    00000004 ........              DC32    PLUS_NFA
 3653                           SUBB:
 3654    00000008 ........              DC32    .+5
 3655                            SECTION .text : CODE (2)
 3656                                   POP2t
 3656.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3656.2                         //#ifndef TOSCT
 3656.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3656.4                         //#endif
 3656.5                         //      ADDS    p, p, #4
 3656.6                                 ENDM
 3657                                   POP2n
 3657.1  00000004 57F8041B              LDR     n, [p],#4
 3657.2                         //      LDR     n, [p]
 3657.3                         //      ADDS    p, p, #4
 3657.4                                 ENDM
 3658    00000008 081A                  SUBS    t, n, t
 3659                                   TPUSH
 3659                                   PUSHt   // push t to p, pre decrement p
 3659.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3659.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3659.3                         //      STR     t, [p]
 3659.4                                 ENDM
 3659                                   NEXT
 3659.1                         // ARMv7-M Thumb = .+5
 3659.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3659.3                         // ARMv6-M Thumb = .+4
 3659.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3659                                   NEXT1
 3659.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3659.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3659.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3659.4                         // ARMv6-M Thumb = .+4
 3659.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3659.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3659.7                                 ENDM
 3659.8                                 ENDM
 3659.9                                 ENDM
 3660                           
 3661                           
 3662                           //      = EQUAL:        (n1 n2 -- f )
 3663                           //      Leave a true flag if n1=n2// otherwise leave a false flag.
 3664                           
 3665                            SECTION .text : CONST (2)
 3666                           EQUAL_NFA:
 3667    00000000 81                    DC8     0x81
 3668    00000001 BD                    DC8     '='+0x80
 3669    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3670    00000004 ........              DC32    SUB_NFA
 3671                           EQUAL:
 3672    00000008 ........              DC32    .+5
 3673                            SECTION .text : CODE (2)
 3674                           #ifdef TRUE_EQU_NEG_ONE
 3675    00000000 4040                  EORS    t, t
 3676                           #endif
 3677                                   POP2t
 3677.1  00000002 57F8040B              LDR     t, [p],#4       // Post-increment
 3677.2                         //#ifndef TOSCT
 3677.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3677.4                         //#endif
 3677.5                         //      ADDS    p, p, #4
 3677.6                                 ENDM
 3678                                   POP2n
 3678.1  00000006 57F8041B              LDR     n, [p],#4
 3678.2                         //      LDR     n, [p]
 3678.3                         //      ADDS    p, p, #4
 3678.4                                 ENDM
 3679    0000000A 401A                  SUBS    t, t, n
 3680    0000000C 09D0                  BEQ     EQUAL_TRUE
 3681    0000000E 4040                  EORS    t, t
 3682                                   TPUSH
 3682                                   PUSHt   // push t to p, pre decrement p
 3682.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3682.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3682.3                         //      STR     t, [p]
 3682.4                                 ENDM
 3682                                   NEXT
 3682.1                         // ARMv7-M Thumb = .+5
 3682.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3682.3                         // ARMv6-M Thumb = .+4
 3682.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3682                                   NEXT1
 3682.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3682.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3682.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3682.4                         // ARMv6-M Thumb = .+4
 3682.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3682.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3682.7                                 ENDM
 3682.8                                 ENDM
 3682.9                                 ENDM
 3683                           
 3684                           EQUAL_TRUE:
 3685                           #ifdef TRUE_EQU_NEG_ONE
 3686    00000022 0138                  SUBS    t, #1 // -1
 3687                           #else
 3689                           #endif
 3690                                   TPUSH
 3690                                   PUSHt   // push t to p, pre decrement p
 3690.1  00000024 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3690.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3690.3                         //      STR     t, [p]
 3690.4                                 ENDM
 3690                                   NEXT
 3690.1                         // ARMv7-M Thumb = .+5
 3690.2  00000028 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3690.3                         // ARMv6-M Thumb = .+4
 3690.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3690                                   NEXT1
 3690.1  0000002C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3690.2  00000030 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3690.3  00000034 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3690.4                         // ARMv6-M Thumb = .+4
 3690.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3690.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3690.7                                 ENDM
 3690.8                                 ENDM
 3690.9                                 ENDM
 3691                           /*
 3692                                   DC32    DOCOL
 3693                                   DC32    SUBB
 3694                                   DC32    ZEQU
 3695                                   DC32    SEMIS
 3696                           */
 3697                           
 3698                           
 3699                           //      < LESSTHAN:     ( n1 n2 -- f ) SIGNED:
 3700                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3701                           //      C0 1 < . 0  -1 C0 < . 1
 3702                           
 3703                            SECTION .text : CONST (2)
 3704                           LESSTHAN_NFA:
 3705    00000000 81                    DC8     0x81
 3706    00000001 BC                    DC8     '<'+0x80
 3707    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3708    00000004 ........              DC32    EQUAL_NFA
 3709                           LESSTHAN:
 3710    00000008 ........              DC32    .+5
 3711                            SECTION .text : CODE (2)
 3712                           #ifdef TRUE_EQU_NEG_ONE
 3713    00000000 4040                  EORS    t, t    // zero t
 3714    00000002 0138                  SUBS    t, #1   // -1
 3715                           #else
 3717                           #endif
 3718                                   POP2n                           // n2
 3718.1  00000004 57F8041B              LDR     n, [p],#4
 3718.2                         //      LDR     n, [p]
 3718.3                         //      ADDS    p, p, #4
 3718.4                                 ENDM
 3719                                   POP2w                           // n1
 3719.1  00000008 57F8042B              LDR     w, [p],#4
 3719.2                         //      LDR     w, [p]
 3719.3                         //      ADDS    p, p, #4
 3719.4                                 ENDM
 3720    0000000C 9142                  CMP     n, w        // n1 < n2
 3721    0000000E 00DC                  BGT     LESS1
 3722                           
 3723    00000010 4040                  EORS    t, t    // zero t =< n_r0
 3724                           LESS1:
 3725                                   TPUSH
 3725                                   PUSHt   // push t to p, pre decrement p
 3725.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3725.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3725.3                         //      STR     t, [p]
 3725.4                                 ENDM
 3725                                   NEXT
 3725.1                         // ARMv7-M Thumb = .+5
 3725.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3725.3                         // ARMv6-M Thumb = .+4
 3725.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3725                                   NEXT1
 3725.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3725.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3725.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3725.4                         // ARMv6-M Thumb = .+4
 3725.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3725.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3725.7                                 ENDM
 3725.8                                 ENDM
 3725.9                                 ENDM
 3726                           
 3727                           
 3728                           //      U< ULESSTHAN:   ( n1 n2 -- f )  UNSIGNED:
 3729                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3730                           //      -1 -2 U< . 0  -1 2 U< . 0  1 2 U< . 1
 3731                           
 3732                            SECTION .text : CONST (2)
 3733                           ULESSTHAN_NFA:
 3734    00000000 82                    DC8     0x82
 3735    00000001 55                    DC8     'U'
 3736    00000002 BC                    DC8     '<'+0x80
 3737    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3738    00000004 ........              DC32    LESSTHAN_NFA
 3739                           ULESSTHAN:
 3740    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3741    00000010 .............         DC32    XORR, ZLESS
                  ...          
 3742    00000018 ........              DC32    ZBRAN
 3743    0000001C 18000000              DC32    ULES1-. //IF
 3744                           
 3745    00000020 .............         DC32    DROP, ZLESS
                  ...          
 3746    00000028 ........              DC32    ZEQU
 3747    0000002C ........              DC32    BRAN
 3748    00000030 0C000000              DC32    ULES2-.
 3749                           
 3750                           ULES1:
 3751    00000034 .............         DC32    SUBB,ZLESS      //ELSE
                  ...          
 3752                           
 3753                           ULES2:
 3754    0000003C ........              DC32    SEMIS           //endif
 3755                           
 3756                           
 3757                           //      > GREATERTHAN:  ( n1 n2 --  f ) SIGNED: L0
 3758                           //      Leave a true flag if n1 is greater than n2 otherwise a false flag.
 3759                           //      -1 1 > . 0  1 -1 > . 1
 3760                           
 3761                            SECTION .text : CONST (2)
 3762                           GREATERTHAN_NFA:
 3763    00000000 81                    DC8     0x81
 3764    00000001 BE                    DC8     '>'+0x80
 3765    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3766    00000004 ........              DC32    ULESSTHAN_NFA
 3767                           GREATERTHAN:
 3768    00000008 ........              DC32    DOCOL
 3769    0000000C ........              DC32    SWAP
 3770    00000010 ........              DC32    LESSTHAN
 3771    00000014 ........              DC32    SEMIS
 3772                           
 3773                           
 3774                           //      0= ZEQU:        ( n_r0 -- f )
 3775                           //      Leave a true flag is the number is equal to zero, otherwise leave a
 3776                           //      false flag. CHANGED Code dependent on true flag being 1 FOR -1 TRUE
 3777                           
 3778                            SECTION .text : CONST (2)
 3779                           ZEQU_NFA:
 3780    00000000 82                    DC8     0x82
 3781    00000001 30                    DC8     '0'
 3782    00000002 BD                    DC8     '='+0x80
 3783    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3784    00000004 ........              DC32    GREATERTHAN_NFA
 3785                           ZEQU:
 3786    00000008 ........              DC32    .+5
 3787                            SECTION .text : CODE (2)
 3788    00000000 4040                  EORS    t, t
 3789                                   POP2n
 3789.1  00000002 57F8041B              LDR     n, [p],#4
 3789.2                         //      LDR     n, [p]
 3789.3                         //      ADDS    p, p, #4
 3789.4                                 ENDM
 3790    00000006 0029                  CMP     n, #0
 3791    00000008 00D1                  BNE     ZEQU_ZERO
 3792                           
 3793                           #ifdef TRUE_EQU_NEG_ONE
 3794    0000000A 401E                  SUBS    t, t, #1
 3795                           #else
 3797                           #endif
 3798                           
 3799                           ZEQU_ZERO:
 3800                                   TPUSH
 3800                                   PUSHt   // push t to p, pre decrement p
 3800.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3800.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3800.3                         //      STR     t, [p]
 3800.4                                 ENDM
 3800                                   NEXT
 3800.1                         // ARMv7-M Thumb = .+5
 3800.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3800.3                         // ARMv6-M Thumb = .+4
 3800.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3800                                   NEXT1
 3800.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3800.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3800.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3800.4                         // ARMv6-M Thumb = .+4
 3800.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3800.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3800.7                                 ENDM
 3800.8                                 ENDM
 3800.9                                 ENDM
 3801                           
 3802                           
 3803                           //      0< ZLESS:       ( n_r0 -- f )
 3804                           //      Leave a true flag if the number is less than zero (negative),
 3805                           //      otherwise leave a false flag.
 3806                           
 3807                            SECTION .text : CONST (2)
 3808                           ZLESS_NFA:
 3809    00000000 82                    DC8     0x82
 3810    00000001 30                    DC8     '0'
 3811    00000002 BC                    DC8     '<'+0x80
 3812    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3813    00000004 ........              DC32    ZEQU_NFA
 3814                           ZLESS:
 3815    00000008 ........              DC32    .+5
 3816                            SECTION .text : CODE (2)
 3817                           #ifdef TOSCT    // REPLACING t SO THIS IS FASTER THAN POP2n
 3820                           #else
 3821                                   POP2n
 3821.1  00000000 57F8041B              LDR     n, [p],#4
 3821.2                         //      LDR     n, [p]
 3821.3                         //      ADDS    p, p, #4
 3821.4                                 ENDM
 3822                           #endif
 3823                           #ifdef TRUE_EQU_NEG_ONE
 3824    00000004 4040                  EORS    t, t
 3825    00000006 0138                  SUBS    t, #1   // TRUE -1
 3826                           #else
 3828                           #endif
 3829    00000008 0943                  ORRS    n, n, n // SET FLAGS
 3830    0000000A 00D4                  BMI     ZLESS1  // JS   ZLESS1
 3831                           
 3832    0000000C 4040                  EORS    t, t    // FALSE
 3833                           ZLESS1:
 3834                                   TPUSH
 3834                                   PUSHt   // push t to p, pre decrement p
 3834.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3834.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3834.3                         //      STR     t, [p]
 3834.4                                 ENDM
 3834                                   NEXT
 3834.1                         // ARMv7-M Thumb = .+5
 3834.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3834.3                         // ARMv6-M Thumb = .+4
 3834.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3834                                   NEXT1
 3834.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3834.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3834.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3834.4                         // ARMv6-M Thumb = .+4
 3834.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3834.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3834.7                                 ENDM
 3834.8                                 ENDM
 3834.9                                 ENDM
 3835                           
 3836                           
 3837                           //      BIN BIN:        ( -- )
 3838                           //      Set the numeric conversion base to TWO (bianry).
 3839                           
 3840                            SECTION .text : CONST (2)
 3841                           BIN_NFA:
 3842    00000000 83                    DC8     0x83
 3843    00000001 4249                  DC8     'BI'
 3844    00000003 CE                    DC8     'N'+0x80
 3845                            ALIGNROM 2,0xFFFFFFFF
 3846    00000004 ........              DC32    ZLESS_NFA
 3847                           BIN:
 3848    00000008 ........              DC32    DOCOL
 3849    0000000C ........02000         DC32    STRVA, 2, NBASE
                  000........  
 3850    00000018 ........              DC32    SEMIS
 3851                           
 3852                           
 3853                           //      HEX HEX:        ( -- )
 3854                           //      Set the numeric conversion base to sixteen (hexadecimal).
 3855                           
 3856                            SECTION .text : CONST (2)
 3857                           HEX_NFA:
 3858    00000000 83                    DC8     0x83
 3859    00000001 4845                  DC8     'HE'
 3860    00000003 D8                    DC8     'X'+0x80
 3861                            ALIGNROM 2,0xFFFFFFFF
 3862    00000004 ........              DC32    BIN_NFA
 3863                           HEX:
 3864    00000008 ........              DC32    DOCOL
 3865    0000000C ........10000         DC32    STRVA, 16, NBASE
                  000........  
 3866    00000018 ........              DC32    SEMIS
 3867                           
 3868                           
 3869                           //      DECIMAL DECIMAL:        ( -- )
 3870                           //      Set the numeric conversion base to TEN (decimal).
 3871                           //      DEC IS A NUMBER!
 3872                           
 3873                            SECTION .text : CONST (2)
 3874                           DECIMAL_NFA:
 3875    00000000 87                    DC8     0x87
 3876    00000001 444543494D41          DC8     'DECIMA'
 3877    00000007 CC                    DC8     'L'+0x80
 3878                            ALIGNROM 2,0xFFFFFFFF
 3879    00000008 ........              DC32    HEX_NFA
 3880                           DECIMAL:
 3881    0000000C ........              DC32    DOCOL
 3882    00000010 ........0A000         DC32    STRVA, 10, NBASE
                  000........  
 3883    0000001C ........              DC32    SEMIS
 3884                           
 3885                           
 3886                           //      NEGATE NEGATE: ( n1 -- n2 ) RENAMED: MINUS to NEGATE
 3887                           //      Leave the two's complement of a number.
 3888                           
 3889                            SECTION .text : CONST (2)
 3890                           NEGATE_NFA:
 3891    00000000 86                    DC8     0x86
 3892    00000001 4E45474154            DC8     'NEGAT'
 3893    00000006 C5                    DC8     'E'+0x80
 3894    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 3895    00000008 ........              DC32    DECIMAL_NFA
 3896                           NEGATE:
 3897    0000000C ........              DC32    .+5
 3898                            SECTION .text : CODE (2)
 3899                                   POP2t                   // MVN YES
 3899.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3899.2                         //#ifndef TOSCT
 3899.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3899.4                         //#endif
 3899.5                         //      ADDS    p, p, #4
 3899.6                                 ENDM
 3900    00000004 C043                  MVNS     t, t           // 1's compliment
 3901    00000006 401C                  ADDS     t, t, #1       // 2's compliment
 3902                                   TPUSH
 3902                                   PUSHt   // push t to p, pre decrement p
 3902.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3902.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3902.3                         //      STR     t, [p]
 3902.4                                 ENDM
 3902                                   NEXT
 3902.1                         // ARMv7-M Thumb = .+5
 3902.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3902.3                         // ARMv6-M Thumb = .+4
 3902.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3902                                   NEXT1
 3902.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3902.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3902.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3902.4                         // ARMv6-M Thumb = .+4
 3902.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3902.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3902.7                                 ENDM
 3902.8                                 ENDM
 3902.9                                 ENDM
 3903                           
 3904                           
 3905                           //      ABS ABS:        ( n_r0 -- ub )
 3906                           //      Leave the absolute value of n_r0 as un.
 3907                           
 3908                            SECTION .text : CONST (2)
 3909                           ABS1_NFA:
 3910    00000000 83                    DC8     0x83
 3911    00000001 4142                  DC8     'AB'
 3912    00000003 D3                    DC8     'S'+0x80
 3913                            ALIGNROM 2,0xFFFFFFFF
 3914    00000004 ........              DC32    NEGATE_NFA
 3915                           ABS:
 3916    00000008 ........              DC32    DOCOL
 3917    0000000C ........              DC32    DUP
 3918    00000010 ........              DC32    PM
 3919    00000014 ........              DC32    SEMIS
 3920                           
 3921                           
 3922                           //      MIN MIN:        ( n1 n2 -- min )
 3923                           //      Leave the smaller of two numbers.
 3924                           
 3925                            SECTION .text : CONST (2)
 3926                           MIN_NFA:
 3927    00000000 83                    DC8     0x83
 3928    00000001 4D49                  DC8     'MI'
 3929    00000003 CE                    DC8     'N'+0x80
 3930                            ALIGNROM 2,0xFFFFFFFF
 3931    00000004 ........              DC32    ABS1_NFA
 3932                           MIN:
 3933    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3934    00000010 ........              DC32    GREATERTHAN
 3935    00000014 ........              DC32    ZBRAN   //IF
 3936    00000018 08000000              DC32     MIN1-.
 3937                           
 3938    0000001C ........              DC32    SWAP    //endif
 3939                           MIN1:
 3940    00000020 ........              DC32    DROP
 3941    00000024 ........              DC32    SEMIS
 3942                           
 3943                           
 3944                           //      MAX MAX:        ( n1 n2 -- max )
 3945                           //      Leave the greater of two numbers.
 3946                           
 3947                            SECTION .text : CONST (2)
 3948                           MAX_NFA:
 3949    00000000 83                    DC8     0x83
 3950    00000001 4D41                  DC8     'MA'
 3951    00000003 D8                    DC8     'X'+0x80
 3952                            ALIGNROM 2,0xFFFFFFFF
 3953    00000004 ........              DC32    MIN_NFA
 3954                           MAX:
 3955    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3956    00000010 ........              DC32    LESSTHAN
 3957    00000014 ........              DC32    ZBRAN   //IF
 3958    00000018 08000000              DC32     MAX1-.
 3959                           
 3960    0000001C ........              DC32    SWAP    //endif
 3961                           MAX1:
 3962    00000020 ........              DC32    DROP
 3963    00000024 ........              DC32    SEMIS
 3964                           
 3965                           
 3966                           //      AND ANDD:       ( n1 n2 -- n2 )
 3967                           //      Leave the bitwise logical and of n1 and n2 as n3.
 3968                           
 3969                            SECTION .text : CONST (2)
 3970                           ANDD_NFA:
 3971    00000000 83                    DC8     0x83
 3972    00000001 414E                  DC8     'AN'
 3973    00000003 C4                    DC8     'D'+0x80
 3974                            ALIGNROM 2,0xFFFFFFFF
 3975    00000004 ........              DC32    MAX_NFA
 3976                           ANDD:
 3977    00000008 ........              DC32    .+5
 3978                            SECTION .text : CODE (2)
 3979                                   POP2t
 3979.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3979.2                         //#ifndef TOSCT
 3979.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3979.4                         //#endif
 3979.5                         //      ADDS    p, p, #4
 3979.6                                 ENDM
 3980                                   POP2n
 3980.1  00000004 57F8041B              LDR     n, [p],#4
 3980.2                         //      LDR     n, [p]
 3980.3                         //      ADDS    p, p, #4
 3980.4                                 ENDM
 3981    00000008 0840                  ANDS     t, t, n
 3982                                   TPUSH
 3982                                   PUSHt   // push t to p, pre decrement p
 3982.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3982.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3982.3                         //      STR     t, [p]
 3982.4                                 ENDM
 3982                                   NEXT
 3982.1                         // ARMv7-M Thumb = .+5
 3982.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3982.3                         // ARMv6-M Thumb = .+4
 3982.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3982                                   NEXT1
 3982.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3982.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3982.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3982.4                         // ARMv6-M Thumb = .+4
 3982.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3982.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3982.7                                 ENDM
 3982.8                                 ENDM
 3982.9                                 ENDM
 3983                           
 3984                           
 3985                           //      OR OR:  ( n1 n2 -- n3 )
 3986                           //      Leave the bit-wise logical or of n1 and n2 as n3.
 3987                           
 3988                            SECTION .text : CONST (2)
 3989                           OR_NFA:
 3990    00000000 82                    DC8     0x82
 3991    00000001 4F                    DC8     'O'
 3992    00000002 D2                    DC8     'R'+0x80
 3993    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3994    00000004 ........              DC32    ANDD_NFA
 3995                           OR:
 3996    00000008 ........              DC32    .+5
 3997                            SECTION .text : CODE (2)
 3998                                   POP2t
 3998.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3998.2                         //#ifndef TOSCT
 3998.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3998.4                         //#endif
 3998.5                         //      ADDS    p, p, #4
 3998.6                                 ENDM
 3999                                   POP2n
 3999.1  00000004 57F8041B              LDR     n, [p],#4
 3999.2                         //      LDR     n, [p]
 3999.3                         //      ADDS    p, p, #4
 3999.4                                 ENDM
 4000    00000008 0843                  ORRS     t, t, n
 4001                                   TPUSH
 4001                                   PUSHt   // push t to p, pre decrement p
 4001.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4001.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4001.3                         //      STR     t, [p]
 4001.4                                 ENDM
 4001                                   NEXT
 4001.1                         // ARMv7-M Thumb = .+5
 4001.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4001.3                         // ARMv6-M Thumb = .+4
 4001.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4001                                   NEXT1
 4001.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4001.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4001.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4001.4                         // ARMv6-M Thumb = .+4
 4001.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4001.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4001.7                                 ENDM
 4001.8                                 ENDM
 4001.9                                 ENDM
 4002                           
 4003                           
 4004                           //      NOT NOT: ( nl -- n2 )
 4005                           //      Leave the bitwise logical not of n1 as n2
 4006                           
 4007                            SECTION .text : CONST (2)
 4008                           NOT_NFA:
 4009    00000000 83                    DC8     0x83
 4010    00000001 4E4F                  DC8     'NO'
 4011    00000003 D4                    DC8     'T'+0x80
 4012                            ALIGNROM 2,0xFFFFFFFF
 4013    00000004 ........              DC32    OR_NFA
 4014                           NOT:
 4015    00000008 ........              DC32    .+5
 4016                            SECTION .text : CODE (2)
 4017                                   POP2t
 4017.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4017.2                         //#ifndef TOSCT
 4017.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4017.4                         //#endif
 4017.5                         //      ADDS    p, p, #4
 4017.6                                 ENDM
 4018    00000004 C043                  MVNS            t, t    // 1's compliment
 4019                                   TPUSH
 4019                                   PUSHt   // push t to p, pre decrement p
 4019.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4019.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4019.3                         //      STR     t, [p]
 4019.4                                 ENDM
 4019                                   NEXT
 4019.1                         // ARMv7-M Thumb = .+5
 4019.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4019.3                         // ARMv6-M Thumb = .+4
 4019.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4019                                   NEXT1
 4019.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4019.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4019.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4019.4                         // ARMv6-M Thumb = .+4
 4019.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4019.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4019.7                                 ENDM
 4019.8                                 ENDM
 4019.9                                 ENDM
 4020                           
 4021                           
 4022                           //      XORR XOR:       ( nl n2 -- n3 )
 4023                           //      Leave the bitwise logical exclusive or n1 and n2 as n3
 4024                           
 4025                            SECTION .text : CONST (2)
 4026                           XORR_NFA:
 4027    00000000 83                    DC8     0x83
 4028    00000001 584F                  DC8     'XO'
 4029    00000003 D2                    DC8     'R'+0x80
 4030                            ALIGNROM 2,0xFFFFFFFF
 4031    00000004 ........              DC32    NOT_NFA
 4032                           XORR:
 4033    00000008 ........              DC32    .+5
 4034                            SECTION .text : CODE (2)
 4035                                   POP2t
 4035.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4035.2                         //#ifndef TOSCT
 4035.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4035.4                         //#endif
 4035.5                         //      ADDS    p, p, #4
 4035.6                                 ENDM
 4036                                   POP2n
 4036.1  00000004 57F8041B              LDR     n, [p],#4
 4036.2                         //      LDR     n, [p]
 4036.3                         //      ADDS    p, p, #4
 4036.4                                 ENDM
 4037    00000008 4840                  EORS     t, t, n
 4038                                   TPUSH
 4038                                   PUSHt   // push t to p, pre decrement p
 4038.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4038.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4038.3                         //      STR     t, [p]
 4038.4                                 ENDM
 4038                                   NEXT
 4038.1                         // ARMv7-M Thumb = .+5
 4038.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4038.3                         // ARMv6-M Thumb = .+4
 4038.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4038                                   NEXT1
 4038.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4038.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4038.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4038.4                         // ARMv6-M Thumb = .+4
 4038.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4038.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4038.7                                 ENDM
 4038.8                                 ENDM
 4038.9                                 ENDM
 4039                           
 4040                           //      SXTH SXH:       ( nl -- n3 )
 4041                           //      Sign extend HALFWORD on the stack
 4042                           
 4043                            SECTION .text : CONST (2)
 4044                           SXTH_NFA:
 4045    00000000 84                    DC8     0x84
 4046    00000001 535854                DC8     'SXT'
 4047    00000004 C8                    DC8     'H'+0x80
 4048    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4049    00000008 ........              DC32    XORR_NFA
 4050                           SXH:
 4051    0000000C ........              DC32    .+5
 4052                            SECTION .text : CODE (2)
 4053                                   POP2t
 4053.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4053.2                         //#ifndef TOSCT
 4053.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4053.4                         //#endif
 4053.5                         //      ADDS    p, p, #4
 4053.6                                 ENDM
 4054    00000004 00B2                  SXTH     t, t
 4055                                   TPUSH
 4055                                   PUSHt   // push t to p, pre decrement p
 4055.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4055.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4055.3                         //      STR     t, [p]
 4055.4                                 ENDM
 4055                                   NEXT
 4055.1                         // ARMv7-M Thumb = .+5
 4055.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4055.3                         // ARMv6-M Thumb = .+4
 4055.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4055                                   NEXT1
 4055.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4055.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4055.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4055.4                         // ARMv6-M Thumb = .+4
 4055.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4055.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4055.7                                 ENDM
 4055.8                                 ENDM
 4055.9                                 ENDM
 4056                           
 4057                           
 4058                           //      SXTB SXB:       ( nl -- n3 )
 4059                           //      Signe extend byte in the word on the stack
 4060                           
 4061                            SECTION .text : CONST (2)
 4062                           SXTB_NFA:
 4063    00000000 84                    DC8     0x84
 4064    00000001 535854                DC8     'SXT'
 4065    00000004 C2                    DC8     'B'+0x80
 4066    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4067    00000008 ........              DC32    SXTH_NFA
 4068                           SXB:
 4069    0000000C ........              DC32    .+5
 4070                            SECTION .text : CODE (2)
 4071                                   POP2t
 4071.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4071.2                         //#ifndef TOSCT
 4071.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4071.4                         //#endif
 4071.5                         //      ADDS    p, p, #4
 4071.6                                 ENDM
 4072    00000004 40B2                  SXTB     t, t
 4073                                   TPUSH
 4073                                   PUSHt   // push t to p, pre decrement p
 4073.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4073.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4073.3                         //      STR     t, [p]
 4073.4                                 ENDM
 4073                                   NEXT
 4073.1                         // ARMv7-M Thumb = .+5
 4073.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4073.3                         // ARMv6-M Thumb = .+4
 4073.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4073                                   NEXT1
 4073.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4073.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4073.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4073.4                         // ARMv6-M Thumb = .+4
 4073.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4073.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4073.7                                 ENDM
 4073.8                                 ENDM
 4073.9                                 ENDM
 4074                           
 4075                           
 4076                           //      REVW REVW:      ( n_r0 -- n_r0 )
 4077                           //      Reverse bytes in n_r0.
 4078                           
 4079                            SECTION .text : CONST (2)
 4080                           REVW_NFA:
 4081    00000000 84                    DC8     0x84
 4082    00000001 524556                DC8     'REV'
 4083    00000004 D7                    DC8     'W'+0x80
 4084    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4085    00000008 ........              DC32    SXTB_NFA
 4086                           REVW:
 4087    0000000C ........              DC32    .+5
 4088                            SECTION .text : CODE (2)
 4089                                   POP2t
 4089.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4089.2                         //#ifndef TOSCT
 4089.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4089.4                         //#endif
 4089.5                         //      ADDS    p, p, #4
 4089.6                                 ENDM
 4090    00000004 00BA                  REV     t, t
 4091                                   TPUSH
 4091                                   PUSHt   // push t to p, pre decrement p
 4091.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4091.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4091.3                         //      STR     t, [p]
 4091.4                                 ENDM
 4091                                   NEXT
 4091.1                         // ARMv7-M Thumb = .+5
 4091.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4091.3                         // ARMv6-M Thumb = .+4
 4091.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4091                                   NEXT1
 4091.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4091.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4091.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4091.4                         // ARMv6-M Thumb = .+4
 4091.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4091.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4091.7                                 ENDM
 4091.8                                 ENDM
 4091.9                                 ENDM
 4092                           
 4093                           
 4094                           //      ASR ASR:   ( sn count -- sn' )  
 4095                           //      Shift sn (sign-extended) right by count.
 4096                           //      Valid count values are 0 to 31.
 4097                           
 4098                            SECTION .text : CONST (2)
 4099                           ASR_NFA:
 4100    00000000 83                    DC8     0x83
 4101    00000001 4153                  DC8     'AS'
 4102    00000003 D2                    DC8     'R'+0x80
 4103                            ALIGNROM 2,0xFFFFFFFF
 4104    00000004 ........              DC32    REVW_NFA
 4105                           ASR:
 4106    00000008 ........              DC32    .+5
 4107                            SECTION .text : CODE (2)
 4108                                   POP2w           ; shift count
 4108.1  00000000 57F8042B              LDR     w, [p],#4
 4108.2                         //      LDR     w, [p]
 4108.3                         //      ADDS    p, p, #4
 4108.4                                 ENDM
 4109                                   POP2t           ; original data
 4109.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4109.2                         //#ifndef TOSCT
 4109.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4109.4                         //#endif
 4109.5                         //      ADDS    p, p, #4
 4109.6                                 ENDM
 4110    00000008 1041                  ASRS    t, t, w
 4111                                   TPUSH           ; shifted data
 4111                                   PUSHt   // push t to p, pre decrement p
 4111.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4111.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4111.3                         //      STR     t, [p]
 4111.4                                 ENDM
 4111                                   NEXT
 4111.1                         // ARMv7-M Thumb = .+5
 4111.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4111.3                         // ARMv6-M Thumb = .+4
 4111.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4111                                   NEXT1
 4111.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4111.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4111.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4111.4                         // ARMv6-M Thumb = .+4
 4111.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4111.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4111.7                                 ENDM
 4111.8                                 ENDM
 4111.9                                 ENDM
 4112                           
 4113                           
 4114                           //      LSR LSR:   ( n_r0 count -- n_r0' )
 4115                           //      Logical (zero-extended) shift right by count.
 4116                           //      Valid count values are 0 to 31.
 4117                           
 4118                            SECTION .text : CONST (2)
 4119                           LSR_NFA:
 4120    00000000 83                    DC8     0x83
 4121    00000001 4C53                  DC8     'LS'
 4122    00000003 D2                    DC8     'R'+0x80
 4123                            ALIGNROM 2,0xFFFFFFFF
 4124    00000004 ........              DC32    ASR_NFA
 4125                           LSR:
 4126    00000008 ........              DC32    .+5
 4127                            SECTION .text : CODE (2)
 4128                                   POP2w           ; shift count
 4128.1  00000000 57F8042B              LDR     w, [p],#4
 4128.2                         //      LDR     w, [p]
 4128.3                         //      ADDS    p, p, #4
 4128.4                                 ENDM
 4129                                   POP2t           ; original data
 4129.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4129.2                         //#ifndef TOSCT
 4129.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4129.4                         //#endif
 4129.5                         //      ADDS    p, p, #4
 4129.6                                 ENDM
 4130    00000008 D040                  LSRS    t, t, w
 4131                                   TPUSH           ; shifted data
 4131                                   PUSHt   // push t to p, pre decrement p
 4131.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4131.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4131.3                         //      STR     t, [p]
 4131.4                                 ENDM
 4131                                   NEXT
 4131.1                         // ARMv7-M Thumb = .+5
 4131.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4131.3                         // ARMv6-M Thumb = .+4
 4131.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4131                                   NEXT1
 4131.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4131.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4131.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4131.4                         // ARMv6-M Thumb = .+4
 4131.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4131.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4131.7                                 ENDM
 4131.8                                 ENDM
 4131.9                                 ENDM
 4132                           
 4133                           
 4134                           //      LSL LSL:   ( n_r0 count -- n_r0' )
 4135                           //      Logical (zero-extended) shift left by count.
 4136                           //      Valid count values are 0 to 31.
 4137                           
 4138                            SECTION .text : CONST (2)
 4139                           LSL_NFA:
 4140    00000000 83                    DC8     0x83
 4141    00000001 4C53                  DC8     'LS'
 4142    00000003 CC                    DC8     'L'+0x80
 4143                            ALIGNROM 2,0xFFFFFFFF
 4144    00000004 ........              DC32    LSR_NFA
 4145                           LSL:
 4146    00000008 ........              DC32    .+5
 4147                            SECTION .text : CODE (2)
 4148                                   POP2w           ; shift count
 4148.1  00000000 57F8042B              LDR     w, [p],#4
 4148.2                         //      LDR     w, [p]
 4148.3                         //      ADDS    p, p, #4
 4148.4                                 ENDM
 4149                                   POP2t           ; original data
 4149.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4149.2                         //#ifndef TOSCT
 4149.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4149.4                         //#endif
 4149.5                         //      ADDS    p, p, #4
 4149.6                                 ENDM
 4150    00000008 9040                  LSLS    t, t, w
 4151                                   TPUSH           ; shifted data---
 4151                                   PUSHt   // push t to p, pre decrement p
 4151.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4151.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4151.3                         //      STR     t, [p]
 4151.4                                 ENDM
 4151                                   NEXT
 4151.1                         // ARMv7-M Thumb = .+5
 4151.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4151.3                         // ARMv6-M Thumb = .+4
 4151.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4151                                   NEXT1
 4151.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4151.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4151.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4151.4                         // ARMv6-M Thumb = .+4
 4151.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4151.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4151.7                                 ENDM
 4151.8                                 ENDM
 4151.9                                 ENDM
 4152                           
 4153                           
 4154                           //      .R DOTR:        ( sn1 n2 -- ) SIGNED:
 4155                           //      Print the signed number sn1 right aligned in a field whose width is n2.
 4156                           //      No following blank is printed.
 4157                           
 4158                            SECTION .text : CONST (2)
 4159                           DOTR_NFA:
 4160    00000000 82                    DC8     0x82
 4161    00000001 2E                    DC8     '.'
 4162    00000002 D2                    DC8     'R'+0x80
 4163    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4164    00000004 ........              DC32    LSL_NFA
 4165                           DOTR:
 4166    00000008 ........              DC32    DOCOL
 4167    0000000C ........              DC32    TOR
 4168    00000010 ........              DC32    STOD
 4169    00000014 ........              DC32    RFROM
 4170    00000018 ........              DC32    DDOTR
 4171    0000001C ........              DC32    SEMIS
 4172                           
 4173                           
 4174                           //      .RU DOTRU:      ( n1 n2 -- ) UNSIGNED:
 4175                           //      Print the unsigned number n1 right aligned in a field whose width is n2.
 4176                           //      No following blank is printed.
 4177                           
 4178                            SECTION .text : CONST (2)
 4179                           DOTRU_NFA:
 4180    00000000 83                    DC8     0x83
 4181    00000001 2E52                  DC8     '.R'
 4182    00000003 D5                    DC8     'U'+0x80
 4183                            ALIGNROM 2,0xFFFFFFFF
 4184    00000004 ........              DC32    DOTR_NFA
 4185                           DOTRU:
 4186    00000008 ........              DC32    DOCOL
 4187    0000000C ........              DC32    TOR
 4188    00000010 ........              DC32    ZERO
 4189    00000014 .............         DC32    BDIGS, DIGS, EDIGS
                  ...........  
 4190    00000020 .............         DC32    DUP, RFROM
                  ...          
 4191    00000028 .............         DC32    SWAP, SUBB, SPACES, TYPE
                  .............
                  ......       
 4192                           #ifdef IO2TP
 4195                           #endif
 4196    00000038 ........              DC32    SEMIS
 4197                           
 4198                           
 4199                           //      U. UDOT:        ( n_r0 -- ) USIGNED DOT
 4200                           
 4201                            SECTION .text : CONST (2)
 4202                           UDOT_NFA:
 4203    00000000 82                    DC8     0x82
 4204    00000001 55                    DC8     'U'
 4205    00000002 AE                    DC8     '.'+0x80
 4206    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4207    00000004 ........              DC32    DOTRU_NFA
 4208                           UDOT:
 4209    00000008 ........              DC32    DOCOL
 4210    0000000C ........              DC32    ZERO
 4211    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4212    00000014 ........              DC32    SEMIS
 4213                           
 4214                           
 4215                           //      ? QUES: ( addr -- )
 4216                           //      Print the value contained at the address in free format according to
 4217                           //      the current base using DOT.
 4218                           
 4219                            SECTION .text : CONST (2)
 4220                           QUES_NFA:
 4221    00000000 81                    DC8     0x81
 4222    00000001 BF                    DC8     '?'+0x80
 4223    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4224    00000004 ........              DC32    UDOT_NFA
 4225                           QUES:
 4226    00000008 ........              DC32    DOCOL
 4227    0000000C ........              DC32    AT
 4228    00000010 ........              DC32    DOT
 4229    00000014 ........              DC32    SEMIS
 4230                           
 4231                           
 4232                           //      . DOT:  ( n_r0 -- ) SIGNED 2'S COMPLEMENT:
 4233                           //      Print a number from a signed 32 bit two's complement value,
 4234                           //      converted according to the numeric base.
 4235                           //      A trailing blanks follows.
 4236                           
 4237                            SECTION .text : CONST (2)
 4238                           DOT_NFA:
 4239    00000000 81                    DC8     0x81
 4240    00000001 AE                    DC8     '.'+0x80
 4241    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4242    00000004 ........              DC32    QUES_NFA
 4243                           DOT:
 4244    00000008 ........              DC32    DOCOL
 4245    0000000C ........              DC32    STOD
 4246    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4247    00000014 ........              DC32    SEMIS
 4248                           
 4249                           
 4250                           //------------------------------ DOTBASE SECTION -------------------------------
 4251                           //      .H DOTHEX:      ( n_r0 -- )
 4252                           //      Prints TOS in Hex using DOT, not affecting Base in the system
 4253                           
 4254                           #ifndef SRM
 4255                           //      .B DOTBIN:      ( n_r0 -- )
 4256                           //      Prints TOS in BINARY using DOT, not affecting Base in the system
 4257                           
 4258                            SECTION .text : CONST (2)
 4259                           DOTBIN_NFA:
 4260    00000000 82                    DC8     0x82
 4261    00000001 2E                    DC8     '.'
 4262    00000002 C2                    DC8     'B'+0x80
 4263    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4264    00000004 ........              DC32    DOT_NFA
 4265                           DOTBIN:
 4266    00000008 ........              DC32    DOCOL
 4267    0000000C .............         DC32    TWO, DOTBASE
                  ...          
 4268    00000014 ........              DC32    SEMIS
 4269                           #endif  // not SRM
 4270                           
 4271                           
 4272                            SECTION .text : CONST (2)
 4273                           DOTHEX_NFA:
 4274    00000000 82                    DC8     0x82
 4275    00000001 2E                    DC8     '.'
 4276    00000002 C8                    DC8     'H'+0x80
 4277    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4278    00000004 ........              DC32    DOTBIN_NFA
 4279                           DOTHEX:
 4280    00000008 ........              DC32    DOCOL
 4281                           #ifdef SRM
 4283                           #else
 4284    0000000C ........10000         DC32    LIT, 16, DOTBASE        // this version appends BASE Suffix
                  000........  
 4285                           #endif
 4286    00000018 ........              DC32    SEMIS
 4287                           
 4288                           
 4289                           #ifndef SRM
 4290                           //      .D DOTDEC:      ( n_r0 -- )
 4291                           //      Prints TOS in DECIMAL using DOT, not affecting Base in the system
 4292                           
 4293                            SECTION .text : CONST (2)
 4294                           DOTDEC_NFA:
 4295    00000000 82                    DC8     0x82
 4296    00000001 2E                    DC8     '.'
 4297    00000002 C4                    DC8     'D'+0x80
 4298    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4299    00000004 ........              DC32    DOTHEX_NFA
 4300                           DOTDEC:
 4301    00000008 ........              DC32    DOCOL
 4302    0000000C ........0A000         DC32    LIT, 10, DOTBASE
                  000........  
 4303    00000018 ........              DC32    SEMIS
 4304                           #endif  // not SRM
 4305                           
 4306                           
 4307                           //=============================== WORDCAT ====================================//
 4308                           //NOEXEC HEADERFORWORDCATEGORIES
 4309                           //      WC_NUMBERS_NFA = NUMBER Stuff: CATEGORY
 4310                           
 4311                            SECTION .text : CONST (2)
 4312                           WC_NUMBERS_NFA:
 4313    00000000 91                    DC8     0x80+4+13
 4314    00000001 0D0A                  DC8     0x0D, 0x0A
 4315    00000003 4E554D4245522         DC8     'NUMBER Stuff:'
                  053747566663A
 4316    00000010 0D8A                  DC8     0x0D, 0x0A+0x80
 4317    00000012 FFFF           ALIGNROM 2,0xFFFFFFFF
 4318    00000014 ........              DC32    DOTDEC_NFA
 4319                           
 4320                           
 4321                           //=============================== UART0_INIT =================================//
 4322                           
 4323                           // LFA ABOVE NEEDS TO BE WC_NUMBERS_NFA
 4324                           $FISH_STM32F4_UART3_INIT.s
 4325                           // LFA BELOW NEEDS TO BE UART3_INIT_NFA
 4326                           
 4327                           //=============================== UART0_INIT =================================//
 4328                           
 4329                           //      MYBAUD MYBAUD: ( n_r0 -- ) BAUD MUST BE IN DECIMAL or EQUIVALENT!!!
 4330                           //      MUST BE USED BEFORE USING UART0_INIT!!!
 4331                           //      Because FISH does a reset if you invoke a HARD FAULT RESET
 4332                           //      THIS MECHANISM IS ESSENTIAL TO STAYING AT USER SET BAUDRATE THRU A RESET!
 4333                           //      SET NON-INIT RAM VARIABLES DBAUD TO ZERO AND UBAUD n_r0.
 4334                           //      See UART0_INIT
 4335                           
 4336                            SECTION .text : CONST (2)
 4337                           MYBAUD_NFA:
 4338    00000000 86                    DC8     0x86
 4339    00000001 4D59424155            DC8     'MYBAU'
 4340    00000006 C4                    DC8     'D'+0x80
 4341    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4342    00000008 ........              DC32    UART3_INIT_NFA
 4343                           MYBAUD:
 4344    0000000C ........              DC32    DOCOL
 4345    00000010 ........00000         DC32    strva, 0, DBAUD
                  000........  
 4346    0000001C .............         DC32    LIT, UBAUD, STORE       // SET UBAUD TO NEW BAUD FOR UART0_INIT
                  ...........  
 4347    00000028 ........              DC32    SEMIS
 4348                           
 4349                           
 4350                           //      STM32F4 UART3_LSR UART3_LSR: ( -- value )
 4351                           
 4352                            SECTION .text : CONST (2)
 4353                           UART3_LSR_NFA:
 4354    00000000 89                    DC8     0x89
 4355    00000001 55415254335F4         DC8     'UART3_LS'
                  C53          
 4356    00000009 D2                    DC8     'R'+0x80
 4357    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 4358    0000000C ........              DC32    MYBAUD_NFA
 4359                           UART3_LSR:
 4360    00000010 ........              DC32    .+5
 4361                            SECTION .text : CODE (2)
 4362    00000000 0549                  LDR     n, = USART3_SR
 4363    00000002 0878                  LDRB    t, [n]
 4364                                   TPUSH
 4364                                   PUSHt   // push t to p, pre decrement p
 4364.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4364.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4364.3                         //      STR     t, [p]
 4364.4                                 ENDM
 4364                                   NEXT
 4364.1                         // ARMv7-M Thumb = .+5
 4364.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4364.3                         // ARMv6-M Thumb = .+4
 4364.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4364                                   NEXT1
 4364.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4364.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4364.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4364.4                         // ARMv6-M Thumb = .+4
 4364.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4364.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4364.7                                 ENDM
 4364.8                                 ENDM
 4364.9                                 ENDM
 4365    00000016 0000           LTORG
 4365.1                                  TABLE
 4365.2  00000018 00480040              Reference on line 4362
 4366                           
 4367                           
 4368                           //      STM32F4 UART3_RX UART3_RX: ( -- addr )
 4369                           //      This is the serial terminal.
 4370                           
 4371                            SECTION .text : CONST (2)
 4372                           UART3_RX_NFA:
 4373    00000000 88                    DC8     0x88
 4374    00000001 55415254335F5         DC8     'UART3_R'
                  2            
 4375    00000008 D8                    DC8     'X'+0x80
 4376    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4377    0000000C ........              DC32    UART3_LSR_NFA
 4378                           UART0_RX:
 4379    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4380                           
 4381                           //      STM32F4 UART3_TX UART3_TX: ( -- addr )
 4382                           //      This is the serial terminal.
 4383                           
 4384                            SECTION .text : CONST (2)
 4385                           UART3_TX_NFA:
 4386    00000000 88                    DC8     0x88
 4387    00000001 55415254335F5         DC8     'UART3_T'
                  4            
 4388    00000008 D8                    DC8     'X'+0x80
 4389    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4390    0000000C ........              DC32    UART3_RX_NFA
 4391                           UART3_TX:
 4392    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4393                           
 4394                           
 4395                           #ifdef XON_XOFF
 4396                           //      XOFF XOFF: ( -- ) Send XOFF
 4397                           
 4398                            SECTION .text : CONST (2)
 4399                           XOFF_NFA:
 4400    00000000 84                    DC8     0x84
 4401    00000001 584F46                DC8     'XOF'
 4402    00000004 C6                    DC8     'F'+0x80
 4403    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4404    00000008 ........              DC32    UART3_TX_NFA
 4405                           XOFF:
 4406    0000000C ........              DC32    .+5
 4407                            SECTION .text : CODE (2)       // Does not incr OUT and wait for line status
 4408                           #ifdef IO2TP
 4410                           #else
 4411    00000000 ........              BL      TXRDY_SUBR
 4412    00000004 ........              BL      XOFF_SUBR
 4413                                   NEXT
 4413.1                         // ARMv7-M Thumb = .+5
 4413.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4413.3                         // ARMv6-M Thumb = .+4
 4413.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4413                                   NEXT1
 4413.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4413.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4413.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4413.4                         // ARMv6-M Thumb = .+4
 4413.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4413.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4413.7                                 ENDM
 4413.8                                 ENDM
 4414                           #endif // #else IO2TP
 4415                           //#endif // XON_XOFF after XON:
 4416                           
 4417                           
 4418                           //      XON XON: ( -- ) Send XON
 4419                           
 4420                            SECTION .text : CONST (2)
 4421                           XON_NFA:
 4422    00000000 83                    DC8     0x83
 4423    00000001 584F                  DC8     'XO'
 4424    00000003 CE                    DC8     'N'+0x80
 4425                            ALIGNROM 2,0xFFFFFFFF
 4426    00000004 ........              DC32    XOFF_NFA
 4427                           XON:
 4428    00000008 ........              DC32    .+5
 4429                            SECTION .text : CODE (2)       // Does not incr OUT or wait for line status.
 4430                           #ifdef IO2TP
 4432                           #else
 4433                           // Required, no 'quick send'
 4434    00000000 ........              BL      TXRDY_SUBR
 4435    00000004 ........              BL      XON_SUBR
 4436                                   NEXT
 4436.1                         // ARMv7-M Thumb = .+5
 4436.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4436.3                         // ARMv6-M Thumb = .+4
 4436.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4436                                   NEXT1
 4436.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4436.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4436.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4436.4                         // ARMv6-M Thumb = .+4
 4436.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4436.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4436.7                                 ENDM
 4436.8                                 ENDM
 4437                           #endif // #else IO2TP
 4438                           #endif // XON_XOFF
 4439                           
 4440                           //---------------- EMIT KEY ?KEY CR SECTION ------------------------------
 4441                           
 4442                           //      SPACES SPACES:  ( n_r0 -- )
 4443                           //      Transmit n_r0 ascii blanks (0x20) to the output device.
 4444                           
 4445                            SECTION .text : CONST (2)
 4446                           SPACES_NFA:
 4447    00000000 86                    DC8     0x86
 4448    00000001 5350414345            DC8     'SPACE'
 4449    00000006 D3                    DC8     'S'+0x80
 4450    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4451                           #ifdef XON_XOFF
 4452    00000008 ........              DC32    XON_NFA
 4453                           #else
 4455                           #endif
 4456                           SPACES:
 4457    0000000C ........              DC32    DOCOL
 4458    00000010 ........              DC32    ZERO
 4459    00000014 ........              DC32    MAX
 4460    00000018 ........              DC32    ZNDUP
 4461    0000001C ........              DC32    ZBRAN
 4462    00000020 18000000              DC32     SPACES_DONE-.
 4463                           
 4464    00000024 ........              DC32    ZERO
 4465    00000028 ........              DC32    XDO     //DO
 4466                           
 4467                           SPACES_DO:
 4468    0000002C ........              DC32    SPACE
 4469    00000030 ........              DC32    XLOOP   //LOOP
 4470    00000034 F8FFFFFF              DC32     SPACES_DO-.
 4471                           
 4472                           SPACES_DONE:
 4473    00000038 ........              DC32    SEMIS
 4474                           
 4475                           
 4476                           //      SPACE SPACE: ( -- )
 4477                           //      Emit a space character, 0x20.
 4478                           
 4479                            SECTION .text : CONST (2)
 4480                           SPACE_NFA:
 4481    00000000 85                    DC8     0x85
 4482    00000001 53504143              DC8     'SPAC'
 4483    00000005 C5                    DC8     'E'+0x80
 4484    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4485    00000008 ........              DC32    SPACES_NFA
 4486                           SPACE:
 4487    0000000C ........              DC32    DOCOL
 4488    00000010 ........              DC32    BLANK
 4489    00000014 ........              DC32    EMIT
 4490    00000018 ........              DC32    SEMIS
 4491                           
 4492                           
 4493                           //      ID. IDDOT:      ( NFA-addr -- ) ?RENAME .NFA
 4494                           //      Print a definition's name from its name field address.
 4495                           
 4496                            SECTION .text : CONST (2)
 4497                           IDDOT_NFA:
 4498    00000000 83                    DC8     0x83
 4499    00000001 4944                  DC8     'ID'
 4500    00000003 AE                    DC8     '.'+0x80
 4501                            ALIGNROM 2,0xFFFFFFFF
 4502    00000004 ........              DC32    SPACE_NFA
 4503                           IDDOT:
 4504    00000008 ........              DC32    DOCOL
 4505                           //      NOW COUNT is on NFA, fig code copied it out to pad
 4506    0000000C ........              DC32    COUNT   // Count could be SMUDGE'd.
 4507    00000010 ........1F000         DC32    LIT, MAXWORDLEN // Strip SMUDGEing from count
                  000          
 4508    00000018 ........              DC32    ANDD            // only time 
 4509    0000001C ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4510    00000020 ........              DC32    SPACE
 4511    00000024 ........              DC32    SEMIS
 4512                           
 4513                           
 4514                           //      ." DOTQ:        ( -- ) IMMEDIATE
 4515                           //      Type quoted string out or compile inline string to be typed at runtime
 4516                           //      CHANGED COMPILE TIME ACTION TO WORK WITH 4 byte alighment REQUIREMENT.
 4517                           //      Used in the form:
 4518                           //              .' CCcc"
 4519                           //      Compiles an in-line string CCcc (delimited by the trailing ") with
 4520                           //      an execution proceedure to transmit the text to the output device.
 4521                           //      If executed outside a definition, ." will immediately print the text
 4522                           //      until the final ',. The maximum number of characters may be an
 4523                           //      installation dependent value. See (.").
 4524                           
 4525                            SECTION .text : CONST (2)
 4526                           DOTQ_NFA:
 4527    00000000 C2                    DC8     0x0C2
 4528    00000001 2E                    DC8     '.'
 4529    00000002 A2                    DC8     '"'+0x80
 4530    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4531    00000004 ........              DC32    IDDOT_NFA
 4532                           DOTQ:
 4533    00000008 ........              DC32    DOCOL
 4534    0000000C ........22000         DC32    LIT, '"'        // 0x22 ending qoute delimiter for WORD
                  000          
 4535    00000014 ........              DC32    STATE_SV
 4536    00000018 ........              DC32    AT
 4537    0000001C ........              DC32    ZBRAN   // IF Not COMPILING
 4538    00000020 2C000000              DC32     DOTQ1-.
 4539                           
 4540    00000024 ........              DC32    COMP    // COMPILING
 4541    00000028 ........              DC32    PDOTQ   // compile LIT, cnt-str-addr, count, type
 4542    0000002C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4543    00000030 ........              DC32    HERE
 4544    00000034 ........              DC32    CAT
 4545    00000038 ........              DC32    ONEP
 4546    0000003C ........              DC32    ALIGNED
 4547    00000040 ........              DC32    ALLOT_PRIM
 4548    00000044 ........              DC32    BRAN    // ELSE
 4549    00000048 14000000              DC32     DOTQ2-.
 4550                           DOTQ1:
 4551    0000004C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4552    00000050 ........              DC32    HERE
 4553    00000054 ........              DC32    COUNT
 4554    00000058 ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4555                                                   // endif
 4556                           #ifdef IO2TP
 4560                           #endif
 4561                           DOTQ2:
 4562    0000005C ........              DC32    SEMIS
 4563                           
 4564                           
 4565                           //      TYPE TYPE:      ( addr count -- )
 4566                           //      ADDR must be ALIGNED!
 4567                           //      OUT MUST BE INITIALIZED!!
 4568                           //      EMIT COUNT OF 8-bits in a string, preferably ascii characters,
 4569                           //      (last nfa char (+80h)ok!) from addr thru count,
 4570                           
 4571                            SECTION .text : CONST (2)
 4572                           TYPE_NFA:
 4573    00000000 84                    DC8     0x84
 4574    00000001 545950                DC8     'TYP'
 4575    00000004 C5                    DC8     'E'+0x80
 4576    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4577    00000008 ........              DC32    DOTQ_NFA
 4578                           TYPE:
 4579    0000000C ........              DC32    DOCOL
 4580    00000010 ........              DC32    ZNDUP
 4581    00000014 ........              DC32    ZBRAN   // IF NOTHING TO TYPE
 4582    00000018 34000000              DC32     TYPE1-.
 4583                           
 4584                           #ifdef XON_XOFF
 4585    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 4586                           #endif
 4587    00000020 ........              DC32    OVER
 4588    00000024 ........              DC32    PLUS
 4589    00000028 ........              DC32    SWAP
 4590    0000002C ........              DC32    XDO     // DO
 4591                           TYPE2:
 4592    00000030 ........              DC32    I
 4593    00000034 ........              DC32    CATLT7F // Limit output to ASCII characters under 80h
 4594    00000038 ........              DC32    EMIT
 4595                           tt1:
 4596    0000003C ........              DC32    XLOOP   // LOOP
 4597                           tt2:
 4598    00000040 F0FFFFFF              DC32     TYPE2-.
 4599                           
 4600    00000044 ........              DC32    BRAN    // ELSE
 4601    00000048 08000000              DC32     TYPE3-.
 4602                           TYPE1:
 4603    0000004C ........              DC32    DROP    // endif
 4604                           TYPE3:
 4605    00000050 ........              DC32    SEMIS
 4606                           
 4607                           
 4608                           //      EMIT EMIT:      ( c -- )
 4609                           //      Transmit ascii character c to the selected output device. OUT is
 4610                           //      incremented for each character output.
 4611                           
 4612                            SECTION .text : CONST (2)
 4613                           EMIT_NFA:
 4614    00000000 84                    DC8     0x84
 4615    00000001 454D49                DC8     'EMI'
 4616    00000004 D4                    DC8     'T'+0x80
 4617    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4618    00000008 ........              DC32    TYPE_NFA
 4619                           EMIT:
 4620                           #ifndef IO2TP
 4621                           // NOT IO2TP SECTION:
 4622    0000000C ........              DC32    .+5
 4623                            SECTION .text : CODE (2)
 4624                                   POP2t                   // GET CHAR
 4624.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4624.2                         //#ifndef TOSCT
 4624.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4624.4                         //#endif
 4624.5                         //      ADDS    p, p, #4
 4624.6                                 ENDM
 4625    00000004 ........              BL      TXRDY_SUBR
 4626    00000008 0649                  LDR     n, = USART3_DR // 
 4627                           // BSOUT handles negative out issue
 4628    0000000A 0870                  STRB    t, [n]          // EMIT (Send) Char
 4629    0000000C 0649                  LDR     n, = OUT        // Increment Out
 4630    0000000E 0868                  LDR     t, [n]
 4631    00000010 401C                  ADDS    t, t, #1
 4632    00000012 0860                  STR     t, [n]
 4633                                   NEXT
 4633.1                         // ARMv7-M Thumb = .+5
 4633.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4633.3                         // ARMv6-M Thumb = .+4
 4633.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4633                                   NEXT1
 4633.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4633.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4633.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4633.4                         // ARMv6-M Thumb = .+4
 4633.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4633.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4633.7                                 ENDM
 4633.8                                 ENDM
 4634                           #else // if IO2TP Transmit char to PAD, increment OUT
 4649                           #endif  // IO2TP
 4650    00000022 0000           LTORG
 4650.1                                  TABLE
 4650.2  00000024 04480040              Reference on line 4626
 4650.3  00000028 ........              Reference on line 4629
 4651                           
 4652                           
 4653                           //      KEY KEY:        (  -- ch )
 4654                           
 4655                            SECTION .text : CONST (2)
 4656                           KEY_NFA:
 4657    00000000 83                    DC8     0x83
 4658    00000001 4B45                  DC8     'KE'
 4659    00000003 D9                    DC8     'Y'+0x80
 4660                            ALIGNROM 2,0xFFFFFFFF
 4661    00000004 ........              DC32    EMIT_NFA
 4662                           KEY_INTERPRETED_ENTRY:
 4663                           #ifndef IO2TP
 4664    00000008 ........              DC32    DOCOL
 4665    0000000C ........              DC32    XON     // EXEC SETS XOFF SO UNDO IT
 4666    00000010 ........              DC32    KEY     // TE GET KEY!
 4667    00000014 ........              DC32    SEMIS
 4668                           
 4669                           
 4670                           //:NONAME KEY KEY:      ( -- CH ) 0-7Fh
 4671                           KEY:
 4672    00000018 ........              DC32    .+5
 4673                            SECTION .text : CODE (2)
 4674    00000000 074A                  LDR     w, = USART3_DR // 
 4675    00000002 084B                  LDR     x, = USART3_SR // 
 4676                           rxRDY?:
 4677    00000004 1968                  LDR     n, [x]          // Get Line Status
 4678                           //      LSRS    n, n, #5        // Bit 5 RXNE: Read data register not empty
 4679                           // THIS IS ___ AND FAILS TEXT DOWNLOAD
 4680    00000006 8909                  LSRS    n, n, #6        // Bit 6 ORIG - REQ'D FOR TEXT FILE DOWNLOAD
 4681    00000008 FCD3                  BCC     rxRDY?          // sets carry flag
 4682                           
 4683    0000000A 1068                  LDR     t, [w]
 4684                                   TPUSH
 4684                                   PUSHt   // push t to p, pre decrement p
 4684.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4684.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4684.3                         //      STR     t, [p]
 4684.4                                 ENDM
 4684                                   NEXT
 4684.1                         // ARMv7-M Thumb = .+5
 4684.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4684.3                         // ARMv6-M Thumb = .+4
 4684.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4684                                   NEXT1
 4684.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4684.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4684.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4684.4                         // ARMv6-M Thumb = .+4
 4684.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4684.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4684.7                                 ENDM
 4684.8                                 ENDM
 4684.9                                 ENDM
 4685                           #else
 4687                           #endif  // IO2TP
 4688    0000001E 0000           LTORG
 4688.1                                  TABLE
 4688.2  00000020 04480040              Reference on line 4674
 4688.3  00000024 00480040              Reference on line 4675
 4689                           
 4690                           
 4691                           //      ?KEY QKEY: ( -- f )
 4692                           //      Return zero unless key in fifo - key is not consumed.
 4693                           //      : TB BEGIN ?KEY UNTIL ; Will execute until any key is entered.
 4694                           
 4695                            SECTION .text : CONST (2)
 4696                           QKEY_NFA:
 4697    00000000 84                    DC8     0x84
 4698    00000001 3F4B45                DC8     '?KE'
 4699    00000004 D9                    DC8     'Y'+0x80
 4700    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4701    00000008 ........              DC32    KEY_NFA // -1
 4702                           QKEY:
 4703    0000000C ........              DC32    .+5
 4704                            SECTION .text : CODE (2)
 4705                           #ifdef IO2TP
 4707                           #else
 4708                           #ifdef XON_XOFF // XON IN QKEY
 4709    00000000 ........              BL      TXRDY_SUBR
 4710    00000004 ........              BL      XON_SUBR
 4711                           #endif
 4712    00000008 4040                  EORS    t, t    // zero t
 4713    0000000A 074B                  LDR     x, = USART3_SR
 4714    0000000C 1968                  LDR     n, [x]          // Get Line Status
 4715    0000000E 8909                  LSRS    n, n, #6        // Char available
 4716    00000010 00D3                  BCC     NO_KEY          // No char, not Ready
 4717                           
 4718                           // HAVE A KEY - DON'T CONSUME IT
 4719                           #ifdef TRUE_EQU_NEG_ONE
 4720    00000012 0138                  SUBS    t, #1   // -1
 4721                           #else
 4723                           #endif
 4724                           #endif  // DEFAULT TO NO KEY IF IO2TP
 4725                           NO_KEY:
 4726                                   TPUSH
 4726                                   PUSHt   // push t to p, pre decrement p
 4726.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4726.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4726.3                         //      STR     t, [p]
 4726.4                                 ENDM
 4726                                   NEXT
 4726.1                         // ARMv7-M Thumb = .+5
 4726.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4726.3                         // ARMv6-M Thumb = .+4
 4726.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4726                                   NEXT1
 4726.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4726.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4726.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4726.4                         // ARMv6-M Thumb = .+4
 4726.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4726.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4726.7                                 ENDM
 4726.8                                 ENDM
 4726.9                                 ENDM
 4727    00000026 0000           LTORG
 4727.1                                  TABLE
 4727.2  00000028 00480040              Reference on line 4713
 4728                           
 4729                           
 4730                           //      CRS CRS:        ( n_r0 -- )
 4731                           //      Emit n_r0 cr'S (0x0d) and lf (0x0A)
 4732                           
 4733                            SECTION .text : CONST (2)
 4734                           CRS_NFA:
 4735    00000000 83                    DC8     0x83
 4736    00000001 4352                  DC8     'CR'
 4737    00000003 D3                    DC8     'S'+0x80
 4738                            ALIGNROM 2,0xFFFFFFFF
 4739    00000004 ........              DC32    QKEY_NFA
 4740                           CRS:
 4741    00000008 ........              DC32    DOCOL
 4742    0000000C ........              DC32    ZERO
 4743    00000010 ........              DC32    XDO
 4744                           CRS_BEGIN:
 4745    00000014 ........              DC32    CR
 4746    00000018 ........              DC32    XLOOP
 4747    0000001C F8FFFFFF              DC32     CRS_BEGIN-.
 4748    00000020 ........              DC32    SEMIS
 4749                           
 4750                           
 4751                           //      CR CR:  ( -- )
 4752                           //      Emit cr (0x0d) and lf (0x0A)
 4753                           
 4754                            SECTION .text : CONST (2)
 4755                           CR_NFA:
 4756    00000000 82                    DC8     0x82
 4757    00000001 43                    DC8     'C'
 4758    00000002 D2                    DC8     'R'+0x80
 4759    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4760    00000004 ........              DC32    CRS_NFA
 4761                           CR:
 4762                           #ifdef IO2TP
 4765                           #else
 4766    00000008 ........              DC32    DOCOL
 4767    0000000C ........              DC32    zero_OUT
 4768    00000010 ........              DC32    PDOTQ
 4769    00000014 02                    DC8     2
 4770    00000015 0D0A                  DC8     0x0D, 0x0A
 4771    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 4772    00000018 ........              DC32    SEMIS
 4773                           #endif
 4774                           
 4775                           
 4776                           //=============================== WORDCAT ====================================//
 4777                           //NOEXEC HEADERFORWORDCATEGORIES
 4778                           //      WC_UART0_NFA = FISH IO: CATEGORY
 4779                           
 4780                            SECTION .text : CONST (2)
 4781                           WC_UARTx_NFA:
 4782    00000000 8C                    DC8     0x80+4+8
 4783    00000001 0D0A                  DC8     0x0D, 0x0A
 4784    00000003 4649534820494         DC8     'FISH IO:'
                  F3A          
 4785    0000000B 0D8A                  DC8     0x0D, 0x0A+0x80
 4786    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4787    00000010 ........              DC32    CR_NFA
 4788                           
 4789                           //      CMSIS_ENABLE_IRQS IRQS_RESUME:  ( -- )
 4790                            SECTION .text : CONST (2)
 4791                           IRQS_RESUME_NFA:
 4792    00000000 8B                    DC8     0x8B
 4793    00000001 495251535F524         DC8     'IRQS_RESUM'
                  553554D      
 4794    0000000B C5                    DC8     'E'+0x80
 4795                            ALIGNROM 2,0xFFFFFFFF
 4796    0000000C ........              DC32    WC_UARTx_NFA
 4797                           CMSIS_ENABLE_IRQS:
 4798    00000010 ........              DC32 .+5
 4799                            SECTION .text : CODE (2)
 4800                            ALIGNROM 2,0xFFFFFFFF
 4801                            IMPORT C_CMSIS_ENABLE_IRQS
 4802    00000000 ........              BL      C_CMSIS_ENABLE_IRQS
 4803                                   NEXT
 4803.1                         // ARMv7-M Thumb = .+5
 4803.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4803.3                         // ARMv6-M Thumb = .+4
 4803.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4803                                   NEXT1
 4803.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4803.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4803.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4803.4                         // ARMv6-M Thumb = .+4
 4803.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4803.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4803.7                                 ENDM
 4803.8                                 ENDM
 4804                           
 4805                           //      CMSIS_DISABLE_IRQS IRQS_SUSPEND:        ( -- )
 4806                            SECTION .text : CONST (2)
 4807                           IRQS_SUSPEND_NFA:
 4808    00000000 8C                    DC8     0x8C
 4809    00000001 495251535F535         DC8     'IRQS_SUSPEN'
                  55350454E    
 4810    0000000C C4                    DC8     'D'+0x80
 4811    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4812    00000010 ........              DC32    IRQS_RESUME_NFA
 4813                           CMSIS_DISABLE_IRQS:
 4814    00000014 ........              DC32 .+5
 4815                            SECTION .text : CODE (2)
 4816                            ALIGNROM 2,0xFFFFFFFF
 4817                            IMPORT C_CMSIS_DISABLE_IRQS
 4818    00000000 ........              BL      C_CMSIS_DISABLE_IRQS
 4819                                   NEXT
 4819.1                         // ARMv7-M Thumb = .+5
 4819.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4819.3                         // ARMv6-M Thumb = .+4
 4819.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4819                                   NEXT1
 4819.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4819.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4819.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4819.4                         // ARMv6-M Thumb = .+4
 4819.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4819.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4819.7                                 ENDM
 4819.8                                 ENDM
 4820                           
 4821                           
 4822                           //      SYSTICK_IRQ_OFF SYSTICK_IRQ_OFF:        ( -- )
 4823                           //      Turn SYSTICK interrupt off.
 4824                           //      STCTR only incremented when SYSTICK interrupt is on.
 4825                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4826                            SECTION .text : CONST (2)
 4827                           SYSTICK_IRQ_OFF_NFA:
 4828    00000000 8F                    DC8     0x8F
 4829    00000001 5359535449434         DC8     'SYSTICK_IRQ_OF'
                  B5F4952515F4F
                  46           
 4830    0000000F C6                    DC8     'F'+0x80
 4831                            ALIGNROM 2,0xFFFFFFFF
 4832    00000010 ........              DC32    IRQS_SUSPEND_NFA
 4833                           SYSTICK_IRQ_OFF:
 4834    00000014 ........              DC32    .+5
 4835                            SECTION .text : CODE (2)
 4836    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4837    00000002 0520                  MOVS    t, #5
 4838    00000004 0860                  STR     t, [n]
 4839                                   NEXT
 4839.1                         // ARMv7-M Thumb = .+5
 4839.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4839.3                         // ARMv6-M Thumb = .+4
 4839.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4839                                   NEXT1
 4839.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4839.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4839.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4839.4                         // ARMv6-M Thumb = .+4
 4839.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4839.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4839.7                                 ENDM
 4839.8                                 ENDM
 4840                           // LTORG         //Always outside of code, else data in words
 4841                           
 4842                           
 4843                           //      SYSTICK_IRQ_ON SYSTICK_IRQ_ON:  ( -- )
 4844                           //      Turn SYSTICK interrupt on.
 4845                           //      STCTR only incremented when SYSTICK interrupt is on.
 4846                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4846.1                                  TABLE
 4846.2  00000014 10E000E0              Reference on line 4836
 4847                            SECTION .text : CONST (2)
 4848                           SYSTICK_IRQ_ON_NFA:
 4849    00000000 8E                    DC8     0x8E
 4850    00000001 5359535449434         DC8     'SYSTICK_IRQ_O'
                  B5F4952515F4F
 4851    0000000E CE                    DC8     'N'+0x80
 4852    0000000F FF             ALIGNROM 2,0xFFFFFFFF
 4853    00000010 ........              DC32    SYSTICK_IRQ_OFF_NFA
 4854                           SYSTICK_IRQ_ON:
 4855    00000014 ........              DC32    .+5
 4856                            SECTION .text : CODE (2)
 4857    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4858    00000002 0720                  MOVS    t, #7
 4859    00000004 0860                  STR     t, [n]
 4860                                   NEXT
 4860.1                         // ARMv7-M Thumb = .+5
 4860.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4860.3                         // ARMv6-M Thumb = .+4
 4860.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4860                                   NEXT1
 4860.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4860.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4860.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4860.4                         // ARMv6-M Thumb = .+4
 4860.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4860.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4860.7                                 ENDM
 4860.8                                 ENDM
 4861                            LTORG   //Always outside of code, else data in words
 4861.1                                  TABLE
 4861.2  00000014 10E000E0              Reference on line 4857
 4862                           
 4863                           //=============================== WORDCAT ====================================//
 4864                           //NOEXEC HEADERFORWORDCATEGORIES
 4865                           //      WC_IRQ_NFA = INTERRUPTS: CATEGORY
 4866                           
 4867                            SECTION .text : CONST (2)
 4868                           WC_IRQ_NFA:
 4869    00000000 8F                    DC8     0x80+4+11
 4870    00000001 0D0A                  DC8     0x0D, 0x0A
 4871    00000003 494E544552525         DC8     'INTERRUPTS:'
                  55054533A    
 4872    0000000E 0D8A                  DC8     0x0D, 0x0A+0x80
 4873                            ALIGNROM 2,0xFFFFFFFF
 4874    00000010 ........              DC32    SYSTICK_IRQ_ON_NFA
 4875                           
 4876                           
 4877                           //------------------------------------------------------------------------------
 4878                           $FISH_STM32F4_FLASH.s       // FLASH_SAVE and FLASH_FORGET Words
 4879                           // LFA BELOW NEEDS TO BE FLASH_FORGET_NFA
 4880                           //------------------------------------------------------------------------------
 4881                           
 4882                           //-------------------------- PROMPT VECTOR SECTION -----------------------------
 4883                           
 4884                           //      POFF ( -- )   Set NULL$ address in PROMPT to zero so quit does CR only.
 4885                           
 4886                            SECTION .text : CONST (2)
 4887                           POFF_NFA:
 4888    00000000 84                    DC8     0x84
 4889    00000001 504F46                DC8     'POF'
 4890    00000004 C6                    DC8     'F'+0x80
 4891    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4892    00000008 ........              DC32    FLASH_FORGET_NFA
 4893                           POFF:
 4894    0000000C ........              DC32    DOCOL
 4895    00000010 ........00000         DC32    STRVA, 0, PROMPT
                  000........  
 4896    0000001C ........              DC32    SEMIS
 4897                           
 4898                           //      PON ( -- )   Set NULL$ address in PROMPT to msg_MY_OK
 4899                           
 4900                            SECTION .text : CONST (2)
 4901                           PON_NFA:
 4902    00000000 83                    DC8     0x83
 4903    00000001 504F                  DC8     'PO'
 4904    00000003 CE                    DC8     'N'+0x80
 4905                            ALIGNROM 2,0xFFFFFFFF
 4906    00000004 ........              DC32    POFF_NFA
 4907                           PON:
 4908    00000008 ........              DC32    DOCOL
 4909    0000000C .............         DC32    STRVA, msg_MY_OK, PROMPT
                  ...........  
 4910    00000018 ........              DC32    SEMIS
 4911                           
 4912                           //      P ( -- addr )   Address of PROMPT, contains 0 or NULL$ address.
 4913                           
 4914                            SECTION .text : CONST (2)
 4915                           P_NFA:
 4916    00000000 81                    DC8     0x81
 4917    00000001 D0                    DC8     'P'+0x80
 4918    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4919    00000004 ........              DC32    PON_NFA
 4920                           P:
 4921    00000008 .............         DC32    DOCON, PROMPT
                  ...          
 4922                           
 4923                           //-------------------------- ERROR_HALT SECTION -----------------------------
 4924                           
 4925                           //      EHOFF ( -- )   Set ERROR_HALT to 0
 4926                           
 4927                            SECTION .text : CONST (2)
 4928                           EHOFF_NFA:
 4929    00000000 85                    DC8     0x85
 4930    00000001 45484F46              DC8     'EHOF'
 4931    00000005 C6                    DC8     'F'+0x80
 4932    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4933    00000008 ........              DC32    P_NFA
 4934                           EHOFF:
 4935    0000000C .............         DC32    DOCOL, ZERO, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 4936                           
 4937                           //      EHON ( -- )   Set ERROR_HALT to 1
 4938                           
 4939                            SECTION .text : CONST (2)
 4940                           EHON_NFA:
 4941    00000000 84                    DC8     0x84
 4942    00000001 45484F                DC8     'EHO'
 4943    00000004 CE                    DC8     'N'+0x80
 4944    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4945    00000008 ........              DC32    EHOFF_NFA
 4946                           EHON:
 4947    0000000C .............         DC32    DOCOL, ONE, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 4948                           
 4949                           //-------------------------- DOTDICTSPACE SECTION ------------------------------
 4950                           
 4951                           //      .DS DOTDICTSPACE:       ( n_r0 -- )
 4952                           //      Prints number of bytes availble in dictionary in DECIMAL using DOT,
 4953                           //      not affecting Base in the system
 4954                           
 4955                            SECTION .text : CONST (2)
 4956                           DOTDICTSPACE_NFA:
 4957    00000000 83                    DC8     0x83
 4958    00000001 2E44                  DC8     '.D'
 4959    00000003 D3                    DC8     'S'+0x80
 4960                            ALIGNROM 2,0xFFFFFFFF
 4961                           //      DC32    FLASH_FORGET_NFA
 4962                           //      DC32    P_NFA
 4963    00000004 ........              DC32    EHON_NFA
 4964                           DOTDICTSPACE:
 4965    00000008 ........              DC32    DOCOL
 4966    0000000C ........              DC32    DICTSPACE
 4967    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 4968    00000014 ........              DC32    DOTDEC
 4969    00000018 ........              DC32    BASE_FROM_R12   // Restore BASE
 4970    0000001C .............         DC32    LIT, msg_dictspace
                  ...          
 4971    00000024 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 4972                           #ifdef IO2TP
 4976                           #endif
 4977    0000002C ........              DC32    SEMIS
 4978                           
 4979                           
 4980                           //-------------------------- DOTVARSPACE SECTION -------------------------------
 4981                           
 4982                           //      .VS DOTVARSPACE:        ( n_r0 -- )
 4983                           //      Prints number of bytes availble in RAM VAR SPACE in DECIMAL using DOT,
 4984                           //      not affecting Base in the system.
 4985                           
 4986                            SECTION .text : CONST (2)
 4987                           DOTVARSPACE_NFA:
 4988    00000000 83                    DC8     0x83
 4989    00000001 2E56                  DC8     '.V'
 4990    00000003 D3                    DC8     'S'+0x80
 4991                            ALIGNROM 2,0xFFFFFFFF
 4992    00000004 ........              DC32    DOTDICTSPACE_NFA
 4993                           DOTVARSPACE:
 4994    00000008 ........              DC32    DOCOL
 4995    0000000C ........              DC32    VARSPACE
 4996    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 4997    00000014 .............         DC32    FOUR, SLASH
                  ...          
 4998    0000001C ........              DC32    DOTDEC
 4999    00000020 ........              DC32    BASE_FROM_R12   // Restore BASE
 5000    00000024 .............         DC32    LIT, msg_uvspace
                  ...          
 5001    0000002C .............         DC32    NULLSTRLEN, TYPE
                  ...          
 5002                           #ifdef IO2TP
 5006                           #endif
 5007    00000034 ........              DC32    SEMIS
 5008                           
 5009                           
 5010                           //      DUMP DUMP:      ( addr n_r0 -- )
 5011                           //      Print adrr and n_r0 lines of 4 columns of memory values in hexadecimal.
 5012                           //      Address must be even and a multiple of 4 else error message issued.
 5013                           //      Any key presssed will stop DUMP.
 5014                           
 5015                            SECTION .text : CONST (2)
 5016                           DUMP_NFA:
 5017    00000000 84                    DC8     0x84
 5018    00000001 44554D                DC8     'DUM'
 5019    00000004 D0                    DC8     'P'+0x80
 5020    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5021    00000008 ........              DC32    DOTVARSPACE_NFA
 5022                           DUMP:
 5023    0000000C ........              DC32    DOCOL
 5024                           
 5025    00000010 .............         DC32    OVER, QALIGNED  // \ -- addr n_r0
                  ...          
 5026                           // DON'T SAVE BASE UNTIL AFTER ALIGNED TEST
 5027    00000018 ........              DC32    BASE_TO_R12     // Save current BASE
 5028    0000001C ........              DC32    HEX
 5029    00000020 .............         DC32    ZERO, XDO
                  ...          
 5030                           DUMP_ADDR_LINE:
 5031    00000028 ........              DC32    CR
 5032    0000002C .............         DC32    DUP, LIT, 10, DOTRU     // Print addr in Field
                  ...0A000000..
                  ......       
 5033    0000003C .............         DC32    FOUR, ZERO, XDO         // Four colum loop
                  ...........  
 5034                           DUMP_EACH_LOC:
 5035    00000048 .............         DC32    DUP, AT
                  ...          
 5036                           // Little Endian means addresses will print correctly
 5037                           // but to see character strings REVW is needed
 5038                           // but the addresses are scrambled!
 5039                           //        DC32    REVW                    // Reverse bytes in word
 5040    00000050 ........0E000         DC32    LIT, 14, DOTRU          // Diplay in Field
                  000........  
 5041    0000005C ........              DC32    FOURP
 5042    00000060 ........              DC32    XLOOP
 5043    00000064 E4FFFFFF              DC32     DUMP_EACH_LOC-.
 5044                           
 5045                           #ifdef IO2TP
 5049                           #endif
 5050    00000068 ........              DC32    QKEY
 5051    0000006C ........              DC32    ZBRAN
 5052    00000070 08000000              DC32     DUMP_CONT-.
 5053    00000074 ........              DC32    LEAVE
 5054                           DUMP_CONT:
 5055    00000078 ........              DC32    XLOOP
 5056    0000007C ACFFFFFF              DC32    DUMP_ADDR_LINE-.
 5057                           
 5058    00000080 .............         DC32    DROP, CR
                  ...          
 5059    00000088 ........              DC32    BASE_FROM_R12   // Restore BASE
 5060    0000008C ........              DC32    SEMIS
 5061                           
 5062                           
 5063                           //      VBASE VBASE:    ( -- addr )
 5064                           //      Return base addr of VAR's .
 5065                           
 5066                            SECTION .text : CONST (2)
 5067                           VBASE_NFA:
 5068    00000000 85                    DC8     0x85
 5069    00000001 56424153              DC8     'VBAS'
 5070    00000005 C5                    DC8     'E'+0x80
 5071    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5072    00000008 ........              DC32    DUMP_NFA
 5073                           VBASE:
 5074    0000000C .............         DC32    DOCON,  RAMVARSPACE_START
                  ...          
 5075                           
 5076                           
 5077                           //      DBASE DBASE:    ( -- addr )
 5078                           //      Return base addr of the dictionary.
 5079                           
 5080                            SECTION .text : CONST (2)
 5081                           DBASE_NFA:
 5082    00000000 85                    DC8     0x85
 5083    00000001 44424153              DC8     'DBAS'
 5084    00000005 C5                    DC8     'E'+0x80
 5085    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5086    00000008 ........              DC32    VBASE_NFA
 5087                           DBASE:
 5088    0000000C .............         DC32    DOCON,  ORIG
                  ...          
 5089                           
 5090                           
 5091                           //      RBASE RBASE:    ( -- addr )
 5092                           //      Return base addr of RAM THE DICTIONARY IS IN!.
 5093                           
 5094                            SECTION .text : CONST (2)
 5095                           RBASE_NFA:
 5096    00000000 85                    DC8     0x85
 5097    00000001 52424153              DC8     'RBAS'
 5098    00000005 C5                    DC8     'E'+0x80
 5099    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5100    00000008 ........              DC32    DBASE_NFA
 5101                           RBASE:
 5102    0000000C .............         DC32    DOCON,  RAM_START    // RAM WHERE DICT ALLOACTED IN MEMMAP
                  ...          
 5103                           
 5104                           
 5105                           //      CLS CLS:        ( -- )
 5106                           //      Clear serial terminal screen using a formfeed character
 5107                           
 5108                            SECTION .text : CONST (2)
 5109                           CLS_NFA:
 5110    00000000 83                    DC8     0x83
 5111    00000001 434C                  DC8     'CL'
 5112    00000003 D3                    DC8     'S'+0x80
 5113                            ALIGNROM 2,0xFFFFFFFF
 5114    00000004 ........              DC32    RBASE_NFA
 5115                           CLS:
 5116    00000008 ........              DC32    DOCOL
 5117    0000000C ........              DC32    PDOTQ
 5118    00000010 04                    DC8     4
 5119    00000011 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT100 ESC SETUP
 5120    00000013 324A                  DC8     '2J'            // Clearscreen
 5121    00000015 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5122    00000018 ........              DC32    PDOTQ
 5123    0000001C 04                    DC8     4
 5124    0000001D 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT00 ESC SETUP
 5125    0000001F 3B48                  DC8     ';H'            // CURSORHOME \ upper left corner
 5126    00000021 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5127    00000024 ........              DC32    CR              // Reset OUT
 5128    00000028 ........              DC32    SEMIS
 5129                           
 5130                           
 5131                           //      ( PAREN:        ( -- ) IMMEDIATE
 5132                           //      Used in the form:
 5133                           //              ( CCcc )
 5134                           //      Ignore comments within parenthesis. A right parenthesis ends comment.
 5135                           //      The comments may be multi-line but a space or tab is required
 5136                           //      for any line that is otherwise empty for formatting purposes,
 5137                           //      else a comment error will be printed. May occur during execution or in a
 5138                           //      colon-definition. A blank after the leading parenthesis is required.
 5139                           
 5140                            SECTION .text : CONST (2)
 5141                           PAREN_NFA:
 5142    00000000 C1                    DC8     0x0C1
 5143    00000001 A8                    DC8     '('+0x80
 5144    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5145    00000004 ........              DC32    CLS_NFA
 5146                           PAREN:
 5147                           // Slow Single line comment
 5148                           //      DC32    DOCOL, LIT, ')', WORD, SEMIS
 5149    00000008 ........              DC32    DOCOL
 5150                           PML_LOOP:
 5151    0000000C ........29000         DC32    LIT, ')'
                  000          
 5152    00000014 ........              DC32    TIB_CHAR_SCAN   // ( c -- f )
 5153                           //
 5154    00000018 ........              DC32    ZEQU            // If null
 5155    0000001C ........              DC32    ZBRAN           // found fall thru
 5156    00000020 34000000              DC32      PE_DONE-.     // else were done
 5157                           
 5158                           // Acting like the outer interpreter here, signal DLE
 5159    00000024 .............         DC32    CR, LIT, 0x10, EMIT
                  ...10000000..
                  ......       
 5160    00000034 ........              DC32    QUERY
 5161                           //  AND IF ONLY CR (null) ERR
 5162                           //        DC32    TIB_SV, CAT
 5163    00000038 .............         DC32    LIT, TIB+1, CAT // PAST COUNT BYTE
                  ...........  
 5164    00000044 ........              DC32    ZBRAN
 5165    00000048 10000000              DC32      PAREN_ERR-.
 5166                           
 5167                           //  If closing paren not in this line LOOP
 5168    0000004C ........              DC32    BRAN
 5169    00000050 BCFFFFFF              DC32      PML_LOOP-.
 5170                           
 5171                           PE_DONE:
 5172    00000054 ........              DC32    SEMIS
 5173                           
 5174                           PAREN_ERR:
 5175    00000058 .............         DC32    LIT, msg_paren_err
                  ...          
 5176    00000060 .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 5177    00000068 ........              DC32    SEMIS
 5178                           
 5179                           
 5180                           //      BACKSLASH BACKSLASH:    ( --  )
 5181                           //      After a trailing space treat the rest of the line as a comment.
 5182                           //      By setting a null terminator in TIB
 5183                           
 5184                            SECTION .text : CONST (2)
 5185                           BACKSLASH_NFA:
 5186    00000000 C1                    DC8     0x0C1
 5187    00000001 DC                    DC8     '\\'+0x80
 5188    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5189    00000004 ........              DC32    PAREN_NFA
 5190                           BACKSLASH:
 5191    00000008 ........              DC32    DOCOL
 5192    0000000C .............         DC32    ZERO, TIB_SV, IN_SV, AT, PLUS, CSTORE
                  .............
                  .............
                  .........    
 5193    00000024 ........              DC32    SEMIS
 5194                           
 5195                           
 5196                           //      SYSCLK SYSCLK:  ( -- value )
 5197                           //      Returns system clock value in Hz, i.e. 48000000 = 48Mhz.
 5198                           
 5199                            SECTION .text : CONST (2)
 5200                           SYSCLK_NFA:
 5201    00000000 86                    DC8     0x86
 5202    00000001 535953434C            DC8     'SYSCL'
 5203    00000006 CB                    DC8     'K'+0x80
 5204    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 5205    00000008 ........              DC32    BACKSLASH_NFA
 5206                           SYSCLK:
 5207    0000000C ........              DC32    .+5
 5208                            SECTION .text : CODE (2)
 5209    00000000 0549                  LDR     n, = SYSCLOCK   // SystemCoreClock
 5210    00000002 0868                  LDR     t, [n]
 5211                                   TPUSH   // Push -- t
 5211                                   PUSHt   // push t to p, pre decrement p
 5211.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 5211.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 5211.3                         //      STR     t, [p]
 5211.4                                 ENDM
 5211                                   NEXT
 5211.1                         // ARMv7-M Thumb = .+5
 5211.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5211.3                         // ARMv6-M Thumb = .+4
 5211.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5211                                   NEXT1
 5211.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5211.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5211.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5211.4                         // ARMv6-M Thumb = .+4
 5211.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5211.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5211.7                                 ENDM
 5211.8                                 ENDM
 5211.9                                 ENDM
 5212    00000016 0000           LTORG   //Always outside of code, else data in words
 5212.1                                  TABLE
 5212.2  00000018 ........              Reference on line 5209
 5213                           
 5214                           
 5215                           //      STCTR   ( -- addr ) SYSTICK Interrupt increments this with 32but wrap.
 5216                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5217                            SECTION .text : CONST (2)
 5218                           STCTR_NFA:
 5219    00000000 85                    DC8     0x85
 5220    00000001 53544354              DC8     'STCT'
 5221    00000005 D2                    DC8     'R'+0x80
 5222    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5223                           //      DC32    STI_ON_NFA
 5224    00000008 ........              DC32    SYSCLK_NFA
 5225                           STCTR:
 5226    0000000C .............         DC32    DOCON, STICKER
                  ...          
 5227                           
 5228                           
 5229                           //      DELAY ( n_r0 value -- ) 7 E000E010h !   5 E000E010h !
 5230                            SECTION .text : CONST (2)
 5231                           DELAY_NFA:
 5232    00000000 85                    DC8     0x85
 5233    00000001 44454C41              DC8     'DELA'
 5234    00000005 D9                    DC8     'Y'+0x80
 5235    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5236    00000008 ........              DC32    STCTR_NFA
 5237                           DELAY:
 5238    0000000C ........              DC32    .+5
 5239                            SECTION .text : CODE (2)
 5240                                   POP2n   // Reload value in n
 5240.1  00000000 57F8041B              LDR     n, [p],#4
 5240.2                         //      LDR     n, [p]
 5240.3                         //      ADDS    p, p, #4
 5240.4                                 ENDM
 5241                                   POP2t   // loop count in t
 5241.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 5241.2                         //#ifndef TOSCT
 5241.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 5241.4                         //#endif
 5241.5                         //      ADDS    p, p, #4
 5241.6                                 ENDM
 5242                           // SET STCTR TO NEGATIVE LOOP COUNT TO END AT ZERO
 5243    00000008 0C4C                  LDR     y, = STICKER
 5244    0000000A C043                  MVNS    t, t            // 1's compliment
 5245    0000000C 401C                  ADDS    t, t, #1        // 2's compliment
 5246    0000000E 2060                  STR     t, [y]
 5247                           // Load SYST_RVR with countdown value
 5248    00000010 0B4A                  LDR     w, = SYST_RVR
 5249    00000012 1160                  STR     n, [w]
 5250                           // and reset SYST_CVR to start countdown.
 5251    00000014 0B4A                 LDR     w, = SYST_CVR
 5252                           // Writing it clears the System Tick counter and the COUNTFLAG bit in STCTRL.
 5253    00000016 1160                  STR     n, [w]
 5254                           // If n=0 in t user is just setting reload value
 5255    00000018 0028                  CMP     t, #0           // LOOP OF ZERO
 5256    0000001A 06D0                  BEQ     DELAY_DONE
 5257                           // INTERRUPT VERSION: negate n_r0 to STCTR and leave when STCTR = 0
 5258                           // STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5259                           // Save and restore user interrupt setting
 5260                           // y = STICKER
 5261    0000001C 0A4A                  LDR     w, = SYST_CSR
 5262    0000001E 1068                  LDR     t, [w]          // Save user SYSTICK interrupt setting
 5263    00000020 0721                  MOVS    n, #7
 5264    00000022 1160                  STR     n, [w]          // Turn SYSTICK interrupt on in case it's off
 5265                           DELAY_LOOP:
 5266    00000024 2168                  LDR     n, [y]
 5267    00000026 0029                  CMP     n, #0
 5268    00000028 FCD1                  BNE     DELAY_LOOP
 5269                           DELAY_DONE:
 5270    0000002A 1060                  STR     t, [w]  // Restore user SYSTICK interrupt setting
 5271                                   NEXT
 5271.1                         // ARMv7-M Thumb = .+5
 5271.2  0000002C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5271.3                         // ARMv6-M Thumb = .+4
 5271.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5271                                   NEXT1
 5271.1  00000030 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5271.2  00000034 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5271.3  00000038 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5271.4                         // ARMv6-M Thumb = .+4
 5271.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5271.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5271.7                                 ENDM
 5271.8                                 ENDM
 5272    0000003A 0000           LTORG
 5272.1                                  TABLE
 5272.2  0000003C ........              Reference on line 5243
 5272.3  00000040 14E000E0              Reference on line 5248
 5272.4  00000044 18E000E0              Reference on line 5251
 5272.5  00000048 10E000E0              Reference on line 5261
 5273                           
 5274                           
 5275                           //      MS MS: ( n_r0 -- ) n_r0 * 1 millisecond execution time
 5276                           //      SYSTICK_IRQ_ON/OFF  STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! 
 5277                           
 5278                            SECTION .text : CONST (2)
 5279                           MS_NFA:
 5280    00000000 82                    DC8     0x82
 5281    00000001 4D                    DC8     'M'
 5282    00000002 D3                    DC8     'S'+0x80
 5283    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 5284    00000004 ........              DC32    DELAY_NFA
 5285                           MS:
 5286    00000008 ........              DC32    DOCOL
 5287                           #ifdef STM32F4_IRC16_48MHZ
 5289                           #endif
 5290                           #ifdef STM32F205RC_XRC10_118MHZ
 5292                           #endif
 5293                           #ifdef STM32F4_XRC08_168MHZ
 5294    0000000C ........3F900         DC32    LIT, 167999d    // 2903Fh 1ms @ 168mhz RELOAD COUNTER VALUE
                  200          
 5295                           #endif
 5296    00000014 ........              DC32    DELAY
 5297    00000018 ........              DC32    SEMIS
 5298                           
 5299                           
 5300                           //      WORDCAT WORDCAT: ( -- )
 5301                           //      Creates a Word Category NFA and LFA that cannot be searched for,
 5302                           //      but is displayed by WORDS and MYWORDS to label a group of Words.
 5303                           //      Define a group of Words and then add a category name with WORDCAT.
 5304                           //      EX: WORDCAT MY APP WORDS:
 5305                           //      It must be on a line of it's own.
 5306                           //      The colon at the end is FISH convention.
 5307                            SECTION .text : CONST (2)
 5308                           WORDCAT_NFA:
 5309    00000000 87                    DC8     0x87
 5310    00000001 574F52444341          DC8     'WORDCA'
 5311    00000007 D4                    DC8     'T'+0x80
 5312                            ALIGNROM 2,0xFFFFFFFF
 5313    00000008 ........              DC32    MS_NFA
 5314                           WORDCAT:
 5315    0000000C ........              DC32    DOCOL
 5316    00000010 .............         DC32    HERE, TOR
                  ...          
 5317    00000018 .............         DC32    ZERO, CCOMMA    // Count byte place holder
                  ...          
 5318    00000020 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5319    0000002C ........              DC32    HERE
 5320    00000030 ........0D000         DC32    LIT, 0Dh, WORD
                  000........  
 5321    0000003C .............         DC32    DUP, CAT
                  ...          
 5322    00000044 ........0A000         DC32    LIT, 0Ah, ROT, CSTORE
                  000..........
                  ......       
 5323    00000054 .............         DC32    DUP, ONEP, ALLOT
                  ...........  
 5324    00000060 ........84000         DC32    LIT, 084h        // Count before system text
                  000          
 5325    00000068 .............         DC32    PLUS, R, CSTORE
                  ...........  
 5326    00000074 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5327    00000080 ........8A000         DC32    LIT, 08Ah, CCOMMA
                  000........  
 5328    0000008C ........              DC32    ALIGN32_DP_FF_PAD
 5329    00000090 .............         DC32    LATEST, COMMA
                  ...          
 5330    00000098 ........              DC32    RFROM
 5331    0000009C .............         DC32    LIT, CURRENT
                  ...          
 5332    000000A4 ........              DC32    STORE
 5333    000000A8 ........              DC32    SEMIS
 5334                           
 5335                           
 5336                           //      WORDS WORDS:    ( -- ) RENAMED: VLIST to WORDS
 5337                           //      Output list of Words in the dictionary in search order.
 5338                           //      Uses WC_ nfa's to format Word Categories.
 5339                           //      Uses FENCE for where to stop.
 5340                           //      See MYWORDS.
 5341                           
 5342                            SECTION .text : CONST (2)
 5343                           WORDS_NFA:
 5344    00000000 85                    DC8     0x85
 5345    00000001 574F5244              DC8     'WORD'
 5346    00000005 D3                    DC8     'S'+0x80
 5347    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5348    00000008 ........              DC32    WORDCAT_NFA
 5349                           WORDS:
 5350    0000000C ........              DC32    DOCOL
 5351    00000010 .............         DC32    THREE, SPACES
                  ...          
 5352    00000018 ........              DC32    LATEST
 5353                           #ifdef XON_XOFF
 5354    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 5355                           #endif
 5356                           WORDS1:  // ADD nfa length to current out_uv & verify it doesn't violate csll.
 5357                           
 5358    00000020 .............         DC32    ZERO, OVER      // -- nfa zero nfa
                  ...          
 5359    00000028 .............         DC32    ONEP, CAT       // If wc_ header skip
                  ...          
 5360    00000030 ........0D000         DC32    LIT, 0x0D       // -- nfa zero (c@) 0x0D
                  000          
 5361    00000038 .............         DC32    EQUAL, ZEQU     // -- nfa zerro flag
                  ...          
 5362    00000040 ........              DC32    ZBRAN           // -- nfa zero
 5363    00000044 1C000000              DC32     WORDS2-.       // wc_ goto
 5364                                   
 5365    00000048 ........              DC32    DROP            // -- nfa
 5366    0000004C .............         DC32    DUP, PFA, LFA   // -- nfa lfa
                  ...........  
 5367    00000058 .............         DC32    OVER, SUBB      // -- nfa (lfa - nfa)
                  ...          
 5368                           
 5369                           WORDS2: // -- nfa n_r0
 5370                           
 5371    00000060 .............         DC32    OUT_SV, AT
                  ...          
 5372    00000068 ........              DC32    PLUS
 5373    0000006C ........4A000         DC32    LIT, 74         // was :NONAME CSLL - WORDS line length constant.
                  000          
 5374    00000074 ........              DC32    GREATERTHAN
 5375    00000078 ........              DC32    ZBRAN           // If not at end of line
 5376    0000007C 10000000              DC32     WORD21-.        // skip cr and out reset
 5377                           
 5378    00000080 ........              DC32    CR              // Start another line
 5379    00000084 .............         DC32    THREE, SPACES
                  ...          
 5380                           
 5381                           WORD21:
 5382                           #ifdef  IO2TP
 5385                           #endif
 5386                           // For MYWORDS test FENCE and stop if less
 5387    0000008C ........              DC32    DUP             // nfa
 5388    00000090 .............         DC32    FENCE_SV, AT
                  ...          
 5389    00000098 ........              DC32    LESSTHAN
 5390    0000009C ........              DC32    ZBRAN
 5391    000000A0 0C000000              DC32     WORDSCONT-.
 5392                           
 5393    000000A4 ........              DC32    BRAN
 5394    000000A8 54000000              DC32     WORDSDONE-.
 5395                           
 5396                           WORDSCONT:
 5397    000000AC ........              DC32    DUP             // nfa
 5398    000000B0 ........              DC32    IDDOT
 5399    000000B4 .............         DC32    TWO, SPACES
                  ...          
 5400                           
 5401    000000BC .............         DC32    DUP, ONEP, CAT  // Take nfa and look for WORDCAT signature
                  ...........  
 5402    000000C8 ........0D000         DC32    LIT, 0x0D       // which is cr
                  000          
 5403    000000D0 ........              DC32    EQUAL
 5404    000000D4 ........              DC32    ZBRAN           // If not wordcat
 5405    000000D8 08000000              DC32     NOT_WC-.       // skip
 5406                           
 5407    000000DC ........              DC32    zero_OUT
 5408                           
 5409                           NOT_WC:
 5410    000000E0 ........              DC32    PFA             // \ nfa -- pfa
 5411    000000E4 ........              DC32    LFA             // \ pfa -- lfa
 5412    000000E8 ........              DC32    AT              // Is next lfa
 5413    000000EC ........              DC32    DUP
 5414    000000F0 ........              DC32    ZEQU            // Zero = end of dictionary
 5415                           
 5416                           // REMOVED SO WORDS AND MYWORDS CAN BE USED IN DOWNLOAD FILES
 5417                           //      DC32    QKEY           // Zero or break key \ ^C = 0x03
 5418                           //      DC32    OR
 5419                           
 5420    000000F4 ........              DC32    ZBRAN           // Until break key or end of dictionary
 5421    000000F8 28FFFFFF              DC32     WORDS1-.
 5422                           
 5423                           #ifdef  IO2TP
 5426                           #endif
 5427                           WORDSDONE:
 5428    000000FC .............         DC32    DROP, CR
                  ...          
 5429    00000104 ........              DC32    SEMIS
 5430                           
 5431                           
 5432                           //      MYWORDS MYWORDS: ( -- )
 5433                           //      Print only system defined words by manipulating FENCE.
 5434                           
 5435                            SECTION .text : CONST (2)
 5436                           MYWORDS_NFA:
 5437    00000000 87                    DC8     0x87
 5438    00000001 4D59574F5244          DC8     'MYWORD'
 5439    00000007 D3                    DC8     'S'+0x80
 5440                            ALIGNROM 2,0xFFFFFFFF
 5441    00000008 ........              DC32    WORDS_NFA
 5442                           MYWORDS:
 5443    0000000C ........              DC32    DOCOL
 5444    00000010 ........00000         DC32    strva , FLASH_SPAGE, FENCE
                  208........  
 5445    0000001C ........              DC32    WORDS                   // now print words in ram
 5446    00000020 ........00000         DC32    strva, 0 , FENCE
                  000........  
 5447    0000002C ........              DC32    SEMIS
 5448                           
 5449                           
 5450                           //      FISH_ONLY FISH_ONLY     ( -- ) MODIFIED:
 5451                           //      RESET DP, UP AND CURRENT TO ORIGINAL FLASH IMAGE
 5452                           
 5453                            SECTION .text : CONST (2)
 5454                           FISH_ONLY_NFA:
 5455    00000000 89                    DC8     0x80+9
 5456    00000001 464953485F4F4         DC8     'FISH_ONL'
                  E4C          
 5457    00000009 D9                    DC8     'Y'+0x80
 5458    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 5459    0000000C ........              DC32    MYWORDS_NFA
 5460                           FISH_ONLY:
 5461    00000010 ........              DC32    .+5
 5462                            SECTION .text : CODE (2)
 5463                           //      LDR     n, = TASK_NFA           // preserve TOS
 5464                           #ifdef FISH_PubRel_WORDSET
 5465    00000000 0949                  LDR     n, = WC_FISH_PubRel_NFA
 5466                           #endif
 5467                           #ifdef FISH_STM32M407vg_PRO_WORDCAT
 5469                           #endif
 5470    00000002 0A4C                  LDR     y, = CURRENT            // CURRENT SETTING
 5471    00000004 2160                  STR     n, [y]
 5472    00000006 0A4C                  LDR     y, = FPC                // FLASH CURRENT
 5473    00000008 2160                  STR     n, [y]
 5474    0000000A 0A49                  LDR     n, = RAMVARSPACE_START
 5475    0000000C 0A4C                  LDR     y, = UP                 // UP SETTING
 5476    0000000E 2160                  STR     n, [y]
 5477    00000010 0A4C                  LDR     y, = FPSV                // FLASH USER VARS
 5478    00000012 2160                  STR     n, [y]
 5479    00000014 0A49                  LDR     n, = ORIG
 5480    00000016 0B4C                  LDR     y, = DP                 // DP SETTING
 5481    00000018 2160                  STR     n, [y]
 5482                                   NEXT
 5482.1                         // ARMv7-M Thumb = .+5
 5482.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5482.3                         // ARMv6-M Thumb = .+4
 5482.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5482                                   NEXT1
 5482.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5482.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5482.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5482.4                         // ARMv6-M Thumb = .+4
 5482.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5482.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5482.7                                 ENDM
 5482.8                                 ENDM
 5483                            LTORG
 5483.1                                  TABLE
 5483.2  00000028 ........              Reference on line 5465
 5483.3  0000002C ........              Reference on line 5470
 5483.4  00000030 ........              Reference on line 5472
 5483.5  00000034 ........              Reference on line 5474
 5483.6  00000038 ........              Reference on line 5475
 5483.7  0000003C ........              Reference on line 5477
 5483.8  00000040 ........              Reference on line 5479
 5483.9  00000044 ........              Reference on line 5480
 5484                           
 5485                           
 5486                           //      FISH FISH:      ( -- )
 5487                           //      Print Flash Status and FISH Signon Message.
 5488                           
 5489                           
 5490                            SECTION .text : CONST (2)
 5491                           FISH_NFA:
 5492    00000000 84                    DC8     0x84
 5493    00000001 464953                DC8     'FIS'
 5494    00000004 C8                    DC8     'H'+0x80
 5495    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5496    00000008 ........              DC32    FISH_ONLY_NFA
 5497                           FISH:
 5498    0000000C ........              DC32    DOCOL
 5499    00000010 ........              DC32    FLASH_SCAN
 5500    00000014 ........              DC32    SIGNON
 5501    00000018 ........              DC32    SEMIS
 5502                           
 5503                           //=============================== WORDCAT ====================================//
 5504                           //NOEXEC HEADERFORWORDCATEGORIES
 5505                           //      WC_FISH_PubRel: = FISH Reference Model: CATEGORY
 5506                            SECTION .text : CONST (2)
 5507                           WC_FISH_PubRel_NFA:
 5508    00000000 99                    DC8     0x80+4+21
 5509    00000001 0D0A                  DC8     0x0D, 0x0A
 5510    00000003 4649534820526         DC8     'FISH Reference Model:'
                  5666572656E63
                  65204D6F64656
                  C3A          
 5511    00000018 0D8A                  DC8     0x0D, 0x0A+0x80
 5512    0000001A FFFF           ALIGNROM 2,0xFFFFFFFF
 5513    0000001C ........              DC32    FISH_NFA
 5514                           
 5515                           ;**** FIRST WORD LISTED****
 5516                           
 5517                           //=============================== WORDCAT ====================================//
 5518                           
 5519                           #ifdef FISH_STM_M3_PRO_WORDCAT
 5521                           #endif
 5522                           // FIRST WORDCAT
 5523                           
 5524                           //------------------------------------------------------------------------------
 5525                           // FOR MULTI TASKING MUST BE PLACED IN RAM AND OFFSET USED IN SYSTEM VARS!!!!!!
 5526                           //            T A S K 
 5527                           //
 5528                           ;.data          // Place TASK at beginning of RAM, or not.
 5529                           /*
 5530                            SECTION .text : CONST (2)
 5531                           TASK_NFA:
 5532                                   DC8     0x84
 5533                                   DC8     'TAS'
 5534                                   DC8     'K'+0x80
 5535                            ALIGNROM 2,0xFFFFFFFF
 5536                           //      TASK Is top of dictionary until new definitionsa added
 5537                           //      PATCH CONTEXT or LATEST else LFA in TASK FROM SYM TABLE
 5538                           //      To debug dictionary searches - see - PFIND & DFIND
 5539                           //      DC32    ZEQU_NFA        // 4 (no match) bombing at +
 5540                           //      DC32    NOOP_NFA        // Patch here to shorten test of PFIND
 5541                           //      DC32    CAT_NFA         // C@ before @
 5542                           //      DC32    LESS_NFA        // < before =
 5543                           //       DC32   SoCinit_NFA     //XON_NFA               // FULL DICT SEARCH
 5544                                   DC32    MS_NFA
 5545                           TASK:
 5546                                   DC32    DOCOL
 5547                                   DC32    SEMIS
 5548                           */
 5549                           
 5550                           //------------------------------------------------------------------------------
 5551                           //:NONAME SECTION:
 5552                           // THESE STAY HERE (INSTEAD OF SLLIB) BECAUSE THEY ARE CONDITIONALLY INCLUDED
 5553                           // HI-LEVEL THEM ASM SECTIONS
 5554                           #ifdef IO2TP
 5563                           #endif
 5564                           
 5565                           #ifdef IO2TP
 5574                           #endif
 5575                           
 5576                           #ifdef USE_CMAIN
 5586                           #endif
 5587                           
 5588                           #ifdef TESTRAM
 5694                           #endif  // TESTRAM
 5695                           //------------------------------------------------------------------------------
 5696                           // Placing blocks that can change at end of link map
 5697                           // Place :NONAME for static Library first in FISH_STM_M3_SLIB.s
 5698                           
 5699                           // $PROJ_DIR$\..\FISH_RM_COMMON
 5700                           // $PROJ_DIR$\..\FISH_RM_CORTEX_M_COMMON_CODE
 5701                           // In Assembler preprocessor set additional include directories 
 5702                           $FISH_RM_MSGS.h
 5703                           // equals below
 5704                           //#include ".\..\FISH_COMMON_CODE\FISH_RM_MSGS.h"
 5705                           
 5706                           // SYSTEMCLOCK #define set in FISH_M0_EQUATES.s for SYSCLOCK value.
 5707                           // THIS IS A :NONAME WORDSET
 5708                           
 5709                           $FISH_STM32F4_SOC_INIT.s
 5710                           
 5711                            END
##############################
#           CRC:0            #
#        Errors:   0         #
#        Warnings: 0         #
#        Bytes: 83921        #
##############################




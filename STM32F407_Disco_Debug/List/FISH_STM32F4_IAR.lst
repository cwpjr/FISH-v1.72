###################################################################################################
#                                                                                                 #
#     IAR Assembler V8.22.1.15669/W32 for ARM 22/Apr/2018  16:11:41                               #
#     Copyright 1999-2018 IAR Systems AB.                                                         #
#                                                                                                 #
#           Source file   =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\FISH_STM32F4_IAR.s   #
#           List file     =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\List\FISH_STM32F4_IAR.lst#
#           Object file   =  C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\Obj\FISH_STM32F4_IAR.o#
#           Command line  =  -f C:\Users\CLYDEW~1\AppData\Local\Temp\EWBA37.tmp                   #
#                            (C:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\FISH_STM32F4_IAR.s  #
#                            -OC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\Obj #
#                            -s+ -M<> -w+ -r -DFISH_PubRel_WORDSET -DFISH_Debug_WORDSET           #
#                            -DSTM32F4_XRC08_168MHZ                                               #
#                            -LC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\STM32F407_Disco_Debug\List #
#                            -t8 --cpu Cortex-M4 --fpu VFPv4_sp                                   #
#                            -IC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\..\FISH_Libs\FISH_RM_COMMON\ #
#                            -IC:\Users\Clyde W Phillips Jr\Desktop\FISH-v1.72\..\FISH_Libs\FISH_RM_COMMON_CODE_CORTEX_M\) #
#                                                                                                 #
###################################################################################################

    1                           // FISH_STM32F4_IAR.s - FULL WORD v1.7.2
    2                           // FISH FOR THE STM IS CURRENTLY SUPPORTING F2 TO F4
    3                           // Code is common, seperate linker files used for memory map differences.
    4                           $FISH_STM32F4_MAIN_INCLUDES.h
    5                           //------------------------------------------------------------------------------
    6                           
    7                           // 2DO: Add VIO_UARTX, VIO_KEY, VIO_?KEY and VIO_EMIT
    8                           // (EMIT), (KEY?), and (KEY).
    9                           
   10                           // v1.8 4th tos/nos caching
   11                           
   12                           // v1.7.2 Fixed backspace issue
   13                           
   14                           // v1.7.1:
   15                           
   16                           // Fix NUMBER by merge with NXP which works correctly!
   17                           // 2DO: Restore SYSTICK ISR to ASM version
   18                           // 2DO: Signon updated. (FOR TEST - FIX B4 SHIP)
   19                           // 2DO: Updated .hex .out and sym.bat
   20                           
   21                           // #define EOL_DLE // DLE 0x10/16d in QUIT>CR after last word interpreted.
   22                           // #define EOL_NAK // NAK 0x15/21d in error messages for STDLED editor highlight
   23                           // The EOL_NAK makes SPACE NAK end of string in FISH_RM_MSGS.h
   24                           
   25                           // Split out files to FISH_RM_COMMON and FISH_RM_COMMON_CODE_CORTEX_M
   26                           
   27                           // ADDED EHON and EHOFF to FISH RM
   28                           // Changes iar.s COLD, ERROR and ABORT
   29                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM:
   30                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - ERROR_HALT: SV 
   31                           
   32                           // ADDED P(PROMPT), PON(PROMPTON) and POFF(PROMPTOFF) to FISH RM
   33                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM: & QUIT:
   34                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - PROMPT: SV 
   35                           
   36                           // Added #define TRUE_EQU_NEG_ONE
   37                           // Changed all user visible true flags to -1
   38                           
   39                           // Added SXTB Rd, Rm  and SXTH Rd, Rm
   40                           
   41                           // Number Stuff Wordcat reorganized (search NOEXEC or WC_NUMBERS_NFA)
   42                           // EXPECT does counted null strings:
   43                           // NUMBER to look for null terminatiion instead of BLANK.
   44                           // WORD changed to expect null string and elimated BLANKS fill of HERE.
   45                           //      SPEEDS UP TOKENIZATION OF TIB INPUT!
   46                           // ALL IN AND IN_SV INIT SET TO 1 in QUERY SV_INIT_VALUES CLRTIB
   47                           // NUMBERSUFFIX changed to replace suffix with null
   48                           // PAREN ( changed to use TIB+1
   49                           // DPL restored to dictionairy.
   50                           
   51                           //------------------------------------------------------------------------------
   52                            SECTION .text : CONST (2)
   53                           msg_FISH:
   54                           // DC8 "?" IS A NULL TERMINATED STRING
   55                           // DC8 '?' IS NOT
   56                           //#if FISH_PubRel_WORDSET | FISH_DebugSrc_WORDSET
   57    00000000 4649534820415         DC8     'FISH ARM '
                  24D20        
   58                           //#endif
   59                           #if FISH_PubRel_WORDSET & FISH_Debug_WORDSET
   60    00000009 20313031302C3         DC8     ' 1010,1100 - EHON/EHOFF '
                  1313030202D20
                  45484F4E2F454
                  84F464620    
   61                           //        DC8     '-1 True Flag '
   62                           #endif
   63                           #if VTOR_PATCH & STM32F205RC
   65                           #endif
   66                           #ifdef FISH_Debug_WORDSET
   67    00000021 4465627567537         DC8     'DebugSrc '
                  26320        
   68                           #endif
   69                           #ifdef  STM32F4_XRC08_168MHZ
   70    0000002A 53544D3332463         DC8     'STM32F407VG DISCO @168Mhz '
                  4303756472044
                  4953434F20403
                  136384D687A20
   71                           #endif
   72                           #ifdef STM32F205RC_XRC10_118MHZ
   74                           #endif
   75                           #ifdef FISH_PRO_WORDCAT
   77                           #endif
   78    00000044 524D2056312E3         DC8     'RM V1.7.2 (C)2014-2018 A-TEAM FORTH : '
                  72E3220284329
                  323031342D323
                  0313820412D54
                  45414D20464F5
                  25448203A20  
   79    0000006A 4170722032322         DC8     __DATE__        // Null string
                  03230313800  
   80                           msg_FISH_TIMESTAMP:
   81    00000076 20617420              DC8     ' at '
   82    0000007A 31363A31313A3         DC8     __TIME__        // Null string
                  43100        
   83                           #ifdef EOL_NAK
   84                           msg_SIGNON_DLE:
   85    00000083 1500                  DC8     0x15, 0
   86                           #endif
   87                           msg_MY_OK:
   88    00000085 206F6B2C20676         DC8     " ok, go fish in BASE "
                  F206669736820
                  696E204241534
                  52000        
   89                           //-----------------START OF DICTIONARY = Last word in search--------------------
   90                           // Conditionally include FISH_STM32F4_Peripheral_Register_ADDRS.h include here
   91                           #ifdef FISH_STM32F4_Peripheral_Register_ADDRS
   92                           $FISH_STM32F4_Peripheral_Register_ADDRS.h
   93                           // If included link below will point to the GPIO WORDCAT
   94                           #endif
   95                           // 
   96                           //      NOOP NOOP:      ( -- )
   97                            SECTION .text : CONST (2)
   98                           NOOP_NFA:
   99    00000000 84                    DC8     0x84
  100    00000001 4E4F4F                DC8     'NOO'
  101    00000004 D0                    DC8     'P'+0x80
  102    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  103                           #ifdef FISH_STM32F4_Peripheral_Register_ADDRS
  104    00000008 ........              DC32    WC_FISH_Peripheral_REG_ADDR_GPIO
  105                           #else
  107                           #endif
  108                           NOOP:
  109    0000000C ........              DC32    .+5
  110                            SECTION .text : CODE (2)
  111                                   NEXT
  111.1                         // ARMv7-M Thumb = .+5
  111.2  00000000 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  111.3                         // ARMv6-M Thumb = .+4
  111.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  111                                   NEXT1
  111.1  00000004 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  111.2  00000008 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  111.3  0000000C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  111.4                         // ARMv6-M Thumb = .+4
  111.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  111.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  111.7                                 ENDM
  111.8                                 ENDM
  112                           
  113                           
  114                           //      EXECUTE EXEC:   ( cfa -- ) RENAMED: EXECUTE to EXEC
  115                           //      Execute a single word whose cfa is on the stack
  116                           
  117                            SECTION .text : CONST (2)
  118                           EXEC_NFA:
  119    00000000 87                    DC8     0x87
  120    00000001 455845435554          DC8     'EXECUT'
  121    00000007 C5                    DC8     'E'+0x80
  122                            ALIGNROM 2,0xFFFFFFFF
  123    00000008 ........              DC32    NOOP_NFA
  124                           EXEC:
  125    0000000C ........              DC32    .+5
  126                            SECTION .text : CODE (2)
  127                           #ifndef IO2TP
  128                           #ifdef XON_XOFF
  129    00000000 ........              BL      TXRDY_SUBR
  130    00000004 ........              BL      XOFF_SUBR
  131                           #endif
  132                           #endif
  133                           EXEC_ACTION:
  134                                   POPp2w // as in xeq token at ToS setup for exec LDM     p!, {w}
  134.1                                 // as in xeq token on ToS setup for exec
  134.2  00000008 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
  134.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
  134.4                                 ENDM
  135                                   NEXT1
  135.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  135.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  135.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  135.4                         // ARMv6-M Thumb = .+4
  135.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  135.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  135.7                                 ENDM
  136                           
  137                           #ifndef IO2TP
  138                           // TXRDY_SUBR:
  139                            SECTION .text : CODE (2)
  140                           TXRDY_SUBR:
  141    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  142    00000002 024C                  LDR     y, = USART3_SR  // Line Status Register
  143                           txRDY?:
  144    00000004 2168                  LDR     n, [y]          // Get Line Status
  145                           // THIS IS TXE TEST AND FAILS IN TEXT DOWNLOAD
  146                           //        LSRS    n, n, #7      // 80h Bit 7 TXE: Transmit data register empty
  147                           // THIS IS ___ AND WORKS IN TEXT DOWNLOAD
  148    00000006 090A                  LSRS    n, n, #8        // 100h Bit 8 ORIG
  149    00000008 FCD3                  BCC     txRDY?          // Ready
  150    0000000A 1047                  BX      w               // lr  - SUBR RETURN
  151                           
  152                           // XOFF_SUBR:
  153                           #ifdef XON_XOFF
  153.1                                  TABLE
  153.2  0000000C 00480040              Reference on line 142
  154                            SECTION .text : CODE (2)
  155                           XOFF_SUBR:
  156    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  157    00000002 0249                  LDR     n,= USART3_DR
  158    00000004 1324                  LDR     y,  = XOFF_CHAR
  159    00000006 0C70                  STRB    y, [n]
  160    00000008 1047                  BX      w               // lr  - SUBR RETURN
  161                           #endif // XON_XOFF
  162                           
  163                           // XON_SUBR:
  164                           #ifdef XON_XOFF
  164.1                                  TABLE
  164.2  0000000C 04480040              Reference on line 157
  165                            SECTION .text : CODE (2)
  166                           XON_SUBR:
  167    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  168    00000002 0249                  LDR     n,= USART3_DR
  169    00000004 1124                  LDR     y, = XON_CHAR   // preserve TOS 11 24 01 49
  170    00000006 0C70                  STRB    y, [n]
  171    00000008 1047                  BX      w       //lr              // SUBR RETURN
  172                           #endif // XON_XOFF
  173                           #endif // IO2TP
  174    0000000A 0000           LTORG
  174.1                                  TABLE
  174.2  0000000C 04480040              Reference on line 168
  175                           
  176                           //      BL BLANK:       ( -- n )
  177                           //      Push ascii space character as n to TOS.
  178                           
  179                            SECTION .text : CONST (2)
  180                           BLANK_NFA:
  181    00000000 82                    DC8     0x82
  182    00000001 42                    DC8     'B'
  183    00000002 CC                    DC8     'L'+0x80
  184    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  185    00000004 ........              DC32    EXEC_NFA
  186                           BLANK:
  187    00000008 ........20000         DC32    DOCON, 0x20
                  000          
  188                           
  189                           
  190                           //========================= START SYSTEM VARIABLES ===========================//
  191                           // _SV IS cfa label of WORD's that return their address.
  192                           // MODIFIED ALL to be label based vs. offset based.
  193                           
  194                           
  195                           //      UP UP_SV:       ( -- addr of UP ) Value stored here is ALIGNED
  196                           //      A system variable, the RAM VAR pointer, which contains
  197                           //      the address of the next free memory above in the USERRAMSPACE.
  198                           //      The value may be read by .UV and altered by VAR.
  199                           
  200                            SECTION .text : CONST (2)
  201                           UP_NFA:
  202    00000000 82                    DC8     0x82
  203    00000001 55                    DC8     'U'
  204    00000002 D0                    DC8     'P'+0x80
  205    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  206    00000004 ........              DC32    BLANK_NFA
  207                           UP_SV:
  208    00000008 .............         DC32    DOCON, UP
                  ...          
  209                           
  210                           
  211                           //      FENCE FENCE_SV: ( -- addr of FENCE )
  212                           //      A system variable containing an address below which FORGET ting is
  213                           //      trapped. To forget below this point the system must alter the contents
  214                           //      of FENCE.
  215                           
  216                            SECTION .text : CONST (2)
  217                           FENCE_NFA:
  218    00000000 85                    DC8     0x85
  219    00000001 46454E43              DC8     'FENC'
  220    00000005 C5                    DC8     'E'+0x80
  221    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  222    00000008 ........              DC32    UP_NFA
  223                           FENCE_SV:
  224    0000000C .............         DC32    DOCON, FENCE
                  ...          
  225                           
  226                           
  227                           //      DP DP_SV:       ( -- addr of DP ) Value stored here is ALIGNED
  228                           //      A system variable, the dictionary pointer, which contains the address
  229                           //      of the next free memory above the dictionary. The value may be read
  230                           //      by HERE and altered by COMMA (ALIGNED) , ALLOT and CALLOT (UNALIGNED) .
  231                           
  232                            SECTION .text : CONST (2)
  233                           DP_NFA:
  234    00000000 82                    DC8     0x82
  235    00000001 44                    DC8     'D'
  236    00000002 D0                    DC8     'P'+0x80
  237    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  238    00000004 ........              DC32    FENCE_NFA
  239                           DP_SV:
  240    00000008 .............         DC32    DOCON, DP
                  ...          
  241                           
  242                           
  243                           //      BASE BASE_SV:   ( -- addr of NBASE )
  244                           //      A system variable containing the current number base used for input
  245                           //      and output conversion.
  246                           
  247                            SECTION .text : CONST (2)
  248                           BASE_NFA:
  249    00000000 84                    DC8     0x84
  250    00000001 424153                DC8     'BAS'
  251    00000004 C5                    DC8     'E'+0x80
  252    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  253    00000008 ........              DC32    DP_NFA
  254                           BASE_SV:
  255    0000000C .............         DC32    DOCON, NBASE
                  ...          
  256                           
  257                           
  258                           //      CURRENT CURRENT_SV:     ( -- addr of CURRENT )
  259                           //      CURRENT searched everytime. CONTEXT is not used
  260                           //      Used by Create, Definitions, etc and by Latest
  261                           //      to leave the nfa of the topmost word in the CURRENT
  262                           //      vocabulary.  See LATEST NOTE:(FIG) CURR @ @ this CURR @
  263                           
  264                            SECTION .text : CONST (2)
  265                           CURRENT_NFA:
  266    00000000 87                    DC8     0x87
  267    00000001 43555252454E          DC8     'CURREN'
  268    00000007 D4                    DC8     'T'+0x80
  269                            ALIGNROM 2,0xFFFFFFFF
  270    00000008 ........              DC32    BASE_NFA
  271                           CURRENT_SV:
  272    0000000C .............         DC32    DOCON, CURRENT  // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
                  ...          
  273                           
  274                           
  275                           //      STATE STATE_SV: ( -- addr of CSTATE )
  276                           //      A system variable containing the compilation state. A non-zero value
  277                           //      indicates compilation. The value itself may be implementation
  278                           //      dependent. 0xC0 must be used for INTERPRET to execute IMMEDIATE words.
  279                           
  280                            SECTION .text : CONST (2)
  281                           STATE_NFA:
  282    00000000 85                    DC8     0x85
  283    00000001 53544154              DC8     'STAT'
  284    00000005 C5                    DC8     'E'+0x80
  285    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  286    00000008 ........              DC32    CURRENT_NFA
  287                           STATE_SV:
  288    0000000C .............         DC32    DOCON, CSTATE       //Compile STATE
                  ...          
  289                           
  290                           
  291                           //      OUT OUT_SV:     ( -- addr of OUT )
  292                           //      A system variable that contains a value incremented by EMIT. The system
  293                           //      may alter and examine OUT to control display formating.
  294                           
  295                            SECTION .text : CONST (2)
  296                           OUT_NFA:
  297    00000000 83                    DC8     0x83
  298    00000001 4F55                  DC8     'OU'
  299    00000003 D4                    DC8     'T'+0x80
  300                            ALIGNROM 2,0xFFFFFFFF
  301    00000004 ........              DC32    STATE_NFA
  302                           OUT_SV:
  303    00000008 .............         DC32    DOCON, OUT
                  ...          
  304                           
  305                           
  306                           //      IN IN_SV:       ( -- addr of IN )
  307                           //      A system variable containing the byte offset within (TIB),
  308                           //      from which the tokens are parsed by WORD and moved to HERE,
  309                           //      as a counted null terminated string (created by EXPECT).
  310                           //      Initialized to 1 to skip count byte produced by EXPECT.
  311                           
  312                            SECTION .text : CONST (2)
  313                           IN_NFA:
  314    00000000 82                    DC8     0x82
  315    00000001 49                    DC8     'I'
  316    00000002 CE                    DC8     'N'+0x80
  317    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  318    00000004 ........              DC32    OUT_NFA
  319                           IN_SV:
  320    00000008 .............          DC32   DOCON, IN
                  ...          
  321                           
  322                           
  323                           //      PAD PAD_SV:     ( -- addr of PAD )
  324                           //      Leave the address of the text output buffer PAD on the stack.
  325                           //      Typically at least 82 bytes long.
  326                           
  327                            SECTION .text : CONST (2)
  328                           PAD_NFA:
  329    00000000 83                    DC8     0x83
  330    00000001 5041                  DC8     'PA'
  331    00000003 C4                    DC8     'D'+0x80
  332                            ALIGNROM 2,0xFFFFFFFF
  333    00000004 ........              DC32    IN_NFA
  334                           PAD_SV:
  335    00000008 .............         DC32    DOCON, PAD
                  ...          
  336                           
  337                           
  338                           //      TIB TIB_SV:     ( -- addr of INITTIB )
  339                           //      Leave the address of the text input buffer TIB on the stack.
  340                           //      Typically at least 82 bytes long.
  341                           
  342                            SECTION .text : CONST (2)
  343                           TIB_NFA:
  344    00000000 83                    DC8     0x83
  345    00000001 5449                  DC8     'TI'
  346    00000003 C2                    DC8     'B'+0x80
  347                            ALIGNROM 2,0xFFFFFFFF
  348    00000004 ........              DC32    PAD_NFA
  349                           TIB_SV:
  350    00000008 .............         DC32    DOCON, TIB
                  ...          
  351                           
  352                           
  353                           //======================== END SYSTEM VARIABLES ==============================//
  354                           
  355                           
  356                           //      HERE HERE:      ( -- addr ) Value stored here is ALIGNED
  357                           //      Leave the address of the next available dictionary location.
  358                           
  359                            SECTION .text : CONST (2)
  360                           HERE_NFA:
  361    00000000 84                    DC8     0x84
  362    00000001 484552                DC8     'HER'
  363    00000004 C5                    DC8     'E'+0x80
  364    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  365    00000008 ........              DC32    TIB_NFA
  366                           HERE:
  367    0000000C ........              DC32    DOCOL
  368    00000010 ........              DC32    DP_SV
  369    00000014 ........              DC32    AT
  370    00000018 ........              DC32    SEMIS
  371                           
  372                           
  373                           //      ALLOT ALLOT:    ( sn -- ) Warning: UNALIGNED:
  374                           //      IF DICTIONAIRY FULL PRINT error MESSAGE AND abort.
  375                           //      Add the signed number to the dictionary pointer DP. May be used to
  376                           //      reserve dictionary space or re-origin memory.
  377                           //      CAUTION!
  378                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  379                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  380                           
  381                            SECTION .text : CONST (2)
  382                           ALLOT_NFA:
  383    00000000 85                    DC8     0x85
  384    00000001 414C4C4F              DC8     'ALLO'
  385    00000005 D4                    DC8     'T'+0x80
  386    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  387    00000008 ........              DC32    HERE_NFA
  388                           ALLOT:
  389    0000000C ........              DC32    DOCOL
  390    00000010 ........              DC32    DICTSPACE       // \ -- n
  391    00000014 .............         DC32    OVER, SUBB
                  ...          
  392    0000001C ........              DC32    ZLESS
  393    00000020 ........              DC32    ZBRAN
  394    00000024 08000000              DC32    ALLOTOK-.
  395                           
  396    00000028 ........              DC32    DICTFULL_ABORT
  397                           
  398                           ALLOTOK:
  399    0000002C ........              DC32    DP_SV
  400    00000030 ........              DC32    PSTORE
  401    00000034 ........              DC32    SEMIS
  402                           
  403                           
  404                           //      ALIGNED ALIGNED:        ( addr -- a-addr ) DPANS94
  405                           
  406                            SECTION .text : CONST (2)
  407                           ALIGNED_NFA:
  408    00000000 87                    DC8     0x87
  409    00000001 414C49474E45          DC8     'ALIGNE'
  410    00000007 C4                    DC8     'D'+0x80
  411                            ALIGNROM 2,0xFFFFFFFF
  412    00000008 ........              DC32    ALLOT_NFA
  413                           ALIGNED:
  414    0000000C ........              DC32    .+5
  415                            SECTION .text : CODE (2)
  416                                   POP2t
  416.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  416.2                         //#ifndef TOSCT
  416.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  416.4                         //#endif
  416.5                         //      ADDS    p, p, #4
  416.6                                 ENDM
  417    00000004 C01C                  ADDS    t, t, #3
  418    00000006 0549                  LDR     n, =-4
  419    00000008 0840                  ANDS    t, t, n
  420                                   TPUSH
  420                                   PUSHt   // push t to p, pre decrement p
  420.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  420.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  420.3                         //      STR     t, [p]
  420.4                                 ENDM
  420                                   NEXT
  420.1                         // ARMv7-M Thumb = .+5
  420.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  420.3                         // ARMv6-M Thumb = .+4
  420.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  420                                   NEXT1
  420.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  420.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  420.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  420.4                         // ARMv6-M Thumb = .+4
  420.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  420.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  420.7                                 ENDM
  420.8                                 ENDM
  420.9                                 ENDM
  421                            LTORG
  421.1                                  TABLE
  421.2  0000001C FCFFFFFF              Reference on line 418
  422                           
  423                           
  424                           //      ALIGN32_DP_FF_PAD ALIGN:        ( -- ) DPANS94
  425                           //      Align DP_SV primitive. Pads current DP with 0xFF until aligned.
  426                           //      USED IN , (COMMA:) .  Reflected by HERE .
  427                           //      CAUTION! USE AFTER ALLOT or C, (CCOMMA:) .
  428                           //      See , (COMMA:) which is ALIGNED.
  429                           
  430                            SECTION .text : CONST (2)
  431                           ALIGN_NFA:
  432    00000000 85                    DC8     0x85
  433    00000001 414C4947              DC8     'ALIG'
  434    00000005 CE                    DC8     'N'+0x80
  435    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  436    00000008 ........              DC32    ALIGNED_NFA
  437                           ALIGN:
  438                           ALIGN32_DP_FF_PAD:
  439    0000000C ........              DC32    DOCOL
  440    00000010 ........              DC32    HERE
  441                                   // COULD ADD CODE TO SEE IF ALIGNED ALREADY
  442    00000014 .............         DC32    THREE, PLUS             // 3PLUS
                  ...          
  443    0000001C .............         DC32    DUP, TOR
                  ...          
  444    00000024 ........              DC32    HERE
  445    00000028 ........              DC32    XDO
  446                           ALIGN_PAD_DO:
  447    0000002C ........FF000         DC32    LIT, 0xFF, I, CSTORE
                  000..........
                  ......       
  448    0000003C ........              DC32    XLOOP
  449    00000040 ECFFFFFF              DC32    ALIGN_PAD_DO-.
  450                           
  451    00000044 ........              DC32    RFROM
  452    00000048 ........FCFFF         DC32    LIT, 0xFFFFFFFC // -4
                  FFF          
  453    00000050 ........              DC32    ANDD
  454    00000054 .............         DC32    DP_SV, STORE
                  ...          
  455    0000005C ........              DC32    SEMIS
  456                           
  457                           
  458                           //      , COMMA:        ( n -- ) ALIGNED
  459                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  460                           //      Write n into next ALIGNED dictionary memory cell, DP reflected by HERE
  461                           
  462                            SECTION .text : CONST (2)
  463                           COMMA_NFA:
  464    00000000 81                    DC8     0x81
  465    00000001 AC                    DC8     ','+0x80
  466    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  467    00000004 ........              DC32    ALIGN_NFA
  468                           COMMA:
  469    00000008 ........              DC32    DOCOL
  470    0000000C ........              DC32    DICTSPACE       // \ -- n
  471    00000010 ........              DC32    ZLESS
  472    00000014 ........              DC32    ZBRAN
  473    00000018 08000000              DC32    COMMA_OK-.
  474                           
  475    0000001C ........              DC32    DICTFULL_ABORT
  476                           
  477                           COMMA_OK:
  478    00000020 ........              DC32    COMMA_PRIM
  479    00000024 ........              DC32    SEMIS
  480                           
  481                           
  482                           //      C, CCOMMA:      ( n -- ) Warning: UNALIGNED:
  483                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  484                           //      Store LS 8 bits of n into the next available dictionary byte, advancing
  485                           //      the dictionary pointer.
  486                           //      CAUTION!
  487                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  488                           //      NOTE: USE ALIGN32_DP_FF_PAD after ALLOT or C, (CCOMMA) .
  489                           //      See , (COMMA:) which is ALIGNED.
  490                           
  491                            SECTION .text : CONST (2)
  492                           CCOMMA_NFA:
  493    00000000 82                    DC8     0x82
  494    00000001 43                    DC8     'C'
  495    00000002 AC                    DC8     ','+0x80
  496    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  497    00000004 ........              DC32    COMMA_NFA
  498                           CCOMMA:
  499    00000008 ........              DC32    DOCOL
  500    0000000C ........              DC32    DICTSPACE       // \ -- n
  501    00000010 ........              DC32    ZLESS
  502    00000014 ........              DC32    ZBRAN
  503    00000018 08000000              DC32    CCOMMA_OK-.
  504                           
  505    0000001C ........              DC32    DICTFULL_ABORT
  506                           
  507                           CCOMMA_OK:
  508    00000020 ........              DC32    HERE
  509    00000024 ........              DC32    CSTORE
  510    00000028 ........              DC32    ONE
  511    0000002C ........              DC32    ALLOT_PRIM
  512    00000030 ........              DC32    SEMIS
  513                           
  514                           
  515                           //      VARALLOT VARALLOT:      ( n -- addr ) Value stored here is ALIGNED
  516                           //      IF USERVAR SPACE FULL PRINT Error MESSAGE AND Abort.
  517                           //      Add n * 32 bits to the RAMVARSPACE pointer UP.
  518                           //      Used to allocate space in Ram for VAR's and other system data structures
  519                           
  520                            SECTION .text : CONST (2)
  521                           VARALLOT_NFA:
  522    00000000 88                    DC8     0x88
  523    00000001 564152414C4C4         DC8     'VARALLO'
                  F            
  524    00000008 D4                    DC8     'T'+0x80
  525    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  526    0000000C ........              DC32    CCOMMA_NFA
  527                           VARALLOT:
  528    00000010 ........              DC32    DOCOL
  529    00000014 ........              DC32    VARSPACE                // \ -- n
  530    00000018 .............         DC32    FOUR, SLASH, OVER, SUBB
                  .............
                  ......       
  531    00000028 ........              DC32    ZLESS
  532    0000002C ........              DC32    ZBRAN
  533    00000030 18000000              DC32    VALLOT_OK-.
  534                           
  535    00000034 .............         DC32    LIT, msg_uvfull
                  ...          
  536    0000003C .............         DC32    NULLSTRLEN, TYPE
                  ...          
  537                           #ifdef IO2TP
  541                           #endif
  542    00000044 ........              DC32    ABORT
  543                           
  544                           VALLOT_OK:
  545    00000048 .............         DC32    UP_SV, AT       // Address of this allotment
                  ...          
  546    00000050 ........              DC32    SWAP            // n
  547    00000054 .............         DC32    FOUR, STAR      // n = 4 bytes
                  ...          
  548    0000005C ........              DC32    UP_SV
  549    00000060 ........              DC32    PSTORE          // Address of next var available
  550    00000064 ........              DC32    SEMIS
  551                           
  552                           
  553                           //      LATEST LATEST: ( -- nfa )
  554                           //      Initially ADDR OF LAST WORD IN THE DICTIONARY
  555                           //      Leave the nfa of the topmost word in the dictionary.
  556                           
  557                            SECTION .text : CONST (2)
  558                           LATEST_NFA:
  559    00000000 86                    DC8     0x86
  560    00000001 4C41544553            DC8     'LATES'
  561    00000006 D4                    DC8     'T'+0x80
  562    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  563    00000008 ........              DC32    VARALLOT_NFA
  564                           LATEST:
  565    0000000C ........              DC32    DOCOL
  566    00000010 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
  567    00000014 ........              DC32    AT
  568    00000018 ........              DC32    SEMIS
  569                           
  570                           
  571                           //      LFA LFA:        ( pfa -- lfa )
  572                           //      Convert the parameter field address of a dictionary definition to
  573                           //      its link field address.
  574                           
  575                            SECTION .text : CONST (2)
  576                           LFA_NFA:
  577    00000000 83                    DC8     0x83
  578    00000001 4C46                  DC8     'LF'
  579    00000003 C1                    DC8     'A'+0x80
  580                            ALIGNROM 2,0xFFFFFFFF
  581    00000004 ........              DC32    LATEST_NFA
  582                           LFA:
  583    00000008 ........              DC32    .+5
  584                            SECTION .text : CODE (2)
  585                                   POP2t
  585.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  585.2                         //#ifndef TOSCT
  585.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  585.4                         //#endif
  585.5                         //      ADDS    p, p, #4
  585.6                                 ENDM
  586    00000004 0838                  SUBS     t, t, #8
  587                                   TPUSH
  587                                   PUSHt   // push t to p, pre decrement p
  587.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  587.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  587.3                         //      STR     t, [p]
  587.4                                 ENDM
  587                                   NEXT
  587.1                         // ARMv7-M Thumb = .+5
  587.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  587.3                         // ARMv6-M Thumb = .+4
  587.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  587                                   NEXT1
  587.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  587.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  587.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  587.4                         // ARMv6-M Thumb = .+4
  587.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  587.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  587.7                                 ENDM
  587.8                                 ENDM
  587.9                                 ENDM
  588                           
  589                           
  590                           //      CFA CFA:        ( pfa -- cfa )
  591                           //      Convert the parameter field address of a dictionary definition to
  592                           //      its code field address. <if thumb2 execution addr smudged>
  593                           
  594                            SECTION .text : CONST (2)
  595                           CFA_NFA:
  596    00000000 83                    DC8     0x83
  597    00000001 4346                  DC8     'CF'
  598    00000003 C1                    DC8     'A'+0x80
  599                            ALIGNROM 2,0xFFFFFFFF
  600    00000004 ........              DC32    LFA_NFA
  601                           CFA:
  602    00000008 ........              DC32    .+5
  603                            SECTION .text : CODE (2)
  604                                   POP2t
  604.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  604.2                         //#ifndef TOSCT
  604.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  604.4                         //#endif
  604.5                         //      ADDS    p, p, #4
  604.6                                 ENDM
  605    00000004 001F                  SUBS     t, t, #4
  606                                   TPUSH
  606                                   PUSHt   // push t to p, pre decrement p
  606.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  606.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  606.3                         //      STR     t, [p]
  606.4                                 ENDM
  606                                   NEXT
  606.1                         // ARMv7-M Thumb = .+5
  606.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  606.3                         // ARMv6-M Thumb = .+4
  606.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  606                                   NEXT1
  606.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  606.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  606.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  606.4                         // ARMv6-M Thumb = .+4
  606.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  606.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  606.7                                 ENDM
  606.8                                 ENDM
  606.9                                 ENDM
  607                           
  608                           
  609                           //      NFA NFA:        ( pfa -- nfa )
  610                           //      Convert the parameter field address of a definition to its name
  611                           //      field. Modified for nfa alighnment padding
  612                           
  613                            SECTION .text : CONST (2)
  614                           NFA_NFA:
  615    00000000 83                    DC8     0x83
  616    00000001 4E46                  DC8     'NF'
  617    00000003 C1                    DC8     'A'+0x80
  618                            ALIGNROM 2,0xFFFFFFFF
  619    00000004 ........              DC32    CFA_NFA
  620                           NFA:
  621    00000008 ........              DC32    DOCOL
  622    0000000C .............         DC32    EIGHT, SUBB     // Addr OF lfa, DUPED TO TRAVERSE Padding
                  ...          
  623                           
  624                           NFA_ALIGN_BEGIN:
  625    00000014 .............         DC32    ONE, SUBB       // ADDR 1 BEFORE lfa, eliminate padding
                  ...          
  626    0000001C .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  627    00000024 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  628    00000030 ........              DC32    ZBRAN           // UNTIL
  629    00000034 E0FFFFFF              DC32    NFA_ALIGN_BEGIN-.
  630                                       
  631    00000038 ........FFFFF         DC32    LIT,-1          // DIRECTION FOR TRAVERSE = Toward nfa
                  FFF          
  632    00000040 ........              DC32    TRAVERSE                // \ -- addr2
  633    00000044 ........              DC32    SEMIS
  634                           
  635                           
  636                           //      PFA PFA:        ( nfa -- pfa )
  637                           //      Convert the name field address of a compiled definition to its
  638                           //      parameter field address.
  639                           
  640                            SECTION .text : CONST (2)
  641                           PFA_NFA:
  642    00000000 83                    DC8     0x83
  643    00000001 5046                  DC8     'PF'
  644    00000003 C1                    DC8     'A'+0x80
  645                            ALIGNROM 2,0xFFFFFFFF
  646    00000004 ........              DC32    NFA_NFA
  647                           PFA:
  648    00000008 ........              DC32    DOCOL           // \ NFA --
  649    0000000C ........              DC32    ONE             // DIRECTION FOR TRAVERSE = Toward CFA
  650    00000010 ........              DC32    TRAVERSE        // \ NFA 1 -- addr2
  651                           
  652                           PFA_ALIGN_BEGIN:
  653    00000014 ........              DC32    ONEP            // ADDR 1 BEFORE lfa, eliminate padding
  654    00000018 .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  655    00000020 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  656    0000002C ........              DC32    ZBRAN           // UNTIL
  657    00000030 E4FFFFFF              DC32    PFA_ALIGN_BEGIN-.
  658                           
  659    00000034 ........              DC32    EIGHT
  660    00000038 ........              DC32    PLUS
  661    0000003C ........              DC32    SEMIS
  662                           
  663                           
  664                           //      ?ALIGNED QALIGNED: ( value -- )
  665                           //      If value not aligned by 4 issue message and ABORT.
  666                           
  667                            SECTION .text : CONST (2)
  668                           QALIGNED_NFA:
  669    00000000 88                    DC8     0x88
  670    00000001 3F414C49474E4         DC8     '?ALIGNE'
                  5            
  671    00000008 C4                    DC8     'D'+0x80
  672    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  673    0000000C ........              DC32    PFA_NFA
  674                           QALIGNED:
  675    00000010 ........              DC32    DOCOL
  676    00000014 ........03000         DC32    LIT, 3, ANDD
                  000........  
  677    00000020 ........              DC32    ZBRAN           //IF no err leave
  678    00000024 3C000000              DC32     QALIGN_OK-.
  679                           
  680    00000028 ........              DC32    PDOTQ
  681    0000002C 2E                    DC8     46
  682    0000002D 56414C5545204         DC8     'VALUE MUST BE EVEN NOT ODD AND MULTIPLE OF 4! '
                  D555354204245
                  204556454E204
                  E4F54204F4444
                  20414E44204D5
                  54C5449504C45
                  204F462034212
                  0            
  683    0000005B FF             ALIGNROM 2,0xFFFFFFFF
  684    0000005C ........              DC32    ABORT
  685                           
  686                           QALIGN_OK:
  687    00000060 ........              DC32    SEMIS
  688                           
  689                           
  690                           //      ?ERROR QERROR: ( f nullstr -- )
  691                           //      If f NON ZERO type error message (nullstr) and ABORT.
  692                           
  693                            SECTION .text : CONST (2)
  694                           QERROR_NFA:
  695    00000000 86                    DC8     0x86
  696    00000001 3F4552524F            DC8     '?ERRO'
  697    00000006 D2                    DC8     'R'+0x80
  698    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  699    00000008 ........              DC32    QALIGNED_NFA
  700                           QERROR:
  701    0000000C ........              DC32    DOCOL
  702    00000010 ........              DC32    SWAP
  703    00000014 ........              DC32    ZBRAN   //IF no err leave
  704    00000018 10000000              DC32     QERROR_FINISH-.
  705                           
  706    0000001C ........              DC32    ERROR   // nullstr-addr ---  ABORT's
  707    00000020 ........              DC32    BRAN    // ELSE
  708    00000024 08000000              DC32     QERROR_DONE-.
  709                           
  710                           QERROR_FINISH:
  711    00000028 ........              DC32    DROP    //endif
  712                           
  713                           QERROR_DONE:
  714    0000002C ........              DC32    SEMIS
  715                           
  716                           
  717                           //      DIGIT DIGIT:    ( c base -- digit 1 ) (ok)
  718                           //                      ( c base -- 0 (bad)
  719                           //      Converts the ascii character c using base to its binary
  720                           //      equivalent digit, accompanied by a true flag. If the conversion is
  721                           //      invalid, leaves only a false flag.
  722                           
  723                           //      If digit gets 0, space, dot, comma or any non number it returns 0 
  724                           
  725                            SECTION .text : CONST (2)
  726                           DIGIT_NFA:
  727    00000000 85                    DC8     0x85
  728    00000001 44494749              DC8     'DIGI'
  729    00000005 D4                    DC8     'T'+0x80
  730    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  731    00000008 ........              DC32    QERROR_NFA
  732                           DIGIT:
  733    0000000C ........              DC32    .+5
  734                            SECTION .text : CODE (2)
  735                                   POP2w                   // Number base
  735.1  00000000 57F8042B              LDR     w, [p],#4
  735.2                         //      LDR     w, [p]
  735.3                         //      ADDS    p, p, #4
  735.4                                 ENDM
  736                                   POP2t                   // ASCII DIGIT
  736.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
  736.2                         //#ifndef TOSCT
  736.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  736.4                         //#endif
  736.5                         //      ADDS    p, p, #4
  736.6                                 ENDM
  737    00000008 3038                  SUBS   t, t, #'0'
  738    0000000A 13D4                  BMI   DIGI2             // Number error
  739                           
  740    0000000C 0928                  CMP   t, #9
  741    0000000E 02DD                  BLE   DIGI1             // Number = 0 THRU 9
  742                           
  743                                   // Combine?
  744    00000010 C01F                  SUBS   t, t, #7
  745    00000012 0A28                  CMP   t, #10            // Number 'A' THRU 'Z'?
  746    00000014 0EDB                  BLT   DIGI2             // NO
  747                           
  748                           DIGI1:
  749    00000016 9042                  CMP     t, w            // COMPARE Number TO base
  750    00000018 0CDA                  BGE     DIGI2
  751                           
  752    0000001A 0246                  MOV     w, t            // NEW BINARY Number
  753    0000001C 0120                  MOVS    t, #1           // TRUE FLAG
  754                                   DPUSH
  754                                   PUSHw   // push w to p, post decrement p
  754.1  0000001E 47F8042D              STR     w, [p, #-4]!
  754.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  754.3                         //      STR     w, [p]
  754.4                                 ENDM
  754                                   TPUSH
  754                                   PUSHt   // push t to p, pre decrement p
  754.1  00000022 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  754.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  754.3                         //      STR     t, [p]
  754.4                                 ENDM
  754                                   NEXT
  754.1                         // ARMv7-M Thumb = .+5
  754.2  00000026 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  754.3                         // ARMv6-M Thumb = .+4
  754.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  754                                   NEXT1
  754.1  0000002A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  754.2  0000002E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  754.3  00000032 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  754.4                         // ARMv6-M Thumb = .+4
  754.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  754.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  754.7                                 ENDM
  754.8                                 ENDM
  754.9                                 ENDM
  754.10                                ENDM
  755                           
  756                                   // Number error
  757                           DIGI2:
  758    00000034 0020                  MOVS   t, #0            // FALSE FLAG
  759                                   TPUSH
  759                                   PUSHt   // push t to p, pre decrement p
  759.1  00000036 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  759.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  759.3                         //      STR     t, [p]
  759.4                                 ENDM
  759                                   NEXT
  759.1                         // ARMv7-M Thumb = .+5
  759.2  0000003A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  759.3                         // ARMv6-M Thumb = .+4
  759.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  759                                   NEXT1
  759.1  0000003E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  759.2  00000042 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  759.3  00000046 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  759.4                         // ARMv6-M Thumb = .+4
  759.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  759.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  759.7                                 ENDM
  759.8                                 ENDM
  759.9                                 ENDM
  760                           
  761                           
  762                           //      ENCLOSE ENCL:   ( addr1 c -- addr1 n1 n2 n3 )
  763                           //      A text scanning iterative primitive used only in WORD.
  764                           //      IN is used before and after callS for the iteration
  765                           //      Typically TIB + IN = addr1
  766                           //      noop EX: \ TIB   32 -- TIB   0 4 5
  767                           //      NULL EX: \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  768                           //      NULL EX: \ WORD/ENCL -> TIB 1, 0, 20'S
  769                           //      From the text address addr1 and an ascii delimiting character c,
  770                           //      is determined the byte offset to the first non-delimiter character n1,
  771                           //      the offset to the first delimiter after the text n2,
  772                           //      and the offset to the first character not included.
  773                           //      This procedure will not process past an ASCII 'null', treating it
  774                           //      as an unconditional delimiter. NULL termination by EXPECT in QUERY.
  775                           
  776                            SECTION .text : CONST (2)
  777                           ENCL_NFA:
  778    00000000 87                    DC8     0x87
  779    00000001 454E434C4F53          DC8     'ENCLOS'
  780    00000007 C5                    DC8     'E'+0x80
  781                            ALIGNROM 2,0xFFFFFFFF
  782    00000008 ........              DC32    DIGIT_NFA
  783                           ENCL:
  784    0000000C ........              DC32    .+5
  785                            SECTION .text : CODE (2)
  786                                   POP2t                   // TERMINATOR CHAR
  786.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
  786.2                         //#ifndef TOSCT
  786.3                         //      LDR     t, [p]          // pop tos to t, post increment p
  786.4                         //#endif
  786.5                         //      ADDS    p, p, #4
  786.6                                 ENDM
  787    00000004 3968                  LDR     n, [p]          // get text address but leave on stack
  788    00000006 0022                  MOVS    w, #0
  789    00000008 521E                  SUBS    w, w, #1        // CHAR  COUNTER
  790    0000000A 491E                  SUBS    n, n, #1        // ADDR -1
  791                           
  792                           //  SCAN TO FIRST NON-TERMINATOR CHARACTER
  793                           //      and PUSH count to stack leaving last 2 params to compute
  794                           ENCL1:
  795    0000000C 491C                  ADDS    n, n, #1        // ADDR+1
  796    0000000E 521C                  ADDS    w, w, #1        // COUNT+1
  797    00000010 0B78                  LDRB    x, [n]
  798    00000012 9842                  CMP     t, x            //CMP   AL,[BX]
  799    00000014 FAD0                  BEQ     ENCL1           //JZ    ENCL1   // WAIT FOR NON-TERMINATOR
  800                                   PUSHw                   //offset to the first non-delimiter character
  800.1  00000016 47F8042D              STR     w, [p, #-4]!
  800.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  800.3                         //      STR     w, [p]
  800.4                                 ENDM
  801                                                           //EXiT is now only DPUSH
  802    0000001A 002B                  CMP     x, #0           //CMP   AH,[BX] // null CHAR?
  803    0000001C 0CD1                  BNE     ENCL2           //JNZ   ENCL2   // NO
  804                           
  805                           // FOUND null BEFORE 1ST NON-TERM CHAR
  806                           // RETURN ok args = NULL EX//
  807                           // \ TIB   32 -- ADDR-B4-NULL 0 1 1 So DFIND CAN FIND IT!
  808                           //
  809    0000001E 1846                  MOV     t, x
  810    00000020 521C                  ADDS    w, w, #1        // w = offset to the delimiter after the text
  811                                   DPUSH
  811                                   PUSHw   // push w to p, post decrement p
  811.1  00000022 47F8042D              STR     w, [p, #-4]!
  811.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  811.3                         //      STR     w, [p]
  811.4                                 ENDM
  811                                   TPUSH
  811                                   PUSHt   // push t to p, pre decrement p
  811.1  00000026 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  811.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  811.3                         //      STR     t, [p]
  811.4                                 ENDM
  811                                   NEXT
  811.1                         // ARMv7-M Thumb = .+5
  811.2  0000002A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  811.3                         // ARMv6-M Thumb = .+4
  811.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  811                                   NEXT1
  811.1  0000002E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  811.2  00000032 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  811.3  00000036 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  811.4                         // ARMv6-M Thumb = .+4
  811.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  811.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  811.7                                 ENDM
  811.8                                 ENDM
  811.9                                 ENDM
  811.10                                ENDM
  812                           
  813                           //   FOUND FIRST TEXT CHAR - COUNT THE CHARS
  814                           ENCL2:
  815    00000038 491C                  ADDS    n, n, #1        // ADDR+1
  816    0000003A 521C                  ADDS    w, w, #1        //COUNT+1
  817    0000003C 0B78                  LDRB    x, [n]
  818    0000003E 9842                  CMP     t, x            //TERMINATOR CHAR?
  819    00000040 01D0                  BEQ     ENCL4           //YES
  820                           
  821    00000042 002B                  CMP     x, #0           //null CHAR?
  822    00000044 F8D1                  BNE     ENCL2           //NO, LOOP AGAIN
  823                           
  824                           ENCL3:  //   FOUND null AT END OF TEXT
  825                           ENCL4:  //   FOUND TERMINATOR CHARACTER
  826    00000046 1046                  MOV     t, w            // COUNT+1 =
  827    00000048 401C                  ADDS    t, t, #1        // offset to the first character not included
  828                                   DPUSH
  828                                   PUSHw   // push w to p, post decrement p
  828.1  0000004A 47F8042D              STR     w, [p, #-4]!
  828.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
  828.3                         //      STR     w, [p]
  828.4                                 ENDM
  828                                   TPUSH
  828                                   PUSHt   // push t to p, pre decrement p
  828.1  0000004E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
  828.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
  828.3                         //      STR     t, [p]
  828.4                                 ENDM
  828                                   NEXT
  828.1                         // ARMv7-M Thumb = .+5
  828.2  00000052 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  828.3                         // ARMv6-M Thumb = .+4
  828.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  828                                   NEXT1
  828.1  00000056 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  828.2  0000005A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  828.3  0000005E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  828.4                         // ARMv6-M Thumb = .+4
  828.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  828.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  828.7                                 ENDM
  828.8                                 ENDM
  828.9                                 ENDM
  828.10                                ENDM
  829                           
  830                           
  831                           //      0 NULL: ( -- ) IMMEDIATE
  832                           //      Don't return to Interpret, return to Quit at end of a line of input.
  833                           //      Executed at end of TIB when QUERY lenght or CR entered.
  834                           
  835                            SECTION .text : CONST (2)
  836                           NULL_NFA:
  837    00000000 C1                    DC8     0x0C1                   // A BINARY ZER
  838    00000001 80                    DC8     0x80
  839    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  840    00000004 ........              DC32    ENCL_NFA
  841                           NULL:
  842                           //      DC32    SEMIS                   // Actual Semis code below
  843    00000008 ........              DC32    .+5
  844                            SECTION .text : CODE (2)
  845                                   POPr2i  // pop docol saved IP from Rstack
  845.1  00000000 56F8045B              LDR     i, [r],#4       ; pop DOCOL'd IP from Rstack
  845.2                         //      LDR i, [r]              //  pop r to i, post increment r
  845.3                         //      ADDS    r, r, #4
  845.4                                 ENDM
  846                                   NEXT
  846.1                         // ARMv7-M Thumb = .+5
  846.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
  846.3                         // ARMv6-M Thumb = .+4
  846.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
  846                                   NEXT1
  846.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
  846.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
  846.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
  846.4                         // ARMv6-M Thumb = .+4
  846.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  846.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  846.7                                 ENDM
  846.8                                 ENDM
  847                           
  848                           
  849                           //      WORD WORD:      ( c -- )
  850                           //      Parse the text in TIB , until a delimiter c is found, tokenizing input.
  851                           //      Move the token to HERE, with a count byte and 2 nulls at the end.
  852                           //      Leading occurrences of c are ignored. IN is incremented.
  853                           //      See IN. Usually used inside a definition.
  854                           
  855                            SECTION .text : CONST (2)
  856                           WORD_NFA:
  857    00000000 84                    DC8     0x84
  858    00000001 574F52                DC8     'WOR'
  859    00000004 C4                    DC8     'D'+0x80
  860    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  861    00000008 ........              DC32    NULL_NFA
  862                           WORD:
  863    0000000C ........              DC32    DOCOL
  864                           WORD1:
  865                           //      This is required for number suffix's at least ???
  866                           // NOT WITH NEW COUNTED NULL STRING EXPECT
  867                           //      DC32    HERE, LIT, MAXWORDLEN+2, BLANKS
  868    00000010 ........              DC32    TIB_SV
  869                           WORD2:
  870    00000014 ........              DC32    IN_SV
  871    00000018 ........              DC32    AT
  872    0000001C ........              DC32    PLUS
  873    00000020 ........              DC32    SWAP    // ( TIB+IN CH-DELIM -- )
  874    00000024 ........              DC32    ENCL    // ( TIB+IN 32 -- TIB+IN   0 4 5 )
  875                           WENCL:
  876    00000028 ........              DC32    IN_SV   // encl TOS = end of word offset to be added to IN
  877    0000002C ........              DC32    PSTORE  // TIB+IN   0 4
  878    00000030 ........              DC32    OVER    // 
  879    00000034 ........              DC32    SUBB    // Char cnt going to R and HERE
  880    00000038 ........              DC32    TOR
  881    0000003C ........              DC32    R
  882    00000040 ........              DC32    HERE
  883    00000044 ........              DC32    CSTORE   // CHAR CNT OF word
  884    00000048 ........              DC32    PLUS
  885    0000004C ........              DC32    HERE
  886    00000050 ........              DC32    ONEP
  887                           //      DC32    RFROM
  888                           // MOVE word TO DICT FOR finding ENDING WITH NULLS
  889    00000054 ........              DC32    R
  890    00000058 ........              DC32    CMOVE   // ( from to count -- )
  891                           // add null to end of token - NUMBER adjusted        
  892    0000005C .............         DC32    ZERO, HERE, ONEP, RFROM, PLUS, CSTORE
                  .............
                  .............
                  .........    
  893                           #ifdef  IOBUFS_DEBUG
  895                           #endif        
  896    00000074 ........              DC32    SEMIS
  897                           
  898                           
  899                           //      NUMBER NUMBER:  ( addr -- sd )
  900                           //      If error print message and ABORT.
  901                           //      Convert a character string left at addr with a preceeding count,
  902                           //      and a terminating null, to a signed number, in the current numeric base.
  903                           //      If a decimal point is encountered in the text, its position will be
  904                           //      given in DPL, but no other effect occurs. If numeric conversion is
  905                           //      not possible, an error message will be given.
  906                           
  907                           //      Added support for , as a single number formatter.
  908                           
  909                           #define comma_test
  910                           
  911                            SECTION .text : CONST (2)
  912                           NUMBER_NFA:
  913    00000000 86                    DC8     0x86
  914    00000001 4E554D4245            DC8     'NUMBE'
  915    00000006 D2                    DC8     'R'+0x80
  916    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  917    00000008 ........              DC32    WORD_NFA
  918                           NUMBER:
  919    0000000C ........              DC32    DOCOL
  920    00000010 ........              DC32    BASE_TO_R12     // Save current BASE.
  921    00000014 ........              DC32    NUMBERSUFFIX    // (addr -- sddr) Change BASE if suffix used.
  922                           
  923                           // SETUP: stack arguments for PNUMBER.
  924    00000018 .............         DC32    ZERO, ZERO
                  ...          
  925    00000020 ........              DC32    ROT             // ( 0 0 addr -- )
  926                           
  927                           // SETUP: reeturn stack with sign flag
  928                           // NONAME CANDIDATE!
  929                           // START: Handle minus sign by saving status on Return Stack.
  930                           // and incrementing to addr after it.
  931    00000024 .............         DC32    DUP, ONEP       // ( 0 0 addr addr+1 -- )
                  ...          
  932    0000002C ........              DC32    CAT             // ( 0 0 addr 1rstchar -- )
  933    00000030 ........2D000         DC32    LIT, '-'        // ( 0 0 addr 1rstchar 0x2D --- )
                  000          
  934    00000038 ........              DC32    EQUAL           // ( 0 0 addr f -- )
  935                           #ifdef TRUE_EQU_NEG_ONE         // EQUAL returns -1 NEED 0 or 1 here!
  936    0000003C .............         DC32    ONE, ANDD       // ( 0 0 addr f -- ) MAKE FLAG ONE OR ZERO!
                  ...          
  937                           #endif
  938    00000044 .............         DC32    DUP, TOR        // ( 0 0 addr f -- ) copy of f >R
                  ...          
  939                           // END: Handle - by saving status on Return Stack.
  940                           
  941                           // SETUP: addr pointing to 1rst digit.
  942                           // If minus sign, flag from above will increment to next char.
  943    0000004C ........              DC32    PLUS            // Increment (OR NOT) addr to next char
  944                           
  945                           // So could be at 1rst OR 2nd character in string here!
  946                           
  947                           // ENTER LOOP WITH -1 DPL = single number and sign flag on return stack.
  948    00000050 ........FFFFF         DC32    LIT, -1
                  FFF          
  949                           // PNUMBER is used in loop to convert string segment until non-mumeric chracter.
  950                           // A period in the string manipulates DPL to create a double number.
  951                           // A comma in the string resets DPL to create a single number.
  952                           // A null indicates the end of the string.
  953                           NUMB1:                          // Begin
  954    00000058 .............         DC32    DPL_SV, STORE   // PNUMBER creates whole, dot or comma number segment
                  ...          
  955                           
  956                           // PNUMBER converts one or more characters until first unconvertable digit.
  957                           // ud and addr in string is maintained while in loop.
  958    00000060 ........              DC32    PNUMBER         // ( 0 0 addr -- ud=(LSW MSW) ADDR=PAST#)
  959                           // Perform check for period, comma and null.
  960                           // Any other character here invalidates this number conversion.
  961                           
  962                           // Null Test: = end of string.
  963    00000064 .............         DC32    DUP, CAT
                  ...          
  964    0000006C ........              DC32    ZERO            // End of string used to be BLANK, is now Null.
  965    00000070 ........              DC32    SUBB
  966    00000074 ........              DC32    ZBRAN           // IF emd of number string conversion is
  967    00000078 6C000000              DC32      NUMB2-.       // DONE UNLESS IT NEEDS TO BE NEGATED.
  968                           
  969                           // Period Test: = increment DPL.
  970    0000007C .............         DC32    DUP, CAT
                  ...          
  971    00000084 ........2E000         DC32    LIT, '.'        // 2Eh = period.
                  000          
  972    0000008C ........              DC32    SUBB
  973    00000090 ........              DC32    ZBRAN
  974    00000094 44000000              DC32      DPL_ZERO_INCR-.
  975                           
  976                           #ifdef  comma_test
  977                           // Comma Test: = reset DPL.
  978    00000098 .............         DC32    DUP, CAT
                  ...          
  979    000000A0 ........2C000         DC32    LIT, ','        // 2CH comma
                  000          
  980    000000A8 ........              DC32    EQUAL
  981    000000AC ........              DC32    ZBRAN
  982    000000B0 14000000              DC32      BASE_RESET_THEN_ERROR-.
  983                           
  984                           // Fall thru if comma so reset DPL to create a single number.
  985                           DPL_RESET:        
  986    000000B4 ........FFFFF         DC32    LIT, -1
                  FFF          
  987    000000BC ........              DC32    BRAN
  988    000000C0 98FFFFFF              DC32      NUMB1-.
  989                           #endif
  990                           
  991                           BASE_RESET_THEN_ERROR:
  992                           // GOING TO ERROR SO RESTORE BASE!
  993    000000C4 ........              DC32    BASE_FROM_R12   // Restore BASE
  994                           //NO_BASE_RESTORE:
  995    000000C8 ........              DC32    ONE     // provide non zero flag for error
  996    000000CC .............         DC32    LIT, msg_number_error
                  ...          
  997    000000D4 ........              DC32    QERROR // ( f nullstr-addr -- ) IF f TRUE EXECUTE ERROR!
  998                           
  999                           DPL_ZERO_INCR:      // set DPL to zero
 1000    000000D8 ........              DC32    ZERO
 1001    000000DC ........              DC32    BRAN
 1002    000000E0 78FFFFFF              DC32      NUMB1-.
 1003                           
 1004                           NUMB2:
 1005    000000E4 ........              DC32    DROP
 1006    000000E8 ........              DC32    RFROM           // FLAG OF "-" TEST
 1007                                                           // IF
 1008    000000EC ........              DC32    ZBRAN
 1009    000000F0 08000000              DC32      NUMB3-.
 1010                           
 1011    000000F4 ........              DC32    DNEGATE
 1012                           
 1013                           NUMB3:                          // endif
 1014    000000F8 ........              DC32    BASE_FROM_R12   // Restore BASE
 1015    000000FC ........              DC32    SEMIS
 1016                           
 1017                           
 1018                           //      ERROR ERROR:    ( nullstr --- )
 1019                           //      Execute error notification and restart of system.
 1020                           //      IN_SV is saved to assist in determining the location of the error.
 1021                           
 1022                            SECTION .text : CONST (2)
 1023                           ERROR_NFA:
 1024    00000000 85                    DC8     0x85
 1025    00000001 4552524F              DC8     'ERRO'
 1026    00000005 D2                    DC8     'R'+0x80
 1027    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1028                           //      DC32    DFIND_NFA
 1029    00000008 ........              DC32    NUMBER_NFA
 1030                           ERROR:
 1031    0000000C ........              DC32    DOCOL
 1032    00000010 .............         DC32    HERE, COUNT, TYPE       // Offending item
                  ...........  
 1033    0000001C .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 1034                           #ifdef IO2TP
 1038                           #endif
 1039                           #ifdef XON_XOFF
 1040    00000024 ........              DC32    XOFF    // TEMP TEST THRE
 1041                           #endif
 1042                                   
 1043                           //      DO THIS WHERE STATE IS SET BACK TO ZERO
 1044    00000028 .............         DC32    STATE_SV, AT
                  ...          
 1045    00000030 ........              DC32    ZBRAN
 1046    00000034 40000000              DC32     CREATED_OK-.
 1047                           
 1048                           //      NON-ZERO CSDP = RESTORE DP TO forget DAMAGED WORDS
 1049    00000038 .............         DC32    CSDP_SV, AT   // Create saves dp here for if word exists err
                  ...          
 1050    00000040 ........              DC32    ZBRAN
 1051    00000044 30000000              DC32     CREATED_OK-.
 1052                           
 1053                           // assume ITS A CREATE'd WORD!!!!
 1054                           ERROR_FIXUP:     // CSDP_SV contains NFA of definition that has error.
 1055    00000048 .............         DC32    CSDP_SV, AT     // SHOULD BE AT NFA!!
                  ...          
 1056    00000050 ........              DC32    PFA     // \ nfa -- pfa
 1057    00000054 .............         DC32    LFA, AT // \ pfa --- lfa
                  ...          
 1058    0000005C .............         DC32    CURRENT_SV, STORE       // Has to be NFA of last good word
                  ...          
 1059                           // RESET DP!
 1060    00000064 .............         DC32    CSDP_SV, AT
                  ...          
 1061    0000006C .............         DC32    DP_SV, STORE
                  ...          
 1062                           
 1063                           CREATED_OK:
 1064    00000074 ........              DC32    SEMIC_CREATE            // RESET CSDP FOR AUTO FORGET
 1065                           #ifdef ABORT_STOP_TILL_CO
 1066    00000078 ........              DC32    ABORT
 1067                           #else
 1069                           #endif
 1070                           //      DC32    QUIT    // FROM Error
 1071                           
 1072                           
 1073                           //      ' TICK: ( -- pfa ) IMMEDIATE
 1074                           //      Used in the form: .
 1075                           //      ' CCcc
 1076                           //      Leaves the parameter field address of dictionary word CCcc.
 1077                           //      If the word is not found after a search of CURRENT,
 1078                           //      an appropriate error message is given.
 1079                           //      As a compiler directive, executed in a colon-definition to compile
 1080                           //      the address as a literal.
 1081                           //      Pronounced "TICK".
 1082                           
 1083                            SECTION .text : CONST (2)
 1084                           TICK_NFA:
 1085    00000000 C1                    DC8     0x0C1
 1086    00000001 A7                    DC8     ''''+0x80
 1087    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1088    00000004 ........              DC32    ERROR_NFA
 1089                           TICK:
 1090    00000008 ........              DC32    DOCOL
 1091    0000000C ........              DC32    DFIND   // noop there for TIB entry
 1092    00000010 ........              DC32    ZEQU
 1093    00000014 .............         DC32    LIT, msg_word_error
                  ...          
 1094    0000001C ........              DC32    QERROR    // \ f nullstr-addr --
 1095    00000020 ........              DC32    DROP
 1096    00000024 ........              DC32    LITERAL
 1097    00000028 ........              DC32    SEMIS
 1098                           
 1099                           
 1100                           //      EXPECT EXPECT:  ( addr count -- )
 1101                           //      Transfer characters from the terminal to the buffer starting at addr+1,
 1102                           //      until a "return" or the count of characters have been received.
 1103                           //      One or two nulls are added at the end creating a null-terminated string.
 1104                           //      A count byte is placed at addr, the count being derived by $LEN
 1105                           //      Use COUNT with TYPE for strings saved this way.
 1106                           //      Strings longer that 255 will have an invalid count byte. Use $LEN:
 1107                           //      $LEN and TYPE can be used when the argument to $LEN is addr+1.
 1108                           
 1109                           //      Comments below use TIB input (QUERY in INTERPRET) as an example.
 1110                           
 1111                            SECTION .text : CONST (2)
 1112                           EXPECT_NFA:
 1113    00000000 86                    DC8     0x86
 1114    00000001 4558504543            DC8     'EXPEC'
 1115    00000006 D4                    DC8     'T'+0x80
 1116    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1117    00000008 ........              DC32    TICK_NFA
 1118                           EXPECT:                 // ( NOS TOS -- NOS TOS )
 1119    0000000C ........              DC32    DOCOL   // ( TIB LEN -- )
 1120    00000010 ........              DC32    ONEP    // ( TIB LEN+1 -- ) (Index and Limit)+1 for count byte
 1121    00000014 ........              DC32    OVER    // ( TIB LEN+1 TIB -- )
 1122    00000018 ........              DC32    PLUS    // ( TIB TIB+LEN+1 -- )
 1123    0000001C ........              DC32    OVER    // ( TIB TIB+LEN+1 TIB -- )
 1124    00000020 ........              DC32    ONEP    // ( TIB TIB+LEN+1 TIB+1 -- ) SKIP COUNT BYTE
 1125                           #ifdef XON_XOFF
 1126    00000024 ........              DC32    XON
 1127                           #endif
 1128                           // ( ORGIGINAL-TIB TIB+LEN+1 TIB+1 -- ORGIGINAL-TIB ) 
 1129                           //                (Index & Limit)+1 for count byte
 1130    00000028 ........              DC32    XDO     // DO   Index = addr, Limit = addr+cnt
 1131                           EXPE1:
 1132    0000002C ........              DC32    KEY     // CAN BREAKPOINT OR CHANGE TO BE 0x0D ONLY
 1133                           #ifdef XON_XOFF
 1134    00000030 ........              DC32    IF_EOL_SEND_XOFF        // IF CR QUICK XOFF!
 1135                           #endif
 1136                           // goto main branch (EL1:)if not tab
 1137    00000034 .............         DC32    DUP, LIT, 9, EQUAL      // ? TAB
                  ...09000000..
                  ......       
 1138    00000044 ........              DC32    ZBRAN                   // Not tab
 1139    00000048 0C000000              DC32     EL1-.                  // Goto MAIN LOOP
 1140                                   
 1141                           // REPLACE TAB WITH SPACE               // -- ch f
 1142    0000004C .............         DC32    DROP, BLANK             // Convert tab to space
                  ...          
 1143                           EL1:
 1144                           // MAIN LOOP ENTERED WITH CHAR ON TOS
 1145    00000054 ........              DC32    DUP             // ( TIB key key -- )
 1146                           // FALL THRU IF BACKSPACE OR DELETE KEY
 1147    00000058 ........              DC32    BACKSPACE_CHAR
 1148    0000005C ........              DC32    EQUAL
 1149    00000060 ........              DC32    OVER
 1150    00000064 ........7F000         DC32    LIT, 07Fh       // DEL KEY
                  000          
 1151    0000006C ........              DC32    EQUAL
 1152    00000070 ........              DC32    OR
 1153                           // BRANCH IF NOT BACKSPACE OR DELETE KEY
 1154    00000074 ........              DC32    ZBRAN           // If not backspace
 1155    00000078 50000000              DC32     EXPE2-.        // go here
 1156                           
 1157                           // CASE OF BACKSPACE/DELETE KEY
 1158    0000007C ........              DC32    DROP            // ( TOS> 8 TIB -- TIB ) Drop Backspace on stack
 1159    00000080 ........              DC32    DUP             // ( TOS> TIB -- TOS> TIB TIB )  Current TIB addr
 1160    00000084 ........              DC32    I               // ( TOS> TIB TIB -- I=TIB+? TIB TIB )
 1161                           // COMPENSATE FOR COUNT BYTE - BUMP ADDR+1 (NEXT CHAR LOCATION) BACK TO CURRENT
 1162    00000088 ........              DC32    ONEM
 1163    0000008C ........              DC32    EQUAL           // ( TOS> I=TIB+? TIB TIB -- f TIB )
 1164    00000090 ........              DC32    DUP             // ( TOS> f TIB -- f f TIB )
 1165                           // I AND RFROM STARTS AT TIB+1 
 1166                           // REMOVE INDEX FROM LOOP TO REPLACE IT WITH BACKSPACE CORRECTED ADDRESS
 1167    00000094 ........              DC32    RFROM           // ( TOS> f f TIB -- TIB+1 f f TIB )
 1168                           // ADDING 2 BECAUSE TIB+1 IS FROM I AND FLAG MAKES IT = TO 1
 1169                           // WHEN AT THE BEGIINING (ADDR+1) OF THE ADDR BUFFER
 1170    00000098 ........              DC32    TWO
 1171    0000009C ........              DC32    SUBB
 1172                           // ADD FLAG 
 1173    000000A0 ........              DC32    PLUS
 1174    000000A4 ........              DC32    TOR
 1175    000000A8 ........              DC32    ZBRAN           // If not at beginning of line
 1176    000000AC 10000000              DC32     EXPE6-.        // Goto bsout
 1177                           
 1178    000000B0 ........              DC32    BELL            // At beginning of TIB issue bell
 1179    000000B4 ........              DC32    BRAN            // Goto end of loop
 1180    000000B8 60000000              DC32     EXPE33-.
 1181                           
 1182                           EXPE6:
 1183    000000BC ........              DC32    BSOUT           // endif
 1184                           EXPE7:  // LABEL NOT USED BECAUSE BELL AND BSOUT Emit THEMSELVES
 1185    000000C0 ........              DC32    BRAN            // Goto end of loop
 1186    000000C4 54000000              DC32     EXPE33-.
 1187                           
 1188                           EXPE2:
 1189    000000C8 ........              DC32    DUP
 1190    000000CC ........0D000         DC32    LIT, 0x0D       // cr
                  000          
 1191    000000D4 ........              DC32    EQUAL
 1192    000000D8 ........              DC32    ZBRAN           // If not cr
 1193    000000DC 1C000000              DC32     EXPE4-.        // Goto save this char and loop again
 1194                                   
 1195    000000E0 ........              DC32    LEAVE           // ( TOS> ODh TIB --  )
 1196                           #ifdef  IOBUFS_DEBUG        
 1198                           #endif
 1199                                   // CR DROPPED HERE I USED AT END FOR CASE OF EXPECT COUNT REACHED
 1200    000000E4 ........              DC32    DROP            // ( TOS> TIB -- )
 1201    000000E8 ........              DC32    BLANK           // ( TOS> 20h TIB -- ) space IS FOR EMIT!
 1202    000000EC ........              DC32    ZERO            // ( TOS> 0 20h TIB -- ) null
 1203    000000F0 ........              DC32    BRAN            // Goto store these at end of loop
 1204    000000F4 08000000              DC32     EXPE5-.
 1205                           
 1206                           EXPE4:
 1207    000000F8 ........              DC32    DUP             // Regular char 
 1208                           
 1209                           EXPE5:
 1210    000000FC ........              DC32    I               // I=TIB Store char
 1211    00000100 ........              DC32    CSTORE          // or 1rst null in CASE OF CR
 1212    00000104 ........              DC32    ZERO            // 1rst or second null if cr
 1213                                   // CASE OF CR ( TOS> 0 20h TIB -- )
 1214    00000108 ........              DC32    I
 1215    0000010C ........              DC32    ONEP
 1216    00000110 ........              DC32    CSTORE
 1217                           EXPE3:
 1218                                   // CASE OF CR ( TOS> 20H TIB -- )
 1219    00000114 ........              DC32    EMIT
 1220                           EXPE33:
 1221    00000118 ........              DC32    XLOOP
 1222    0000011C 10FFFFFF              DC32     EXPE1-.        // Loop is LEAVE'd
 1223                           
 1224                           #ifdef XON_XOFF
 1225    00000120 ........              DC32    XOFF            // FOR CASE OF count reached befor cr
 1226                           #endif
 1227                           // Creat count byte        
 1228                                   // ( ORIGINAL ADDR -- )
 1229                                   // ORIGINAL ADDR (TIB) ON STACK HERE SO CORRECT FOR $LEN
 1230    00000124 ........              DC32    ONEP            // PAST COUNT BYTE FOR CORRECT COUNT
 1231                                   // NULLSTRLEN:          // ( addr -- addr len )
 1232    00000128 ........              DC32    NULLSTRLEN      // ( TOS> LEN TIB+1 -- )
 1233    0000012C .............         DC32    SWAP, ONEM      // BACK UP TO COUNT BYTE
                  ...          
 1234    00000134 ........              DC32    CSTORE
 1235    00000138 ........              DC32    SEMIS
 1236                           
 1237                           
 1238                           //      COUNT COUNT:    ( addr1 --- addr2 n )
 1239                           //      Leave the byte address addr2 and byte count n of a count byte string,
 1240                           //      beginning at address addr1. It is presumed that the first byte at
 1241                           //      addr1 contains the text byte count and the actual text starts with
 1242                           //      the second byte. NFA's may report SMUDGE'd byte counts, handled only
 1243                           //      by ID. User Strings may be up to 255 characters.
 1244                           //      Typically COUNT is followed by TYPE.
 1245                           //      See TYPE $LEN and EXPECT
 1246                           
 1247                            SECTION .text : CONST (2)
 1248                           COUNT_NFA:
 1249    00000000 85                    DC8     0x85
 1250    00000001 434F554E              DC8     'COUN'
 1251    00000005 D4                    DC8     'T'+0x80
 1252    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1253    00000008 ........              DC32    EXPECT_NFA
 1254                           COUNT:
 1255    0000000C ........              DC32    DOCOL
 1256    00000010 ........              DC32    DUP
 1257    00000014 ........              DC32    ONEP
 1258    00000018 ........              DC32    SWAP
 1259                           //        DC32    CATLT7F
 1260    0000001C ........              DC32    CAT     // n could be SMUDGE'd count from NFA's
 1261    00000020 ........              DC32    SEMIS   // Only internal usage is ID.
 1262                           
 1263                           
 1264                           //      $LEN NULLSTRLEN:        ( addr --- addr len )
 1265                           //      Count length of null terminated string like 'c' does,
 1266                           //      and return the string len after addr.
 1267                           //      TYPE can be used after this word.
 1268                           
 1269                            SECTION .text : CONST (2)
 1270                           NULLSTRLEN_NFA:
 1271    00000000 84                    DC8     0x84
 1272    00000001 244C45                DC8     '$LE'
 1273    00000004 CE                    DC8     'N'+0x80
 1274    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1275    00000008 ........              DC32    COUNT_NFA
 1276                           NULLSTRLEN:
 1277    0000000C ........              DC32    .+5
 1278                            SECTION .text : CODE (2)
 1279                                   NDPOP2w                 // Put addr in w_R2 yet leave addr on stack
 1279.1  00000000 3A68                  LDR     w, [p]
 1279.2                                 ENDM
 1280                                                           // Usually TIB.
 1281    00000002 4040                  EORS    t, t, t         // zero count
 1282                           
 1283                           NSLEN_LOOP:
 1284    00000004 115C                  LDRB            n, [w,t]
 1285    00000006 0943                  ORRS            n, n, n
 1286    00000008 01D0                  BEQ             NSLEN_DONE
 1287    0000000A 401C                  ADDS            t, t, #1
 1288    0000000C FAE7                  B               NSLEN_LOOP
 1289                           
 1290                           NSLEN_DONE:
 1291                                   TPUSH
 1291                                   PUSHt   // push t to p, pre decrement p
 1291.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1291.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1291.3                         //      STR     t, [p]
 1291.4                                 ENDM
 1291                                   NEXT
 1291.1                         // ARMv7-M Thumb = .+5
 1291.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1291.3                         // ARMv6-M Thumb = .+4
 1291.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1291                                   NEXT1
 1291.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1291.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1291.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1291.4                         // ARMv6-M Thumb = .+4
 1291.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1291.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1291.7                                 ENDM
 1291.8                                 ENDM
 1291.9                                 ENDM
 1292                           
 1293                           
 1294                           //      FORGET FORGET:  ( -- )
 1295                           //      PRINTS NEW HERE IF SUCCESSFUL. FIXED FIG VERSION MEMORY LEAK.
 1296                           //      Executed in the form:
 1297                           //      FORGET CCcc
 1298                           //      Deletes definition named CCcc from the dictionary with all entries
 1299                           //      physically following it. In fig-FORTH, an error message will occur
 1300                           //      if the CURRENT and CONTEXT vocabularies are not currently the same.
 1301                           //      MODIFIED: To update Current along with context and reset DP,
 1302                           //      and execute .DS and .VS
 1303                           
 1304                            SECTION .text : CONST (2)
 1305                           FORGET_NFA:
 1306    00000000 86                    DC8     0x86
 1307    00000001 464F524745            DC8     'FORGE'
 1308    00000006 D4                    DC8     'T'+0x80
 1309    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1310    00000008 ........              DC32    NULLSTRLEN_NFA
 1311                           FORGET:
 1312    0000000C ........              DC32    DOCOL
 1313    00000010 ........              DC32    TICK                    // \ -- pfa ELSE error message
 1314    00000014 ........              DC32    DUP
 1315    00000018 ........00000         DC32    LIT, FLASH_SPAGE        // DONT FORGET FISH WORDS SAVED IN FLASH
                  208          
 1316    00000020 ........              DC32    LESSTHAN
 1317    00000024 .............         DC32    LIT, msg_forget_fish
                  ...          
 1318    0000002C ........              DC32    QERROR                  // \ f nullstr-addr --
 1319    00000030 ........              DC32    DUP
 1320    00000034 ........00001         DC32    LIT, FLASH_PPAGE        // DONT FORGET USER WORDS IN FLASH
                  008          
 1321    0000003C ........              DC32    LESSTHAN
 1322    00000040 .............         DC32    LIT, msg_forget_saved
                  ...          
 1323    00000048 ........              DC32    QERROR                  // \ f nullstr-addr --
 1324                           //      MOVE NFA update of the DP to after Currrent and Context
 1325    0000004C ........              DC32    DUP                     // PFA PFA --
 1326    00000050 ........              DC32    LFA                     // PFA LFA --
 1327                           
 1328                           // VAR space reclamation starts here:
 1329                           // PFA LFA --
 1330    00000054 ........              DC32    TOR                     // LFA_BOT
 1331                           
 1332                           VS_RECVR_LOOP:
 1333    00000058 .............         DC32    LATEST, PFA, LFA        // LFA_TOP
                  ...........  
 1334    00000064 .............         DC32    DUP, AT                 // LFA NEXT_LFA
                  ...          
 1335    0000006C .............         DC32    CURRENT_SV, STORE       // SET NEXT WORD TO CHECK
                  ...          
 1336    00000074 .............         DC32    DUP, FOURP, AT          // GET CFA
                  ...........  
 1337    00000080 .............         DC32    LIT, DOVAR, EQUAL       // IS IT A DOVAR
                  ...........  
 1338    0000008C ........              DC32    ZBRAN
 1339    00000090 14000000              DC32     VS_RECVR_NEXT-.
 1340                                   
 1341    00000094 ........FCFFF         DC32    LIT, -4, UP_SV, PSTORE  // DECREMENT UP
                  FFF..........
                  ......       
 1342                           
 1343                           VS_RECVR_NEXT:
 1344    000000A4 .............         DC32    R, EQUAL
                  ...          
 1345    000000AC ........              DC32    ZBRAN
 1346    000000B0 A8FFFFFF              DC32     VS_RECVR_LOOP-.
 1347                           
 1348    000000B4 ........              DC32    RFROM
 1349                           // VAR SPACE RECLAMATION DONE
 1350                           
 1351                           // PFA LFA --
 1352    000000B8 ........              DC32    AT              // LFA
 1353    000000BC ........              DC32    CURRENT_SV
 1354    000000C0 ........              DC32    STORE
 1355    000000C4 ........              DC32    NFA             // FROM PFA
 1356    000000C8 ........              DC32    DP_SV
 1357    000000CC ........              DC32    STORE
 1358    000000D0 .............         DC32    DOTVARSPACE, DOTDICTSPACE
                  ...          
 1359    000000D8 ........              DC32    SEMIS
 1360                           
 1361                           
 1362                           //      BYE BYE: ( -- ) COLD RESTART WITH SERIAL INITIALIZATION
 1363                           
 1364                            SECTION .text : CONST (2)
 1365                           BYE_NFA:
 1366    00000000 83                    DC8     0x83
 1367    00000001 4259                  DC8     'BY'
 1368    00000003 C5                    DC8     'E'+0x80
 1369                            ALIGNROM 2,0xFFFFFFFF
 1370    00000004 ........              DC32    FORGET_NFA
 1371                           BYE:
 1372    00000008 ........              DC32    .+5
 1373                            SECTION .text : CODE (2)
 1374                           //        B       FM3_COLD      // __iar_program_start
 1375    00000000 ........              B       STM32Fx_COLD_FISH
 1376                            LTORG
 1377                           
 1378                           
 1379                           //      ABORT ABORT:    ( -- )
 1380                           //      Clear the stacks, zero out and execute RUN or QUIT
 1381                           //      DOES NOT RESET DICTIONAIRY. SEE COLD.
 1382                           
 1383                            SECTION .text : CONST (2)
 1384                           ABORT_NFA:
 1385    00000000 85                    DC8     0x85
 1386    00000001 41424F52              DC8     'ABOR'
 1387    00000005 D4                    DC8     'T'+0x80
 1388    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1389    00000008 ........              DC32    BYE_NFA
 1390                           ABORT:
 1391    0000000C ........              DC32    DOCOL
 1392    00000010 ........              DC32    SPSTO
 1393    00000014 ........              DC32    RPSTO
 1394                           #ifdef IO2TP
 1399                           #endif
 1400    00000018 ........              DC32    zero_OUT
 1401                           //      DC32    QSTACK  // IF STACK error abort using QERROR->ERROR
 1402                           
 1403                           // LOOK UP RUN AND EXEC IT
 1404    0000001C .............         DC32    LIT, msg_RUN
                  ...          
 1405    00000024 ........              DC32    LATEST
 1406                           //ABORT_BP1_B4_PFIND_RUN:
 1407                           // DC32 NOOP
 1408    00000028 ........              DC32    PFIND   // 0 OR pfa len 1
 1409    0000002C ........              DC32    ZBRAN
 1410    00000030 10000000              DC32      ABORT_QUIT-.
 1411                           
 1412    00000034 ........              DC32    DROP    // LEN
 1413    00000038 .............         DC32    CFA, EXEC
                  ...          
 1414                           ABORT_QUIT:
 1415                           //      DC32    SEMIC_CREATE // Use ERROR if need to recover from bad definition
 1416                           #ifdef ABORT_STOP_TILL_CO
 1417    00000040 .............         DC32    LIT, ERROR_HALT, AT
                  ...........  
 1418    0000004C ........              DC32    ZBRAN
 1419    00000050 6C000000              DC32      CO_END-.
 1420                           // halt on all errors until "CO" entered
 1421                           // BEGIN
 1422    00000054 .............         DC32    LIT, msg_CO, NULLSTRLEN, TYPE
                  .............
                  ......       
 1423                           NOT_CO:
 1424    00000064 ........              DC32    QKEY
 1425    00000068 ........              DC32    ZBRAN
 1426    0000006C F8FFFFFF              DC32      NOT_CO-.
 1427                           // IF KEY = "C'
 1428    00000070 .............         DC32    KEY, LIT, 43h, EQUAL
                  ...43000000..
                  ......       
 1429    00000080 ........              DC32    ZBRAN
 1430    00000084 E0FFFFFF              DC32      NOT_CO-.
 1431                           // NEXT KEY "0"
 1432    00000088 .............         DC32    KEY, LIT, 4Fh, EQUAL
                  ...4F000000..
                  ......       
 1433    00000098 ........              DC32    ZBRAN
 1434    0000009C C8FFFFFF              DC32      NOT_CO-.
 1435                           // NEXT KEY "Enter"
 1436    000000A0 .............         DC32    KEY, LIT, 0Dh, EQUAL
                  ...0D000000..
                  ......       
 1437    000000B0 ........              DC32    ZBRAN
 1438    000000B4 B0FFFFFF              DC32      NOT_CO-.
 1439                           // UNTIL
 1440    000000B8 ........              DC32    CR
 1441                           CO_END:
 1442                           #endif
 1443    000000BC ........              DC32    QUIT    // OI
 1444                           #ifdef ABORT_STOP_TILL_CO
 1445                           $FISH_CO_MSGS.h
 1446                           #endif
 1447                           
 1448                           //      COLD COLD:      ( -- )  MODIFIED:
 1449                           //      FIGISH SYSTEM COLD = WARM (INIT RAMVARSPACE) -> type signon MSG ->ABORT
 1450                           //      CLEARS DICTIONAIRY. SEE ABORT.
 1451                           
 1452                            SECTION .text : CONST (2)
 1453                           COLD_NFA:
 1454    00000000 84                    DC8     0x84
 1455    00000001 434F4C                DC8     'COL'
 1456    00000004 C4                    DC8     'D'+0x80
 1457    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1458    00000008 ........              DC32    ABORT_NFA
 1459                           COLD:
 1460    0000000C ........              DC32    DOCOL
 1461    00000010 ........              DC32    WARM            // FISH System VAR init.
 1462    00000014 ........              DC32    SIGNON
 1463                           #ifdef ABORT_STOP_TILL_CO
 1464    00000018 ........              DC32    QUIT
 1465                           #else
 1467                           #endif
 1468                           
 1469                           //=============================== WORDCAT ====================================//
 1470                           //NOEXEC HEADERFORWORDCATEGORIES
 1471                           //      WC_FISH_SYS: = FISH System: CATEGORY
 1472                           
 1473                            SECTION .text : CONST (2)
 1474                           WC_FISH_SYS_NFA:
 1475    00000000 90                    DC8     0x80+4+12
 1476    00000001 0D0A                  DC8     0x0D, 0x0A
 1477    00000003 4649534820537         DC8     'FISH System:'
                  97374656D3A  
 1478    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1479    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1480    00000014 ........              DC32    COLD_NFA
 1481                           
 1482                           
 1483                           //----------------------------- DOTSTACK SECTION -------------------------------
 1484                           
 1485                           //      .SH DOTSHEX:    ( -- )
 1486                           //      Nondestructively print items on stack in HEX, preserving base.
 1487                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1488                           
 1489                            SECTION .text : CONST (2)
 1490                           DOTSHEX_NFA:
 1491    00000000 83                    DC8     0x83
 1492    00000001 2E53                  DC8     '.S'
 1493    00000003 C8                    DC8     'H'+0x80
 1494                            ALIGNROM 2,0xFFFFFFFF
 1495    00000004 ........              DC32    WC_FISH_SYS_NFA
 1496                           DOTSHEX:
 1497    00000008 ........              DC32    DOCOL
 1498    0000000C ........10000         DC32    LIT, 16, DOTSBASE
                  000........  
 1499    00000018 ........              DC32    SEMIS
 1500                           
 1501                           
 1502                           //      .SD DOTSDEC:    ( -- )
 1503                           //      Nondestructively print items on stack in DECIMAL, preserving base.
 1504                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1505                           
 1506                            SECTION .text : CONST (2)
 1507                           DOTSDEC_NFA:
 1508    00000000 83                    DC8     0x83
 1509    00000001 2E53                  DC8     '.S'
 1510    00000003 C4                    DC8     'D'+0x80
 1511                            ALIGNROM 2,0xFFFFFFFF
 1512    00000004 ........              DC32    DOTSHEX_NFA
 1513                           DOTSDEC:
 1514    00000008 ........              DC32    DOCOL
 1515    0000000C ........0A000         DC32    LIT, 10, DOTSBASE
                  000........  
 1516    00000018 ........              DC32    SEMIS
 1517                           
 1518                           
 1519                           //      .SB DOTSBIN:    ( -- )
 1520                           //      Nondestructively print items on stack in BINARY, preserving base.
 1521                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1522                           
 1523                            SECTION .text : CONST (2)
 1524                           DOTSBIN_NFA:
 1525    00000000 83                    DC8     0x83
 1526    00000001 2E53                  DC8     '.S'
 1527    00000003 C2                    DC8     'B'+0x80
 1528                            ALIGNROM 2,0xFFFFFFFF
 1529    00000004 ........              DC32    DOTSDEC_NFA
 1530                           DOTSBIN:
 1531    00000008 ........              DC32    DOCOL
 1532    0000000C .............         DC32    TWO, DOTSBASE
                  ...          
 1533    00000014 ........              DC32    SEMIS
 1534                           
 1535                           
 1536                           //      .S DOTS:        ( -- )
 1537                           //      Nondestructively print items on stack in current base.
 1538                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1539                           
 1540                            SECTION .text : CONST (2)
 1541                           DOTS_NFA:
 1542    00000000 82                    DC8     0x82
 1543    00000001 2E                    DC8     '.'
 1544    00000002 D3                    DC8     'S'+0x80
 1545    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1546    00000004 ........              DC32    DOTSBIN_NFA
 1547                           DOTS:
 1548    00000008 ........              DC32    DOCOL
 1549    0000000C .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1550    0000001C .............         DC32    EQUAL, ZEQU, ZBRAN
                  ...........  
 1551    00000028 68000000              DC32    DOTSEND-.                       // IF NOTHING ON STACK
 1552                           
 1553    0000002C ........              DC32    PDOTQ
 1554    00000030 05                    DC8     5
 1555    00000031 544F533E20            DC8     'TOS> '
 1556    00000036 FFFF           ALIGNROM 2,0xFFFFFFFF
 1557                                 
 1558    00000038 .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1559    00000048 ........              DC32    XDO
 1560                           
 1561                           DOTSLOOP:
 1562    0000004C .............         DC32    I, AT
                  ...          
 1563    00000054 .............         DC32    BASE_SV, AT
                  ...          
 1564    0000005C ........0A000         DC32    LIT, 10, EQUAL                  // 
                  000........  
 1565    00000068 ........              DC32    ZBRAN                           // NOT = DECIMAL
 1566    0000006C 10000000              DC32    DBSUSEDUDOT-.
 1567    00000070 ........              DC32    DOT_BASE_SUFFIX
 1568    00000074 ........              DC32    BRAN
 1569    00000078 08000000              DC32    DBSUSEDOT-.
 1570                           
 1571                           DBSUSEDUDOT:
 1572    0000007C ........              DC32    UDOT_BASE_SUFFIX
 1573                           
 1574                           DBSUSEDOT:
 1575    00000080 ........              DC32    SPACE
 1576    00000084 .............         DC32    FOUR, XPLOOP
                  ...          
 1577    0000008C C0FFFFFF              DC32    DOTSLOOP-.
 1578                           
 1579                           DOTSEND:
 1580    00000090 ........              DC32    SEMIS
 1581                           
 1582                           
 1583                           //      2DUP TDUP:      ( n2 n1 -- n2 n1 n2 n1 )
 1584                           //      Duplicate top two stack items. The prefix 2 convention means
 1585                           //      an operation on the top two stack items.
 1586                           
 1587                            SECTION .text : CONST (2)
 1588                           TDUP_NFA:
 1589    00000000 84                    DC8     0x84
 1590    00000001 324455                DC8     '2DU'
 1591    00000004 D0                    DC8     'P'+0x80
 1592    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1593    00000008 ........              DC32    DOTS_NFA
 1594                           TDUP:
 1595    0000000C ........              DC32    .+5
 1596                            SECTION .text : CODE (2)
 1597                           // TDUP: OPT by picking pops
 1598    00000000 3868                  LDR     t, [p]          //
 1599    00000002 7A68                  LDR     w, [p, #4]      //
 1600                                   DPUSH                   // 
 1600                                   PUSHw   // push w to p, post decrement p
 1600.1  00000004 47F8042D              STR     w, [p, #-4]!
 1600.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1600.3                         //      STR     w, [p]
 1600.4                                 ENDM
 1600                                   TPUSH
 1600                                   PUSHt   // push t to p, pre decrement p
 1600.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1600.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1600.3                         //      STR     t, [p]
 1600.4                                 ENDM
 1600                                   NEXT
 1600.1                         // ARMv7-M Thumb = .+5
 1600.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1600.3                         // ARMv6-M Thumb = .+4
 1600.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1600                                   NEXT1
 1600.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1600.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1600.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1600.4                         // ARMv6-M Thumb = .+4
 1600.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1600.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1600.7                                 ENDM
 1600.8                                 ENDM
 1600.9                                 ENDM
 1600.10                                ENDM
 1601                           
 1602                           
 1603                           //      -DUP ZNDUP:     ( n1 -- n1 (if zero)
 1604                           //                      ( n1 -- n1 n1 (non-zero)
 1605                           //      Reproduce n1 only if it is non-zero. Used in type andSPACES.
 1606                           //      This is usually used to copy a value just before IF, to eliminate
 1607                           //      the need for an ELSE part to drop it. 
 1608                           
 1609                            SECTION .text : CONST (2)
 1610                           DDUP_NFA:
 1611    00000000 84                    DC8     0x84
 1612    00000001 2D4455                DC8     '-DU'
 1613    00000004 D0                    DC8     'P'+0x80
 1614    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1615    00000008 ........              DC32    TDUP_NFA
 1616                           ZNDUP:
 1617    0000000C ........              DC32    DOCOL
 1618    00000010 ........              DC32    DUP
 1619    00000014 ........              DC32    ZBRAN   // IF
 1620    00000018 08000000              DC32    DDUP1-.
 1621                           
 1622    0000001C ........              DC32    DUP     //endif
 1623                           DDUP1:
 1624    00000020 ........              DC32    SEMIS
 1625                           
 1626                           
 1627                           //      ROT ROT: ( nl n2 n3 --- n2 n3 nl )
 1628                           //      Rotate the top three values on the stack, bringing the third to the top.
 1629                           
 1630                            SECTION .text : CONST (2)
 1631                           ROT_NFA:
 1632    00000000 83                    DC8     0x83
 1633    00000001 524F                  DC8     'RO'
 1634    00000003 D4                    DC8     'T'+0x80
 1635                            ALIGNROM 2,0xFFFFFFFF
 1636    00000004 ........              DC32    DDUP_NFA
 1637                           ROT:
 1638    00000008 ........              DC32    .+5
 1639                            SECTION .text : CODE (2)
 1640                                   POP2w
 1640.1  00000000 57F8042B              LDR     w, [p],#4
 1640.2                         //      LDR     w, [p]
 1640.3                         //      ADDS    p, p, #4
 1640.4                                 ENDM
 1641                                   POP2n
 1641.1  00000004 57F8041B              LDR     n, [p],#4
 1641.2                         //      LDR     n, [p]
 1641.3                         //      ADDS    p, p, #4
 1641.4                                 ENDM
 1642                           #ifdef TOSCT
 1644                           #endif
 1645                                   POP2t
 1645.1  00000008 57F8040B              LDR     t, [p],#4       // Post-increment
 1645.2                         //#ifndef TOSCT
 1645.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1645.4                         //#endif
 1645.5                         //      ADDS    p, p, #4
 1645.6                                 ENDM
 1646                                   PUSHn
 1646.1  0000000C 47F8041D              STR     n, [p, #-4]!
 1646.2                         //      SUBS    p, p, #4        // push n to p, pre decrement p
 1646.3                         //      STR     n, [p]
 1646.4                                 ENDM
 1647                                   DPUSH                   //  --  LSW MSW )
 1647                                   PUSHw   // push w to p, post decrement p
 1647.1  00000010 47F8042D              STR     w, [p, #-4]!
 1647.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1647.3                         //      STR     w, [p]
 1647.4                                 ENDM
 1647                                   TPUSH
 1647                                   PUSHt   // push t to p, pre decrement p
 1647.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1647.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1647.3                         //      STR     t, [p]
 1647.4                                 ENDM
 1647                                   NEXT
 1647.1                         // ARMv7-M Thumb = .+5
 1647.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1647.3                         // ARMv6-M Thumb = .+4
 1647.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1647                                   NEXT1
 1647.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1647.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1647.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1647.4                         // ARMv6-M Thumb = .+4
 1647.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1647.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1647.7                                 ENDM
 1647.8                                 ENDM
 1647.9                                 ENDM
 1647.10                                ENDM
 1648                           
 1649                           
 1650                           //      I I:    ( -- n )
 1651                           //      Used within a DO-LOOP to copy the loop index to the stack. Other use
 1652                           //      is implementation dependent.
 1653                           //      See R.
 1654                           
 1655                            SECTION .text : CONST (2)
 1656                           I_NFA:
 1657    00000000 81                    DC8     0x81
 1658    00000001 C9                    DC8     'I'+0x80
 1659    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1660    00000004 ........              DC32    ROT_NFA
 1661                           I:
 1662    00000008 ........              DC32    .+5
 1663                            SECTION .text : CODE (2)
 1664    00000000 3068                  LDR     t, [r]  // GET INDEX VALUE
 1665                                   TPUSH
 1665                                   PUSHt   // push t to p, pre decrement p
 1665.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1665.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1665.3                         //      STR     t, [p]
 1665.4                                 ENDM
 1665                                   NEXT
 1665.1                         // ARMv7-M Thumb = .+5
 1665.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1665.3                         // ARMv6-M Thumb = .+4
 1665.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1665                                   NEXT1
 1665.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1665.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1665.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1665.4                         // ARMv6-M Thumb = .+4
 1665.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1665.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1665.7                                 ENDM
 1665.8                                 ENDM
 1665.9                                 ENDM
 1666                           
 1667                           
 1668                           //      SP@ SPAT:       ( -- addr )
 1669                           //      \ -- addr = Current TOP of the parameter stack (p) )
 1670                           //      Place the address of the TOP of the parameter stack (p)
 1671                           //      on the parameter stack (p) as it was before RP@ was executed.
 1672                           //      e.g.  1  2  SP@  @  .   .   .     would type 2  2  1
 1673                           
 1674                            SECTION .text : CONST (2)
 1675                           SPAT_NFA:
 1676    00000000 83                    DC8     0x83
 1677    00000001 5350                  DC8     'SP'
 1678    00000003 C0                    DC8     '@'+0x80
 1679                            ALIGNROM 2,0xFFFFFFFF
 1680    00000004 ........              DC32    I_NFA
 1681                           SPAT:
 1682    00000008 ........              DC32    .+5
 1683                            SECTION .text : CODE (2)
 1684    00000000 3846                  MOV     t, p
 1685                                   TPUSH
 1685                                   PUSHt   // push t to p, pre decrement p
 1685.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1685.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1685.3                         //      STR     t, [p]
 1685.4                                 ENDM
 1685                                   NEXT
 1685.1                         // ARMv7-M Thumb = .+5
 1685.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1685.3                         // ARMv6-M Thumb = .+4
 1685.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1685                                   NEXT1
 1685.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1685.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1685.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1685.4                         // ARMv6-M Thumb = .+4
 1685.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1685.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1685.7                                 ENDM
 1685.8                                 ENDM
 1685.9                                 ENDM
 1686                           
 1687                           
 1688                           //      RP@ RPAT:       ( -- addr )
 1689                           //      \ -- addr = Current TOP of the Return Stack (r) )
 1690                           //      Place the address of the TOP of the return stack (r)
 1691                           //      on the parameter stack (p) as it was before RP@ was executed.
 1692                           //      e.g.  1 >R  2 >R  RP@  @  .   .   . would type 2  2  1
 1693                           
 1694                            SECTION .text : CONST (2)
 1695                           RPAT_NFA:
 1696    00000000 83                    DC8     0x83
 1697    00000001 5250                  DC8     'RP'
 1698    00000003 C0                    DC8     '@'+0x80
 1699                            ALIGNROM 2,0xFFFFFFFF
 1700    00000004 ........              DC32    SPAT_NFA
 1701                           RPAT:
 1702    00000008 ........              DC32    .+5
 1703                            SECTION .text : CODE (2)
 1704    00000000 3046                  MOV     t, r
 1705                                   TPUSH
 1705                                   PUSHt   // push t to p, pre decrement p
 1705.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1705.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1705.3                         //      STR     t, [p]
 1705.4                                 ENDM
 1705                                   NEXT
 1705.1                         // ARMv7-M Thumb = .+5
 1705.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1705.3                         // ARMv6-M Thumb = .+4
 1705.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1705                                   NEXT1
 1705.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1705.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1705.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1705.4                         // ARMv6-M Thumb = .+4
 1705.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1705.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1705.7                                 ENDM
 1705.8                                 ENDM
 1705.9                                 ENDM
 1706                           
 1707                           
 1708                           //      LEAVE LEAVE:    ( -- )
 1709                           //      Force termination of a DO-LOOP at the next opportunity by setting
 1710                           //      the loop limit equal to the current value of the index. The index
 1711                           //      itself remains unchanged, and execution proceeds until LOOP
 1712                           //      or +LOOP is encountered.
 1713                           
 1714                            SECTION .text : CONST (2)
 1715                           LEAVE_NFA:
 1716    00000000 85                    DC8     0x85
 1717    00000001 4C454156              DC8     'LEAV'
 1718    00000005 C5                    DC8     'E'+0x80
 1719    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1720                           //      DC32    RPSTO_NFA
 1721    00000008 ........              DC32    RPAT_NFA
 1722                           LEAVE:
 1723    0000000C ........              DC32    .+5
 1724                            SECTION .text : CODE (2)
 1725    00000000 3268                  LDR     w, [r]          // GET Index
 1726    00000002 7260                  STR     w, [r, #4]  // Store it at Limit
 1727                                   NEXT
 1727.1                         // ARMv7-M Thumb = .+5
 1727.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1727.3                         // ARMv6-M Thumb = .+4
 1727.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1727                                   NEXT1
 1727.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1727.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1727.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1727.4                         // ARMv6-M Thumb = .+4
 1727.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1727.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1727.7                                 ENDM
 1727.8                                 ENDM
 1728                           
 1729                           
 1730                           //      R> RFROM:       ( -- n )
 1731                           //      Remove the top value from the return stack and leave it on the
 1732                           //      computation stack. See >R and R.
 1733                           
 1734                            SECTION .text : CONST (2)
 1735                           RFROM_NFA:
 1736    00000000 82                    DC8     0x82
 1737    00000001 52                    DC8     'R'
 1738    00000002 BE                    DC8     '>'+0x80
 1739    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1740    00000004 ........              DC32    LEAVE_NFA
 1741                           RFROM:
 1742    00000008 ........              DC32    .+5
 1743                            SECTION .text : CODE (2)
 1744                                   POPr2t
 1744.1  00000000 56F8040B              LDR     t, [r],#4
 1744.2                         //      LDR     t, [r]
 1744.3                         //      ADDS    r, r, #4
 1744.4                                 ENDM
 1745                                   TPUSH
 1745                                   PUSHt   // push t to p, pre decrement p
 1745.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1745.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1745.3                         //      STR     t, [p]
 1745.4                                 ENDM
 1745                                   NEXT
 1745.1                         // ARMv7-M Thumb = .+5
 1745.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1745.3                         // ARMv6-M Thumb = .+4
 1745.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1745                                   NEXT1
 1745.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1745.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1745.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1745.4                         // ARMv6-M Thumb = .+4
 1745.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1745.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1745.7                                 ENDM
 1745.8                                 ENDM
 1745.9                                 ENDM
 1746                           
 1747                           
 1748                           //      R R:    ( -- n )
 1749                           //      Copy the top of the return stack to the computation stack.
 1750                           
 1751                            SECTION .text : CONST (2)
 1752                           R_NFA:
 1753    00000000 81                    DC8     0x81
 1754    00000001 D2                    DC8     'R'+0x80
 1755    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1756    00000004 ........              DC32    RFROM_NFA
 1757                           R:
 1758    00000008 ........              DC32    .+5
 1759                            SECTION .text : CODE (2)
 1760    00000000 3068                  LDR     t, [r]  // Get Index
 1761                                   TPUSH
 1761                                   PUSHt   // push t to p, pre decrement p
 1761.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1761.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1761.3                         //      STR     t, [p]
 1761.4                                 ENDM
 1761                                   NEXT
 1761.1                         // ARMv7-M Thumb = .+5
 1761.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1761.3                         // ARMv6-M Thumb = .+4
 1761.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1761                                   NEXT1
 1761.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1761.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1761.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1761.4                         // ARMv6-M Thumb = .+4
 1761.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1761.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1761.7                                 ENDM
 1761.8                                 ENDM
 1761.9                                 ENDM
 1762                           
 1763                           //      >R TOR: ( n -- )
 1764                           //      Remove a number from the computation stack and place as the most
 1765                           //      accessable on the return stack. Use should be balanced with R> in
 1766                           //      the same definition.
 1767                           
 1768                            SECTION .text : CONST (2)
 1769                           TOR_NFA:
 1770    00000000 82                    DC8     0x82
 1771    00000001 3E                    DC8     '>'
 1772    00000002 D2                    DC8     'R'+0x80
 1773    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1774    00000004 ........              DC32    R_NFA
 1775                           TOR:
 1776    00000008 ........              DC32    .+5
 1777                            SECTION .text : CODE (2)
 1778                                   POP2n   // preserve TOS
 1778.1  00000000 57F8041B              LDR     n, [p],#4
 1778.2                         //      LDR     n, [p]
 1778.3                         //      ADDS    p, p, #4
 1778.4                                 ENDM
 1779                                   PUSHn2r
 1779.1  00000004 46F8041D              STR     n, [r, #-4]!
 1779.2                         //      SUBS    r, r, #4        //  push t to r, pre decrement r
 1779.3                         //      STR     n, [r]
 1779.4                                 ENDM
 1780                           #ifdef TOSCT
 1782                           #endif
 1783                                   NEXT
 1783.1                         // ARMv7-M Thumb = .+5
 1783.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1783.3                         // ARMv6-M Thumb = .+4
 1783.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1783                                   NEXT1
 1783.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1783.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1783.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1783.4                         // ARMv6-M Thumb = .+4
 1783.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1783.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1783.7                                 ENDM
 1783.8                                 ENDM
 1784                           
 1785                           
 1786                           //      OVER OVER:      ( nl n2 -- nl n2 n1 )
 1787                           //      Copy the second stack value, placing it as the new top.
 1788                           
 1789                            SECTION .text : CONST (2)
 1790                           OVER_NFA:
 1791    00000000 84                    DC8     0x84
 1792    00000001 4F5645                DC8     'OVE'
 1793    00000004 D2                    DC8     'R'+0x80
 1794    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1795    00000008 ........              DC32    TOR_NFA
 1796                           OVER:
 1797    0000000C ........              DC32    .+5
 1798                            SECTION .text : CODE (2)
 1799                                   POP2w           // n2
 1799.1  00000000 57F8042B              LDR     w, [p],#4
 1799.2                         //      LDR     w, [p]
 1799.3                         //      ADDS    p, p, #4
 1799.4                                 ENDM
 1800                           #ifdef TOSCT
 1804                           #else
 1805                                   POP2t           // n1
 1805.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1805.2                         //#ifndef TOSCT
 1805.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1805.4                         //#endif
 1805.5                         //      ADDS    p, p, #4
 1805.6                                 ENDM
 1806                           #endif
 1807                                   PUSHt           // -- n1 )
 1807.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1807.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1807.3                         //      STR     t, [p]
 1807.4                                 ENDM
 1808                                   DPUSH           //  --  LSW MSW )
 1808                                   PUSHw   // push w to p, post decrement p
 1808.1  0000000C 47F8042D              STR     w, [p, #-4]!
 1808.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1808.3                         //      STR     w, [p]
 1808.4                                 ENDM
 1808                                   TPUSH
 1808                                   PUSHt   // push t to p, pre decrement p
 1808.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1808.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1808.3                         //      STR     t, [p]
 1808.4                                 ENDM
 1808                                   NEXT
 1808.1                         // ARMv7-M Thumb = .+5
 1808.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1808.3                         // ARMv6-M Thumb = .+4
 1808.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1808                                   NEXT1
 1808.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1808.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1808.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1808.4                         // ARMv6-M Thumb = .+4
 1808.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1808.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1808.7                                 ENDM
 1808.8                                 ENDM
 1808.9                                 ENDM
 1808.10                                ENDM
 1809                           
 1810                           
 1811                           //      DROP DROP:      ( n1 -- )
 1812                           //      Drop n1 from the stack.
 1813                           
 1814                            SECTION .text : CONST (2)
 1815                           DROP_NFA:
 1816    00000000 84                    DC8     0x84
 1817    00000001 44524F                DC8     'DRO'
 1818    00000004 D0                    DC8     'P'+0x80
 1819    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1820    00000008 ........              DC32    OVER_NFA
 1821                           DROP:
 1822    0000000C ........              DC32    .+5
 1823                            SECTION .text : CODE (2)
 1824                           #ifdef TOSCT
 1828                           #else // DROP:
 1829                           //        POP2t         // Opt to just do p
 1830    00000000 3F1D                  ADDS    p, p, #4
 1831                           
 1832                           #endif
 1833                                   NEXT
 1833.1                         // ARMv7-M Thumb = .+5
 1833.2  00000002 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1833.3                         // ARMv6-M Thumb = .+4
 1833.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1833                                   NEXT1
 1833.1  00000006 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1833.2  0000000A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1833.3  0000000E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1833.4                         // ARMv6-M Thumb = .+4
 1833.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1833.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1833.7                                 ENDM
 1833.8                                 ENDM
 1834                           
 1835                           
 1836                           //      SWAP SWAP:      ( nl n2 -- n2 n1 )
 1837                           //      Exchange the top two values On the stack.
 1838                           
 1839                            SECTION .text : CONST (2)
 1840                           SWAP_NFA:
 1841    00000000 84                    DC8     0x84
 1842    00000001 535741                DC8     'SWA'
 1843    00000004 D0                    DC8     'P'+0x80
 1844    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1845    00000008 ........              DC32    DROP_NFA
 1846                           SWAP:
 1847    0000000C ........              DC32    .+5
 1848                            SECTION .text : CODE (2)
 1849                           #ifdef TOSCT
 1853                           #else // SWAP:
 1854                                   POP2w           // n2
 1854.1  00000000 57F8042B              LDR     w, [p],#4
 1854.2                         //      LDR     w, [p]
 1854.3                         //      ADDS    p, p, #4
 1854.4                                 ENDM
 1855                                   POP2t           // n1
 1855.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 1855.2                         //#ifndef TOSCT
 1855.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 1855.4                         //#endif
 1855.5                         //      ADDS    p, p, #4
 1855.6                                 ENDM
 1856                           #endif
 1857                                   DPUSH           //  --  LSW MSW )
 1857                                   PUSHw   // push w to p, post decrement p
 1857.1  00000008 47F8042D              STR     w, [p, #-4]!
 1857.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 1857.3                         //      STR     w, [p]
 1857.4                                 ENDM
 1857                                   TPUSH
 1857                                   PUSHt   // push t to p, pre decrement p
 1857.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1857.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1857.3                         //      STR     t, [p]
 1857.4                                 ENDM
 1857                                   NEXT
 1857.1                         // ARMv7-M Thumb = .+5
 1857.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1857.3                         // ARMv6-M Thumb = .+4
 1857.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1857                                   NEXT1
 1857.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1857.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1857.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1857.4                         // ARMv6-M Thumb = .+4
 1857.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1857.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1857.7                                 ENDM
 1857.8                                 ENDM
 1857.9                                 ENDM
 1857.10                                ENDM
 1858                           
 1859                           
 1860                           //      DUP DUP:        ( n1 -- n1 n1 )
 1861                           //      Duplicate the value n1 on the stack.
 1862                           
 1863                            SECTION .text : CONST (2)
 1864                           DUP_NFA:
 1865    00000000 83                    DC8     0x83
 1866    00000001 4455                  DC8     'DU'
 1867    00000003 D0                    DC8     'P'+0x80
 1868                            ALIGNROM 2,0xFFFFFFFF
 1869    00000004 ........              DC32    SWAP_NFA
 1870                           DUP:
 1871    00000008 ........              DC32    .+5
 1872                            SECTION .text : CODE (2)
 1873                           //#ifdef TOSCT
 1874                           // NO NEED TO REFRESH t ?
 1875                           //#else DUP:
 1876                           // OPT by picking pops
 1877    00000000 3868                  LDR     t, [p]  //t_r0 p_r7
 1878                           //#endif
 1879                                   TPUSH   //// push t to p, pre decrement p
 1879                                   PUSHt   // push t to p, pre decrement p
 1879.1  00000002 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 1879.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 1879.3                         //      STR     t, [p]
 1879.4                                 ENDM
 1879                                   NEXT
 1879.1                         // ARMv7-M Thumb = .+5
 1879.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1879.3                         // ARMv6-M Thumb = .+4
 1879.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1879                                   NEXT1
 1879.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1879.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1879.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1879.4                         // ARMv6-M Thumb = .+4
 1879.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1879.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1879.7                                 ENDM
 1879.8                                 ENDM
 1879.9                                 ENDM
 1880                           
 1881                           //=============================== WORDCAT ====================================//
 1882                           //NOEXEC HEADERFORWORDCATEGORIES
 1883                           //      WC_STACK_NFA = Stack Stuff: CATEGORY
 1884                           
 1885                            SECTION .text : CONST (2)
 1886                           WC_STACK_NFA:
 1887    00000000 90                    DC8     0x80+4+12
 1888    00000001 0D0A                  DC8     0x0D, 0x0A
 1889    00000003 537461636B205         DC8     'Stack Stuff:'
                  3747566663A  
 1890    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1891    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1892    00000014 ........              DC32    DUP_NFA
 1893                           
 1894                           
 1895                           //      ANDBITS ANDBITS:        ( addr val -- )
 1896                           
 1897                            SECTION .text : CONST (2)
 1898                           ANDBITS_NFA:
 1899    00000000 87                    DC8     0x87
 1900    00000001 414E44424954          DC8     'ANDBIT'
 1901    00000007 D3                    DC8     'S'+0x80
 1902                            ALIGNROM 2,0xFFFFFFFF
 1903    00000008 ........              DC32    WC_STACK_NFA
 1904                           ANDBITS:
 1905    0000000C ........              DC32    .+5
 1906                            SECTION .text : CODE (2)
 1907                                   POPp2w          // val
 1907.1                                 // as in xeq token on ToS setup for exec
 1907.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1907.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1907.4                                 ENDM
 1908                                   POP2n           // addr
 1908.1  00000004 57F8041B              LDR     n, [p],#4
 1908.2                         //      LDR     n, [p]
 1908.3                         //      ADDS    p, p, #4
 1908.4                                 ENDM
 1909    00000008 0868                  LDR     t, [n]  // read [val]
 1910    0000000A 1040                  ANDS    t, t, w // modify val
 1911    0000000C 0860                  STR     t, [n]  // Write val
 1912                                   NEXT
 1912.1                         // ARMv7-M Thumb = .+5
 1912.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1912.3                         // ARMv6-M Thumb = .+4
 1912.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1912                                   NEXT1
 1912.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1912.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1912.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1912.4                         // ARMv6-M Thumb = .+4
 1912.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1912.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1912.7                                 ENDM
 1912.8                                 ENDM
 1913                           
 1914                           
 1915                           //      SETBITS SETBITS:        ( addr val -- ) OR val bits into addr.
 1916                           //      See also CLRBITS.
 1917                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1918                           
 1919                            SECTION .text : CONST (2)
 1920                           SETBITS_NFA:
 1921    00000000 87                    DC8     0x87
 1922    00000001 534554424954          DC8     'SETBIT'
 1923    00000007 D3                    DC8     'S'+0x80
 1924                            ALIGNROM 2,0xFFFFFFFF
 1925    00000008 ........              DC32    ANDBITS_NFA
 1926                           SETBITS:
 1927    0000000C ........              DC32    .+5
 1928                            SECTION .text : CODE (2)
 1929                                   POPp2w          // val
 1929.1                                 // as in xeq token on ToS setup for exec
 1929.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1929.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1929.4                                 ENDM
 1930                                   POP2n           // addr
 1930.1  00000004 57F8041B              LDR     n, [p],#4
 1930.2                         //      LDR     n, [p]
 1930.3                         //      ADDS    p, p, #4
 1930.4                                 ENDM
 1931    00000008 0868                  LDR     t, [n]  // read[val]
 1932    0000000A 1043                  ORRS    t, t, w // modify val
 1933    0000000C 0860                  STR     t, [n]  // Write val
 1934                                   NEXT
 1934.1                         // ARMv7-M Thumb = .+5
 1934.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1934.3                         // ARMv6-M Thumb = .+4
 1934.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1934                                   NEXT1
 1934.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1934.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1934.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1934.4                         // ARMv6-M Thumb = .+4
 1934.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1934.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1934.7                                 ENDM
 1934.8                                 ENDM
 1935                           
 1936                           
 1937                           //      CLRBITS CLRBITS:        ( addr val -- )
 1938                           //      XOR val bits into addr. See also SETBITS.
 1939                           //      Preserves bits at addr - useful for ARM SoC initialization.
 1940                           
 1941                            SECTION .text : CONST (2)
 1942                           CLRBITS_NFA:
 1943    00000000 87                    DC8     0x87
 1944    00000001 434C52424954          DC8     'CLRBIT'
 1945    00000007 D3                    DC8     'S'+0x80
 1946                            ALIGNROM 2,0xFFFFFFFF
 1947    00000008 ........              DC32    SETBITS_NFA
 1948                           CLRBITS:
 1949    0000000C ........              DC32    .+5
 1950                            SECTION .text : CODE (2)
 1951                                   POPp2w                  // val
 1951.1                                 // as in xeq token on ToS setup for exec
 1951.2  00000000 57F8042B              LDR     w, [p], #4      ; xeq token at ToS
 1951.3                         //      LDM     p!, {w} // fetch memory p points to into {w}, inc p
 1951.4                                 ENDM
 1952                                   POP2n                   // addr
 1952.1  00000004 57F8041B              LDR     n, [p],#4
 1952.2                         //      LDR     n, [p]
 1952.3                         //      ADDS    p, p, #4
 1952.4                                 ENDM
 1953    00000008 0868                  LDR     t, [n]          // read [val]
 1954    0000000A 9043                  BICS    t, t, w         // modify val  - AND-NOT
 1955    0000000C 0860                  STR     t, [n]          // write val
 1956                                   NEXT
 1956.1                         // ARMv7-M Thumb = .+5
 1956.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1956.3                         // ARMv6-M Thumb = .+4
 1956.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1956                                   NEXT1
 1956.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1956.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1956.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1956.4                         // ARMv6-M Thumb = .+4
 1956.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1956.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1956.7                                 ENDM
 1956.8                                 ENDM
 1957                           
 1958                           
 1959                           //      CMOVE CMOVE:    ( from to count -- )
 1960                           //      Move the specified quantity of bytes beginning at address from to
 1961                           //      address to. The contents of address from is moved first proceeding
 1962                           //      toward high memory. Further specification is necessary on word
 1963                           //      addressing computers.
 1964                           
 1965                            SECTION .text : CONST (2)
 1966                           CMOVE_NFA:
 1967    00000000 85                    DC8     0x85
 1968    00000001 434D4F56              DC8     'CMOV'
 1969    00000005 C5                    DC8     'E'+0x80
 1970    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1971    00000008 ........              DC32    CLRBITS_NFA
 1972                           CMOVE:
 1973    0000000C ........              DC32    .+5
 1974                            SECTION .text : CODE (2)
 1975                                   POP2n //    ldr n, [p],#4      //COUNT
 1975.1  00000000 57F8041B              LDR     n, [p],#4
 1975.2                         //      LDR     n, [p]
 1975.3                         //      ADDS    p, p, #4
 1975.4                                 ENDM
 1976                                   POP2w //    ldr w, [p],#4      //DEST
 1976.1  00000004 57F8042B              LDR     w, [p],#4
 1976.2                         //      LDR     w, [p]
 1976.3                         //      ADDS    p, p, #4
 1976.4                                 ENDM
 1977                                   POP2x //    ldr x, [p],#4      //SOURCE
 1977.1  00000008 57F8043B              LDR     x, [p],#4
 1977.2                         //      LDR     x, [p]
 1977.3                         //      ADDS    p, p, #4
 1977.4                                 ENDM
 1978    0000000C 0029                  CMP     n, #0
 1979    0000000E 07D0                  BEQ     CM2
 1980                           CM1:
 1981                           //not for THUMB
 1982                           //strcpy  LDRB R2, [R1], #1
 1983                           //        STRB R2, [R0], #1
 1984                           //        TST R2, R2      // repeat if R2 is nonzero
 1985                           //        BNE strcpy
 1986    00000010 1878                  LDRB    t, [x]
 1987    00000012 1070                  STRB    t, [w]
 1988    00000014 491E                  SUBS    n, n, #1
 1989    00000016 0029                  CMP     n, #0
 1990    00000018 02D0                  BEQ     CM2
 1991                           
 1992    0000001A 521C                  ADDS    w, w, #1
 1993    0000001C 5B1C                  ADDS    x, x, #1
 1994    0000001E F7D1                  BNE     CM1
 1995                           CM2:
 1996                           #ifdef TOSCT
 1998                           #endif
 1999                                   NEXT
 1999.1                         // ARMv7-M Thumb = .+5
 1999.2  00000020 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 1999.3                         // ARMv6-M Thumb = .+4
 1999.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 1999                                   NEXT1
 1999.1  00000024 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 1999.2  00000028 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 1999.3  0000002C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 1999.4                         // ARMv6-M Thumb = .+4
 1999.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1999.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1999.7                                 ENDM
 1999.8                                 ENDM
 2000                           
 2001                           
 2002                           //      FILL FILL:      ( addr quan b -- )
 2003                           //      Fill memory at the address with the specified quantity of bytes b.
 2004                           
 2005                            SECTION .text : CONST (2)
 2006                           FILL_NFA:
 2007    00000000 84                    DC8     0x84
 2008    00000001 46494C                DC8     'FIL'
 2009    00000004 CC                    DC8     'L'+0x80
 2010    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2011    00000008 ........              DC32    CMOVE_NFA
 2012                           FILL:
 2013    0000000C ........              DC32    .+5
 2014                            SECTION .text : CODE (2)
 2015                                   POP2t                   // Fill CHAR
 2015.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2015.2                         //#ifndef TOSCT
 2015.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2015.4                         //#endif
 2015.5                         //      ADDS    p, p, #4
 2015.6                                 ENDM
 2016                                   POP2n                   // Fill COUNT
 2016.1  00000004 57F8041B              LDR     n, [p],#4
 2016.2                         //      LDR     n, [p]
 2016.3                         //      ADDS    p, p, #4
 2016.4                                 ENDM
 2017                                   POP2w                   // Beginning ADDR
 2017.1  00000008 57F8042B              LDR     w, [p],#4
 2017.2                         //      LDR     w, [p]
 2017.3                         //      ADDS    p, p, #4
 2017.4                                 ENDM
 2018    0000000C 0029                  CMP     n, #0
 2019    0000000E 04D0                  BEQ     FEND            // Count is zero
 2020    00000010 8B18                  ADDS    x, n, w
 2021                           FLOOP:
 2022    00000012 1070                  STRB    t, [w]
 2023    00000014 521C                  ADDS    w, w, #1
 2024    00000016 9A42                  CMP     w, x
 2025    00000018 FBD1                  BNE     FLOOP
 2026                           FEND:
 2027                           #ifdef TOSCT
 2029                           #endif
 2030                                   NEXT
 2030.1                         // ARMv7-M Thumb = .+5
 2030.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2030.3                         // ARMv6-M Thumb = .+4
 2030.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2030                                   NEXT1
 2030.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2030.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2030.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2030.4                         // ARMv6-M Thumb = .+4
 2030.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2030.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2030.7                                 ENDM
 2030.8                                 ENDM
 2031                           
 2032                           
 2033                           //      ERASE ERASE:    ( addr n -- )
 2034                           //      Clear a region of memory to zero from addr over n addresses.
 2035                           
 2036                            SECTION .text : CONST (2)
 2037                           ERASE_NFA:
 2038    00000000 85                    DC8     0x85
 2039    00000001 45524153              DC8     'ERAS'
 2040    00000005 C5                    DC8     'E'+0x80
 2041    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2042    00000008 ........              DC32    FILL_NFA
 2043                           ERASE:
 2044    0000000C ........              DC32    DOCOL
 2045    00000010 ........              DC32    ZERO
 2046    00000014 ........              DC32    FILL
 2047    00000018 ........              DC32    SEMIS
 2048                           
 2049                           
 2050                           //      BLANKS BLANKS:  ( addr count -- )
 2051                           //      Fill an area of memory beginning at addr with blanks (0x20).
 2052                           
 2053                            SECTION .text : CONST (2)
 2054                           BLANKS_NFA:
 2055    00000000 86                    DC8     0x86
 2056    00000001 424C414E4B            DC8     'BLANK'
 2057    00000006 D3                    DC8     'S'+0x80
 2058    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2059    00000008 ........              DC32    ERASE_NFA
 2060                           BLANKS:
 2061    0000000C ........              DC32    DOCOL
 2062    00000010 ........              DC32    BLANK
 2063    00000014 ........              DC32    FILL
 2064    00000018 ........              DC32    SEMIS
 2065                           
 2066                           
 2067                           //      +! PSTORE:      ( n addr -- )
 2068                           //      Add n to the value at the address.
 2069                           //      Pronounced Plus Store
 2070                           
 2071                            SECTION .text : CONST (2)
 2072                           PSTORE_NFA:
 2073    00000000 82                    DC8     0x82
 2074    00000001 2B                    DC8     '+'
 2075    00000002 A1                    DC8     '!'+0x80
 2076    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2077    00000004 ........              DC32    BLANKS_NFA
 2078                           PSTORE:
 2079    00000008 ........              DC32    .+5
 2080                            SECTION .text : CODE (2)
 2081                                   POP2n                   // ADDRESS
 2081.1  00000000 57F8041B              LDR     n, [p],#4
 2081.2                         //      LDR     n, [p]
 2081.3                         //      ADDS    p, p, #4
 2081.4                                 ENDM
 2082                           #ifdef TOSCT
 2084                           #endif
 2085                                   POP2t                   // INCREMENT
 2085.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 2085.2                         //#ifndef TOSCT
 2085.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2085.4                         //#endif
 2085.5                         //      ADDS    p, p, #4
 2085.6                                 ENDM
 2086    00000008 0A68                  LDR     w, [n]
 2087    0000000A 8018                  ADDS    t, t, w
 2088    0000000C 0860                  STR     t, [n]
 2089                                   NEXT
 2089.1                         // ARMv7-M Thumb = .+5
 2089.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2089.3                         // ARMv6-M Thumb = .+4
 2089.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2089                                   NEXT1
 2089.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2089.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2089.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2089.4                         // ARMv6-M Thumb = .+4
 2089.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2089.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2089.7                                 ENDM
 2089.8                                 ENDM
 2090                           
 2091                           
 2092                           //      @ AT:   ( addr -- n )
 2093                           //      Read 32 bit contents of address to TOS.
 2094                           //      Pronounced Fetch, as in Fetch word at addr.
 2095                           
 2096                            SECTION .text : CONST (2)
 2097                           AT_NFA:
 2098    00000000 81                    DC8     0x81
 2099    00000001 C0                    DC8     '@'+0x80 //C0H
 2100    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2101                           //      DC32    TOGGLE_NFA
 2102    00000004 ........              DC32    PSTORE_NFA
 2103                           AT:
 2104    00000008 ........              DC32    .+5
 2105                            SECTION .text : CODE (2)
 2106                           //#ifdef TOSCT
 2107                           //        LDR     t, [t]
 2108                           //        STR     t, [p]
 2109                           //        NEXT
 2110                           //#else AT:
 2111                                   POP2n
 2111.1  00000000 57F8041B              LDR     n, [p],#4
 2111.2                         //      LDR     n, [p]
 2111.3                         //      ADDS    p, p, #4
 2111.4                                 ENDM
 2112    00000004 0868                  LDR     t, [n]
 2113                                   TPUSH
 2113                                   PUSHt   // push t to p, pre decrement p
 2113.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 2113.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 2113.3                         //      STR     t, [p]
 2113.4                                 ENDM
 2113                                   NEXT
 2113.1                         // ARMv7-M Thumb = .+5
 2113.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2113.3                         // ARMv6-M Thumb = .+4
 2113.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2113                                   NEXT1
 2113.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2113.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2113.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2113.4                         // ARMv6-M Thumb = .+4
 2113.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2113.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2113.7                                 ENDM
 2113.8                                 ENDM
 2113.9                                 ENDM
 2114                           //#endif
 2115                                   
 2116                           //      C@ CAT: ( addr -- b )
 2117                           //      Leave the 8 bit contents of addr on the stack.
 2118                           //      Pronounced "Char Fetch", as in Fetch byte at addr.
 2119                           
 2120                            SECTION .text : CONST (2)
 2121                           CAT_NFA:
 2122    00000000 82                    DC8     0x82
 2123    00000001 43                    DC8     'C'
 2124    00000002 C0                    DC8     '@'+0x80 //C0H
 2125    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2126    00000004 ........              DC32    AT_NFA
 2127                           CAT:
 2128    00000008 ........              DC32    .+5
 2129                            SECTION .text : CODE (2)
 2130                                   POP2n
 2130.1  00000000 57F8041B              LDR     n, [p],#4
 2130.2                         //      LDR     n, [p]
 2130.3                         //      ADDS    p, p, #4
 2130.4                                 ENDM
 2131    00000004 0878                  LDRB    t, [n]
 2132                                   TPUSH
 2132                                   PUSHt   // push t to p, pre decrement p
 2132.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 2132.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 2132.3                         //      STR     t, [p]
 2132.4                                 ENDM
 2132                                   NEXT
 2132.1                         // ARMv7-M Thumb = .+5
 2132.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2132.3                         // ARMv6-M Thumb = .+4
 2132.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2132                                   NEXT1
 2132.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2132.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2132.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2132.4                         // ARMv6-M Thumb = .+4
 2132.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2132.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2132.7                                 ENDM
 2132.8                                 ENDM
 2132.9                                 ENDM
 2133                           
 2134                           
 2135                           //      ! STORE:        ( n addr -- )
 2136                           //      Store n at address. Pronounced "Store".
 2137                           
 2138                            SECTION .text : CONST (2)
 2139                           STORE_NFA:
 2140    00000000 81                    DC8     0x81
 2141    00000001 A1                    DC8     '!'+0x80
 2142    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2143    00000004 ........              DC32    CAT_NFA
 2144                           STORE:
 2145    00000008 ........              DC32    .+5
 2146                            SECTION .text : CODE (2)
 2147                                   POP2t           // ADDR
 2147.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2147.2                         //#ifndef TOSCT
 2147.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2147.4                         //#endif
 2147.5                         //      ADDS    p, p, #4
 2147.6                                 ENDM
 2148                                   POP2n           // DATA
 2148.1  00000004 57F8041B              LDR     n, [p],#4
 2148.2                         //      LDR     n, [p]
 2148.3                         //      ADDS    p, p, #4
 2148.4                                 ENDM
 2149    00000008 0160                  STR     n, [t]
 2150                                   NEXT
 2150.1                         // ARMv7-M Thumb = .+5
 2150.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2150.3                         // ARMv6-M Thumb = .+4
 2150.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2150                                   NEXT1
 2150.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2150.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2150.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2150.4                         // ARMv6-M Thumb = .+4
 2150.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2150.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2150.7                                 ENDM
 2150.8                                 ENDM
 2151                           
 2152                           
 2153                           //      C! CSTORE:      ( n addr -- )
 2154                           //      Store LS 8 bits of n at address. Pronounced "Char Store".
 2155                           
 2156                            SECTION .text : CONST (2)
 2157                           CSTORE_NFA:
 2158    00000000 82                    DC8     0x82
 2159    00000001 43                    DC8     'C'
 2160    00000002 A1                    DC8     '!'+0x80
 2161    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2162    00000004 ........              DC32    STORE_NFA
 2163                           CSTORE:
 2164    00000008 ........              DC32    .+5
 2165                            SECTION .text : CODE (2)
 2166                                   POP2t
 2166.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 2166.2                         //#ifndef TOSCT
 2166.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 2166.4                         //#endif
 2166.5                         //      ADDS    p, p, #4
 2166.6                                 ENDM
 2167                                   POP2n
 2167.1  00000004 57F8041B              LDR     n, [p],#4
 2167.2                         //      LDR     n, [p]
 2167.3                         //      ADDS    p, p, #4
 2167.4                                 ENDM
 2168    00000008 0170                  STRB    n, [t]
 2169                                   NEXT
 2169.1                         // ARMv7-M Thumb = .+5
 2169.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 2169.3                         // ARMv6-M Thumb = .+4
 2169.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 2169                                   NEXT1
 2169.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 2169.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 2169.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 2169.4                         // ARMv6-M Thumb = .+4
 2169.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2169.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2169.7                                 ENDM
 2169.8                                 ENDM
 2170                           
 2171                           
 2172                           //=============================== WORDCAT ====================================//
 2173                           //NOEXEC HEADERFORWORDCATEGORIES
 2174                           //      WC_RWMEMORY_NFA = Read and Write Memory With: CATEGORY
 2175                           
 2176                            SECTION .text : CONST (2)
 2177                           WC_RWMEMORY_NFA:
 2178    00000000 9F                    DC8     0x80+31
 2179    00000001 0D0A                  DC8     0x0D, 0x0A
 2180    00000003 5265616420616         DC8     'Read and Write Memory With:'
                  E642057726974
                  65204D656D6F7
                  2792057697468
                  3A           
 2181    0000001E 0D8A                  DC8     0x0D, 0x0A+0x80
 2182                            ALIGNROM 2,0xFFFFFFFF
 2183    00000020 ........              DC32    CSTORE_NFA
 2184                           
 2185                           
 2186                           //      ] RBRAC:        ( -- )
 2187                           //      Resume compilation, by STATE back to 0xC0 (zero is interpreting)
 2188                           //      0xC0 STATE  used in INTERPRET to execute Immediate words while compiling
 2189                           //      See [.
 2190                           
 2191                            SECTION .text : CONST (2)
 2192                           RBRAC_NFA:
 2193    00000000 81                    DC8     0x81
 2194    00000001 DD                    DC8     ']'+0x80
 2195    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2196                           //      DC32    SMUDGE_NFA
 2197    00000004 ........              DC32    WC_RWMEMORY_NFA
 2198                           RBRAC:
 2199    00000008 ........              DC32    DOCOL
 2200    0000000C ........C0000         DC32    strva, 0xC0, CSTATE
                  000........  
 2201    00000018 ........              DC32    SEMIS
 2202                           
 2203                           
 2204                           //      [ LBRAC:        ( -- ) IMMEDIATE
 2205                           //      Used in a colon-definition in form
 2206                           //              xxx    [  words   ]    more
 2207                           //      Suspend compilation by setting STATE to zero (0xC0 is compiling).
 2208                           //      The words after [ are executed, not compiled. This allows calculation
 2209                           //      or compilation exceptions before resuming compilation with ] .
 2210                           //      See LITERAL and ]
 2211                           
 2212                            SECTION .text : CONST (2)
 2213                           LBRAC_NFA:
 2214    00000000 C1                    DC8     0x0C1
 2215    00000001 DB                    DC8     '['+0x80
 2216    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2217    00000004 ........              DC32    RBRAC_NFA
 2218                           LBRAC:
 2219    00000008 ........              DC32    DOCOL
 2220    0000000C ........00000         DC32    strva, 0, CSTATE
                  000........  
 2221    00000018 ........              DC32    SEMIS
 2222                           
 2223                           
 2224                           //      [COMPILE] BCOMP:        ( -- ) IMMEDIATE
 2225                           //      Used in a colon-definition in form:
 2226                           //              :  xxx    [COMPILE]   immediate_word   ;
 2227                           //      [COMPILE] will force the compilation of an IMMEDIATE WORD
 2228                           //      that would otherwise execute during compilation. The above example
 2229                           //      will select the FORTH vocabulary then xxx executes, rather than at
 2230                           //      compile time.
 2231                           
 2232                            SECTION .text : CONST (2)
 2233                           BCOMP_NFA:
 2234    00000000 C9                    DC8     0x0C9
 2235    00000001 5B434F4D50494         DC8     '[COMPILE'
                  C45          
 2236    00000009 DD                    DC8     ']'+0x80
 2237    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2238    0000000C ........              DC32    LBRAC_NFA
 2239                           BCOMP:
 2240    00000010 ........              DC32    DOCOL
 2241    00000014 ........              DC32    DFIND   // noop there for TIB entry
 2242                           //      -FIND \ --- pfa len tf (found) \ --- ff (not found)
 2243    00000018 ........              DC32    ZEQU
 2244    0000001C .............         DC32    LIT, msg_qstack
                  ...          
 2245    00000024 ........              DC32    QERROR    // \ f nullstr-addr --
 2246    00000028 ........              DC32    DROP
 2247    0000002C ........              DC32    CFA
 2248    00000030 ........              DC32    COMMA   // alighned, INCREMENTS DP REFLECTED by HERE
 2249    00000034 ........              DC32    SEMIS
 2250                           
 2251                           
 2252                           //      DLITERAL DLITERAL:      ( d -- d ) IMMEDIATE
 2253                           //                              ( d -- )   (compiling)
 2254                           //      If compiling, compile a stack double number into a literal. Later
 2255                           //      execution of the definition containing the literal will push it to
 2256                           //      the stack. If executing, the number will remain on the stack.
 2257                           //      : xxx    [ calculate ]  DLITERAL  ; //
 2258                           
 2259                            SECTION .text : CONST (2)
 2260                           DLITERAL_NFA:
 2261    00000000 C8                    DC8     0x0C8
 2262    00000001 444C495445524         DC8     'DLITERA'
                  1            
 2263    00000008 CC                    DC8     'L'+0x80
 2264    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2265    0000000C ........              DC32    BCOMP_NFA
 2266                           DLITERAL:
 2267    00000010 ........              DC32    DOCOL
 2268    00000014 ........              DC32    STATE_SV
 2269    00000018 ........              DC32    AT
 2270    0000001C ........              DC32    ZBRAN   // IF
 2271    00000020 10000000              DC32     DLIT1-.
 2272                           
 2273    00000024 ........              DC32    SWAP
 2274    00000028 ........              DC32    LITERAL
 2275    0000002C ........              DC32    LITERAL // endif
 2276                           DLIT1:
 2277    00000030 ........              DC32    SEMIS
 2278                           
 2279                           
 2280                           //      LITERAL LITERAL:        ( n -- ) IMMEDIATE
 2281                           //      If compiling, then compile the stack value n as a 32 bit literal.
 2282                           //      This definition is immediate so that it will execute during a colon
 2283                           //      definition. The intended use is:
 2284                           //      : xxx    [ calculate ]  LITERAL  ; //
 2285                           //      Compilation is suspended for the compile time calculation of value.
 2286                           //      Compilation is resumed and LITERAL compiles this value.
 2287                           
 2288                            SECTION .text : CONST (2)
 2289                           LITERAL_NFA:
 2290    00000000 C7                    DC8     0x0C7
 2291    00000001 4C4954455241          DC8     'LITERA'
 2292    00000007 CC                    DC8     'L'+0x80
 2293                            ALIGNROM 2,0xFFFFFFFF
 2294    00000008 ........              DC32    DLITERAL_NFA
 2295                           LITERAL:
 2296    0000000C ........              DC32    DOCOL
 2297    00000010 ........              DC32    STATE_SV
 2298    00000014 ........              DC32    AT
 2299    00000018 ........              DC32    ZBRAN           // If not compiling
 2300    0000001C 10000000              DC32     LITE1-.        // go here
 2301                           
 2302    00000020 ........              DC32    COMP            // Compile
 2303    00000024 ........              DC32    LIT             // Literal
 2304    00000028 ........              DC32    COMMA           // Then COMPILE THE LITERAL VALUE
 2305                           LITE1:
 2306    0000002C ........              DC32    SEMIS
 2307                           
 2308                           
 2309                           //      #> EDIGS:       ( d=(LSW MSW) -- addr count )
 2310                           //      Terminates numeric output conversion by dropping dnum,
 2311                           //      leaving the text address and character count suitable for type.
 2312                           
 2313                            SECTION .text : CONST (2)
 2314                           EDIGS_NFA:
 2315    00000000 82                    DC8     0x82
 2316    00000001 23                    DC8     '#'
 2317    00000002 BE                    DC8     '>'+0x80
 2318    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2319    00000004 ........              DC32    LITERAL_NFA
 2320                           EDIGS:
 2321    00000008 ........              DC32    DOCOL
 2322    0000000C ........              DC32    DROP
 2323    00000010 ........              DC32    DROP
 2324    00000014 ........              DC32    HLD_SV
 2325    00000018 ........              DC32    AT
 2326    0000001C ........              DC32    PAD_SV
 2327    00000020 ........              DC32    OVER
 2328    00000024 ........              DC32    SUBB
 2329    00000028 ........              DC32    SEMIS
 2330                           
 2331                           
 2332                           //      HOLD HOLD:      ( c -- )
 2333                           //      Used between <# and #> to insert an ascii character into a pictured
 2334                           //      numeric output string.
 2335                           //      e.g. 0x2E HOLD will place a decimal point.
 2336                           
 2337                            SECTION .text : CONST (2)
 2338                           HOLD_NFA:
 2339    00000000 84                    DC8     0x84
 2340    00000001 484F4C                DC8     'HOL'
 2341    00000004 C4                    DC8     'D'+0x80
 2342    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2343    00000008 ........              DC32    EDIGS_NFA
 2344                           HOLD:
 2345    0000000C ........              DC32    DOCOL
 2346    00000010 ........FFFFF         DC32    LIT,-1
                  FFF          
 2347    00000018 ........              DC32    HLD_SV
 2348    0000001C ........              DC32    PSTORE
 2349    00000020 ........              DC32    HLD_SV
 2350    00000024 ........              DC32    AT
 2351    00000028 ........              DC32    CSTORE
 2352    0000002C ........              DC32    SEMIS
 2353                           
 2354                           
 2355                           //      SIGN SIGN:      ( n d=<LSW MSW> -- d=<LSW MSW> )
 2356                           //      Place an ascii "-" sign just before a converted numeric output
 2357                           //      string in the text output buffer when n is negative. n is discarded
 2358                           //      but double number dnum is maintained. Must be used between <# and #>.
 2359                           
 2360                            SECTION .text : CONST (2)
 2361                           SIGN_NFA:
 2362    00000000 84                    DC8     0x84
 2363    00000001 534947                DC8     'SIG'
 2364    00000004 CE                    DC8     'N'+0x80
 2365    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2366    00000008 ........              DC32    HOLD_NFA
 2367                           SIGN:
 2368    0000000C ........              DC32    DOCOL
 2369    00000010 ........              DC32    ROT
 2370    00000014 ........              DC32    ZLESS
 2371    00000018 ........              DC32    ZBRAN           // If
 2372    0000001C 10000000              DC32     SIGN1-.
 2373                           
 2374    00000020 ........2D000         DC32    LIT, '-'        // 0x2D
                  000          
 2375    00000028 ........              DC32    HOLD            // Endif
 2376                           SIGN1:
 2377    0000002C ........              DC32    SEMIS
 2378                           
 2379                           
 2380                           //      #S DIGS:        ( d1=<LSW MSW> -- d2=<LSW MSW> )
 2381                           //      Generates ascii text in the text output buffer, by the use of #,
 2382                           //      until a zero double number d2 results.
 2383                           //      Used between <# and #>.
 2384                           //      EACH NUMBER = BASE*number+(character-'0')
 2385                           
 2386                            SECTION .text : CONST (2)
 2387                           DIGS_NFA:
 2388    00000000 82                    DC8     0x82
 2389    00000001 23                    DC8     '#'
 2390    00000002 D3                    DC8     'S'+0x80
 2391    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2392    00000004 ........              DC32    SIGN_NFA
 2393                           DIGS:
 2394    00000008 ........              DC32    DOCOL
 2395                           DIGS1:                          // Begin generating ascii chars by DIG
 2396    0000000C ........              DC32    DIG             //\ d1=<LSW MSW> -- d2=QUO=<LSW MSW>
 2397    00000010 ........              DC32    OVER
 2398    00000014 ........              DC32    OVER
 2399    00000018 ........              DC32    OR
 2400    0000001C ........              DC32    ZEQU
 2401    00000020 ........              DC32    ZBRAN           //UNTIL
 2402    00000024 E8FFFFFF              DC32     DIGS1-.
 2403    00000028 ........              DC32    SEMIS
 2404                           
 2405                           
 2406                           //      # DIG:  ( d1=<LSW MSW> -- d2=QUO=<LSW MSW> ) BASE MUST BE SET!
 2407                           //      Generate from a double number d1, the next ascii character which is
 2408                           //      placed in an output string. Result d2 is the quotient after division
 2409                           //      by base, and is maintained for further processing.
 2410                           //      Used between <# and #>.
 2411                           //      See #S.
 2412                           //      EACH NUMBER = BASE*number+(character-'0')
 2413                           
 2414                            SECTION .text : CONST (2)
 2415                           DIG_NFA:
 2416    00000000 81                    DC8     0x81
 2417    00000001 A3                    DC8     '#'+0x80
 2418    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2419    00000004 ........              DC32    DIGS_NFA
 2420                           DIG:
 2421    00000008 ........              DC32    DOCOL
 2422    0000000C ........              DC32    BASE_SV         // EX 0 1 0
 2423    00000010 ........              DC32    AT              // -- 0 1 0 A
 2424    00000014 ........              DC32    MSMOD           // -- 0 1 0 0
 2425    00000018 ........              DC32    ROT             // -- 0 0 0 1
 2426    0000001C ........09000         DC32    LIT,9
                  000          
 2427    00000024 ........              DC32    OVER
 2428    00000028 ........              DC32    LESSTHAN
 2429    0000002C ........              DC32    ZBRAN           // If
 2430    00000030 10000000              DC32     DIG1-.
 2431                           
 2432    00000034 ........07000         DC32    LIT,7
                  000          
 2433    0000003C ........              DC32    PLUS            // Endif
 2434                           DIG1:
 2435    00000040 ........30000         DC32    LIT, 0x30
                  000          
 2436    00000048 ........              DC32    PLUS
 2437    0000004C ........              DC32    HOLD
 2438    00000050 ........              DC32    SEMIS
 2439                           
 2440                           
 2441                           //      <# BDIGS:       ( -- )
 2442                           //      Setup for pictured numeric output formatting using the words:
 2443                           //              <# # #S SIGN HOLD #>
 2444                           //      The conversion is done on a double number producing text at Pad
 2445                           
 2446                            SECTION .text : CONST (2)
 2447                           BDIGS_NFA:
 2448    00000000 82                    DC8     0x82
 2449    00000001 3C                    DC8     '<'
 2450    00000002 A3                    DC8     '#'+0x80
 2451    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2452    00000004 ........              DC32    DIG_NFA
 2453                           BDIGS:
 2454    00000008 ........              DC32    DOCOL
 2455    0000000C .............         DC32    strva, PAD, NHLD
                  ...........  
 2456    00000018 ........              DC32    SEMIS
 2457                           
 2458                           
 2459                           //      DOES> DOES:     ( pfa -- ) MODIFIED:
 2460                           //      A word which defines the run-time action within a high-level
 2461                           //      defining word. DOES> alters the code field and first parameter of
 2462                           //      the new word to execute the sequence of compiled word addresses
 2463                           //      following DOES>. Used in combination with <BUILDS. When the DOES>
 2464                           //      part executes it begins with the address of the first parameter of
 2465                           //      the new word on the stack. This allows interpretation using this
 2466                           //      area or its contents. Typical uses include the Forth assembler,
 2467                           //      multidimensional arrays, and compiler generation.
 2468                           
 2469                            SECTION .text : CONST (2)
 2470                           DOES_NFA:
 2471    00000000 85                    DC8     0x85
 2472    00000001 444F4553              DC8     'DOES'
 2473    00000005 BE                    DC8     '>'+0x80
 2474    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2475    00000008 ........              DC32    BDIGS_NFA
 2476                           DOES:
 2477    0000000C ........              DC32    DOCOL
 2478    00000010 ........              DC32    RFROM   // Get the addr of the first word after DOES>
 2479    00000014 ........              DC32    LATEST  // ( -- addr ) nfa OF the current <creator> word
 2480    00000018 ........              DC32    PFA     // Use the pfa to store a run-time cfa
 2481    0000001C .............         DC32    DUP, CFA
                  ...          
 2482    00000024 .............         DC32    LIT, CREATE_DOES_GOTO
                  ...          
 2483    0000002C .............         DC32    SWAP, STORE     // STORE GOTO
                  ...          
 2484    00000034 ........              DC32    STORE   // Store the run-time cfa as 1rst pfa Parameter.
 2485    00000038 ........              DC32    SEMIS
 2486                           
 2487                           
 2488                           //      <BUILDS BUILDS: ( -- )  MODIFIED: See CREATE and DOES>
 2489                           //      Used within a colon-definition
 2490                           //              CCcc  <BUILDS  ...  DOES>     ...
 2491                           //      Each time CCcc is executed, <BUILDS defines a new word with a
 2492                           //      high-level execution proceedure. Executing CCcc in the form
 2493                           //              CCcc nnnn
 2494                           //      uses <BUILDS to create a dictionary entry for nnnn with a call to
 2495                           //      the DOES> part for nnnn. When nnnn is later executed, it has the
 2496                           //      address of its parameter area on the stack and executes the words
 2497                           //      after DOES> in CCcc. <BUILDS and DOES> allow runtime proceedures to
 2498                           //      written in high-level code.
 2499                           
 2500                            SECTION .text : CONST (2)
 2501                           BUILDS_NFA:
 2502    00000000 87                    DC8     0x87
 2503    00000001 3C4255494C44          DC8     '<BUILD'
 2504    00000007 D3                    DC8     'S'+0x80
 2505                            ALIGNROM 2,0xFFFFFFFF
 2506    00000008 ........              DC32    DOES_NFA
 2507                           BUILDS:
 2508    0000000C ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 2509    00000010 ........              DC32    CREATE                  // CREATE's A CON POINTING TO IT'S PFA
 2510    00000014 ........              DC32    SEMIS
 2511                           
 2512                           
 2513                           //      +LOOP PLOOP:    ( n1 -- ) IMMEDIATE
 2514                           //                      ( addr n2 -- ) COMPILE
 2515                           //      At run time, DO begins a sequence with repetitive execution
 2516                           //      controlled by a loop limit n1 and an index with initial value n2. DO
 2517                           //      removes these from the stack. Upon reaching LOOP the index is
 2518                           //      incremented by one.
 2519                           //      Until the new index equals or exceeds the limit, execution loops
 2520                           //      back to just after DO// otherwise the loop parameters are discarded
 2521                           //      and execution continues ahead. Both n1 and n2 are determined at
 2522                           //      run-time and may be the result of other operations.
 2523                           //      Within a loop 'I' will copy the current value of the index to the
 2524                           //      stack. See I, LOOP, +LOOP, LEAVE.
 2525                           //
 2526                           //      When compiling within the colon definition, DO compiles (DO), leaves
 2527                           //      the following address addr and n for later error checking.
 2528                           
 2529                            SECTION .text : CONST (2)
 2530                           PLOOP_NFA:
 2531    00000000 C5                    DC8     0x0C5
 2532    00000001 2B4C4F4F              DC8     '+LOO'
 2533    00000005 D0                    DC8     'P'+0x80
 2534    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2535    00000008 ........              DC32    BUILDS_NFA
 2536                           PLOOP:
 2537    0000000C ........              DC32    DOCOL
 2538    00000010 ........              DC32    THREE
 2539    00000014 ........              DC32    QPAIR
 2540    00000018 ........              DC32    COMP
 2541    0000001C ........              DC32    XPLOOP
 2542    00000020 ........              DC32    BACK
 2543    00000024 ........              DC32    SEMIS
 2544                           
 2545                           
 2546                           //      LOOP LOOP:      ( addr n -- ) IMMEDIATE
 2547                           //      Occurs in a colon-definition in form:
 2548                           //              DO ... LOOP
 2549                           //      At run-time, LOOP selectively controls branching back to the
 2550                           //      corresponding DO based on the loop index and limit. The loop index
 2551                           //      is incremented by one and compared to the limit. The branch back to
 2552                           //      DO occurs until the index equals or exceeds the limit, then
 2553                           //      the parameters are discarded and execution continues ahead.
 2554                           //
 2555                           //      At compile-time. LOOP compiles (LOOP) and uses addr to calculate an
 2556                           //      offset to DO. n is used for error testing.
 2557                           
 2558                            SECTION .text : CONST (2)
 2559                           LOOP_NFA:
 2560    00000000 C4                    DC8     0x0C4
 2561    00000001 4C4F4F                DC8     'LOO'
 2562    00000004 D0                    DC8     'P'+0x80
 2563    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2564    00000008 ........              DC32    PLOOP_NFA
 2565                           LOOP:
 2566    0000000C ........              DC32    DOCOL
 2567    00000010 ........              DC32    THREE
 2568    00000014 ........              DC32    QPAIR
 2569    00000018 ........              DC32    COMP
 2570    0000001C ........              DC32    XLOOP
 2571    00000020 ........              DC32    BACK
 2572    00000024 ........              DC32    SEMIS
 2573                           
 2574                           
 2575                           //      DO DO:  ( n1 n2 -- ) IMMEDIATE
 2576                           //              (addr n -- ) COMPILE
 2577                           //      Occurs in a colon-definition in form:
 2578                           //      DO ... LOOP
 2579                           
 2580                            SECTION .text : CONST (2)
 2581                           DO_NFA:
 2582    00000000 C2                    DC8     0x0C2
 2583    00000001 44                    DC8     'D'
 2584    00000002 CF                    DC8     'O'+0x80
 2585    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2586    00000004 ........              DC32    LOOP_NFA
 2587                           DO:
 2588    00000008 ........              DC32    DOCOL
 2589    0000000C ........              DC32    COMP
 2590    00000010 ........              DC32    XDO
 2591    00000014 ........              DC32    HERE
 2592    00000018 ........              DC32    THREE
 2593    0000001C ........              DC32    SEMIS
 2594                           
 2595                           
 2596                           //      ENDIF ENDIF:    ( addr n -- ) IMMEDIATE
 2597                           //      Occurs in a colon-definition in form:
 2598                           //              IF ... ENDIF
 2599                           //              IF ... ELSE ... ENDIF
 2600                           //      At run-time, ENDIF serves only as the destination of a forward
 2601                           //      branch from IF or ELSE. It marks the conclusion of the conditional
 2602                           //      structure. THEN is another name for ENDIF. Both names are supported
 2603                           //      in fig-FORTH. See also IF and ELSE.
 2604                           //
 2605                           //      At compile-time, ENDIF computes the forward branch offset from addr
 2606                           //      to HERE and stores it at addr. n is used for error tests.
 2607                           
 2608                            SECTION .text : CONST (2)
 2609                           ENDIF_NFA:
 2610    00000000 C5                    DC8     0x0C5
 2611    00000001 454E4449              DC8     'ENDI'
 2612    00000005 C6                    DC8     'F'+0x80
 2613    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2614    00000008 ........              DC32    DO_NFA
 2615                           ENDIF:
 2616    0000000C ........              DC32    DOCOL
 2617    00000010 ........              DC32    QCOMP
 2618    00000014 ........              DC32    TWO     // 2 is the Error checking number for if.
 2619    00000018 ........              DC32    QPAIR
 2620    0000001C ........              DC32    HERE
 2621    00000020 ........              DC32    OVER
 2622    00000024 ........              DC32    SUBB
 2623    00000028 ........              DC32    SWAP
 2624    0000002C ........              DC32    STORE
 2625    00000030 ........              DC32    SEMIS
 2626                           
 2627                           
 2628                           //      THEN THEN:      ( -- ) IMMEDIATE
 2629                           //      An alias for ENDIF.
 2630                           
 2631                            SECTION .text : CONST (2)
 2632                           THEN_NFA:
 2633    00000000 C4                    DC8     0x0C4
 2634    00000001 544845                DC8     'THE'
 2635    00000004 CE                    DC8     'N'+0x80
 2636    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2637    00000008 ........              DC32    ENDIF_NFA
 2638                           THEN:
 2639    0000000C ........              DC32    DOCOL
 2640    00000010 ........              DC32    ENDIF
 2641    00000014 ........              DC32    SEMIS
 2642                           
 2643                           
 2644                           //      ELSE ELSE:      ( addr1 n1 -- ) IMMEDIATE
 2645                           //                      ( addr2 n2 -- ) COMPILING
 2646                           //      Occurs within a colon-definition in the form:
 2647                           //              IF ... ELSE ... ENDIF
 2648                           //      At run-time, ELSE executes after the true part following IF. ELSE
 2649                           //      forces execution to skip over the following false part and resumes
 2650                           //      execution after the ENDIF. It has no stack effect.
 2651                           //
 2652                           //      At compile-time ELSE emplaces BRANCH reserving a branch offset,
 2653                           //      leaves the address addr2 and n2 for error testing. ELSE also
 2654                           //      resolves the pending forward branch from IF by calculating the
 2655                           //      offset from addr1 to HERE and storing at addr1.
 2656                           
 2657                            SECTION .text : CONST (2)
 2658                           ELSE_NFA:
 2659    00000000 C4                    DC8     0x0C4
 2660    00000001 454C53                DC8     'ELS'
 2661    00000004 C5                    DC8     'E'+0x80
 2662    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2663    00000008 ........              DC32    THEN_NFA
 2664                           ELSE:
 2665    0000000C ........              DC32    DOCOL
 2666    00000010 ........              DC32    TWO
 2667    00000014 ........              DC32    QPAIR
 2668    00000018 ........              DC32    COMP
 2669    0000001C ........              DC32    BRAN
 2670    00000020 ........              DC32    HERE
 2671    00000024 ........              DC32    ZERO
 2672    00000028 ........              DC32    COMMA   // aligned, INCREMENTS DP REFLECTED by HERE
 2673    0000002C ........              DC32    SWAP
 2674    00000030 ........              DC32    TWO
 2675    00000034 ........              DC32    ENDIF
 2676    00000038 ........              DC32    TWO
 2677    0000003C ........              DC32    SEMIS
 2678                           
 2679                           
 2680                           //      IF IF:  ( f -- ) IMMEDIATE
 2681                           //              ( -- addr n ) COMPILE
 2682                           //      Occurs is a colon-definition in form:
 2683                           //              IF (tp) ...  ENDIF      .
 2684                           //              IF (tp) ... ELSE (fp) ... ENDIF
 2685                           //      At run-time, IF selects execution based on a boolean flag. If f is
 2686                           //      true (non-zero), execution continues ahead thru the true part. If f
 2687                           //      is false (zero), execution skips till just after ELSE to execute
 2688                           //      the false part. After either part, execution resumes after ENDIF.
 2689                           //      ELSE and its false part are optional.; if missing, false execution
 2690                           //      skips to just after ENDIF..
 2691                           //
 2692                           //      At compile-time IF compiles 0BRANCH and reserves space for an offset
 2693                           //      at addr. addr and n are used later for resolution of the offset and
 2694                           //      error testing.
 2695                           
 2696                            SECTION .text : CONST (2)
 2697                           IF_NFA:
 2698    00000000 C2                    DC8     0x0C2
 2699    00000001 49                    DC8     'I'
 2700    00000002 C6                    DC8     'F'+0x80
 2701    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2702    00000004 ........              DC32    ELSE_NFA
 2703                           IF:
 2704    00000008 ........              DC32    DOCOL
 2705    0000000C ........              DC32    COMP
 2706    00000010 ........              DC32    ZBRAN
 2707    00000014 ........              DC32    HERE
 2708    00000018 ........              DC32    ZERO
 2709    0000001C ........              DC32    COMMA
 2710    00000020 ........              DC32    TWO     // 2 is the Error checking number for if.
 2711    00000024 ........              DC32    SEMIS
 2712                           
 2713                           
 2714                           //      UNTIL UNTIL:    ( f -- ) IMMEDIATE
 2715                           //                      ( addr n -- ) COMPILE:
 2716                           //      Occurs within a colon-definition in the form:
 2717                           //              BEGIN ... UNTIL
 2718                           //      At run-time, UNTIL controls the conditional branch back to the
 2719                           //      corresponding BEGIN. If f is false, execution returns to just after.
 2720                           //      BEGIN:  if true, execution continues ahead.
 2721                           //      At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to
 2722                           //      addr. n is used for error tests.
 2723                           
 2724                            SECTION .text : CONST (2)
 2725                           UNTIL_NFA:
 2726    00000000 C5                    DC8     0x0C5
 2727    00000001 554E5449              DC8     'UNTI'
 2728    00000005 CC                    DC8     'L'+0x80
 2729    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2730    00000008 ........              DC32    IF_NFA
 2731                           UNTIL:
 2732    0000000C ........              DC32    DOCOL
 2733    00000010 ........              DC32    ONE
 2734    00000014 ........              DC32    QPAIR
 2735    00000018 ........              DC32    COMP
 2736    0000001C ........              DC32    ZBRAN
 2737    00000020 ........              DC32    BACK
 2738    00000024 ........              DC32    SEMIS
 2739                           
 2740                           
 2741                           //      AGAIN AGAIN:    ( addr n -- ) IMMEDIATE
 2742                           //      Used in a colon-definition in the form:
 2743                           //                      BEGIN ... AGAIN
 2744                           //      At run-time, AGAIN forces execution to return to corresponding BEGIN.
 2745                           //      There is no effect on the stack. Execution cannot leave this loop
 2746                           //      (unless R> DROP is executed one level below).
 2747                           //
 2748                           //      At compile time, AGAIN compiles BRANCH with an offset from HERE to
 2749                           //      addr. n is used for compile-time error checking.
 2750                           
 2751                            SECTION .text : CONST (2)
 2752                           AGAIN_NFA:
 2753    00000000 C5                    DC8     0x0C5
 2754    00000001 41474149              DC8     'AGAI'
 2755    00000005 CE                    DC8     'N'+0x80
 2756    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2757    00000008 ........              DC32    UNTIL_NFA
 2758                           AGAIN:
 2759    0000000C ........              DC32    DOCOL
 2760    00000010 ........              DC32    ONE
 2761    00000014 ........              DC32    QPAIR
 2762    00000018 ........              DC32    COMP
 2763    0000001C ........              DC32    BRAN
 2764    00000020 ........              DC32    BACK
 2765    00000024 ........              DC32    SEMIS
 2766                           
 2767                           
 2768                           //      REPEAT REPEAT:  ( addr n -- ) IMMEDIATE
 2769                           //      Used within a colon-definition in the form:
 2770                           //              BEGIN ... WHILE ... REPEAT
 2771                           //      At run-time, REPEAT forces an unconditional branch back to just
 2772                           //      after the corresponding BEGIN.
 2773                           //
 2774                           //      At compile-time, REPEAT compiles BRANCH and the offset from HERE to
 2775                           //      addr. n is used for error testing.
 2776                           
 2777                            SECTION .text : CONST (2)
 2778                           REPEAT_NFA:
 2779    00000000 C6                    DC8     0x0C6
 2780    00000001 5245504541            DC8     'REPEA'
 2781    00000006 D4                    DC8     'T'+0x80
 2782    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2783    00000008 ........              DC32    AGAIN_NFA
 2784                           REPEAT:
 2785    0000000C ........              DC32    DOCOL
 2786    00000010 ........              DC32    TOR
 2787    00000014 ........              DC32    TOR
 2788    00000018 ........              DC32    AGAIN
 2789    0000001C ........              DC32    RFROM
 2790    00000020 ........              DC32    RFROM
 2791    00000024 ........              DC32    TWO
 2792    00000028 ........              DC32    SUBB
 2793    0000002C ........              DC32    ENDIF
 2794    00000030 ........              DC32    SEMIS
 2795                           
 2796                           
 2797                           //      WHILE WHILE:    ( f -- ) IMMEDIATE
 2798                           //                      (ad1 nl -- ad1 n1 ad2 n2 ) COMPILE
 2799                           //      Occurs in a colon-definition in the form:
 2800                           //              BEGIN ... WHILE (tp) ... REPEAT
 2801                           //      At run-time, WHILE selects conditional execution based on boolean
 2802                           //      flag f. If f is true (non-zero), WHILE continues execution of the
 2803                           //      true part thru to REPEAT, which then branches back to BEGIN. If f is
 2804                           //      false (zero), execution skips to just after REPEAT, exiting the
 2805                           //      structure.
 2806                           //
 2807                           //      At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the
 2808                           //      reserved offset. The stack values will be resolved by REPEAT.
 2809                           
 2810                            SECTION .text : CONST (2)
 2811                           WHILE_NFA:
 2812    00000000 C5                    DC8     0x0C5
 2813    00000001 5748494C              DC8     'WHIL'
 2814    00000005 C5                    DC8     'E'+0x80
 2815    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2816    00000008 ........              DC32    REPEAT_NFA
 2817                           WHILE:
 2818    0000000C ........              DC32    DOCOL
 2819    00000010 ........              DC32    IF
 2820    00000014 ........              DC32    TWOP
 2821    00000018 ........              DC32    SEMIS
 2822                           
 2823                           
 2824                           //      BEGIN BEGIN:    ( -- addr n ) IMMEDIATE
 2825                           //      Occurs in a colon-definition in form:
 2826                           //      BEGIN ... UNTIL
 2827                           //      BEGIN ... AGAIN
 2828                           //      BEGIN ... WHILE ... REPEAT
 2829                           //      At run-time, BEGIN marks the start of a sequence that may be
 2830                           //      repetitively executed. It serves as a return point from the
 2831                           //      corresponding UNTIL, AGAIN or REPEAT. When executing UNTIL, a return
 2832                           //      to BEGIN will occur if the top of the stack is false//
 2833                           //      for AGAIN and REPEAT a return to BEGIN always occurs.
 2834                           //
 2835                           //      At compile time BEGIN leaves its return address and n for compiler
 2836                           //      error checking.
 2837                           
 2838                            SECTION .text : CONST (2)
 2839                           BEGIN_NFA:
 2840    00000000 C5                    DC8     0x0C5
 2841    00000001 42454749              DC8     'BEGI'
 2842    00000005 CE                    DC8     'N'+0x80
 2843    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2844    00000008 ........              DC32    WHILE_NFA
 2845                           BEGIN:
 2846    0000000C ........              DC32    DOCOL
 2847    00000010 ........              DC32    QCOMP
 2848    00000014 ........              DC32    HERE
 2849    00000018 ........              DC32    ONE
 2850    0000001C ........              DC32    SEMIS
 2851                           
 2852                           
 2853                           //=============================== WORDCAT ====================================//
 2854                           //NOEXEC HEADERFORWORDCATEGORIES
 2855                           //      WC_COMPILE_NFA = Inside Colon WORDS: CATEGORY
 2856                           
 2857                            SECTION .text : CONST (2)
 2858                           WC_COMPILE_NFA:
 2859    00000000 97                    DC8     0x80+4+19
 2860    00000001 0D0A                  DC8     0x0D, 0x0A
 2861    00000003 496E736964652         DC8     'Inside Colon WORDS:'
                  0436F6C6F6E20
                  574F5244533A 
 2862    00000016 0D8A                  DC8     0x0D, 0x0A+0x80
 2863                            ALIGNROM 2,0xFFFFFFFF
 2864    00000018 ........              DC32    BEGIN_NFA
 2865                           
 2866                           
 2867                           //      IMMEDIATE IMMED:        ( -- )
 2868                           //      Mark the most recently made definition so that when encountered at
 2869                           //      compile time, it will be executed rather than being compiled. i.e.
 2870                           //      the precedence bit in its header is set.
 2871                           //      This method allows definitions to handle unusual compiling
 2872                           //      situations, rather. than build them into the fundamental compiler.
 2873                           //      The system may force compilation of an immediate definition by
 2874                           //      preceeding it with [COMPILE].
 2875                           
 2876                            SECTION .text : CONST (2)
 2877                           IMMED_NFA:
 2878    00000000 89                    DC8     0x89
 2879    00000001 494D4D4544494         DC8     'IMMEDIAT'
                  154          
 2880    00000009 C5                    DC8     'E'+0x80
 2881    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2882    0000000C ........              DC32    WC_COMPILE_NFA
 2883                           IMMED:
 2884    00000010 ........              DC32    DOCOL
 2885    00000014 ........              DC32    LATEST
 2886    00000018 ........40000         DC32    LIT, 0x40
                  000          
 2887    00000020 ........              DC32    TOGGLE
 2888    00000024 ........              DC32    SEMIS
 2889                           
 2890                           
 2891                           //      CREATE CREATE:  ( -- )
 2892                           //      Create a word in The Dictionary.
 2893                           //      Make searchable and forgetable NFA/LFA, DOCON, ADDR->PFA
 2894                           //      USE <BUILDS with DOES> instead of CREATE.
 2895                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2896                           //
 2897                           //      Saves HERE in CSDP in case there's an error creating a word.
 2898                           //      CSDP is reset when a word is completed, by ; <BUILDS (?) CON and VAR.
 2899                           //
 2900                           //      A defining word used in the form:
 2901                           //              CREATE CCcc
 2902                           //      by such words as VAR, CON AND <BUILDS to create a dictionary header for
 2903                           //      a new word. The code field contains the address of the words
 2904                           //      parameter field.
 2905                           
 2906                            SECTION .text : CONST (2)
 2907                           CREATE_NFA:
 2908    00000000 86                    DC8     0x86
 2909    00000001 4352454154            DC8     'CREAT'
 2910    00000006 C5                    DC8     'E'+0x80
 2911    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2912    00000008 ........              DC32    IMMED_NFA
 2913                           CREATE:
 2914    0000000C ........              DC32    DOCOL
 2915    00000010 ........              DC32    DICTSPACE       //      \ -- n
 2916    00000014 ........0F000         DC32    LIT, 15, SUBB   // One less than smallest definition
                  000........  
 2917    00000020 ........              DC32    ZLESS
 2918    00000024 ........              DC32    ZBRAN
 2919    00000028 08000000              DC32    CREATEOK-.
 2920                           
 2921    0000002C ........              DC32    DICTFULL_ABORT
 2922                           
 2923                           CREATEOK:
 2924    00000030 ........              DC32    DFIND                   // Parse nfa
 2925                           //      -FIND DFIND \ --- pfa len tf (found) \ --- ff (not found)
 2926    00000034 ........              DC32    ZBRAN
 2927    00000038 24000000              DC32     CREA1-.
 2928                           
 2929                           #ifdef IO2TP
 2933                           #endif
 2934    0000003C ........              DC32    DROP
 2935    00000040 ........              DC32    NFA
 2936    00000044 ........              DC32    IDDOT
 2937    00000048 .............         DC32    LIT, msg_wordexists
                  ...          
 2938                           // Nothing created yet so ABORT is correct.
 2939                           //        DC32    ERROR
 2940    00000050 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 2941    00000058 ........              DC32    ABORT
 2942                           
 2943                           CREA1:
 2944                           // Save HERE in CSDP so ERROR can reset DP if this definition fails.
 2945                           // CSDP is reset by SEMIC_CREATE when this definition is completed.
 2946                           // SEMIC_CREATE used in ; CON and VAR to reset CSDP.
 2947                           
 2948                           // This new definitions cstring name has been moved to HERE 
 2949    0000005C .............         DC32    HERE, DUP       // This will become the new CURRENT (this NFA).
                  ...          
 2950    00000064 .............         DC32    CSDP_SV, STORE  // HERE to CSDP to restore in case of error.
                  ...          
 2951                           // Dup HERE-NFA to allot NFAx
 2952    0000006C ........              DC32    DUP
 2953                           // Limit NFA allot to maxwordlen. DOES NOT CHANGE actual count!
 2954                           // If count is larger than MAXWORDLEN behaviour of this def is unpredictable!
 2955    00000070 ........              DC32    CAT
 2956    00000074 ........1F000         DC32    LIT, MAXWORDLEN // ELIMINATED WIDTH AND WIDTH_SV 
                  000          
 2957    0000007C ........              DC32    MIN
 2958    00000080 ........              DC32    ALLOT_PRIM      // HERE (DP) at end of NFA with padding.
 2959                           // Dup HERE-NFA to set count byte, and to be consumed later
 2960                           // for setting CURRENT after previous CURRENT compiled into LFA.
 2961    00000084 ........              DC32    DUP
 2962                           // Make regular (not immediate) NFA count byte
 2963    00000088 ........80000         DC32    LIT, 0x80
                  000          
 2964    00000090 ........              DC32    TOGGLE          // Count Byte = 80+count
 2965                           // HERE is new now. Mark end of NFA for PFIND search
 2966    00000094 ........              DC32    HERE            // DP after allot of NFA
 2967    00000098 ........80000         DC32    LIT,0x80        // Set last character in NFA
                  000          
 2968    000000A0 ........              DC32    TOGGLE          // smudge bit
 2969                           // Bump DP to LFA
 2970    000000A4 .............         DC32    ONE, DP_SV      // MOVE HERE (DP)
                  ...          
 2971    000000AC ........              DC32    PSTORE          // TO LFA
 2972                           // Set LFA
 2973    000000B0 ........              DC32    LATEST          // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
 2974    000000B4 ........              DC32    COMMA           // Compile last words NFA into this link field.
 2975                                                           // DUP'd HERE should be on stack
 2976                           // Have to set CURRENT with last dup's HERE-NFA after LATEST is compiled
 2977    000000B8 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
 2978    000000BC ........              DC32    STORE           // so storing NEWWORD_NFA into CURRENT.
 2979    000000C0 .............         DC32    COMP, DOCON     // Compile DOCON as CFA
                  ...          
 2980    000000C8 .............         DC32    HERE, FOURP     // Compute and
                  ...          
 2981    000000D0 ........              DC32    COMMA           // COMPILE Addr of PFA
 2982                           //      DC32    SMUDGE          // ELIMINATED
 2983                           //      DC32    SEMIC_CREATE    // USED IN CALLERS OF CREATE, NOT HERE!
 2984    000000D4 ........              DC32    SEMIS
 2985                           
 2986                           
 2987                           //      CON CON:        ( n -- )  MODIFIED: and CONSTANT renamed CON
 2988                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2989                           //      A defining word used in the form:
 2990                           //              n CONSTANT CCcc
 2991                           //      to create word CCcc, with its parameter field containing n. When
 2992                           //      CCcc is later executed, it will push the value of n to the stack.
 2993                           
 2994                            SECTION .text : CONST (2)
 2995                           CONSTANT_NFA:
 2996    00000000 88                    DC8     0x88
 2997    00000001 434F4E5354414         DC8     'CONSTAN'
                  E            
 2998    00000008 D4                    DC8     'T'+0x80
 2999    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3000    0000000C ........              DC32    CREATE_NFA
 3001                           CONSTANT:
 3002    00000010 .............         DC32    DOCOL, CON, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3003                           
 3004                           
 3005                            SECTION .text : CONST (2)
 3006                           CON_NFA:
 3007    00000000 83                    DC8     0x83
 3008    00000001 434F                  DC8     'CO'
 3009    00000003 CE                    DC8     'N'+0x80
 3010                            ALIGNROM 2,0xFFFFFFFF
 3011                           //      DC32    CREATE_NFA
 3012    00000004 ........              DC32    CONSTANT_NFA
 3013                           CON:
 3014    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3015    0000000C ........              DC32    CREATE  // Make Header NFA/LFA, DOCON, ADDR->PFA
 3016    00000010 ........FCFFF         DC32    LIT, -4, DP_SV, PSTORE  // back up to ADDR->PFA
                  FFF..........
                  ......       
 3017    00000020 ........              DC32    COMMA                   // Replace with Con value
 3018    00000024 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3019                           //        DC32    DOTDICTSPACE
 3020    00000028 ........              DC32    SEMIS
 3021                           
 3022                           
 3023                           //      VAR VAR:        ( -- ) RENAMED: VARIABLE to VAR
 3024                           //      IF RAMVARSPACE FULL PRINT Error MESSAGE AND Abort.
 3025                           //      A defining word used in the form:
 3026                           //              VARIABLE CCcc
 3027                           //      When VARIABLE is executed, it creates the definition CCcc with its
 3028                           //      with its cell space uninitialized. When CCcc is executed,
 3029                           //      its cell space address is put on the stack. Use with @ or !
 3030                           //      NOTE: VAR's cell space is allocated in ram. See UP and VARALLOT.
 3031                           
 3032                            SECTION .text : CONST (2)
 3033                           VARIABLE_NFA:
 3034    00000000 88                    DC8     0x88
 3035    00000001 5641524941424         DC8     'VARIABL'
                  C            
 3036    00000008 C5                    DC8     'E'+0x80
 3037    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3038    0000000C ........              DC32    CON_NFA
 3039                           VARIABLE:
 3040    00000010 .............         DC32    DOCOL, VAR_, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3041                           
 3042                            SECTION .text : CONST (2)
 3043                           VAR_NFA:
 3044    00000000 83                    DC8     0x83
 3045    00000001 5641                  DC8     'VA'
 3046    00000003 D2                    DC8     'R'+0x80
 3047                            ALIGNROM 2,0xFFFFFFFF
 3048                           //      DC32    CON_NFA
 3049    00000004 ........              DC32    VARIABLE_NFA
 3050                           VAR_:
 3051    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3052    0000000C ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3053    00000010 ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3054    00000020 .............         DC32    COMP, DOVAR     // CFA of VAR's
                  ...          
 3055                           //        DC32    COMP, DOCON     // CFA of VAR's
 3056                           // aligned, INCREMENTS DP REFLECTED by HERE
 3057                           // compile the value \ v --
 3058    00000028 ........              DC32    ONE
 3059    0000002C ........              DC32    VARALLOT        // Do .VS check and return VAR addr.
 3060    00000030 ........              DC32    COMMA           // Compile address of the ram allotment.
 3061    00000034 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3062                           //        DC32    DOTDICTSPACE
 3063                           //        DC32    DOTVARSPACE
 3064    00000038 ........              DC32    SEMIS
 3065                           
 3066                           
 3067                           //      ; SEMI: ( -- ) IMMEDIATE
 3068                           //      Terminate a colon-definition and stop further compilation.
 3069                           //      Compiles the run-time ;S.
 3070                           
 3071                            SECTION .text : CONST (2)
 3072                           SEMI_NFA:
 3073    00000000 C1                    DC8     0x0C1
 3074    00000001 BB                    DC8     ';'+0x80
 3075    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3076    00000004 ........              DC32    VAR_NFA
 3077                           SEMI:
 3078    00000008 ........              DC32    DOCOL
 3079    0000000C ........              DC32    QCSP
 3080    00000010 ........              DC32    COMP
 3081    00000014 ........              DC32    SEMIS
 3082    00000018 ........              DC32    LBRAC
 3083    0000001C ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3084                           //        DC32    DOTDICTSPACE
 3085    00000020 ........              DC32    SEMIS
 3086                           
 3087                           
 3088                           //      : COLON:        ( -- ) IMMEDIATE
 3089                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 3090                           //      Used in the form called a colon-definition:
 3091                           //              : CCcc     ...     //
 3092                           //      Creates a dictionary entry defining CCcc as equivalent to the
 3093                           //      following sequence of Forth word definitions '...' until the next
 3094                           //      ';' or ';CODE'.
 3095                           //      The compiling process is done by the text interpreter as long as
 3096                           //      STATE is non-zero. Other details are that the CONTEXT vocabulary is
 3097                           //      set to the CURRENT vocabulary and that words with the precedence bit
 3098                           //      set (P) are executed rather than being compiled.
 3099                           
 3100                            SECTION .text : CONST (2)
 3101                           COLON_NFA:
 3102    00000000 C1                    DC8     0x0C1
 3103    00000001 BA                    DC8     ':'+0x80
 3104    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3105    00000004 ........              DC32    SEMI_NFA
 3106                           COLON:
 3107    00000008 ........              DC32    DOCOL
 3108                           //      DICTSPACE TEST DONE IN CREATE
 3109    0000000C ........              DC32    QEXEC
 3110    00000010 ........              DC32    SCSP    // Save the stack position in CSP. Compiler security.
 3111    00000014 ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3112    00000018 ........              DC32    RBRAC   // Resume compiliting by setting STATE_SV to 0xC0
 3113    0000001C ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3114    0000002C .............         DC32    COMP, DOCOL     // aligned, INCREMENTS DP REFLECTED by HERE
                  ...          
 3115    00000034 ........              DC32    SEMIS
 3116                           
 3117                           
 3118                           //=============================== WORDCAT ====================================//
 3119                           //NOEXEC HEADERFORWORDCATEGORIES
 3120                           //      WC_CREATE_NFA = CREATE WORDS With: CATEGORY
 3121                           
 3122                            SECTION .text : CONST (2)
 3123                           WC_CREATE_NFA:
 3124    00000000 96                    DC8     0x80+22
 3125    00000001 0D0A                  DC8     0x0D, 0x0A
 3126    00000003 4352454154452         DC8     'CREATE WORDS With:'
                  0574F52445320
                  576974683A   
 3127    00000015 0D8A                  DC8     0x0D, 0x0A+0x80
 3128    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 3129    00000018 ........              DC32    COLON_NFA
 3130                           
 3131                           //      DABS DABS: ( sd=(LSW MSW) -- ud=(LSW MSW) )
 3132                           //      Leave the absolute value ud of a signed double number.
 3133                           
 3134                            SECTION .text : CONST (2)
 3135                           DABS_NFA:
 3136    00000000 84                    DC8     0x84
 3137    00000001 444142                DC8     'DAB'
 3138    00000004 D3                    DC8     'S'+0x80
 3139    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3140    00000008 ........              DC32    WC_CREATE_NFA
 3141                           DABSF:
 3142                           DABS:
 3143    0000000C ........              DC32    DOCOL
 3144    00000010 ........              DC32    DUP
 3145    00000014 ........              DC32    DPM
 3146    00000018 ........              DC32    SEMIS
 3147                           
 3148                           
 3149                           //      DNEGATE DNEGATE: ( d1 -- d<2>=(LSW MSW) ) RENAMED: DMINUS to DNEGATE
 3150                           //      Convert d1 to its double number two's complement d2.
 3151                           
 3152                            SECTION .text : CONST (2)
 3153                           DNEGATE_NFA:
 3154    00000000 87                    DC8     0x87
 3155    00000001 444E45474154          DC8     'DNEGAT'
 3156    00000007 C5                    DC8     'E'+0x80
 3157                            ALIGNROM 2,0xFFFFFFFF
 3158    00000008 ........              DC32    DABS_NFA
 3159                           DNEGATE:
 3160    0000000C ........              DC32    .+5
 3161                            SECTION .text : CODE (2)
 3162                                   POP2t                   // MSW   //POP  BX
 3162.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3162.2                         //#ifndef TOSCT
 3162.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3162.4                         //#endif
 3162.5                         //      ADDS    p, p, #4
 3162.6                                 ENDM
 3163                                   POP2w                   // LSW   //POP  CX
 3163.1  00000004 57F8042B              LDR     w, [p],#4
 3163.2                         //      LDR     w, [p]
 3163.3                         //      ADDS    p, p, #4
 3163.4                                 ENDM
 3164    00000008 C043                  MVNS    t, t            // negate MSW
 3165    0000000A D243                  MVNS    w, w            // negate LSW
 3166    0000000C 521C                  ADDS    w, w, #1        // add 1 to LSW
 3167                                   DPUSH                   //  --  LSW MSW )
 3167                                   PUSHw   // push w to p, post decrement p
 3167.1  0000000E 47F8042D              STR     w, [p, #-4]!
 3167.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3167.3                         //      STR     w, [p]
 3167.4                                 ENDM
 3167                                   TPUSH
 3167                                   PUSHt   // push t to p, pre decrement p
 3167.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3167.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3167.3                         //      STR     t, [p]
 3167.4                                 ENDM
 3167                                   NEXT
 3167.1                         // ARMv7-M Thumb = .+5
 3167.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3167.3                         // ARMv6-M Thumb = .+4
 3167.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3167                                   NEXT1
 3167.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3167.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3167.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3167.4                         // ARMv6-M Thumb = .+4
 3167.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3167.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3167.7                                 ENDM
 3167.8                                 ENDM
 3167.9                                 ENDM
 3167.10                                ENDM
 3168                           
 3169                           
 3170                           //      DPL_SV: ( -- addr of NDPL ) Contains # of digits after . in double number
 3171                           //      A system variable containing the number of digits to the right of the
 3172                           //      decimal on double integer input. It may also be used to hold output
 3173                           //      column location of a decimal point, in system generated formating. The
 3174                           //      default value on single number input is -1.
 3175                            SECTION .text : CONST (2)
 3176                           DPL_NFA:
 3177    00000000 83                    DC8     0x83
 3178    00000001 4450                  DC8     'DP'
 3179    00000003 CC                    DC8     'L'+0x80
 3180                            ALIGNROM 2,0xFFFFFFFF
 3181    00000004 ........              DC32    DNEGATE_NFA
 3182                           DPL_SV:
 3183    00000008 .............         DC32    DOCON, NDPL
                  ...          
 3184                           
 3185                           
 3186                           //      D.R DDOTR:      ( sd=<LSW MSW> n -- ) SIGNED:
 3187                           //      Print a signed double number sd right aligned
 3188                           //      in a field n characters wide.
 3189                           
 3190                            SECTION .text : CONST (2)
 3191                           DDOTR_NFA:
 3192    00000000 83                    DC8     0x83
 3193    00000001 442E                  DC8     'D.'
 3194    00000003 D2                    DC8     'R'+0x80
 3195                            ALIGNROM 2,0xFFFFFFFF
 3196    00000004 ........              DC32    DPL_NFA
 3197                           DDOTR:
 3198    00000008 ........              DC32    DOCOL
 3199    0000000C ........              DC32    TOR     // N CHAR FIELD LEN to r
 3200    00000010 ........              DC32    SWAP    // ( LSW MSW -- MSW LSW )
 3201    00000014 ........              DC32    OVER    // ( MSW LSW -- MSW LSW MSW )
 3202    00000018 ........              DC32    DABS    // ( MSW LSW MSW -- MSW uLSW uMSW )
 3203    0000001C ........              DC32    BDIGS   // <# SET HLD to Pad
 3204    00000020 ........              DC32    DIGS    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3205    00000024 ........              DC32    SIGN    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3206    00000028 ........              DC32    EDIGS   //      #>  ( d=<LSW MSW>  ---  addr  count )
 3207    0000002C ........              DC32    RFROM   // GET THE N CHAR FIELD LEN
 3208    00000030 ........              DC32    OVER    // ( addr count n -- addr count n count )
 3209    00000034 ........              DC32    SUBB    // ( n addr count addr -- n addr count-n )
 3210    00000038 ........              DC32    SPACES  // SPACES  ( n -- )
 3211    0000003C ........              DC32    TYPE    // ( n addr -- )
 3212    00000040 ........              DC32    SEMIS
 3213                           
 3214                           
 3215                           //      D. DDOT:        ( S32-2'S COMPLEMET = (d=<LSW MSW> -- )
 3216                           //      Print a signed double number from a 32 bit two's complement value.
 3217                           //      The high-order 32 bits are most accessable on the stack. Conversion
 3218                           //      is performed according to the current base. A blank follows.
 3219                           
 3220                            SECTION .text : CONST (2)
 3221                           DDOT_NFA:
 3222    00000000 82                    DC8     0x82
 3223    00000001 44                    DC8     'D'
 3224    00000002 AE                    DC8     '.'+0x80
 3225    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3226    00000004 ........              DC32    DDOTR_NFA
 3227                           DDOT:
 3228    00000008 ........              DC32    DOCOL
 3229    0000000C ........              DC32    ZERO
 3230    00000010 ........              DC32    DDOTR
 3231    00000014 ........              DC32    SPACE
 3232    00000018 ........              DC32    SEMIS
 3233                           
 3234                           
 3235                           //      D+ DPLUS:       ( LSW1 MSW1 LSW2 MSW2 --- LSW MSW )  SIGNED:
 3236                           //      Leave the signed double number sum of two signed double numbers.
 3237                           
 3238                            SECTION .text : CONST (2)
 3239                           DPLUS_NFA:
 3240    00000000 82                    DC8     0x82
 3241    00000001 44                    DC8     'D'
 3242    00000002 AB                    DC8     '+'+0x80
 3243    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3244    00000004 ........              DC32    DDOT_NFA
 3245                           DPLUS:
 3246    00000008 ........              DC32    .+5
 3247                            SECTION .text : CODE (2)
 3248                                   POP2t   //    ldr     t, [p],#4       // MS
 3248.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3248.2                         //#ifndef TOSCT
 3248.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3248.4                         //#endif
 3248.5                         //      ADDS    p, p, #4
 3248.6                                 ENDM
 3249                                   POP2n   //    ldr     n, [p],#4       // LS
 3249.1  00000004 57F8041B              LDR     n, [p],#4
 3249.2                         //      LDR     n, [p]
 3249.3                         //      ADDS    p, p, #4
 3249.4                                 ENDM
 3250                                   POP2x   //    ldr     x, [p],#4       // MS
 3250.1  00000008 57F8043B              LDR     x, [p],#4
 3250.2                         //      LDR     x, [p]
 3250.3                         //      ADDS    p, p, #4
 3250.4                                 ENDM
 3251                                   POP2w   //    ldr     w, [p],#4       // LS
 3251.1  0000000C 57F8042B              LDR     w, [p],#4
 3251.2                         //      LDR     w, [p]
 3251.3                         //      ADDS    p, p, #4
 3251.4                                 ENDM
 3252    00000010 5218                  ADDS    w, w, n         // LS sum, set status flags
 3253    00000012 5841                  ADCS    t, t, x         // MS sum + carry
 3254                                   DPUSH                   //  --  LSW MSW )
 3254                                   PUSHw   // push w to p, post decrement p
 3254.1  00000014 47F8042D              STR     w, [p, #-4]!
 3254.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3254.3                         //      STR     w, [p]
 3254.4                                 ENDM
 3254                                   TPUSH
 3254                                   PUSHt   // push t to p, pre decrement p
 3254.1  00000018 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3254.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3254.3                         //      STR     t, [p]
 3254.4                                 ENDM
 3254                                   NEXT
 3254.1                         // ARMv7-M Thumb = .+5
 3254.2  0000001C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3254.3                         // ARMv6-M Thumb = .+4
 3254.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3254                                   NEXT1
 3254.1  00000020 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3254.2  00000024 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3254.3  00000028 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3254.4                         // ARMv6-M Thumb = .+4
 3254.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3254.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3254.7                                 ENDM
 3254.8                                 ENDM
 3254.9                                 ENDM
 3254.10                                ENDM
 3255                           
 3256                           
 3257                           //      S->D STOD:      ( n -- d=<LSW MSW> ) SIGNED:
 3258                           //      Sign extend a single number to form a double number.
 3259                           //      : S->D DUP 0< NEGATE // hi level equivalent
 3260                           
 3261                            SECTION .text : CONST (2)
 3262                           STOD_NFA:
 3263    00000000 84                    DC8     0x84
 3264    00000001 532D3E                DC8     'S->'
 3265    00000004 C4                    DC8     'D'+0x80
 3266    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3267    00000008 ........              DC32    DPLUS_NFA
 3268                           STOD:
 3269    0000000C ........              DC32    .+5
 3270                            SECTION .text : CODE (2)
 3271                                   POP2w                   // POP LSW
 3271.1  00000000 57F8042B              LDR     w, [p],#4
 3271.2                         //      LDR     w, [p]
 3271.3                         //      ADDS    p, p, #4
 3271.4                                 ENDM
 3272    00000004 4040                  EORS    t, t            // Zero MSW
 3273    00000006 1243                  ORRS    w, w, w         // OR LSW
 3274    00000008 00D5                  BPL     STOD1           // LSW is POS
 3275                           
 3276    0000000A 401E                  SUBS     t, t, #1       // LSW is NEG
 3277                           STOD1:
 3278                                   DPUSH                   //  --  LSW MSW )
 3278                                   PUSHw   // push w to p, post decrement p
 3278.1  0000000C 47F8042D              STR     w, [p, #-4]!
 3278.2                         //      SUBS    p, p, #4        //  push w to p, pre decrement p
 3278.3                         //      STR     w, [p]
 3278.4                                 ENDM
 3278                                   TPUSH
 3278                                   PUSHt   // push t to p, pre decrement p
 3278.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3278.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3278.3                         //      STR     t, [p]
 3278.4                                 ENDM
 3278                                   NEXT
 3278.1                         // ARMv7-M Thumb = .+5
 3278.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3278.3                         // ARMv6-M Thumb = .+4
 3278.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3278                                   NEXT1
 3278.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3278.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3278.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3278.4                         // ARMv6-M Thumb = .+4
 3278.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3278.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3278.7                                 ENDM
 3278.8                                 ENDM
 3278.9                                 ENDM
 3278.10                                ENDM
 3279                           
 3280                           
 3281                           //      2* TWOSTAR:     ( n -- n*2 ) LSL 1
 3282                           
 3283                            SECTION .text : CONST (2)
 3284                           TWOSTAR_NFA:
 3285    00000000 82                    DC8     0x82
 3286    00000001 32                    DC8     '2'
 3287    00000002 AA                    DC8     '*'+0x80
 3288    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3289    00000004 ........              DC32    STOD_NFA
 3290                           TWOSTAR:
 3291    00000008 ........              DC32    .+5
 3292                            SECTION .text : CODE (2)
 3293                                   POP2t
 3293.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3293.2                         //#ifndef TOSCT
 3293.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3293.4                         //#endif
 3293.5                         //      ADDS    p, p, #4
 3293.6                                 ENDM
 3294    00000004 4000                  LSLS    t, t, #1        //
 3295                                   TPUSH
 3295                                   PUSHt   // push t to p, pre decrement p
 3295.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3295.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3295.3                         //      STR     t, [p]
 3295.4                                 ENDM
 3295                                   NEXT
 3295.1                         // ARMv7-M Thumb = .+5
 3295.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3295.3                         // ARMv6-M Thumb = .+4
 3295.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3295                                   NEXT1
 3295.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3295.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3295.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3295.4                         // ARMv6-M Thumb = .+4
 3295.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3295.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3295.7                                 ENDM
 3295.8                                 ENDM
 3295.9                                 ENDM
 3296                           
 3297                           
 3298                           //      2/ TWOSLASH:    ( n -- n/1 ) ASR 1 (FLOORED)
 3299                           
 3300                            SECTION .text : CONST (2)
 3301                           TWOSLASH_NFA:
 3302    00000000 82                    DC8     0x82
 3303    00000001 32                    DC8     '2'
 3304    00000002 AF                    DC8     '/'+0x80
 3305    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3306    00000004 ........              DC32    TWOSTAR_NFA
 3307                           TWOSLASH:
 3308    00000008 ........              DC32    .+5
 3309                            SECTION .text : CODE (2)
 3310                                   POP2t
 3310.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3310.2                         //#ifndef TOSCT
 3310.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3310.4                         //#endif
 3310.5                         //      ADDS    p, p, #4
 3310.6                                 ENDM
 3311    00000004 4010                  ASRS    t, t, #1        //
 3312                                   TPUSH
 3312                                   PUSHt   // push t to p, pre decrement p
 3312.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3312.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3312.3                         //      STR     t, [p]
 3312.4                                 ENDM
 3312                                   NEXT
 3312.1                         // ARMv7-M Thumb = .+5
 3312.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3312.3                         // ARMv6-M Thumb = .+4
 3312.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3312                                   NEXT1
 3312.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3312.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3312.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3312.4                         // ARMv6-M Thumb = .+4
 3312.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3312.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3312.7                                 ENDM
 3312.8                                 ENDM
 3312.9                                 ENDM
 3313                                   
 3314                           
 3315                           //      1- ONEM:        ( n -- n-1 )
 3316                           
 3317                            SECTION .text : CONST (2)
 3318                           ONEM_NFA:
 3319    00000000 82                    DC8     0x82
 3320    00000001 31                    DC8     '1'
 3321    00000002 AD                    DC8     '-'+0x80
 3322    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3323    00000004 ........              DC32    TWOSLASH_NFA
 3324                           ONEM:
 3325    00000008 ........              DC32    .+5
 3326                            SECTION .text : CODE (2)
 3327                                   POP2t
 3327.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3327.2                         //#ifndef TOSCT
 3327.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3327.4                         //#endif
 3327.5                         //      ADDS    p, p, #4
 3327.6                                 ENDM
 3328    00000004 401E                  SUBS    t, t, #1        //
 3329                                   TPUSH
 3329                                   PUSHt   // push t to p, pre decrement p
 3329.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3329.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3329.3                         //      STR     t, [p]
 3329.4                                 ENDM
 3329                                   NEXT
 3329.1                         // ARMv7-M Thumb = .+5
 3329.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3329.3                         // ARMv6-M Thumb = .+4
 3329.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3329                                   NEXT1
 3329.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3329.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3329.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3329.4                         // ARMv6-M Thumb = .+4
 3329.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3329.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3329.7                                 ENDM
 3329.8                                 ENDM
 3329.9                                 ENDM
 3330                           
 3331                           
 3332                           //      1+ ONEP:        ( n -- n+1 )
 3333                           
 3334                            SECTION .text : CONST (2)
 3335                           ONEP_NFA:
 3336    00000000 82                    DC8     0x82
 3337    00000001 31                    DC8     '1'
 3338    00000002 AB                    DC8     '+'+0x80
 3339    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3340    00000004 ........              DC32    ONEM_NFA
 3341                           ONEP:
 3342    00000008 ........              DC32    .+5
 3343                            SECTION .text : CODE (2)
 3344                                   POP2t
 3344.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3344.2                         //#ifndef TOSCT
 3344.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3344.4                         //#endif
 3344.5                         //      ADDS    p, p, #4
 3344.6                                 ENDM
 3345    00000004 401C                  ADDS    t, t, #1        //
 3346                                   TPUSH
 3346                                   PUSHt   // push t to p, pre decrement p
 3346.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3346.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3346.3                         //      STR     t, [p]
 3346.4                                 ENDM
 3346                                   NEXT
 3346.1                         // ARMv7-M Thumb = .+5
 3346.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3346.3                         // ARMv6-M Thumb = .+4
 3346.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3346                                   NEXT1
 3346.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3346.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3346.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3346.4                         // ARMv6-M Thumb = .+4
 3346.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3346.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3346.7                                 ENDM
 3346.8                                 ENDM
 3346.9                                 ENDM
 3347                           
 3348                           
 3349                           //      2+ TWOP:        ( n -- n+2 )
 3350                           
 3351                            SECTION .text : CONST (2)
 3352                           TWOP_NFA:
 3353    00000000 82                    DC8     0x82
 3354    00000001 32                    DC8     '2'
 3355    00000002 AB                    DC8     '+'+0x80
 3356    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3357    00000004 ........              DC32    ONEP_NFA
 3358                           TWOP:
 3359    00000008 ........              DC32    .+5
 3360                            SECTION .text : CODE (2)
 3361                                   POP2t
 3361.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3361.2                         //#ifndef TOSCT
 3361.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3361.4                         //#endif
 3361.5                         //      ADDS    p, p, #4
 3361.6                                 ENDM
 3362    00000004 801C                  ADDS    t, t, #2
 3363                                   TPUSH
 3363                                   PUSHt   // push t to p, pre decrement p
 3363.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3363.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3363.3                         //      STR     t, [p]
 3363.4                                 ENDM
 3363                                   NEXT
 3363.1                         // ARMv7-M Thumb = .+5
 3363.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3363.3                         // ARMv6-M Thumb = .+4
 3363.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3363                                   NEXT1
 3363.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3363.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3363.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3363.4                         // ARMv6-M Thumb = .+4
 3363.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3363.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3363.7                                 ENDM
 3363.8                                 ENDM
 3363.9                                 ENDM
 3364                           
 3365                           
 3366                           //      4+ FOURP:       ( n -- n+4 )
 3367                           
 3368                            SECTION .text : CONST (2)
 3369                           FOURP_NFA:
 3370    00000000 82                    DC8     0x82
 3371    00000001 34                    DC8     '4'
 3372    00000002 AB                    DC8     '+'+0x80
 3373    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3374    00000004 ........              DC32    TWOP_NFA
 3375                           FOURP:
 3376    00000008 ........              DC32    .+5
 3377                            SECTION .text : CODE (2)
 3378                                   POP2t
 3378.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3378.2                         //#ifndef TOSCT
 3378.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3378.4                         //#endif
 3378.5                         //      ADDS    p, p, #4
 3378.6                                 ENDM
 3379    00000004 001D                  ADDS    t, t, #4
 3380                                   TPUSH
 3380                                   PUSHt   // push t to p, pre decrement p
 3380.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3380.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3380.3                         //      STR     t, [p]
 3380.4                                 ENDM
 3380                                   NEXT
 3380.1                         // ARMv7-M Thumb = .+5
 3380.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3380.3                         // ARMv6-M Thumb = .+4
 3380.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3380                                   NEXT1
 3380.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3380.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3380.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3380.4                         // ARMv6-M Thumb = .+4
 3380.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3380.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3380.7                                 ENDM
 3380.8                                 ENDM
 3380.9                                 ENDM
 3381                           
 3382                           
 3383                           //      4- FOURM:       ( n -- n-4 )
 3384                           
 3385                            SECTION .text : CONST (2)
 3386                           FOURM_NFA:
 3387    00000000 82                    DC8     0x82
 3388    00000001 34                    DC8     '4'
 3389    00000002 AD                    DC8     '-'+0x80
 3390    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3391    00000004 ........              DC32    FOURP_NFA
 3392                           FOURM:
 3393    00000008 ........              DC32    .+5
 3394                            SECTION .text : CODE (2)
 3395                                   POP2t
 3395.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3395.2                         //#ifndef TOSCT
 3395.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3395.4                         //#endif
 3395.5                         //      ADDS    p, p, #4
 3395.6                                 ENDM
 3396    00000004 001F                  SUBS    t, t, #4
 3397                                   TPUSH
 3397                                   PUSHt   // push t to p, pre decrement p
 3397.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3397.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3397.3                         //      STR     t, [p]
 3397.4                                 ENDM
 3397                                   NEXT
 3397.1                         // ARMv7-M Thumb = .+5
 3397.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3397.3                         // ARMv6-M Thumb = .+4
 3397.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3397                                   NEXT1
 3397.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3397.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3397.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3397.4                         // ARMv6-M Thumb = .+4
 3397.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3397.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3397.7                                 ENDM
 3397.8                                 ENDM
 3397.9                                 ENDM
 3398                           
 3399                           
 3400                           //      0 ZERO: ( -- 0 )
 3401                           
 3402                            SECTION .text : CONST (2)
 3403                           ZERO_NFA:
 3404    00000000 81                    DC8     0x81
 3405    00000001 B0                    DC8     '0'+0x80
 3406    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3407    00000004 ........              DC32    FOURM_NFA
 3408                           ZERO:
 3409    00000008 ........00000         DC32    DOCON, 0
                  000          
 3410                           
 3411                           
 3412                           //      1 ONE: ( -- 1 )
 3413                           
 3414                            SECTION .text : CONST (2)
 3415                           ONE_NFA:
 3416    00000000 81                    DC8     0x81
 3417    00000001 B1                    DC8     '1'+0x80
 3418    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3419    00000004 ........              DC32    ZERO_NFA
 3420                           ONE:
 3421    00000008 ........01000         DC32    DOCON, 1
                  000          
 3422                           
 3423                           
 3424                           //      2 TWO: ( -- 2 )
 3425                           
 3426                            SECTION .text : CONST (2)
 3427                           TWO_NFA:
 3428    00000000 81                    DC8     0x81
 3429    00000001 B2                    DC8     '2'+0x80
 3430    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3431    00000004 ........              DC32    ONE_NFA
 3432                           TWO:
 3433    00000008 ........02000         DC32    DOCON, 2
                  000          
 3434                           
 3435                           
 3436                           //      3 THREE: ( -- 3 )
 3437                           
 3438                            SECTION .text : CONST (2)
 3439                           THREE_NFA:
 3440    00000000 81                    DC8     0x81
 3441    00000001 B3                    DC8     '3'+0x80
 3442    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3443    00000004 ........              DC32    TWO_NFA
 3444                           THREE:
 3445    00000008 ........03000         DC32    DOCON, 3
                  000          
 3446                           
 3447                           
 3448                           //      4 FOUR: ( -- 4 )
 3449                           
 3450                            SECTION .text : CONST (2)
 3451                           FOUR_NFA:
 3452    00000000 81                    DC8     0x81
 3453    00000001 B4                    DC8     '4'+0x80
 3454    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3455    00000004 ........              DC32    THREE_NFA
 3456                           FOUR:
 3457    00000008 ........04000         DC32    DOCON, 4
                  000          
 3458                           
 3459                           
 3460                           //      M* MSTAR:       ( n1 n2 -- d=<S32LSW S32MSW> )  SIGNED:
 3461                           //      A mixed magnitude math operation which leaves the double number
 3462                           //      signed product of two signed number.
 3463                           
 3464                            SECTION .text : CONST (2)
 3465                           MSTAR_NFA:
 3466    00000000 82                    DC8     0x82
 3467    00000001 4D                    DC8     'M'
 3468    00000002 AA                    DC8     '*'+0x80
 3469    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3470    00000004 ........              DC32    FOUR_NFA
 3471                           MSTAR:
 3472    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3473    00000010 ........              DC32    XORR
 3474    00000014 ........              DC32    TOR
 3475    00000018 ........              DC32    ABS
 3476    0000001C ........              DC32    SWAP
 3477    00000020 ........              DC32    ABS
 3478    00000024 ........              DC32    USTAR
 3479    00000028 ........              DC32    RFROM
 3480    0000002C ........              DC32    DPM
 3481    00000030 ........              DC32    SEMIS
 3482                           
 3483                           
 3484                           //      M/ MSLASH:      ( sd  n1  ---  d=<s32REM  S32QUO> )
 3485                           //      A mixed magnitude math operator which leaves the signed remainder
 3486                           //      and signed quotient from sd, a double number dividend and divisor n1.
 3487                           //      The remainder takes its sign from the dividend.
 3488                           
 3489                            SECTION .text : CONST (2)
 3490                           MSLASH_NFA:
 3491    00000000 82                    DC8     0x82
 3492    00000001 4D                    DC8     'M'
 3493    00000002 AF                    DC8     '/'+0x80
 3494    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3495    00000004 ........              DC32    MSTAR_NFA
 3496                           MSLASH:
 3497    00000008 ........              DC32    DOCOL
 3498    0000000C ........              DC32    OVER
 3499    00000010 ........              DC32    TOR
 3500    00000014 ........              DC32    TOR
 3501    00000018 ........              DC32    DABS    // ( LSW MSW -- uLSW uMSW )
 3502    0000001C ........              DC32    R
 3503    00000020 ........              DC32    ABS
 3504    00000024 ........              DC32    USLASH
 3505    00000028 ........              DC32    RFROM
 3506    0000002C ........              DC32    R
 3507    00000030 ........              DC32    XORR
 3508    00000034 ........              DC32    PM
 3509    00000038 ........              DC32    SWAP
 3510    0000003C ........              DC32    RFROM
 3511    00000040 ........              DC32    PM
 3512    00000044 ........              DC32    SWAP
 3513    00000048 ........              DC32    SEMIS
 3514                           
 3515                           
 3516                           //      * STAR: ( n1 n2 -- prod=n3 )
 3517                           //      Leave the signed product n3 of two (32bit) signed numbers n1 and n2.
 3518                           
 3519                            SECTION .text : CONST (2)
 3520                           STAR_NFA:
 3521    00000000 81                    DC8     0x81
 3522    00000001 AA                    DC8     '*'+0x80
 3523    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3524    00000004 ........              DC32    MSLASH_NFA
 3525                           STAR:
 3526    00000008 ........              DC32    DOCOL
 3527    0000000C ........              DC32    MSTAR
 3528    00000010 ........              DC32    DROP
 3529    00000014 ........              DC32    SEMIS
 3530                           
 3531                           
 3532                           //      /MOD SLMOD:     ( n1 n2 -- rem quot )   SIGNED:
 3533                           //      Leave the remainder and signed quotient of n1/n2. The remainder has
 3534                           //      the sign of the dividend.
 3535                           
 3536                            SECTION .text : CONST (2)
 3537                           SLMOD_NFA:
 3538    00000000 84                    DC8     0x84
 3539    00000001 2F4D4F                DC8     '/MO'
 3540    00000004 C4                    DC8     'D'+0x80
 3541    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3542    00000008 ........              DC32    STAR_NFA
 3543                           SLMOD:
 3544    0000000C ........              DC32    DOCOL
 3545    00000010 ........              DC32    TOR
 3546    00000014 ........              DC32    STOD
 3547    00000018 ........              DC32    RFROM
 3548    0000001C ........              DC32    MSLASH
 3549    00000020 ........              DC32    SEMIS
 3550                           
 3551                           
 3552                           //      / SLASH:        ( sn1 sn2 -- sn ) SIGNED:
 3553                           //      Leave the signed quotient sn of sn1/sn2.
 3554                           
 3555                            SECTION .text : CONST (2)
 3556                           SLASH_NFA:
 3557    00000000 81                    DC8     0x81
 3558    00000001 AF                    DC8     '/'+0x80
 3559    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3560    00000004 ........              DC32    SLMOD_NFA
 3561                           SLASH:
 3562    00000008 ........              DC32    DOCOL
 3563    0000000C ........              DC32    SLMOD
 3564    00000010 ........              DC32    SWAP
 3565    00000014 ........              DC32    DROP
 3566    00000018 ........              DC32    SEMIS
 3567                           
 3568                           
 3569                           //      MOD MOD:        ( sn1 n2 -- modulo )
 3570                           //      Leave the remainder of sn1/n2, with the same sign as sn1.
 3571                           
 3572                            SECTION .text : CONST (2)
 3573                           MODD_NFA:
 3574    00000000 83                    DC8     0x83
 3575    00000001 4D4F                  DC8     'MO'
 3576    00000003 C4                    DC8     'D'+0x80
 3577                            ALIGNROM 2,0xFFFFFFFF
 3578    00000004 ........              DC32    SLASH_NFA
 3579                           MOD:
 3580    00000008 ........              DC32    DOCOL
 3581    0000000C ........              DC32    SLMOD
 3582    00000010 ........              DC32    DROP
 3583    00000014 ........              DC32    SEMIS
 3584                           
 3585                           
 3586                           //      */MOD SSMOD:    ( n1 n2 n3 -- n4 n5 )
 3587                           //      Leave the quotient n5 and remainder n4 of the operation n1*n2/n3 A
 3588                           //      31 bit intermediate product is used as for */.
 3589                           
 3590                            SECTION .text : CONST (2)
 3591                           SSMOD_NFA:
 3592    00000000 85                    DC8     0x85
 3593    00000001 2A2F4D4F              DC8     '*/MO'
 3594    00000005 C4                    DC8     'D'+0x80
 3595    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 3596    00000008 ........              DC32    MODD_NFA
 3597                           SSMOD:
 3598    0000000C ........              DC32    DOCOL
 3599    00000010 ........              DC32    TOR
 3600    00000014 ........              DC32    MSTAR
 3601    00000018 ........              DC32    RFROM
 3602    0000001C ........              DC32    MSLASH
 3603    00000020 ........              DC32    SEMIS
 3604                           
 3605                           
 3606                           //      */ SSLASH:      ( n1 n2 n3 -- n4 )
 3607                           //      Leave the ratio n4 = n1*n2/n3 where all are signed numbers.
 3608                           //      Retention of an intermediate 31 bit product permits greater accuracy
 3609                           //      than would. be available with the sequence:
 3610                           //              n1  n2  *  n3  /
 3611                           
 3612                            SECTION .text : CONST (2)
 3613                           SSLASH_NFA:
 3614    00000000 82                    DC8     0x82
 3615    00000001 2A                    DC8     '*'
 3616    00000002 AF                    DC8     '/'+0x80
 3617    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3618    00000004 ........              DC32    SSMOD_NFA
 3619                           SSLASH:
 3620    00000008 ........              DC32    DOCOL
 3621    0000000C ........              DC32    SSMOD
 3622    00000010 ........              DC32    SWAP
 3623    00000014 ........              DC32    DROP
 3624    00000018 ........              DC32    SEMIS
 3625                           
 3626                           
 3627                           //      + PLUS: ( n1 n2 -- n3 )
 3628                           //      Add n1 and n2, leaving sum n3
 3629                           
 3630                            SECTION .text : CONST (2)
 3631                           PLUS_NFA:
 3632    00000000 81                    DC8     0x81
 3633    00000001 AB                    DC8     0xAB    // '+' + 0x80
 3634    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3635    00000004 ........              DC32    SSLASH_NFA
 3636                           PLUS:
 3637    00000008 ........              DC32    .+5
 3638                            SECTION .text : CODE (2)
 3639                                   POP2t
 3639.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3639.2                         //#ifndef TOSCT
 3639.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3639.4                         //#endif
 3639.5                         //      ADDS    p, p, #4
 3639.6                                 ENDM
 3640                                   POP2n
 3640.1  00000004 57F8041B              LDR     n, [p],#4
 3640.2                         //      LDR     n, [p]
 3640.3                         //      ADDS    p, p, #4
 3640.4                                 ENDM
 3641    00000008 4018                  ADDS    t, t, n
 3642                                   TPUSH
 3642                                   PUSHt   // push t to p, pre decrement p
 3642.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3642.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3642.3                         //      STR     t, [p]
 3642.4                                 ENDM
 3642                                   NEXT
 3642.1                         // ARMv7-M Thumb = .+5
 3642.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3642.3                         // ARMv6-M Thumb = .+4
 3642.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3642                                   NEXT1
 3642.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3642.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3642.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3642.4                         // ARMv6-M Thumb = .+4
 3642.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3642.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3642.7                                 ENDM
 3642.8                                 ENDM
 3642.9                                 ENDM
 3643                           
 3644                           
 3645                           //      - SUBB: ( n1 n2 -- n3 )
 3646                           //      Leave the difference of n1-n2 as n3.
 3647                           //      1 2 - . -1
 3648                           //      2 1 - .  1
 3649                           
 3650                            SECTION .text : CONST (2)
 3651                           SUB_NFA:
 3652    00000000 81                    DC8     0x81
 3653    00000001 AD                    DC8     '-'+0x80
 3654    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3655    00000004 ........              DC32    PLUS_NFA
 3656                           SUBB:
 3657    00000008 ........              DC32    .+5
 3658                            SECTION .text : CODE (2)
 3659                                   POP2t
 3659.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3659.2                         //#ifndef TOSCT
 3659.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3659.4                         //#endif
 3659.5                         //      ADDS    p, p, #4
 3659.6                                 ENDM
 3660                                   POP2n
 3660.1  00000004 57F8041B              LDR     n, [p],#4
 3660.2                         //      LDR     n, [p]
 3660.3                         //      ADDS    p, p, #4
 3660.4                                 ENDM
 3661    00000008 081A                  SUBS    t, n, t
 3662                                   TPUSH
 3662                                   PUSHt   // push t to p, pre decrement p
 3662.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3662.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3662.3                         //      STR     t, [p]
 3662.4                                 ENDM
 3662                                   NEXT
 3662.1                         // ARMv7-M Thumb = .+5
 3662.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3662.3                         // ARMv6-M Thumb = .+4
 3662.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3662                                   NEXT1
 3662.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3662.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3662.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3662.4                         // ARMv6-M Thumb = .+4
 3662.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3662.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3662.7                                 ENDM
 3662.8                                 ENDM
 3662.9                                 ENDM
 3663                           
 3664                           
 3665                           //      = EQUAL:        (n1 n2 -- f )
 3666                           //      Leave a true flag if n1=n2// otherwise leave a false flag.
 3667                           
 3668                            SECTION .text : CONST (2)
 3669                           EQUAL_NFA:
 3670    00000000 81                    DC8     0x81
 3671    00000001 BD                    DC8     '='+0x80
 3672    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3673    00000004 ........              DC32    SUB_NFA
 3674                           EQUAL:
 3675    00000008 ........              DC32    .+5
 3676                            SECTION .text : CODE (2)
 3677                           #ifdef TRUE_EQU_NEG_ONE
 3678    00000000 4040                  EORS    t, t
 3679                           #endif
 3680                                   POP2t
 3680.1  00000002 57F8040B              LDR     t, [p],#4       // Post-increment
 3680.2                         //#ifndef TOSCT
 3680.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3680.4                         //#endif
 3680.5                         //      ADDS    p, p, #4
 3680.6                                 ENDM
 3681                                   POP2n
 3681.1  00000006 57F8041B              LDR     n, [p],#4
 3681.2                         //      LDR     n, [p]
 3681.3                         //      ADDS    p, p, #4
 3681.4                                 ENDM
 3682    0000000A 401A                  SUBS    t, t, n
 3683    0000000C 09D0                  BEQ     EQUAL_TRUE
 3684    0000000E 4040                  EORS    t, t
 3685                                   TPUSH
 3685                                   PUSHt   // push t to p, pre decrement p
 3685.1  00000010 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3685.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3685.3                         //      STR     t, [p]
 3685.4                                 ENDM
 3685                                   NEXT
 3685.1                         // ARMv7-M Thumb = .+5
 3685.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3685.3                         // ARMv6-M Thumb = .+4
 3685.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3685                                   NEXT1
 3685.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3685.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3685.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3685.4                         // ARMv6-M Thumb = .+4
 3685.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3685.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3685.7                                 ENDM
 3685.8                                 ENDM
 3685.9                                 ENDM
 3686                           
 3687                           EQUAL_TRUE:
 3688                           #ifdef TRUE_EQU_NEG_ONE
 3689    00000022 0138                  SUBS    t, #1 // -1
 3690                           #else
 3692                           #endif
 3693                                   TPUSH
 3693                                   PUSHt   // push t to p, pre decrement p
 3693.1  00000024 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3693.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3693.3                         //      STR     t, [p]
 3693.4                                 ENDM
 3693                                   NEXT
 3693.1                         // ARMv7-M Thumb = .+5
 3693.2  00000028 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3693.3                         // ARMv6-M Thumb = .+4
 3693.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3693                                   NEXT1
 3693.1  0000002C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3693.2  00000030 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3693.3  00000034 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3693.4                         // ARMv6-M Thumb = .+4
 3693.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3693.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3693.7                                 ENDM
 3693.8                                 ENDM
 3693.9                                 ENDM
 3694                           /*
 3695                                   DC32    DOCOL
 3696                                   DC32    SUBB
 3697                                   DC32    ZEQU
 3698                                   DC32    SEMIS
 3699                           */
 3700                           
 3701                           
 3702                           //      < LESSTHAN:     ( n1 n2 -- f ) SIGNED:
 3703                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3704                           //      C0 1 < . 0  -1 C0 < . 1
 3705                           
 3706                            SECTION .text : CONST (2)
 3707                           LESSTHAN_NFA:
 3708    00000000 81                    DC8     0x81
 3709    00000001 BC                    DC8     '<'+0x80
 3710    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3711    00000004 ........              DC32    EQUAL_NFA
 3712                           LESSTHAN:
 3713    00000008 ........              DC32    .+5
 3714                            SECTION .text : CODE (2)
 3715                           #ifdef TRUE_EQU_NEG_ONE
 3716    00000000 4040                  EORS    t, t    // zero t
 3717    00000002 0138                  SUBS    t, #1   // -1
 3718                           #else
 3720                           #endif
 3721                                   POP2n                           // n2
 3721.1  00000004 57F8041B              LDR     n, [p],#4
 3721.2                         //      LDR     n, [p]
 3721.3                         //      ADDS    p, p, #4
 3721.4                                 ENDM
 3722                                   POP2w                           // n1
 3722.1  00000008 57F8042B              LDR     w, [p],#4
 3722.2                         //      LDR     w, [p]
 3722.3                         //      ADDS    p, p, #4
 3722.4                                 ENDM
 3723    0000000C 9142                  CMP     n, w        // n1 < n2
 3724    0000000E 00DC                  BGT     LESS1
 3725                           
 3726    00000010 4040                  EORS    t, t    // zero t =< n
 3727                           LESS1:
 3728                                   TPUSH
 3728                                   PUSHt   // push t to p, pre decrement p
 3728.1  00000012 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3728.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3728.3                         //      STR     t, [p]
 3728.4                                 ENDM
 3728                                   NEXT
 3728.1                         // ARMv7-M Thumb = .+5
 3728.2  00000016 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3728.3                         // ARMv6-M Thumb = .+4
 3728.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3728                                   NEXT1
 3728.1  0000001A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3728.2  0000001E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3728.3  00000022 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3728.4                         // ARMv6-M Thumb = .+4
 3728.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3728.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3728.7                                 ENDM
 3728.8                                 ENDM
 3728.9                                 ENDM
 3729                           
 3730                           
 3731                           //      U< ULESSTHAN:   ( n1 n2 -- f )  UNSIGNED:
 3732                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3733                           //      -1 -2 U< . 0  -1 2 U< . 0  1 2 U< . 1
 3734                           
 3735                            SECTION .text : CONST (2)
 3736                           ULESSTHAN_NFA:
 3737    00000000 82                    DC8     0x82
 3738    00000001 55                    DC8     'U'
 3739    00000002 BC                    DC8     '<'+0x80
 3740    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3741    00000004 ........              DC32    LESSTHAN_NFA
 3742                           ULESSTHAN:
 3743    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3744    00000010 .............         DC32    XORR, ZLESS
                  ...          
 3745    00000018 ........              DC32    ZBRAN
 3746    0000001C 18000000              DC32    ULES1-. //IF
 3747                           
 3748    00000020 .............         DC32    DROP, ZLESS
                  ...          
 3749    00000028 ........              DC32    ZEQU
 3750    0000002C ........              DC32    BRAN
 3751    00000030 0C000000              DC32    ULES2-.
 3752                           
 3753                           ULES1:
 3754    00000034 .............         DC32    SUBB,ZLESS      //ELSE
                  ...          
 3755                           
 3756                           ULES2:
 3757    0000003C ........              DC32    SEMIS           //endif
 3758                           
 3759                           
 3760                           //      > GREATERTHAN:  ( n1 n2 --  f ) SIGNED: L0
 3761                           //      Leave a true flag if n1 is greater than n2 otherwise a false flag.
 3762                           //      -1 1 > . 0  1 -1 > . 1
 3763                           
 3764                            SECTION .text : CONST (2)
 3765                           GREATERTHAN_NFA:
 3766    00000000 81                    DC8     0x81
 3767    00000001 BE                    DC8     '>'+0x80
 3768    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3769    00000004 ........              DC32    ULESSTHAN_NFA
 3770                           GREATERTHAN:
 3771    00000008 ........              DC32    DOCOL
 3772    0000000C ........              DC32    SWAP
 3773    00000010 ........              DC32    LESSTHAN
 3774    00000014 ........              DC32    SEMIS
 3775                           
 3776                           
 3777                           //      0= ZEQU:        ( n -- f )
 3778                           //      Leave a true flag is the number is equal to zero, otherwise leave a
 3779                           //      false flag. CHANGED Code dependent on true flag being 1 FOR -1 TRUE
 3780                           
 3781                            SECTION .text : CONST (2)
 3782                           ZEQU_NFA:
 3783    00000000 82                    DC8     0x82
 3784    00000001 30                    DC8     '0'
 3785    00000002 BD                    DC8     '='+0x80
 3786    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3787    00000004 ........              DC32    GREATERTHAN_NFA
 3788                           ZEQU:
 3789    00000008 ........              DC32    .+5
 3790                            SECTION .text : CODE (2)
 3791    00000000 4040                  EORS    t, t
 3792                                   POP2n
 3792.1  00000002 57F8041B              LDR     n, [p],#4
 3792.2                         //      LDR     n, [p]
 3792.3                         //      ADDS    p, p, #4
 3792.4                                 ENDM
 3793    00000006 0029                  CMP     n, #0
 3794    00000008 00D1                  BNE     ZEQU_ZERO
 3795                           
 3796                           #ifdef TRUE_EQU_NEG_ONE
 3797    0000000A 401E                  SUBS    t, t, #1
 3798                           #else
 3800                           #endif
 3801                           
 3802                           ZEQU_ZERO:
 3803                                   TPUSH
 3803                                   PUSHt   // push t to p, pre decrement p
 3803.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3803.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3803.3                         //      STR     t, [p]
 3803.4                                 ENDM
 3803                                   NEXT
 3803.1                         // ARMv7-M Thumb = .+5
 3803.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3803.3                         // ARMv6-M Thumb = .+4
 3803.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3803                                   NEXT1
 3803.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3803.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3803.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3803.4                         // ARMv6-M Thumb = .+4
 3803.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3803.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3803.7                                 ENDM
 3803.8                                 ENDM
 3803.9                                 ENDM
 3804                           
 3805                           
 3806                           //      0< ZLESS:       ( n -- f )
 3807                           //      Leave a true flag if the number is less than zero (negative),
 3808                           //      otherwise leave a false flag.
 3809                           
 3810                            SECTION .text : CONST (2)
 3811                           ZLESS_NFA:
 3812    00000000 82                    DC8     0x82
 3813    00000001 30                    DC8     '0'
 3814    00000002 BC                    DC8     '<'+0x80
 3815    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3816    00000004 ........              DC32    ZEQU_NFA
 3817                           ZLESS:
 3818    00000008 ........              DC32    .+5
 3819                            SECTION .text : CODE (2)
 3820                           #ifdef TOSCT    // REPLACING t SO THIS IS FASTER THAN POP2n
 3823                           #else
 3824                                   POP2n
 3824.1  00000000 57F8041B              LDR     n, [p],#4
 3824.2                         //      LDR     n, [p]
 3824.3                         //      ADDS    p, p, #4
 3824.4                                 ENDM
 3825                           #endif
 3826                           #ifdef TRUE_EQU_NEG_ONE
 3827    00000004 4040                  EORS    t, t
 3828    00000006 0138                  SUBS    t, #1   // TRUE -1
 3829                           #else
 3831                           #endif
 3832    00000008 0943                  ORRS    n, n, n // SET FLAGS
 3833    0000000A 00D4                  BMI     ZLESS1  // JS   ZLESS1
 3834                           
 3835    0000000C 4040                  EORS    t, t    // FALSE
 3836                           ZLESS1:
 3837                                   TPUSH
 3837                                   PUSHt   // push t to p, pre decrement p
 3837.1  0000000E 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3837.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3837.3                         //      STR     t, [p]
 3837.4                                 ENDM
 3837                                   NEXT
 3837.1                         // ARMv7-M Thumb = .+5
 3837.2  00000012 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3837.3                         // ARMv6-M Thumb = .+4
 3837.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3837                                   NEXT1
 3837.1  00000016 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3837.2  0000001A 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3837.3  0000001E 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3837.4                         // ARMv6-M Thumb = .+4
 3837.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3837.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3837.7                                 ENDM
 3837.8                                 ENDM
 3837.9                                 ENDM
 3838                           
 3839                           
 3840                           //      BIN BIN:        ( -- )
 3841                           //      Set the numeric conversion base to TWO (bianry).
 3842                           
 3843                            SECTION .text : CONST (2)
 3844                           BIN_NFA:
 3845    00000000 83                    DC8     0x83
 3846    00000001 4249                  DC8     'BI'
 3847    00000003 CE                    DC8     'N'+0x80
 3848                            ALIGNROM 2,0xFFFFFFFF
 3849    00000004 ........              DC32    ZLESS_NFA
 3850                           BIN:
 3851    00000008 ........              DC32    DOCOL
 3852    0000000C ........02000         DC32    STRVA, 2, NBASE
                  000........  
 3853    00000018 ........              DC32    SEMIS
 3854                           
 3855                           
 3856                           //      HEX HEX:        ( -- )
 3857                           //      Set the numeric conversion base to sixteen (hexadecimal).
 3858                           
 3859                            SECTION .text : CONST (2)
 3860                           HEX_NFA:
 3861    00000000 83                    DC8     0x83
 3862    00000001 4845                  DC8     'HE'
 3863    00000003 D8                    DC8     'X'+0x80
 3864                            ALIGNROM 2,0xFFFFFFFF
 3865    00000004 ........              DC32    BIN_NFA
 3866                           HEX:
 3867    00000008 ........              DC32    DOCOL
 3868    0000000C ........10000         DC32    STRVA, 16, NBASE
                  000........  
 3869    00000018 ........              DC32    SEMIS
 3870                           
 3871                           
 3872                           //      DECIMAL DECIMAL:        ( -- )
 3873                           //      Set the numeric conversion base to TEN (decimal).
 3874                           //      DEC IS A NUMBER!
 3875                           
 3876                            SECTION .text : CONST (2)
 3877                           DECIMAL_NFA:
 3878    00000000 87                    DC8     0x87
 3879    00000001 444543494D41          DC8     'DECIMA'
 3880    00000007 CC                    DC8     'L'+0x80
 3881                            ALIGNROM 2,0xFFFFFFFF
 3882    00000008 ........              DC32    HEX_NFA
 3883                           DECIMAL:
 3884    0000000C ........              DC32    DOCOL
 3885    00000010 ........0A000         DC32    STRVA, 10, NBASE
                  000........  
 3886    0000001C ........              DC32    SEMIS
 3887                           
 3888                           
 3889                           //      NEGATE NEGATE: ( n1 -- n2 ) RENAMED: MINUS to NEGATE
 3890                           //      Leave the two's complement of a number.
 3891                           
 3892                            SECTION .text : CONST (2)
 3893                           NEGATE_NFA:
 3894    00000000 86                    DC8     0x86
 3895    00000001 4E45474154            DC8     'NEGAT'
 3896    00000006 C5                    DC8     'E'+0x80
 3897    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 3898    00000008 ........              DC32    DECIMAL_NFA
 3899                           NEGATE:
 3900    0000000C ........              DC32    .+5
 3901                            SECTION .text : CODE (2)
 3902                                   POP2t                   // MVN YES
 3902.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3902.2                         //#ifndef TOSCT
 3902.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3902.4                         //#endif
 3902.5                         //      ADDS    p, p, #4
 3902.6                                 ENDM
 3903    00000004 C043                  MVNS     t, t           // 1's compliment
 3904    00000006 401C                  ADDS     t, t, #1       // 2's compliment
 3905                                   TPUSH
 3905                                   PUSHt   // push t to p, pre decrement p
 3905.1  00000008 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3905.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3905.3                         //      STR     t, [p]
 3905.4                                 ENDM
 3905                                   NEXT
 3905.1                         // ARMv7-M Thumb = .+5
 3905.2  0000000C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3905.3                         // ARMv6-M Thumb = .+4
 3905.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3905                                   NEXT1
 3905.1  00000010 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3905.2  00000014 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3905.3  00000018 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3905.4                         // ARMv6-M Thumb = .+4
 3905.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3905.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3905.7                                 ENDM
 3905.8                                 ENDM
 3905.9                                 ENDM
 3906                           
 3907                           
 3908                           //      ABS ABS:        ( n -- ub )
 3909                           //      Leave the absolute value of n as un.
 3910                           
 3911                            SECTION .text : CONST (2)
 3912                           ABS1_NFA:
 3913    00000000 83                    DC8     0x83
 3914    00000001 4142                  DC8     'AB'
 3915    00000003 D3                    DC8     'S'+0x80
 3916                            ALIGNROM 2,0xFFFFFFFF
 3917    00000004 ........              DC32    NEGATE_NFA
 3918                           ABS:
 3919    00000008 ........              DC32    DOCOL
 3920    0000000C ........              DC32    DUP
 3921    00000010 ........              DC32    PM
 3922    00000014 ........              DC32    SEMIS
 3923                           
 3924                           
 3925                           //      MIN MIN:        ( n1 n2 -- min )
 3926                           //      Leave the smaller of two numbers.
 3927                           
 3928                            SECTION .text : CONST (2)
 3929                           MIN_NFA:
 3930    00000000 83                    DC8     0x83
 3931    00000001 4D49                  DC8     'MI'
 3932    00000003 CE                    DC8     'N'+0x80
 3933                            ALIGNROM 2,0xFFFFFFFF
 3934    00000004 ........              DC32    ABS1_NFA
 3935                           MIN:
 3936    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3937    00000010 ........              DC32    GREATERTHAN
 3938    00000014 ........              DC32    ZBRAN   //IF
 3939    00000018 08000000              DC32     MIN1-.
 3940                           
 3941    0000001C ........              DC32    SWAP    //endif
 3942                           MIN1:
 3943    00000020 ........              DC32    DROP
 3944    00000024 ........              DC32    SEMIS
 3945                           
 3946                           
 3947                           //      MAX MAX:        ( n1 n2 -- max )
 3948                           //      Leave the greater of two numbers.
 3949                           
 3950                            SECTION .text : CONST (2)
 3951                           MAX_NFA:
 3952    00000000 83                    DC8     0x83
 3953    00000001 4D41                  DC8     'MA'
 3954    00000003 D8                    DC8     'X'+0x80
 3955                            ALIGNROM 2,0xFFFFFFFF
 3956    00000004 ........              DC32    MIN_NFA
 3957                           MAX:
 3958    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3959    00000010 ........              DC32    LESSTHAN
 3960    00000014 ........              DC32    ZBRAN   //IF
 3961    00000018 08000000              DC32     MAX1-.
 3962                           
 3963    0000001C ........              DC32    SWAP    //endif
 3964                           MAX1:
 3965    00000020 ........              DC32    DROP
 3966    00000024 ........              DC32    SEMIS
 3967                           
 3968                           
 3969                           //      AND ANDD:       ( n1 n2 -- n2 )
 3970                           //      Leave the bitwise logical and of n1 and n2 as n3.
 3971                           
 3972                            SECTION .text : CONST (2)
 3973                           ANDD_NFA:
 3974    00000000 83                    DC8     0x83
 3975    00000001 414E                  DC8     'AN'
 3976    00000003 C4                    DC8     'D'+0x80
 3977                            ALIGNROM 2,0xFFFFFFFF
 3978    00000004 ........              DC32    MAX_NFA
 3979                           ANDD:
 3980    00000008 ........              DC32    .+5
 3981                            SECTION .text : CODE (2)
 3982                                   POP2t
 3982.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 3982.2                         //#ifndef TOSCT
 3982.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 3982.4                         //#endif
 3982.5                         //      ADDS    p, p, #4
 3982.6                                 ENDM
 3983                                   POP2n
 3983.1  00000004 57F8041B              LDR     n, [p],#4
 3983.2                         //      LDR     n, [p]
 3983.3                         //      ADDS    p, p, #4
 3983.4                                 ENDM
 3984    00000008 0840                  ANDS     t, t, n
 3985                                   TPUSH
 3985                                   PUSHt   // push t to p, pre decrement p
 3985.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 3985.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 3985.3                         //      STR     t, [p]
 3985.4                                 ENDM
 3985                                   NEXT
 3985.1                         // ARMv7-M Thumb = .+5
 3985.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 3985.3                         // ARMv6-M Thumb = .+4
 3985.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 3985                                   NEXT1
 3985.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 3985.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 3985.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 3985.4                         // ARMv6-M Thumb = .+4
 3985.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3985.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3985.7                                 ENDM
 3985.8                                 ENDM
 3985.9                                 ENDM
 3986                           
 3987                           
 3988                           //      OR OR:  ( n1 n2 -- n3 )
 3989                           //      Leave the bit-wise logical or of n1 and n2 as n3.
 3990                           
 3991                            SECTION .text : CONST (2)
 3992                           OR_NFA:
 3993    00000000 82                    DC8     0x82
 3994    00000001 4F                    DC8     'O'
 3995    00000002 D2                    DC8     'R'+0x80
 3996    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3997    00000004 ........              DC32    ANDD_NFA
 3998                           OR:
 3999    00000008 ........              DC32    .+5
 4000                            SECTION .text : CODE (2)
 4001                                   POP2t
 4001.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4001.2                         //#ifndef TOSCT
 4001.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4001.4                         //#endif
 4001.5                         //      ADDS    p, p, #4
 4001.6                                 ENDM
 4002                                   POP2n
 4002.1  00000004 57F8041B              LDR     n, [p],#4
 4002.2                         //      LDR     n, [p]
 4002.3                         //      ADDS    p, p, #4
 4002.4                                 ENDM
 4003    00000008 0843                  ORRS     t, t, n
 4004                                   TPUSH
 4004                                   PUSHt   // push t to p, pre decrement p
 4004.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4004.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4004.3                         //      STR     t, [p]
 4004.4                                 ENDM
 4004                                   NEXT
 4004.1                         // ARMv7-M Thumb = .+5
 4004.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4004.3                         // ARMv6-M Thumb = .+4
 4004.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4004                                   NEXT1
 4004.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4004.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4004.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4004.4                         // ARMv6-M Thumb = .+4
 4004.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4004.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4004.7                                 ENDM
 4004.8                                 ENDM
 4004.9                                 ENDM
 4005                           
 4006                           
 4007                           //      NOT NOT: ( nl -- n2 )
 4008                           //      Leave the bitwise logical not of n1 as n2
 4009                           
 4010                            SECTION .text : CONST (2)
 4011                           NOT_NFA:
 4012    00000000 83                    DC8     0x83
 4013    00000001 4E4F                  DC8     'NO'
 4014    00000003 D4                    DC8     'T'+0x80
 4015                            ALIGNROM 2,0xFFFFFFFF
 4016    00000004 ........              DC32    OR_NFA
 4017                           NOT:
 4018    00000008 ........              DC32    .+5
 4019                            SECTION .text : CODE (2)
 4020                                   POP2t
 4020.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4020.2                         //#ifndef TOSCT
 4020.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4020.4                         //#endif
 4020.5                         //      ADDS    p, p, #4
 4020.6                                 ENDM
 4021    00000004 C043                  MVNS            t, t    // 1's compliment
 4022                                   TPUSH
 4022                                   PUSHt   // push t to p, pre decrement p
 4022.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4022.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4022.3                         //      STR     t, [p]
 4022.4                                 ENDM
 4022                                   NEXT
 4022.1                         // ARMv7-M Thumb = .+5
 4022.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4022.3                         // ARMv6-M Thumb = .+4
 4022.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4022                                   NEXT1
 4022.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4022.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4022.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4022.4                         // ARMv6-M Thumb = .+4
 4022.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4022.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4022.7                                 ENDM
 4022.8                                 ENDM
 4022.9                                 ENDM
 4023                           
 4024                           
 4025                           //      XORR XOR:       ( nl n2 -- n3 )
 4026                           //      Leave the bitwise logical exclusive or n1 and n2 as n3
 4027                           
 4028                            SECTION .text : CONST (2)
 4029                           XORR_NFA:
 4030    00000000 83                    DC8     0x83
 4031    00000001 584F                  DC8     'XO'
 4032    00000003 D2                    DC8     'R'+0x80
 4033                            ALIGNROM 2,0xFFFFFFFF
 4034    00000004 ........              DC32    NOT_NFA
 4035                           XORR:
 4036    00000008 ........              DC32    .+5
 4037                            SECTION .text : CODE (2)
 4038                                   POP2t
 4038.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4038.2                         //#ifndef TOSCT
 4038.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4038.4                         //#endif
 4038.5                         //      ADDS    p, p, #4
 4038.6                                 ENDM
 4039                                   POP2n
 4039.1  00000004 57F8041B              LDR     n, [p],#4
 4039.2                         //      LDR     n, [p]
 4039.3                         //      ADDS    p, p, #4
 4039.4                                 ENDM
 4040    00000008 4840                  EORS     t, t, n
 4041                                   TPUSH
 4041                                   PUSHt   // push t to p, pre decrement p
 4041.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4041.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4041.3                         //      STR     t, [p]
 4041.4                                 ENDM
 4041                                   NEXT
 4041.1                         // ARMv7-M Thumb = .+5
 4041.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4041.3                         // ARMv6-M Thumb = .+4
 4041.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4041                                   NEXT1
 4041.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4041.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4041.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4041.4                         // ARMv6-M Thumb = .+4
 4041.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4041.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4041.7                                 ENDM
 4041.8                                 ENDM
 4041.9                                 ENDM
 4042                           
 4043                           //      SXTH SXH:       ( nl -- n3 )
 4044                           //      Sign extend HALFWORD on the stack
 4045                           
 4046                            SECTION .text : CONST (2)
 4047                           SXTH_NFA:
 4048    00000000 84                    DC8     0x84
 4049    00000001 535854                DC8     'SXT'
 4050    00000004 C8                    DC8     'H'+0x80
 4051    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4052    00000008 ........              DC32    XORR_NFA
 4053                           SXH:
 4054    0000000C ........              DC32    .+5
 4055                            SECTION .text : CODE (2)
 4056                                   POP2t
 4056.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4056.2                         //#ifndef TOSCT
 4056.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4056.4                         //#endif
 4056.5                         //      ADDS    p, p, #4
 4056.6                                 ENDM
 4057    00000004 00B2                  SXTH     t, t
 4058                                   TPUSH
 4058                                   PUSHt   // push t to p, pre decrement p
 4058.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4058.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4058.3                         //      STR     t, [p]
 4058.4                                 ENDM
 4058                                   NEXT
 4058.1                         // ARMv7-M Thumb = .+5
 4058.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4058.3                         // ARMv6-M Thumb = .+4
 4058.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4058                                   NEXT1
 4058.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4058.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4058.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4058.4                         // ARMv6-M Thumb = .+4
 4058.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4058.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4058.7                                 ENDM
 4058.8                                 ENDM
 4058.9                                 ENDM
 4059                           
 4060                           
 4061                           //      SXTB SXB:       ( nl -- n3 )
 4062                           //      Signe extend byte in the word on the stack
 4063                           
 4064                            SECTION .text : CONST (2)
 4065                           SXTB_NFA:
 4066    00000000 84                    DC8     0x84
 4067    00000001 535854                DC8     'SXT'
 4068    00000004 C2                    DC8     'B'+0x80
 4069    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4070    00000008 ........              DC32    SXTH_NFA
 4071                           SXB:
 4072    0000000C ........              DC32    .+5
 4073                            SECTION .text : CODE (2)
 4074                                   POP2t
 4074.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4074.2                         //#ifndef TOSCT
 4074.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4074.4                         //#endif
 4074.5                         //      ADDS    p, p, #4
 4074.6                                 ENDM
 4075    00000004 40B2                  SXTB     t, t
 4076                                   TPUSH
 4076                                   PUSHt   // push t to p, pre decrement p
 4076.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4076.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4076.3                         //      STR     t, [p]
 4076.4                                 ENDM
 4076                                   NEXT
 4076.1                         // ARMv7-M Thumb = .+5
 4076.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4076.3                         // ARMv6-M Thumb = .+4
 4076.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4076                                   NEXT1
 4076.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4076.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4076.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4076.4                         // ARMv6-M Thumb = .+4
 4076.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4076.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4076.7                                 ENDM
 4076.8                                 ENDM
 4076.9                                 ENDM
 4077                           
 4078                           
 4079                           //      REVW REVW:      ( n -- n )
 4080                           //      Reverse bytes in n.
 4081                           
 4082                            SECTION .text : CONST (2)
 4083                           REVW_NFA:
 4084    00000000 84                    DC8     0x84
 4085    00000001 524556                DC8     'REV'
 4086    00000004 D7                    DC8     'W'+0x80
 4087    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4088    00000008 ........              DC32    SXTB_NFA
 4089                           REVW:
 4090    0000000C ........              DC32    .+5
 4091                            SECTION .text : CODE (2)
 4092                                   POP2t
 4092.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4092.2                         //#ifndef TOSCT
 4092.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4092.4                         //#endif
 4092.5                         //      ADDS    p, p, #4
 4092.6                                 ENDM
 4093    00000004 00BA                  REV     t, t
 4094                                   TPUSH
 4094                                   PUSHt   // push t to p, pre decrement p
 4094.1  00000006 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4094.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4094.3                         //      STR     t, [p]
 4094.4                                 ENDM
 4094                                   NEXT
 4094.1                         // ARMv7-M Thumb = .+5
 4094.2  0000000A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4094.3                         // ARMv6-M Thumb = .+4
 4094.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4094                                   NEXT1
 4094.1  0000000E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4094.2  00000012 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4094.3  00000016 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4094.4                         // ARMv6-M Thumb = .+4
 4094.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4094.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4094.7                                 ENDM
 4094.8                                 ENDM
 4094.9                                 ENDM
 4095                           
 4096                           
 4097                           //      ASR ASR:   ( sn count -- sn' )  
 4098                           //      Shift sn (sign-extended) right by count.
 4099                           //      Valid count values are 0 to 31.
 4100                           
 4101                            SECTION .text : CONST (2)
 4102                           ASR_NFA:
 4103    00000000 83                    DC8     0x83
 4104    00000001 4153                  DC8     'AS'
 4105    00000003 D2                    DC8     'R'+0x80
 4106                            ALIGNROM 2,0xFFFFFFFF
 4107    00000004 ........              DC32    REVW_NFA
 4108                           ASR:
 4109    00000008 ........              DC32    .+5
 4110                            SECTION .text : CODE (2)
 4111                                   POP2w           ; shift count
 4111.1  00000000 57F8042B              LDR     w, [p],#4
 4111.2                         //      LDR     w, [p]
 4111.3                         //      ADDS    p, p, #4
 4111.4                                 ENDM
 4112                                   POP2t           ; original data
 4112.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4112.2                         //#ifndef TOSCT
 4112.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4112.4                         //#endif
 4112.5                         //      ADDS    p, p, #4
 4112.6                                 ENDM
 4113    00000008 1041                  ASRS    t, t, w
 4114                                   TPUSH           ; shifted data
 4114                                   PUSHt   // push t to p, pre decrement p
 4114.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4114.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4114.3                         //      STR     t, [p]
 4114.4                                 ENDM
 4114                                   NEXT
 4114.1                         // ARMv7-M Thumb = .+5
 4114.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4114.3                         // ARMv6-M Thumb = .+4
 4114.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4114                                   NEXT1
 4114.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4114.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4114.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4114.4                         // ARMv6-M Thumb = .+4
 4114.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4114.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4114.7                                 ENDM
 4114.8                                 ENDM
 4114.9                                 ENDM
 4115                           
 4116                           
 4117                           //      LSR LSR:   ( n count -- n' )
 4118                           //      Logical (zero-extended) shift right by count.
 4119                           //      Valid count values are 0 to 31.
 4120                           
 4121                            SECTION .text : CONST (2)
 4122                           LSR_NFA:
 4123    00000000 83                    DC8     0x83
 4124    00000001 4C53                  DC8     'LS'
 4125    00000003 D2                    DC8     'R'+0x80
 4126                            ALIGNROM 2,0xFFFFFFFF
 4127    00000004 ........              DC32    ASR_NFA
 4128                           LSR:
 4129    00000008 ........              DC32    .+5
 4130                            SECTION .text : CODE (2)
 4131                                   POP2w           ; shift count
 4131.1  00000000 57F8042B              LDR     w, [p],#4
 4131.2                         //      LDR     w, [p]
 4131.3                         //      ADDS    p, p, #4
 4131.4                                 ENDM
 4132                                   POP2t           ; original data
 4132.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4132.2                         //#ifndef TOSCT
 4132.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4132.4                         //#endif
 4132.5                         //      ADDS    p, p, #4
 4132.6                                 ENDM
 4133    00000008 D040                  LSRS    t, t, w
 4134                                   TPUSH           ; shifted data
 4134                                   PUSHt   // push t to p, pre decrement p
 4134.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4134.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4134.3                         //      STR     t, [p]
 4134.4                                 ENDM
 4134                                   NEXT
 4134.1                         // ARMv7-M Thumb = .+5
 4134.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4134.3                         // ARMv6-M Thumb = .+4
 4134.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4134                                   NEXT1
 4134.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4134.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4134.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4134.4                         // ARMv6-M Thumb = .+4
 4134.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4134.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4134.7                                 ENDM
 4134.8                                 ENDM
 4134.9                                 ENDM
 4135                           
 4136                           
 4137                           //      LSL LSL:   ( n count -- n' )
 4138                           //      Logical (zero-extended) shift left by count.
 4139                           //      Valid count values are 0 to 31.
 4140                           
 4141                            SECTION .text : CONST (2)
 4142                           LSL_NFA:
 4143    00000000 83                    DC8     0x83
 4144    00000001 4C53                  DC8     'LS'
 4145    00000003 CC                    DC8     'L'+0x80
 4146                            ALIGNROM 2,0xFFFFFFFF
 4147    00000004 ........              DC32    LSR_NFA
 4148                           LSL:
 4149    00000008 ........              DC32    .+5
 4150                            SECTION .text : CODE (2)
 4151                                   POP2w           ; shift count
 4151.1  00000000 57F8042B              LDR     w, [p],#4
 4151.2                         //      LDR     w, [p]
 4151.3                         //      ADDS    p, p, #4
 4151.4                                 ENDM
 4152                                   POP2t           ; original data
 4152.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 4152.2                         //#ifndef TOSCT
 4152.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4152.4                         //#endif
 4152.5                         //      ADDS    p, p, #4
 4152.6                                 ENDM
 4153    00000008 9040                  LSLS    t, t, w
 4154                                   TPUSH           ; shifted data---
 4154                                   PUSHt   // push t to p, pre decrement p
 4154.1  0000000A 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4154.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4154.3                         //      STR     t, [p]
 4154.4                                 ENDM
 4154                                   NEXT
 4154.1                         // ARMv7-M Thumb = .+5
 4154.2  0000000E 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4154.3                         // ARMv6-M Thumb = .+4
 4154.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4154                                   NEXT1
 4154.1  00000012 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4154.2  00000016 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4154.3  0000001A 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4154.4                         // ARMv6-M Thumb = .+4
 4154.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4154.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4154.7                                 ENDM
 4154.8                                 ENDM
 4154.9                                 ENDM
 4155                           
 4156                           
 4157                           //      .R DOTR:        ( sn1 n2 -- ) SIGNED:
 4158                           //      Print the signed number sn1 right aligned in a field whose width is n2.
 4159                           //      No following blank is printed.
 4160                           
 4161                            SECTION .text : CONST (2)
 4162                           DOTR_NFA:
 4163    00000000 82                    DC8     0x82
 4164    00000001 2E                    DC8     '.'
 4165    00000002 D2                    DC8     'R'+0x80
 4166    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4167    00000004 ........              DC32    LSL_NFA
 4168                           DOTR:
 4169    00000008 ........              DC32    DOCOL
 4170    0000000C ........              DC32    TOR
 4171    00000010 ........              DC32    STOD
 4172    00000014 ........              DC32    RFROM
 4173    00000018 ........              DC32    DDOTR
 4174    0000001C ........              DC32    SEMIS
 4175                           
 4176                           
 4177                           //      .RU DOTRU:      ( n1 n2 -- ) UNSIGNED:
 4178                           //      Print the unsigned number n1 right aligned in a field whose width is n2.
 4179                           //      No following blank is printed.
 4180                           
 4181                            SECTION .text : CONST (2)
 4182                           DOTRU_NFA:
 4183    00000000 83                    DC8     0x83
 4184    00000001 2E52                  DC8     '.R'
 4185    00000003 D5                    DC8     'U'+0x80
 4186                            ALIGNROM 2,0xFFFFFFFF
 4187    00000004 ........              DC32    DOTR_NFA
 4188                           DOTRU:
 4189    00000008 ........              DC32    DOCOL
 4190    0000000C ........              DC32    TOR
 4191    00000010 ........              DC32    ZERO
 4192    00000014 .............         DC32    BDIGS, DIGS, EDIGS
                  ...........  
 4193    00000020 .............         DC32    DUP, RFROM
                  ...          
 4194    00000028 .............         DC32    SWAP, SUBB, SPACES, TYPE
                  .............
                  ......       
 4195                           #ifdef IO2TP
 4198                           #endif
 4199    00000038 ........              DC32    SEMIS
 4200                           
 4201                           
 4202                           //      U. UDOT:        ( n -- ) USIGNED DOT
 4203                           
 4204                            SECTION .text : CONST (2)
 4205                           UDOT_NFA:
 4206    00000000 82                    DC8     0x82
 4207    00000001 55                    DC8     'U'
 4208    00000002 AE                    DC8     '.'+0x80
 4209    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4210    00000004 ........              DC32    DOTRU_NFA
 4211                           UDOT:
 4212    00000008 ........              DC32    DOCOL
 4213    0000000C ........              DC32    ZERO
 4214    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4215    00000014 ........              DC32    SEMIS
 4216                           
 4217                           
 4218                           //      ? QUES: ( addr -- )
 4219                           //      Print the value contained at the address in free format according to
 4220                           //      the current base using DOT.
 4221                           
 4222                            SECTION .text : CONST (2)
 4223                           QUES_NFA:
 4224    00000000 81                    DC8     0x81
 4225    00000001 BF                    DC8     '?'+0x80
 4226    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4227    00000004 ........              DC32    UDOT_NFA
 4228                           QUES:
 4229    00000008 ........              DC32    DOCOL
 4230    0000000C ........              DC32    AT
 4231    00000010 ........              DC32    DOT
 4232    00000014 ........              DC32    SEMIS
 4233                           
 4234                           
 4235                           //      . DOT:  ( n -- ) SIGNED 2'S COMPLEMENT:
 4236                           //      Print a number from a signed 32 bit two's complement value,
 4237                           //      converted according to the numeric base.
 4238                           //      A trailing blanks follows.
 4239                           
 4240                            SECTION .text : CONST (2)
 4241                           DOT_NFA:
 4242    00000000 81                    DC8     0x81
 4243    00000001 AE                    DC8     '.'+0x80
 4244    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4245    00000004 ........              DC32    QUES_NFA
 4246                           DOT:
 4247    00000008 ........              DC32    DOCOL
 4248    0000000C ........              DC32    STOD
 4249    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4250    00000014 ........              DC32    SEMIS
 4251                           
 4252                           
 4253                           //------------------------------ DOTBASE SECTION -------------------------------
 4254                           //      .H DOTHEX:      ( n -- )
 4255                           //      Prints TOS in Hex using DOT, not affecting Base in the system
 4256                           
 4257                           #ifndef SRM
 4258                           //      .B DOTBIN:      ( n -- )
 4259                           //      Prints TOS in BINARY using DOT, not affecting Base in the system
 4260                           
 4261                            SECTION .text : CONST (2)
 4262                           DOTBIN_NFA:
 4263    00000000 82                    DC8     0x82
 4264    00000001 2E                    DC8     '.'
 4265    00000002 C2                    DC8     'B'+0x80
 4266    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4267    00000004 ........              DC32    DOT_NFA
 4268                           DOTBIN:
 4269    00000008 ........              DC32    DOCOL
 4270    0000000C .............         DC32    TWO, DOTBASE
                  ...          
 4271    00000014 ........              DC32    SEMIS
 4272                           #endif  // not SRM
 4273                           
 4274                           
 4275                            SECTION .text : CONST (2)
 4276                           DOTHEX_NFA:
 4277    00000000 82                    DC8     0x82
 4278    00000001 2E                    DC8     '.'
 4279    00000002 C8                    DC8     'H'+0x80
 4280    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4281    00000004 ........              DC32    DOTBIN_NFA
 4282                           DOTHEX:
 4283    00000008 ........              DC32    DOCOL
 4284                           #ifdef SRM
 4286                           #else
 4287    0000000C ........10000         DC32    LIT, 16, DOTBASE        // this version appends BASE Suffix
                  000........  
 4288                           #endif
 4289    00000018 ........              DC32    SEMIS
 4290                           
 4291                           
 4292                           #ifndef SRM
 4293                           //      .D DOTDEC:      ( n -- )
 4294                           //      Prints TOS in DECIMAL using DOT, not affecting Base in the system
 4295                           
 4296                            SECTION .text : CONST (2)
 4297                           DOTDEC_NFA:
 4298    00000000 82                    DC8     0x82
 4299    00000001 2E                    DC8     '.'
 4300    00000002 C4                    DC8     'D'+0x80
 4301    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4302    00000004 ........              DC32    DOTHEX_NFA
 4303                           DOTDEC:
 4304    00000008 ........              DC32    DOCOL
 4305    0000000C ........0A000         DC32    LIT, 10, DOTBASE
                  000........  
 4306    00000018 ........              DC32    SEMIS
 4307                           #endif  // not SRM
 4308                           
 4309                           
 4310                           //=============================== WORDCAT ====================================//
 4311                           //NOEXEC HEADERFORWORDCATEGORIES
 4312                           //      WC_NUMBERS_NFA = NUMBER Stuff: CATEGORY
 4313                           
 4314                            SECTION .text : CONST (2)
 4315                           WC_NUMBERS_NFA:
 4316    00000000 91                    DC8     0x80+4+13
 4317    00000001 0D0A                  DC8     0x0D, 0x0A
 4318    00000003 4E554D4245522         DC8     'NUMBER Stuff:'
                  053747566663A
 4319    00000010 0D8A                  DC8     0x0D, 0x0A+0x80
 4320    00000012 FFFF           ALIGNROM 2,0xFFFFFFFF
 4321    00000014 ........              DC32    DOTDEC_NFA
 4322                           
 4323                           
 4324                           //=============================== UART0_INIT =================================//
 4325                           
 4326                           // LFA ABOVE NEEDS TO BE WC_NUMBERS_NFA
 4327                           $FISH_STM32F4_UART3_INIT.s
 4328                           // LFA BELOW NEEDS TO BE UART3_INIT_NFA
 4329                           
 4330                           //=============================== UART0_INIT =================================//
 4331                           
 4332                           //      MYBAUD MYBAUD: ( n -- ) BAUD MUST BE IN DECIMAL or EQUIVALENT!!!
 4333                           //      MUST BE USED BEFORE USING UART0_INIT!!!
 4334                           //      Because FISH does a reset if you invoke a HARD FAULT RESET
 4335                           //      THIS MECHANISM IS ESSENTIAL TO STAYING AT USER SET BAUDRATE THRU A RESET!
 4336                           //      SET NON-INIT RAM VARIABLES DBAUD TO ZERO AND UBAUD n.
 4337                           //      See UART0_INIT
 4338                           
 4339                            SECTION .text : CONST (2)
 4340                           MYBAUD_NFA:
 4341    00000000 86                    DC8     0x86
 4342    00000001 4D59424155            DC8     'MYBAU'
 4343    00000006 C4                    DC8     'D'+0x80
 4344    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4345    00000008 ........              DC32    UART3_INIT_NFA
 4346                           MYBAUD:
 4347    0000000C ........              DC32    DOCOL
 4348    00000010 ........00000         DC32    strva, 0, DBAUD
                  000........  
 4349    0000001C .............         DC32    LIT, UBAUD, STORE       // SET UBAUD TO NEW BAUD FOR UART0_INIT
                  ...........  
 4350    00000028 ........              DC32    SEMIS
 4351                           
 4352                           
 4353                           //      STM32F4 UART3_LSR UART3_LSR: ( -- value )
 4354                           
 4355                            SECTION .text : CONST (2)
 4356                           UART3_LSR_NFA:
 4357    00000000 89                    DC8     0x89
 4358    00000001 55415254335F4         DC8     'UART3_LS'
                  C53          
 4359    00000009 D2                    DC8     'R'+0x80
 4360    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 4361    0000000C ........              DC32    MYBAUD_NFA
 4362                           UART3_LSR:
 4363    00000010 ........              DC32    .+5
 4364                            SECTION .text : CODE (2)
 4365    00000000 0549                  LDR     n, = USART3_SR
 4366    00000002 0878                  LDRB    t, [n]
 4367                                   TPUSH
 4367                                   PUSHt   // push t to p, pre decrement p
 4367.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4367.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4367.3                         //      STR     t, [p]
 4367.4                                 ENDM
 4367                                   NEXT
 4367.1                         // ARMv7-M Thumb = .+5
 4367.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4367.3                         // ARMv6-M Thumb = .+4
 4367.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4367                                   NEXT1
 4367.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4367.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4367.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4367.4                         // ARMv6-M Thumb = .+4
 4367.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4367.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4367.7                                 ENDM
 4367.8                                 ENDM
 4367.9                                 ENDM
 4368    00000016 0000           LTORG
 4368.1                                  TABLE
 4368.2  00000018 00480040              Reference on line 4365
 4369                           
 4370                           
 4371                           //      STM32F4 UART3_RX UART3_RX: ( -- addr )
 4372                           //      This is the serial terminal.
 4373                           
 4374                            SECTION .text : CONST (2)
 4375                           UART3_RX_NFA:
 4376    00000000 88                    DC8     0x88
 4377    00000001 55415254335F5         DC8     'UART3_R'
                  2            
 4378    00000008 D8                    DC8     'X'+0x80
 4379    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4380    0000000C ........              DC32    UART3_LSR_NFA
 4381                           UART0_RX:
 4382    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4383                           
 4384                           //      STM32F4 UART3_TX UART3_TX: ( -- addr )
 4385                           //      This is the serial terminal.
 4386                           
 4387                            SECTION .text : CONST (2)
 4388                           UART3_TX_NFA:
 4389    00000000 88                    DC8     0x88
 4390    00000001 55415254335F5         DC8     'UART3_T'
                  4            
 4391    00000008 D8                    DC8     'X'+0x80
 4392    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4393    0000000C ........              DC32    UART3_RX_NFA
 4394                           UART3_TX:
 4395    00000010 ........04480         DC32    DOCON, USART3_DR
                  040          
 4396                           
 4397                           
 4398                           #ifdef XON_XOFF
 4399                           //      XOFF XOFF: ( -- ) Send XOFF
 4400                           
 4401                            SECTION .text : CONST (2)
 4402                           XOFF_NFA:
 4403    00000000 84                    DC8     0x84
 4404    00000001 584F46                DC8     'XOF'
 4405    00000004 C6                    DC8     'F'+0x80
 4406    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4407    00000008 ........              DC32    UART3_TX_NFA
 4408                           XOFF:
 4409    0000000C ........              DC32    .+5
 4410                            SECTION .text : CODE (2)       // Does not incr OUT and wait for line status
 4411                           #ifdef IO2TP
 4413                           #else
 4414    00000000 ........              BL      TXRDY_SUBR
 4415    00000004 ........              BL      XOFF_SUBR
 4416                                   NEXT
 4416.1                         // ARMv7-M Thumb = .+5
 4416.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4416.3                         // ARMv6-M Thumb = .+4
 4416.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4416                                   NEXT1
 4416.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4416.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4416.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4416.4                         // ARMv6-M Thumb = .+4
 4416.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4416.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4416.7                                 ENDM
 4416.8                                 ENDM
 4417                           #endif // #else IO2TP
 4418                           //#endif // XON_XOFF after XON:
 4419                           
 4420                           
 4421                           //      XON XON: ( -- ) Send XON
 4422                           
 4423                            SECTION .text : CONST (2)
 4424                           XON_NFA:
 4425    00000000 83                    DC8     0x83
 4426    00000001 584F                  DC8     'XO'
 4427    00000003 CE                    DC8     'N'+0x80
 4428                            ALIGNROM 2,0xFFFFFFFF
 4429    00000004 ........              DC32    XOFF_NFA
 4430                           XON:
 4431    00000008 ........              DC32    .+5
 4432                            SECTION .text : CODE (2)       // Does not incr OUT or wait for line status.
 4433                           #ifdef IO2TP
 4435                           #else
 4436                           // Required, no 'quick send'
 4437    00000000 ........              BL      TXRDY_SUBR
 4438    00000004 ........              BL      XON_SUBR
 4439                                   NEXT
 4439.1                         // ARMv7-M Thumb = .+5
 4439.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4439.3                         // ARMv6-M Thumb = .+4
 4439.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4439                                   NEXT1
 4439.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4439.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4439.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4439.4                         // ARMv6-M Thumb = .+4
 4439.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4439.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4439.7                                 ENDM
 4439.8                                 ENDM
 4440                           #endif // #else IO2TP
 4441                           #endif // XON_XOFF
 4442                           
 4443                           //---------------- EMIT KEY ?KEY CR SECTION ------------------------------
 4444                           
 4445                           //      SPACES SPACES:  ( n -- )
 4446                           //      Transmit n ascii blanks (0x20) to the output device.
 4447                           
 4448                            SECTION .text : CONST (2)
 4449                           SPACES_NFA:
 4450    00000000 86                    DC8     0x86
 4451    00000001 5350414345            DC8     'SPACE'
 4452    00000006 D3                    DC8     'S'+0x80
 4453    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4454                           #ifdef XON_XOFF
 4455    00000008 ........              DC32    XON_NFA
 4456                           #else
 4458                           #endif
 4459                           SPACES:
 4460    0000000C ........              DC32    DOCOL
 4461    00000010 ........              DC32    ZERO
 4462    00000014 ........              DC32    MAX
 4463    00000018 ........              DC32    ZNDUP
 4464    0000001C ........              DC32    ZBRAN
 4465    00000020 18000000              DC32     SPACES_DONE-.
 4466                           
 4467    00000024 ........              DC32    ZERO
 4468    00000028 ........              DC32    XDO     //DO
 4469                           
 4470                           SPACES_DO:
 4471    0000002C ........              DC32    SPACE
 4472    00000030 ........              DC32    XLOOP   //LOOP
 4473    00000034 F8FFFFFF              DC32     SPACES_DO-.
 4474                           
 4475                           SPACES_DONE:
 4476    00000038 ........              DC32    SEMIS
 4477                           
 4478                           
 4479                           //      SPACE SPACE: ( -- )
 4480                           //      Emit a space character, 0x20.
 4481                           
 4482                            SECTION .text : CONST (2)
 4483                           SPACE_NFA:
 4484    00000000 85                    DC8     0x85
 4485    00000001 53504143              DC8     'SPAC'
 4486    00000005 C5                    DC8     'E'+0x80
 4487    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4488    00000008 ........              DC32    SPACES_NFA
 4489                           SPACE:
 4490    0000000C ........              DC32    DOCOL
 4491    00000010 ........              DC32    BLANK
 4492    00000014 ........              DC32    EMIT
 4493    00000018 ........              DC32    SEMIS
 4494                           
 4495                           
 4496                           //      ID. IDDOT:      ( NFA-addr -- ) ?RENAME .NFA
 4497                           //      Print a definition's name from its name field address.
 4498                           
 4499                            SECTION .text : CONST (2)
 4500                           IDDOT_NFA:
 4501    00000000 83                    DC8     0x83
 4502    00000001 4944                  DC8     'ID'
 4503    00000003 AE                    DC8     '.'+0x80
 4504                            ALIGNROM 2,0xFFFFFFFF
 4505    00000004 ........              DC32    SPACE_NFA
 4506                           IDDOT:
 4507    00000008 ........              DC32    DOCOL
 4508                           //      NOW COUNT is on NFA, fig code copied it out to pad
 4509    0000000C ........              DC32    COUNT   // Count could be SMUDGE'd.
 4510    00000010 ........1F000         DC32    LIT, MAXWORDLEN // Strip SMUDGEing from count
                  000          
 4511    00000018 ........              DC32    ANDD            // only time 
 4512    0000001C ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4513    00000020 ........              DC32    SPACE
 4514    00000024 ........              DC32    SEMIS
 4515                           
 4516                           
 4517                           //      ." DOTQ:        ( -- ) IMMEDIATE
 4518                           //      Type quoted string out or compile inline string to be typed at runtime
 4519                           //      CHANGED COMPILE TIME ACTION TO WORK WITH 4 byte alighment REQUIREMENT.
 4520                           //      Used in the form:
 4521                           //              .' CCcc"
 4522                           //      Compiles an in-line string CCcc (delimited by the trailing ") with
 4523                           //      an execution proceedure to transmit the text to the output device.
 4524                           //      If executed outside a definition, ." will immediately print the text
 4525                           //      until the final ',. The maximum number of characters may be an
 4526                           //      installation dependent value. See (.").
 4527                           
 4528                            SECTION .text : CONST (2)
 4529                           DOTQ_NFA:
 4530    00000000 C2                    DC8     0x0C2
 4531    00000001 2E                    DC8     '.'
 4532    00000002 A2                    DC8     '"'+0x80
 4533    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4534    00000004 ........              DC32    IDDOT_NFA
 4535                           DOTQ:
 4536    00000008 ........              DC32    DOCOL
 4537    0000000C ........22000         DC32    LIT, '"'        // 0x22 ending qoute delimiter for WORD
                  000          
 4538    00000014 ........              DC32    STATE_SV
 4539    00000018 ........              DC32    AT
 4540    0000001C ........              DC32    ZBRAN   // IF Not COMPILING
 4541    00000020 2C000000              DC32     DOTQ1-.
 4542                           
 4543    00000024 ........              DC32    COMP    // COMPILING
 4544    00000028 ........              DC32    PDOTQ   // compile LIT, cnt-str-addr, count, type
 4545    0000002C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4546    00000030 ........              DC32    HERE
 4547    00000034 ........              DC32    CAT
 4548    00000038 ........              DC32    ONEP
 4549    0000003C ........              DC32    ALIGNED
 4550    00000040 ........              DC32    ALLOT_PRIM
 4551    00000044 ........              DC32    BRAN    // ELSE
 4552    00000048 14000000              DC32     DOTQ2-.
 4553                           DOTQ1:
 4554    0000004C ........              DC32    WORD   // \ cH-DELIM  --  CHCNT-STR OF TOKEN TO HERE
 4555    00000050 ........              DC32    HERE
 4556    00000054 ........              DC32    COUNT
 4557    00000058 ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4558                                                   // endif
 4559                           #ifdef IO2TP
 4563                           #endif
 4564                           DOTQ2:
 4565    0000005C ........              DC32    SEMIS
 4566                           
 4567                           
 4568                           //      TYPE TYPE:      ( addr count -- )
 4569                           //      ADDR must be ALIGNED!
 4570                           //      OUT MUST BE INITIALIZED!!
 4571                           //      EMIT COUNT OF 8-bits in a string, preferably ascii characters,
 4572                           //      (last nfa char (+80h)ok!) from addr thru count,
 4573                           
 4574                            SECTION .text : CONST (2)
 4575                           TYPE_NFA:
 4576    00000000 84                    DC8     0x84
 4577    00000001 545950                DC8     'TYP'
 4578    00000004 C5                    DC8     'E'+0x80
 4579    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4580    00000008 ........              DC32    DOTQ_NFA
 4581                           TYPE:
 4582    0000000C ........              DC32    DOCOL
 4583    00000010 ........              DC32    ZNDUP
 4584    00000014 ........              DC32    ZBRAN   // IF NOTHING TO TYPE
 4585    00000018 34000000              DC32     TYPE1-.
 4586                           
 4587                           #ifdef XON_XOFF
 4588    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 4589                           #endif
 4590    00000020 ........              DC32    OVER
 4591    00000024 ........              DC32    PLUS
 4592    00000028 ........              DC32    SWAP
 4593    0000002C ........              DC32    XDO     // DO
 4594                           TYPE2:
 4595    00000030 ........              DC32    I
 4596    00000034 ........              DC32    CATLT7F // Limit output to ASCII characters under 80h
 4597    00000038 ........              DC32    EMIT
 4598                           tt1:
 4599    0000003C ........              DC32    XLOOP   // LOOP
 4600                           tt2:
 4601    00000040 F0FFFFFF              DC32     TYPE2-.
 4602                           
 4603    00000044 ........              DC32    BRAN    // ELSE
 4604    00000048 08000000              DC32     TYPE3-.
 4605                           TYPE1:
 4606    0000004C ........              DC32    DROP    // endif
 4607                           TYPE3:
 4608    00000050 ........              DC32    SEMIS
 4609                           
 4610                           
 4611                           //      EMIT EMIT:      ( c -- )
 4612                           //      Transmit ascii character c to the selected output device. OUT is
 4613                           //      incremented for each character output.
 4614                           
 4615                            SECTION .text : CONST (2)
 4616                           EMIT_NFA:
 4617    00000000 84                    DC8     0x84
 4618    00000001 454D49                DC8     'EMI'
 4619    00000004 D4                    DC8     'T'+0x80
 4620    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4621    00000008 ........              DC32    TYPE_NFA
 4622                           EMIT:
 4623                           #ifndef IO2TP
 4624                           // NOT IO2TP SECTION:
 4625    0000000C ........              DC32    .+5
 4626                            SECTION .text : CODE (2)
 4627                                   POP2t                   // GET CHAR
 4627.1  00000000 57F8040B              LDR     t, [p],#4       // Post-increment
 4627.2                         //#ifndef TOSCT
 4627.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 4627.4                         //#endif
 4627.5                         //      ADDS    p, p, #4
 4627.6                                 ENDM
 4628    00000004 ........              BL      TXRDY_SUBR
 4629    00000008 0649                  LDR     n, = USART3_DR // 
 4630                           // BSOUT handles negative out issue
 4631    0000000A 0870                  STRB    t, [n]          // EMIT (Send) Char
 4632    0000000C 0649                  LDR     n, = OUT        // Increment Out
 4633    0000000E 0868                  LDR     t, [n]
 4634    00000010 401C                  ADDS    t, t, #1
 4635    00000012 0860                  STR     t, [n]
 4636                                   NEXT
 4636.1                         // ARMv7-M Thumb = .+5
 4636.2  00000014 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4636.3                         // ARMv6-M Thumb = .+4
 4636.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4636                                   NEXT1
 4636.1  00000018 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4636.2  0000001C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4636.3  00000020 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4636.4                         // ARMv6-M Thumb = .+4
 4636.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4636.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4636.7                                 ENDM
 4636.8                                 ENDM
 4637                           #else // if IO2TP Transmit char to PAD, increment OUT
 4652                           #endif  // IO2TP
 4653    00000022 0000           LTORG
 4653.1                                  TABLE
 4653.2  00000024 04480040              Reference on line 4629
 4653.3  00000028 ........              Reference on line 4632
 4654                           
 4655                           
 4656                           //      KEY KEY:        (  -- ch )
 4657                           
 4658                            SECTION .text : CONST (2)
 4659                           KEY_NFA:
 4660    00000000 83                    DC8     0x83
 4661    00000001 4B45                  DC8     'KE'
 4662    00000003 D9                    DC8     'Y'+0x80
 4663                            ALIGNROM 2,0xFFFFFFFF
 4664    00000004 ........              DC32    EMIT_NFA
 4665                           KEY_INTERPRETED_ENTRY:
 4666                           #ifndef IO2TP
 4667    00000008 ........              DC32    DOCOL
 4668    0000000C ........              DC32    XON     // EXEC SETS XOFF SO UNDO IT
 4669    00000010 ........              DC32    KEY     // TE GET KEY!
 4670    00000014 ........              DC32    SEMIS
 4671                           
 4672                           
 4673                           //:NONAME KEY KEY:      ( -- CH ) 0-7Fh
 4674                           KEY:
 4675    00000018 ........              DC32    .+5
 4676                            SECTION .text : CODE (2)
 4677    00000000 074A                  LDR     w, = USART3_DR // 
 4678    00000002 084B                  LDR     x, = USART3_SR // 
 4679                           rxRDY?:
 4680    00000004 1968                  LDR     n, [x]          // Get Line Status
 4681                           //      LSRS    n, n, #5        // Bit 5 RXNE: Read data register not empty
 4682                           // THIS IS ___ AND FAILS TEXT DOWNLOAD
 4683    00000006 8909                  LSRS    n, n, #6        // Bit 6 ORIG - REQ'D FOR TEXT FILE DOWNLOAD
 4684    00000008 FCD3                  BCC     rxRDY?          // sets carry flag to fall thru
 4685                           
 4686    0000000A 1068                  LDR     t, [w]          // t_r0 w_r2 should be uart data register
 4687                                   TPUSH
 4687                                   PUSHt   // push t to p, pre decrement p
 4687.1  0000000C 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4687.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4687.3                         //      STR     t, [p]
 4687.4                                 ENDM
 4687                                   NEXT
 4687.1                         // ARMv7-M Thumb = .+5
 4687.2  00000010 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4687.3                         // ARMv6-M Thumb = .+4
 4687.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4687                                   NEXT1
 4687.1  00000014 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4687.2  00000018 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4687.3  0000001C 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4687.4                         // ARMv6-M Thumb = .+4
 4687.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4687.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4687.7                                 ENDM
 4687.8                                 ENDM
 4687.9                                 ENDM
 4688                           #else
 4690                           #endif  // IO2TP
 4691    0000001E 0000           LTORG
 4691.1                                  TABLE
 4691.2  00000020 04480040              Reference on line 4677
 4691.3  00000024 00480040              Reference on line 4678
 4692                           
 4693                           
 4694                           //      ?KEY QKEY: ( -- f )
 4695                           //      Return zero unless key in fifo - key is not consumed.
 4696                           //      : TB BEGIN ?KEY UNTIL ; Will execute until any key is entered.
 4697                           
 4698                            SECTION .text : CONST (2)
 4699                           QKEY_NFA:
 4700    00000000 84                    DC8     0x84
 4701    00000001 3F4B45                DC8     '?KE'
 4702    00000004 D9                    DC8     'Y'+0x80
 4703    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4704    00000008 ........              DC32    KEY_NFA // -1
 4705                           QKEY:
 4706    0000000C ........              DC32    .+5
 4707                            SECTION .text : CODE (2)
 4708                           #ifdef IO2TP
 4710                           #else
 4711                           #ifdef XON_XOFF // XON IN QKEY
 4712    00000000 ........              BL      TXRDY_SUBR
 4713    00000004 ........              BL      XON_SUBR
 4714                           #endif
 4715    00000008 4040                  EORS    t, t    // zero t
 4716    0000000A 074B                  LDR     x, = USART3_SR
 4717    0000000C 1968                  LDR     n, [x]          // Get Line Status
 4718    0000000E 8909                  LSRS    n, n, #6        // Char available
 4719    00000010 00D3                  BCC     NO_KEY          // No char, not Ready
 4720                           
 4721                           // HAVE A KEY - DON'T CONSUME IT
 4722                           #ifdef TRUE_EQU_NEG_ONE
 4723    00000012 0138                  SUBS    t, #1   // -1
 4724                           #else
 4726                           #endif
 4727                           #endif  // DEFAULT TO NO KEY IF IO2TP
 4728                           NO_KEY:
 4729                                   TPUSH
 4729                                   PUSHt   // push t to p, pre decrement p
 4729.1  00000014 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 4729.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 4729.3                         //      STR     t, [p]
 4729.4                                 ENDM
 4729                                   NEXT
 4729.1                         // ARMv7-M Thumb = .+5
 4729.2  00000018 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4729.3                         // ARMv6-M Thumb = .+4
 4729.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4729                                   NEXT1
 4729.1  0000001C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4729.2  00000020 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4729.3  00000024 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4729.4                         // ARMv6-M Thumb = .+4
 4729.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4729.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4729.7                                 ENDM
 4729.8                                 ENDM
 4729.9                                 ENDM
 4730    00000026 0000           LTORG
 4730.1                                  TABLE
 4730.2  00000028 00480040              Reference on line 4716
 4731                           
 4732                           
 4733                           //      CRS CRS:        ( n -- )
 4734                           //      Emit n cr'S (0x0d) and lf (0x0A)
 4735                           
 4736                            SECTION .text : CONST (2)
 4737                           CRS_NFA:
 4738    00000000 83                    DC8     0x83
 4739    00000001 4352                  DC8     'CR'
 4740    00000003 D3                    DC8     'S'+0x80
 4741                            ALIGNROM 2,0xFFFFFFFF
 4742    00000004 ........              DC32    QKEY_NFA
 4743                           CRS:
 4744    00000008 ........              DC32    DOCOL
 4745    0000000C ........              DC32    ZERO
 4746    00000010 ........              DC32    XDO
 4747                           CRS_BEGIN:
 4748    00000014 ........              DC32    CR
 4749    00000018 ........              DC32    XLOOP
 4750    0000001C F8FFFFFF              DC32     CRS_BEGIN-.
 4751    00000020 ........              DC32    SEMIS
 4752                           
 4753                           
 4754                           //      CR CR:  ( -- )
 4755                           //      Emit cr (0x0d) and lf (0x0A)
 4756                           
 4757                            SECTION .text : CONST (2)
 4758                           CR_NFA:
 4759    00000000 82                    DC8     0x82
 4760    00000001 43                    DC8     'C'
 4761    00000002 D2                    DC8     'R'+0x80
 4762    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4763    00000004 ........              DC32    CRS_NFA
 4764                           CR:
 4765                           #ifdef IO2TP
 4768                           #else
 4769    00000008 ........              DC32    DOCOL
 4770    0000000C ........              DC32    zero_OUT
 4771    00000010 ........              DC32    PDOTQ
 4772    00000014 02                    DC8     2
 4773    00000015 0D0A                  DC8     0x0D, 0x0A
 4774    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 4775    00000018 ........              DC32    SEMIS
 4776                           #endif
 4777                           
 4778                           
 4779                           //=============================== WORDCAT ====================================//
 4780                           //NOEXEC HEADERFORWORDCATEGORIES
 4781                           //      WC_UART0_NFA = FISH IO: CATEGORY
 4782                           
 4783                            SECTION .text : CONST (2)
 4784                           WC_UARTx_NFA:
 4785    00000000 8C                    DC8     0x80+4+8
 4786    00000001 0D0A                  DC8     0x0D, 0x0A
 4787    00000003 4649534820494         DC8     'FISH IO:'
                  F3A          
 4788    0000000B 0D8A                  DC8     0x0D, 0x0A+0x80
 4789    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4790    00000010 ........              DC32    CR_NFA
 4791                           
 4792                           //      CMSIS_ENABLE_IRQS IRQS_RESUME:  ( -- )
 4793                            SECTION .text : CONST (2)
 4794                           IRQS_RESUME_NFA:
 4795    00000000 8B                    DC8     0x8B
 4796    00000001 495251535F524         DC8     'IRQS_RESUM'
                  553554D      
 4797    0000000B C5                    DC8     'E'+0x80
 4798                            ALIGNROM 2,0xFFFFFFFF
 4799    0000000C ........              DC32    WC_UARTx_NFA
 4800                           CMSIS_ENABLE_IRQS:
 4801    00000010 ........              DC32 .+5
 4802                            SECTION .text : CODE (2)
 4803                            ALIGNROM 2,0xFFFFFFFF
 4804                            IMPORT C_CMSIS_ENABLE_IRQS
 4805    00000000 ........              BL      C_CMSIS_ENABLE_IRQS
 4806                                   NEXT
 4806.1                         // ARMv7-M Thumb = .+5
 4806.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4806.3                         // ARMv6-M Thumb = .+4
 4806.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4806                                   NEXT1
 4806.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4806.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4806.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4806.4                         // ARMv6-M Thumb = .+4
 4806.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4806.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4806.7                                 ENDM
 4806.8                                 ENDM
 4807                           
 4808                           //      CMSIS_DISABLE_IRQS IRQS_SUSPEND:        ( -- )
 4809                            SECTION .text : CONST (2)
 4810                           IRQS_SUSPEND_NFA:
 4811    00000000 8C                    DC8     0x8C
 4812    00000001 495251535F535         DC8     'IRQS_SUSPEN'
                  55350454E    
 4813    0000000C C4                    DC8     'D'+0x80
 4814    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4815    00000010 ........              DC32    IRQS_RESUME_NFA
 4816                           CMSIS_DISABLE_IRQS:
 4817    00000014 ........              DC32 .+5
 4818                            SECTION .text : CODE (2)
 4819                            ALIGNROM 2,0xFFFFFFFF
 4820                            IMPORT C_CMSIS_DISABLE_IRQS
 4821    00000000 ........              BL      C_CMSIS_DISABLE_IRQS
 4822                                   NEXT
 4822.1                         // ARMv7-M Thumb = .+5
 4822.2  00000004 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4822.3                         // ARMv6-M Thumb = .+4
 4822.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4822                                   NEXT1
 4822.1  00000008 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4822.2  0000000C 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4822.3  00000010 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4822.4                         // ARMv6-M Thumb = .+4
 4822.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4822.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4822.7                                 ENDM
 4822.8                                 ENDM
 4823                           
 4824                           
 4825                           //      SYSTICK_IRQ_OFF SYSTICK_IRQ_OFF:        ( -- )
 4826                           //      Turn SYSTICK interrupt off.
 4827                           //      STCTR only incremented when SYSTICK interrupt is on.
 4828                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4829                            SECTION .text : CONST (2)
 4830                           SYSTICK_IRQ_OFF_NFA:
 4831    00000000 8F                    DC8     0x8F
 4832    00000001 5359535449434         DC8     'SYSTICK_IRQ_OF'
                  B5F4952515F4F
                  46           
 4833    0000000F C6                    DC8     'F'+0x80
 4834                            ALIGNROM 2,0xFFFFFFFF
 4835    00000010 ........              DC32    IRQS_SUSPEND_NFA
 4836                           SYSTICK_IRQ_OFF:
 4837    00000014 ........              DC32    .+5
 4838                            SECTION .text : CODE (2)
 4839    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4840    00000002 0520                  MOVS    t, #5
 4841    00000004 0860                  STR     t, [n]
 4842                                   NEXT
 4842.1                         // ARMv7-M Thumb = .+5
 4842.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4842.3                         // ARMv6-M Thumb = .+4
 4842.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4842                                   NEXT1
 4842.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4842.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4842.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4842.4                         // ARMv6-M Thumb = .+4
 4842.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4842.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4842.7                                 ENDM
 4842.8                                 ENDM
 4843                           // LTORG         //Always outside of code, else data in words
 4844                           
 4845                           
 4846                           //      SYSTICK_IRQ_ON SYSTICK_IRQ_ON:  ( -- )
 4847                           //      Turn SYSTICK interrupt on.
 4848                           //      STCTR only incremented when SYSTICK interrupt is on.
 4849                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 4849.1                                  TABLE
 4849.2  00000014 10E000E0              Reference on line 4839
 4850                            SECTION .text : CONST (2)
 4851                           SYSTICK_IRQ_ON_NFA:
 4852    00000000 8E                    DC8     0x8E
 4853    00000001 5359535449434         DC8     'SYSTICK_IRQ_O'
                  B5F4952515F4F
 4854    0000000E CE                    DC8     'N'+0x80
 4855    0000000F FF             ALIGNROM 2,0xFFFFFFFF
 4856    00000010 ........              DC32    SYSTICK_IRQ_OFF_NFA
 4857                           SYSTICK_IRQ_ON:
 4858    00000014 ........              DC32    .+5
 4859                            SECTION .text : CODE (2)
 4860    00000000 0449                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 4861    00000002 0720                  MOVS    t, #7
 4862    00000004 0860                  STR     t, [n]
 4863                                   NEXT
 4863.1                         // ARMv7-M Thumb = .+5
 4863.2  00000006 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 4863.3                         // ARMv6-M Thumb = .+4
 4863.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 4863                                   NEXT1
 4863.1  0000000A 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 4863.2  0000000E 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 4863.3  00000012 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 4863.4                         // ARMv6-M Thumb = .+4
 4863.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4863.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4863.7                                 ENDM
 4863.8                                 ENDM
 4864                            LTORG   //Always outside of code, else data in words
 4864.1                                  TABLE
 4864.2  00000014 10E000E0              Reference on line 4860
 4865                           
 4866                           //=============================== WORDCAT ====================================//
 4867                           //NOEXEC HEADERFORWORDCATEGORIES
 4868                           //      WC_IRQ_NFA = INTERRUPTS: CATEGORY
 4869                           
 4870                            SECTION .text : CONST (2)
 4871                           WC_IRQ_NFA:
 4872    00000000 8F                    DC8     0x80+4+11
 4873    00000001 0D0A                  DC8     0x0D, 0x0A
 4874    00000003 494E544552525         DC8     'INTERRUPTS:'
                  55054533A    
 4875    0000000E 0D8A                  DC8     0x0D, 0x0A+0x80
 4876                            ALIGNROM 2,0xFFFFFFFF
 4877    00000010 ........              DC32    SYSTICK_IRQ_ON_NFA
 4878                           
 4879                           
 4880                           //------------------------------------------------------------------------------
 4881                           $FISH_STM32F4_FLASH.s       // FLASH_SAVE and FLASH_FORGET Words
 4882                           // LFA BELOW NEEDS TO BE FLASH_FORGET_NFA
 4883                           //------------------------------------------------------------------------------
 4884                           
 4885                           //-------------------------- PROMPT VECTOR SECTION -----------------------------
 4886                           
 4887                           //      POFF ( -- )   Set NULL$ address in PROMPT to zero so quit does CR only.
 4888                           
 4889                            SECTION .text : CONST (2)
 4890                           POFF_NFA:
 4891    00000000 84                    DC8     0x84
 4892    00000001 504F46                DC8     'POF'
 4893    00000004 C6                    DC8     'F'+0x80
 4894    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4895    00000008 ........              DC32    FLASH_FORGET_NFA
 4896                           POFF:
 4897    0000000C ........              DC32    DOCOL
 4898    00000010 ........00000         DC32    STRVA, 0, PROMPT
                  000........  
 4899    0000001C ........              DC32    SEMIS
 4900                           
 4901                           //      PON ( -- )   Set NULL$ address in PROMPT to msg_MY_OK
 4902                           
 4903                            SECTION .text : CONST (2)
 4904                           PON_NFA:
 4905    00000000 83                    DC8     0x83
 4906    00000001 504F                  DC8     'PO'
 4907    00000003 CE                    DC8     'N'+0x80
 4908                            ALIGNROM 2,0xFFFFFFFF
 4909    00000004 ........              DC32    POFF_NFA
 4910                           PON:
 4911    00000008 ........              DC32    DOCOL
 4912    0000000C .............         DC32    STRVA, msg_MY_OK, PROMPT
                  ...........  
 4913    00000018 ........              DC32    SEMIS
 4914                           
 4915                           //      P ( -- addr )   Address of PROMPT, contains 0 or NULL$ address.
 4916                           
 4917                            SECTION .text : CONST (2)
 4918                           P_NFA:
 4919    00000000 81                    DC8     0x81
 4920    00000001 D0                    DC8     'P'+0x80
 4921    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4922    00000004 ........              DC32    PON_NFA
 4923                           P:
 4924    00000008 .............         DC32    DOCON, PROMPT
                  ...          
 4925                           
 4926                           //-------------------------- ERROR_HALT SECTION -----------------------------
 4927                           
 4928                           //      EHOFF ( -- )   Set ERROR_HALT to 0
 4929                           
 4930                            SECTION .text : CONST (2)
 4931                           EHOFF_NFA:
 4932    00000000 85                    DC8     0x85
 4933    00000001 45484F46              DC8     'EHOF'
 4934    00000005 C6                    DC8     'F'+0x80
 4935    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4936    00000008 ........              DC32    P_NFA
 4937                           EHOFF:
 4938    0000000C .............         DC32    DOCOL, ZERO, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 4939                           
 4940                           //      EHON ( -- )   Set ERROR_HALT to 1
 4941                           
 4942                            SECTION .text : CONST (2)
 4943                           EHON_NFA:
 4944    00000000 84                    DC8     0x84
 4945    00000001 45484F                DC8     'EHO'
 4946    00000004 CE                    DC8     'N'+0x80
 4947    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4948    00000008 ........              DC32    EHOFF_NFA
 4949                           EHON:
 4950    0000000C .............         DC32    DOCOL, ONE, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 4951                           
 4952                           //-------------------------- DOTDICTSPACE SECTION ------------------------------
 4953                           
 4954                           //      .DS DOTDICTSPACE:       ( n -- )
 4955                           //      Prints number of bytes availble in dictionary in DECIMAL using DOT,
 4956                           //      not affecting Base in the system
 4957                           
 4958                            SECTION .text : CONST (2)
 4959                           DOTDICTSPACE_NFA:
 4960    00000000 83                    DC8     0x83
 4961    00000001 2E44                  DC8     '.D'
 4962    00000003 D3                    DC8     'S'+0x80
 4963                            ALIGNROM 2,0xFFFFFFFF
 4964                           //      DC32    FLASH_FORGET_NFA
 4965                           //      DC32    P_NFA
 4966    00000004 ........              DC32    EHON_NFA
 4967                           DOTDICTSPACE:
 4968    00000008 ........              DC32    DOCOL
 4969    0000000C ........              DC32    DICTSPACE
 4970    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 4971    00000014 ........              DC32    DOTDEC
 4972    00000018 ........              DC32    BASE_FROM_R12   // Restore BASE
 4973    0000001C .............         DC32    LIT, msg_dictspace
                  ...          
 4974    00000024 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 4975                           #ifdef IO2TP
 4979                           #endif
 4980    0000002C ........              DC32    SEMIS
 4981                           
 4982                           
 4983                           //-------------------------- DOTVARSPACE SECTION -------------------------------
 4984                           
 4985                           //      .VS DOTVARSPACE:        ( n -- )
 4986                           //      Prints number of bytes availble in RAM VAR SPACE in DECIMAL using DOT,
 4987                           //      not affecting Base in the system.
 4988                           
 4989                            SECTION .text : CONST (2)
 4990                           DOTVARSPACE_NFA:
 4991    00000000 83                    DC8     0x83
 4992    00000001 2E56                  DC8     '.V'
 4993    00000003 D3                    DC8     'S'+0x80
 4994                            ALIGNROM 2,0xFFFFFFFF
 4995    00000004 ........              DC32    DOTDICTSPACE_NFA
 4996                           DOTVARSPACE:
 4997    00000008 ........              DC32    DOCOL
 4998    0000000C ........              DC32    VARSPACE
 4999    00000010 ........              DC32    BASE_TO_R12     // Save current BASE
 5000    00000014 .............         DC32    FOUR, SLASH
                  ...          
 5001    0000001C ........              DC32    DOTDEC
 5002    00000020 ........              DC32    BASE_FROM_R12   // Restore BASE
 5003    00000024 .............         DC32    LIT, msg_uvspace
                  ...          
 5004    0000002C .............         DC32    NULLSTRLEN, TYPE
                  ...          
 5005                           #ifdef IO2TP
 5009                           #endif
 5010    00000034 ........              DC32    SEMIS
 5011                           
 5012                           
 5013                           //      DUMP DUMP:      ( addr n -- )
 5014                           //      Print adrr and n lines of 4 columns of memory values in hexadecimal.
 5015                           //      Address must be even and a multiple of 4 else error message issued.
 5016                           //      Any key presssed will stop DUMP.
 5017                           
 5018                            SECTION .text : CONST (2)
 5019                           DUMP_NFA:
 5020    00000000 84                    DC8     0x84
 5021    00000001 44554D                DC8     'DUM'
 5022    00000004 D0                    DC8     'P'+0x80
 5023    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5024    00000008 ........              DC32    DOTVARSPACE_NFA
 5025                           DUMP:
 5026    0000000C ........              DC32    DOCOL
 5027                           
 5028    00000010 .............         DC32    OVER, QALIGNED  // \ -- addr n
                  ...          
 5029                           // DON'T SAVE BASE UNTIL AFTER ALIGNED TEST
 5030    00000018 ........              DC32    BASE_TO_R12     // Save current BASE
 5031    0000001C ........              DC32    HEX
 5032    00000020 .............         DC32    ZERO, XDO
                  ...          
 5033                           DUMP_ADDR_LINE:
 5034    00000028 ........              DC32    CR
 5035    0000002C .............         DC32    DUP, LIT, 10, DOTRU     // Print addr in Field
                  ...0A000000..
                  ......       
 5036    0000003C .............         DC32    FOUR, ZERO, XDO         // Four colum loop
                  ...........  
 5037                           DUMP_EACH_LOC:
 5038    00000048 .............         DC32    DUP, AT
                  ...          
 5039                           // Little Endian means addresses will print correctly
 5040                           // but to see character strings REVW is needed
 5041                           // but the addresses are scrambled!
 5042                           //        DC32    REVW                    // Reverse bytes in word
 5043    00000050 ........0E000         DC32    LIT, 14, DOTRU          // Diplay in Field
                  000........  
 5044    0000005C ........              DC32    FOURP
 5045    00000060 ........              DC32    XLOOP
 5046    00000064 E4FFFFFF              DC32     DUMP_EACH_LOC-.
 5047                           
 5048                           #ifdef IO2TP
 5052                           #endif
 5053    00000068 ........              DC32    QKEY
 5054    0000006C ........              DC32    ZBRAN
 5055    00000070 08000000              DC32     DUMP_CONT-.
 5056    00000074 ........              DC32    LEAVE
 5057                           DUMP_CONT:
 5058    00000078 ........              DC32    XLOOP
 5059    0000007C ACFFFFFF              DC32    DUMP_ADDR_LINE-.
 5060                           
 5061    00000080 .............         DC32    DROP, CR
                  ...          
 5062    00000088 ........              DC32    BASE_FROM_R12   // Restore BASE
 5063    0000008C ........              DC32    SEMIS
 5064                           
 5065                           
 5066                           //      VBASE VBASE:    ( -- addr )
 5067                           //      Return base addr of VAR's .
 5068                           
 5069                            SECTION .text : CONST (2)
 5070                           VBASE_NFA:
 5071    00000000 85                    DC8     0x85
 5072    00000001 56424153              DC8     'VBAS'
 5073    00000005 C5                    DC8     'E'+0x80
 5074    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5075    00000008 ........              DC32    DUMP_NFA
 5076                           VBASE:
 5077    0000000C .............         DC32    DOCON,  RAMVARSPACE_START
                  ...          
 5078                           
 5079                           
 5080                           //      DBASE DBASE:    ( -- addr )
 5081                           //      Return base addr of the dictionary.
 5082                           
 5083                            SECTION .text : CONST (2)
 5084                           DBASE_NFA:
 5085    00000000 85                    DC8     0x85
 5086    00000001 44424153              DC8     'DBAS'
 5087    00000005 C5                    DC8     'E'+0x80
 5088    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5089    00000008 ........              DC32    VBASE_NFA
 5090                           DBASE:
 5091    0000000C .............         DC32    DOCON,  ORIG
                  ...          
 5092                           
 5093                           
 5094                           //      RBASE RBASE:    ( -- addr )
 5095                           //      Return base addr of RAM THE DICTIONARY IS IN!.
 5096                           
 5097                            SECTION .text : CONST (2)
 5098                           RBASE_NFA:
 5099    00000000 85                    DC8     0x85
 5100    00000001 52424153              DC8     'RBAS'
 5101    00000005 C5                    DC8     'E'+0x80
 5102    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5103    00000008 ........              DC32    DBASE_NFA
 5104                           RBASE:
 5105    0000000C .............         DC32    DOCON,  RAM_START    // RAM WHERE DICT ALLOACTED IN MEMMAP
                  ...          
 5106                           
 5107                           
 5108                           //      CLS CLS:        ( -- )
 5109                           //      Clear serial terminal screen using a formfeed character
 5110                           
 5111                            SECTION .text : CONST (2)
 5112                           CLS_NFA:
 5113    00000000 83                    DC8     0x83
 5114    00000001 434C                  DC8     'CL'
 5115    00000003 D3                    DC8     'S'+0x80
 5116                            ALIGNROM 2,0xFFFFFFFF
 5117    00000004 ........              DC32    RBASE_NFA
 5118                           CLS:
 5119    00000008 ........              DC32    DOCOL
 5120    0000000C ........              DC32    PDOTQ
 5121    00000010 04                    DC8     4
 5122    00000011 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT100 ESC SETUP
 5123    00000013 324A                  DC8     '2J'            // Clearscreen
 5124    00000015 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5125    00000018 ........              DC32    PDOTQ
 5126    0000001C 04                    DC8     4
 5127    0000001D 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT00 ESC SETUP
 5128    0000001F 3B48                  DC8     ';H'            // CURSORHOME \ upper left corner
 5129    00000021 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5130    00000024 ........              DC32    CR              // Reset OUT
 5131    00000028 ........              DC32    SEMIS
 5132                           
 5133                           
 5134                           //      ( PAREN:        ( -- ) IMMEDIATE
 5135                           //      Used in the form:
 5136                           //              ( CCcc )
 5137                           //      Ignore comments within parenthesis. A right parenthesis ends comment.
 5138                           //      The comments may be multi-line but a space or tab is required
 5139                           //      for any line that is otherwise empty for formatting purposes,
 5140                           //      else a comment error will be printed. May occur during execution or in a
 5141                           //      colon-definition. A blank after the leading parenthesis is required.
 5142                           
 5143                            SECTION .text : CONST (2)
 5144                           PAREN_NFA:
 5145    00000000 C1                    DC8     0x0C1
 5146    00000001 A8                    DC8     '('+0x80
 5147    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5148    00000004 ........              DC32    CLS_NFA
 5149                           PAREN:
 5150                           // Slow Single line comment
 5151                           //      DC32    DOCOL, LIT, ')', WORD, SEMIS
 5152    00000008 ........              DC32    DOCOL
 5153                           PML_LOOP:
 5154    0000000C ........29000         DC32    LIT, ')'
                  000          
 5155    00000014 ........              DC32    TIB_CHAR_SCAN   // ( c -- f )
 5156                           //
 5157    00000018 ........              DC32    ZEQU            // If null
 5158    0000001C ........              DC32    ZBRAN           // found fall thru
 5159    00000020 34000000              DC32      PE_DONE-.     // else were done
 5160                           
 5161                           // Acting like the outer interpreter here, signal DLE
 5162    00000024 .............         DC32    CR, LIT, 0x10, EMIT
                  ...10000000..
                  ......       
 5163    00000034 ........              DC32    QUERY
 5164                           //  AND IF ONLY CR (null) ERR
 5165                           //        DC32    TIB_SV, CAT
 5166    00000038 .............         DC32    LIT, TIB+1, CAT // PAST COUNT BYTE
                  ...........  
 5167    00000044 ........              DC32    ZBRAN
 5168    00000048 10000000              DC32      PAREN_ERR-.
 5169                           
 5170                           //  If closing paren not in this line LOOP
 5171    0000004C ........              DC32    BRAN
 5172    00000050 BCFFFFFF              DC32      PML_LOOP-.
 5173                           
 5174                           PE_DONE:
 5175    00000054 ........              DC32    SEMIS
 5176                           
 5177                           PAREN_ERR:
 5178    00000058 .............         DC32    LIT, msg_paren_err
                  ...          
 5179    00000060 .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 5180    00000068 ........              DC32    SEMIS
 5181                           
 5182                           
 5183                           //      BACKSLASH BACKSLASH:    ( --  )
 5184                           //      After a trailing space treat the rest of the line as a comment.
 5185                           //      By setting a null terminator in TIB
 5186                           
 5187                            SECTION .text : CONST (2)
 5188                           BACKSLASH_NFA:
 5189    00000000 C1                    DC8     0x0C1
 5190    00000001 DC                    DC8     '\\'+0x80
 5191    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5192    00000004 ........              DC32    PAREN_NFA
 5193                           BACKSLASH:
 5194    00000008 ........              DC32    DOCOL
 5195    0000000C .............         DC32    ZERO, TIB_SV, IN_SV, AT, PLUS, CSTORE
                  .............
                  .............
                  .........    
 5196    00000024 ........              DC32    SEMIS
 5197                           
 5198                           
 5199                           //      SYSCLK SYSCLK:  ( -- value )
 5200                           //      Returns system clock value in Hz, i.e. 48000000 = 48Mhz.
 5201                           
 5202                            SECTION .text : CONST (2)
 5203                           SYSCLK_NFA:
 5204    00000000 86                    DC8     0x86
 5205    00000001 535953434C            DC8     'SYSCL'
 5206    00000006 CB                    DC8     'K'+0x80
 5207    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 5208    00000008 ........              DC32    BACKSLASH_NFA
 5209                           SYSCLK:
 5210    0000000C ........              DC32    .+5
 5211                            SECTION .text : CODE (2)
 5212    00000000 0549                  LDR     n, = SYSCLOCK   // SystemCoreClock
 5213    00000002 0868                  LDR     t, [n]
 5214                                   TPUSH   // Push -- t
 5214                                   PUSHt   // push t to p, pre decrement p
 5214.1  00000004 47F8040D              STR     t, [p, #-4]!    // Pre-increment
 5214.2                         //      SUBS    p, p, #4        // push t to p, pre decrement p
 5214.3                         //      STR     t, [p]
 5214.4                                 ENDM
 5214                                   NEXT
 5214.1                         // ARMv7-M Thumb = .+5
 5214.2  00000008 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5214.3                         // ARMv6-M Thumb = .+4
 5214.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5214                                   NEXT1
 5214.1  0000000C 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5214.2  00000010 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5214.3  00000014 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5214.4                         // ARMv6-M Thumb = .+4
 5214.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5214.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5214.7                                 ENDM
 5214.8                                 ENDM
 5214.9                                 ENDM
 5215    00000016 0000           LTORG   //Always outside of code, else data in words
 5215.1                                  TABLE
 5215.2  00000018 ........              Reference on line 5212
 5216                           
 5217                           
 5218                           //      STCTR   ( -- addr ) SYSTICK Interrupt increments this with 32but wrap.
 5219                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5220                            SECTION .text : CONST (2)
 5221                           STCTR_NFA:
 5222    00000000 85                    DC8     0x85
 5223    00000001 53544354              DC8     'STCT'
 5224    00000005 D2                    DC8     'R'+0x80
 5225    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5226                           //      DC32    STI_ON_NFA
 5227    00000008 ........              DC32    SYSCLK_NFA
 5228                           STCTR:
 5229    0000000C .............         DC32    DOCON, STICKER
                  ...          
 5230                           
 5231                           
 5232                           //      DELAY ( n value -- ) 7 E000E010h !   5 E000E010h !
 5233                            SECTION .text : CONST (2)
 5234                           DELAY_NFA:
 5235    00000000 85                    DC8     0x85
 5236    00000001 44454C41              DC8     'DELA'
 5237    00000005 D9                    DC8     'Y'+0x80
 5238    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5239    00000008 ........              DC32    STCTR_NFA
 5240                           DELAY:
 5241    0000000C ........              DC32    .+5
 5242                            SECTION .text : CODE (2)
 5243                                   POP2n   // Reload value in n
 5243.1  00000000 57F8041B              LDR     n, [p],#4
 5243.2                         //      LDR     n, [p]
 5243.3                         //      ADDS    p, p, #4
 5243.4                                 ENDM
 5244                                   POP2t   // loop count in t
 5244.1  00000004 57F8040B              LDR     t, [p],#4       // Post-increment
 5244.2                         //#ifndef TOSCT
 5244.3                         //      LDR     t, [p]          // pop tos to t, post increment p
 5244.4                         //#endif
 5244.5                         //      ADDS    p, p, #4
 5244.6                                 ENDM
 5245                           // SET STCTR TO NEGATIVE LOOP COUNT TO END AT ZERO
 5246    00000008 0C4C                  LDR     y, = STICKER
 5247    0000000A C043                  MVNS    t, t            // 1's compliment
 5248    0000000C 401C                  ADDS    t, t, #1        // 2's compliment
 5249    0000000E 2060                  STR     t, [y]
 5250                           // Load SYST_RVR with countdown value
 5251    00000010 0B4A                  LDR     w, = SYST_RVR
 5252    00000012 1160                  STR     n, [w]
 5253                           // and reset SYST_CVR to start countdown.
 5254    00000014 0B4A                 LDR     w, = SYST_CVR
 5255                           // Writing it clears the System Tick counter and the COUNTFLAG bit in STCTRL.
 5256    00000016 1160                  STR     n, [w]
 5257                           // If n=0 in t user is just setting reload value
 5258    00000018 0028                  CMP     t, #0           // LOOP OF ZERO
 5259    0000001A 06D0                  BEQ     DELAY_DONE
 5260                           // INTERRUPT VERSION: negate n to STCTR and leave when STCTR = 0
 5261                           // STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5262                           // Save and restore user interrupt setting
 5263                           // y = STICKER
 5264    0000001C 0A4A                  LDR     w, = SYST_CSR
 5265    0000001E 1068                  LDR     t, [w]          // Save user SYSTICK interrupt setting
 5266    00000020 0721                  MOVS    n, #7
 5267    00000022 1160                  STR     n, [w]          // Turn SYSTICK interrupt on in case it's off
 5268                           DELAY_LOOP:
 5269    00000024 2168                  LDR     n, [y]
 5270    00000026 0029                  CMP     n, #0
 5271    00000028 FCD1                  BNE     DELAY_LOOP
 5272                           DELAY_DONE:
 5273    0000002A 1060                  STR     t, [w]  // Restore user SYSTICK interrupt setting
 5274                                   NEXT
 5274.1                         // ARMv7-M Thumb = .+5
 5274.2  0000002C 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5274.3                         // ARMv6-M Thumb = .+4
 5274.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5274                                   NEXT1
 5274.1  00000030 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5274.2  00000034 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5274.3  00000038 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5274.4                         // ARMv6-M Thumb = .+4
 5274.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5274.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5274.7                                 ENDM
 5274.8                                 ENDM
 5275    0000003A 0000           LTORG
 5275.1                                  TABLE
 5275.2  0000003C ........              Reference on line 5246
 5275.3  00000040 14E000E0              Reference on line 5251
 5275.4  00000044 18E000E0              Reference on line 5254
 5275.5  00000048 10E000E0              Reference on line 5264
 5276                           
 5277                           
 5278                           //      MS MS: ( n -- ) n * 1 millisecond execution time
 5279                           //      SYSTICK_IRQ_ON/OFF  STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! 
 5280                           
 5281                            SECTION .text : CONST (2)
 5282                           MS_NFA:
 5283    00000000 82                    DC8     0x82
 5284    00000001 4D                    DC8     'M'
 5285    00000002 D3                    DC8     'S'+0x80
 5286    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 5287    00000004 ........              DC32    DELAY_NFA
 5288                           MS:
 5289    00000008 ........              DC32    DOCOL
 5290                           #ifdef STM32F4_IRC16_48MHZ
 5292                           #endif
 5293                           #ifdef STM32F205RC_XRC10_118MHZ
 5295                           #endif
 5296                           #ifdef STM32F4_XRC08_168MHZ
 5297    0000000C ........3F900         DC32    LIT, 167999d    // 2903Fh 1ms @ 168mhz RELOAD COUNTER VALUE
                  200          
 5298                           #endif
 5299    00000014 ........              DC32    DELAY
 5300    00000018 ........              DC32    SEMIS
 5301                           
 5302                           
 5303                           //      WORDCAT WORDCAT: ( -- )
 5304                           //      Creates a Word Category NFA and LFA that cannot be searched for,
 5305                           //      but is displayed by WORDS and MYWORDS to label a group of Words.
 5306                           //      Define a group of Words and then add a category name with WORDCAT.
 5307                           //      EX: WORDCAT MY APP WORDS:
 5308                           //      It must be on a line of it's own.
 5309                           //      The colon at the end is FISH convention.
 5310                            SECTION .text : CONST (2)
 5311                           WORDCAT_NFA:
 5312    00000000 87                    DC8     0x87
 5313    00000001 574F52444341          DC8     'WORDCA'
 5314    00000007 D4                    DC8     'T'+0x80
 5315                            ALIGNROM 2,0xFFFFFFFF
 5316    00000008 ........              DC32    MS_NFA
 5317                           WORDCAT:
 5318    0000000C ........              DC32    DOCOL
 5319    00000010 .............         DC32    HERE, TOR
                  ...          
 5320    00000018 .............         DC32    ZERO, CCOMMA    // Count byte place holder
                  ...          
 5321    00000020 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5322    0000002C ........              DC32    HERE
 5323    00000030 ........0D000         DC32    LIT, 0Dh, WORD
                  000........  
 5324    0000003C .............         DC32    DUP, CAT
                  ...          
 5325    00000044 ........0A000         DC32    LIT, 0Ah, ROT, CSTORE
                  000..........
                  ......       
 5326    00000054 .............         DC32    DUP, ONEP, ALLOT
                  ...........  
 5327    00000060 ........84000         DC32    LIT, 084h        // Count before system text
                  000          
 5328    00000068 .............         DC32    PLUS, R, CSTORE
                  ...........  
 5329    00000074 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5330    00000080 ........8A000         DC32    LIT, 08Ah, CCOMMA
                  000........  
 5331    0000008C ........              DC32    ALIGN32_DP_FF_PAD
 5332    00000090 .............         DC32    LATEST, COMMA
                  ...          
 5333    00000098 ........              DC32    RFROM
 5334    0000009C .............         DC32    LIT, CURRENT
                  ...          
 5335    000000A4 ........              DC32    STORE
 5336    000000A8 ........              DC32    SEMIS
 5337                           
 5338                           
 5339                           //      WORDS WORDS:    ( -- ) RENAMED: VLIST to WORDS
 5340                           //      Output list of Words in the dictionary in search order.
 5341                           //      Uses WC_ nfa's to format Word Categories.
 5342                           //      Uses FENCE for where to stop.
 5343                           //      See MYWORDS.
 5344                           
 5345                            SECTION .text : CONST (2)
 5346                           WORDS_NFA:
 5347    00000000 85                    DC8     0x85
 5348    00000001 574F5244              DC8     'WORD'
 5349    00000005 D3                    DC8     'S'+0x80
 5350    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5351    00000008 ........              DC32    WORDCAT_NFA
 5352                           WORDS:
 5353    0000000C ........              DC32    DOCOL
 5354    00000010 .............         DC32    THREE, SPACES
                  ...          
 5355    00000018 ........              DC32    LATEST
 5356                           #ifdef XON_XOFF
 5357    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 5358                           #endif
 5359                           WORDS1:  // ADD nfa length to current out_uv & verify it doesn't violate csll.
 5360                           
 5361    00000020 .............         DC32    ZERO, OVER      // -- nfa zero nfa
                  ...          
 5362    00000028 .............         DC32    ONEP, CAT       // If wc_ header skip
                  ...          
 5363    00000030 ........0D000         DC32    LIT, 0x0D       // -- nfa zero (c@) 0x0D
                  000          
 5364    00000038 .............         DC32    EQUAL, ZEQU     // -- nfa zerro flag
                  ...          
 5365    00000040 ........              DC32    ZBRAN           // -- nfa zero
 5366    00000044 1C000000              DC32     WORDS2-.       // wc_ goto
 5367                                   
 5368    00000048 ........              DC32    DROP            // -- nfa
 5369    0000004C .............         DC32    DUP, PFA, LFA   // -- nfa lfa
                  ...........  
 5370    00000058 .............         DC32    OVER, SUBB      // -- nfa (lfa - nfa)
                  ...          
 5371                           
 5372                           WORDS2: // -- nfa n
 5373                           
 5374    00000060 .............         DC32    OUT_SV, AT
                  ...          
 5375    00000068 ........              DC32    PLUS
 5376    0000006C ........4A000         DC32    LIT, 74         // was :NONAME CSLL - WORDS line length constant.
                  000          
 5377    00000074 ........              DC32    GREATERTHAN
 5378    00000078 ........              DC32    ZBRAN           // If not at end of line
 5379    0000007C 10000000              DC32     WORD21-.        // skip cr and out reset
 5380                           
 5381    00000080 ........              DC32    CR              // Start another line
 5382    00000084 .............         DC32    THREE, SPACES
                  ...          
 5383                           
 5384                           WORD21:
 5385                           #ifdef  IO2TP
 5388                           #endif
 5389                           // For MYWORDS test FENCE and stop if less
 5390    0000008C ........              DC32    DUP             // nfa
 5391    00000090 .............         DC32    FENCE_SV, AT
                  ...          
 5392    00000098 ........              DC32    LESSTHAN
 5393    0000009C ........              DC32    ZBRAN
 5394    000000A0 0C000000              DC32     WORDSCONT-.
 5395                           
 5396    000000A4 ........              DC32    BRAN
 5397    000000A8 54000000              DC32     WORDSDONE-.
 5398                           
 5399                           WORDSCONT:
 5400    000000AC ........              DC32    DUP             // nfa
 5401    000000B0 ........              DC32    IDDOT
 5402    000000B4 .............         DC32    TWO, SPACES
                  ...          
 5403                           
 5404    000000BC .............         DC32    DUP, ONEP, CAT  // Take nfa and look for WORDCAT signature
                  ...........  
 5405    000000C8 ........0D000         DC32    LIT, 0x0D       // which is cr
                  000          
 5406    000000D0 ........              DC32    EQUAL
 5407    000000D4 ........              DC32    ZBRAN           // If not wordcat
 5408    000000D8 08000000              DC32     NOT_WC-.       // skip
 5409                           
 5410    000000DC ........              DC32    zero_OUT
 5411                           
 5412                           NOT_WC:
 5413    000000E0 ........              DC32    PFA             // \ nfa -- pfa
 5414    000000E4 ........              DC32    LFA             // \ pfa -- lfa
 5415    000000E8 ........              DC32    AT              // Is next lfa
 5416    000000EC ........              DC32    DUP
 5417    000000F0 ........              DC32    ZEQU            // Zero = end of dictionary
 5418                           
 5419                           // REMOVED SO WORDS AND MYWORDS CAN BE USED IN DOWNLOAD FILES
 5420                           //      DC32    QKEY           // Zero or break key \ ^C = 0x03
 5421                           //      DC32    OR
 5422                           
 5423    000000F4 ........              DC32    ZBRAN           // Until break key or end of dictionary
 5424    000000F8 28FFFFFF              DC32     WORDS1-.
 5425                           
 5426                           #ifdef  IO2TP
 5429                           #endif
 5430                           WORDSDONE:
 5431    000000FC .............         DC32    DROP, CR
                  ...          
 5432    00000104 ........              DC32    SEMIS
 5433                           
 5434                           
 5435                           //      MYWORDS MYWORDS: ( -- )
 5436                           //      Print only system defined words by manipulating FENCE.
 5437                           
 5438                            SECTION .text : CONST (2)
 5439                           MYWORDS_NFA:
 5440    00000000 87                    DC8     0x87
 5441    00000001 4D59574F5244          DC8     'MYWORD'
 5442    00000007 D3                    DC8     'S'+0x80
 5443                            ALIGNROM 2,0xFFFFFFFF
 5444    00000008 ........              DC32    WORDS_NFA
 5445                           MYWORDS:
 5446    0000000C ........              DC32    DOCOL
 5447    00000010 ........00000         DC32    strva , FLASH_SPAGE, FENCE
                  208........  
 5448    0000001C ........              DC32    WORDS                   // now print words in ram
 5449    00000020 ........00000         DC32    strva, 0 , FENCE
                  000........  
 5450    0000002C ........              DC32    SEMIS
 5451                           
 5452                           
 5453                           //      FISH_ONLY FISH_ONLY     ( -- ) MODIFIED:
 5454                           //      RESET DP, UP AND CURRENT TO ORIGINAL FLASH IMAGE
 5455                           
 5456                            SECTION .text : CONST (2)
 5457                           FISH_ONLY_NFA:
 5458    00000000 89                    DC8     0x80+9
 5459    00000001 464953485F4F4         DC8     'FISH_ONL'
                  E4C          
 5460    00000009 D9                    DC8     'Y'+0x80
 5461    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 5462    0000000C ........              DC32    MYWORDS_NFA
 5463                           FISH_ONLY:
 5464    00000010 ........              DC32    .+5
 5465                            SECTION .text : CODE (2)
 5466                           //      LDR     n, = TASK_NFA           // preserve TOS
 5467                           #ifdef FISH_PubRel_WORDSET
 5468    00000000 0949                  LDR     n, = WC_FISH_PubRel_NFA
 5469                           #endif
 5470                           #ifdef FISH_STM32M407vg_PRO_WORDCAT
 5472                           #endif
 5473    00000002 0A4C                  LDR     y, = CURRENT            // CURRENT SETTING
 5474    00000004 2160                  STR     n, [y]
 5475    00000006 0A4C                  LDR     y, = FPC                // FLASH CURRENT
 5476    00000008 2160                  STR     n, [y]
 5477    0000000A 0A49                  LDR     n, = RAMVARSPACE_START
 5478    0000000C 0A4C                  LDR     y, = UP                 // UP SETTING
 5479    0000000E 2160                  STR     n, [y]
 5480    00000010 0A4C                  LDR     y, = FPSV                // FLASH USER VARS
 5481    00000012 2160                  STR     n, [y]
 5482    00000014 0A49                  LDR     n, = ORIG
 5483    00000016 0B4C                  LDR     y, = DP                 // DP SETTING
 5484    00000018 2160                  STR     n, [y]
 5485                                   NEXT
 5485.1                         // ARMv7-M Thumb = .+5
 5485.2  0000001A 55F8042B              ldr     w, [i], #4      ; get IP->cfa to w, incr i after
 5485.3                         // ARMv6-M Thumb = .+4
 5485.4                         //        LDM   i!, {w} // get IP->cfa to w, incr i after
 5485                                   NEXT1
 5485.1  0000001E 22F00302              BIC     w, w, #3        ; Tested WORKS ALSO Thumb2 klooge: clear the 2 LSbits
 5485.2  00000022 52F8043B              LDR     x, [w], #4      ; contents of cfa -> x, bump w to cfa+4
 5485.3  00000026 1847                  BX      x               ; w preserves cfa+4 for DOCOL's benefit
 5485.4                         // ARMv6-M Thumb = .+4
 5485.5                         //      LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5485.6                         //      BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5485.7                                 ENDM
 5485.8                                 ENDM
 5486                            LTORG
 5486.1                                  TABLE
 5486.2  00000028 ........              Reference on line 5468
 5486.3  0000002C ........              Reference on line 5473
 5486.4  00000030 ........              Reference on line 5475
 5486.5  00000034 ........              Reference on line 5477
 5486.6  00000038 ........              Reference on line 5478
 5486.7  0000003C ........              Reference on line 5480
 5486.8  00000040 ........              Reference on line 5482
 5486.9  00000044 ........              Reference on line 5483
 5487                           
 5488                           
 5489                           //      FISH FISH:      ( -- )
 5490                           //      Print Flash Status and FISH Signon Message.
 5491                           
 5492                           
 5493                            SECTION .text : CONST (2)
 5494                           FISH_NFA:
 5495    00000000 84                    DC8     0x84
 5496    00000001 464953                DC8     'FIS'
 5497    00000004 C8                    DC8     'H'+0x80
 5498    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5499    00000008 ........              DC32    FISH_ONLY_NFA
 5500                           FISH:
 5501    0000000C ........              DC32    DOCOL
 5502    00000010 ........              DC32    FLASH_SCAN
 5503    00000014 ........              DC32    SIGNON
 5504    00000018 ........              DC32    SEMIS
 5505                           
 5506                           //=============================== WORDCAT ====================================//
 5507                           //NOEXEC HEADERFORWORDCATEGORIES
 5508                           //      WC_FISH_PubRel: = FISH Reference Model: CATEGORY
 5509                            SECTION .text : CONST (2)
 5510                           WC_FISH_PubRel_NFA:
 5511    00000000 99                    DC8     0x80+4+21
 5512    00000001 0D0A                  DC8     0x0D, 0x0A
 5513    00000003 4649534820526         DC8     'FISH Reference Model:'
                  5666572656E63
                  65204D6F64656
                  C3A          
 5514    00000018 0D8A                  DC8     0x0D, 0x0A+0x80
 5515    0000001A FFFF           ALIGNROM 2,0xFFFFFFFF
 5516    0000001C ........              DC32    FISH_NFA
 5517                           
 5518                           ;**** FIRST WORD LISTED****
 5519                           
 5520                           //=============================== WORDCAT ====================================//
 5521                           
 5522                           #ifdef FISH_STM_M3_PRO_WORDCAT
 5524                           #endif
 5525                           // FIRST WORDCAT
 5526                           
 5527                           //------------------------------------------------------------------------------
 5528                           // FOR MULTI TASKING MUST BE PLACED IN RAM AND OFFSET USED IN SYSTEM VARS!!!!!!
 5529                           //            T A S K 
 5530                           //
 5531                           ;.data          // Place TASK at beginning of RAM, or not.
 5532                           /*
 5533                            SECTION .text : CONST (2)
 5534                           TASK_NFA:
 5535                                   DC8     0x84
 5536                                   DC8     'TAS'
 5537                                   DC8     'K'+0x80
 5538                            ALIGNROM 2,0xFFFFFFFF
 5539                           //      TASK Is top of dictionary until new definitionsa added
 5540                           //      PATCH CONTEXT or LATEST else LFA in TASK FROM SYM TABLE
 5541                           //      To debug dictionary searches - see - PFIND & DFIND
 5542                           //      DC32    ZEQU_NFA        // 4 (no match) bombing at +
 5543                           //      DC32    NOOP_NFA        // Patch here to shorten test of PFIND
 5544                           //      DC32    CAT_NFA         // C@ before @
 5545                           //      DC32    LESS_NFA        // < before =
 5546                           //       DC32   SoCinit_NFA     //XON_NFA               // FULL DICT SEARCH
 5547                                   DC32    MS_NFA
 5548                           TASK:
 5549                                   DC32    DOCOL
 5550                                   DC32    SEMIS
 5551                           */
 5552                           
 5553                           //------------------------------------------------------------------------------
 5554                           //:NONAME SECTION:
 5555                           // THESE STAY HERE (INSTEAD OF SLLIB) BECAUSE THEY ARE CONDITIONALLY INCLUDED
 5556                           // HI-LEVEL THEM ASM SECTIONS
 5557                           #ifdef IO2TP
 5566                           #endif
 5567                           
 5568                           #ifdef IO2TP
 5577                           #endif
 5578                           
 5579                           #ifdef USE_CMAIN
 5589                           #endif
 5590                           
 5591                           #ifdef TESTRAM
 5697                           #endif  // TESTRAM
 5698                           //------------------------------------------------------------------------------
 5699                           // Placing blocks that can change at end of link map
 5700                           // Place :NONAME for static Library first in FISH_STM_M3_SLIB.s
 5701                           
 5702                           // $PROJ_DIR$\..\FISH_RM_COMMON
 5703                           // $PROJ_DIR$\..\FISH_RM_CORTEX_M_COMMON_CODE
 5704                           // In Assembler preprocessor set additional include directories 
 5705                           $FISH_RM_MSGS.h
 5706                           // equals below
 5707                           //#include ".\..\FISH_COMMON_CODE\FISH_RM_MSGS.h"
 5708                           
 5709                           // SYSTEMCLOCK #define set in FISH_M0_EQUATES.s for SYSCLOCK value.
 5710                           // THIS IS A :NONAME WORDSET
 5711                           
 5712                           $FISH_STM32F4_SOC_INIT.s
 5713                           
 5714                            END
##############################
#           CRC:0            #
#        Errors:   0         #
#        Warnings: 0         #
#        Bytes: 83903        #
##############################



